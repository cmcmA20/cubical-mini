<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.HLevel.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Comment">-- -vtactic.hlevel:20 -vtc.def:10</a>
<a id="58" class="Keyword">module</a> <a id="65" href="Meta.HLevel.Reflection.html" class="Module">Meta.HLevel.Reflection</a> <a id="88" class="Keyword">where</a>

<a id="95" class="Keyword">open</a> <a id="100" class="Keyword">import</a> <a id="107" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="124" class="Keyword">open</a> <a id="129" class="Keyword">import</a> <a id="136" href="Foundations.Equiv.html" class="Module">Foundations.Equiv</a>
<a id="154" class="Keyword">open</a> <a id="159" class="Keyword">import</a> <a id="166" href="Foundations.HLevel.html" class="Module">Foundations.HLevel</a>
<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Foundations.Pi.html" class="Module">Foundations.Pi</a>
<a id="212" class="Keyword">open</a> <a id="217" class="Keyword">import</a> <a id="224" href="Foundations.Sigma.html" class="Module">Foundations.Sigma</a>

<a id="243" class="Keyword">open</a> <a id="248" class="Keyword">import</a> <a id="255" href="Meta.Foldable.html" class="Module">Meta.Foldable</a>
<a id="269" class="Keyword">open</a> <a id="274" class="Keyword">import</a> <a id="281" href="Meta.Literals.FromNat.html" class="Module">Meta.Literals.FromNat</a>
<a id="303" class="Keyword">open</a> <a id="308" class="Keyword">import</a> <a id="315" href="Meta.Literals.FromProduct.html" class="Module">Meta.Literals.FromProduct</a>
<a id="341" class="Keyword">open</a> <a id="346" class="Keyword">import</a> <a id="353" href="Meta.Literals.FromString.html" class="Module">Meta.Literals.FromString</a>
<a id="378" class="Keyword">open</a> <a id="383" class="Keyword">import</a> <a id="390" href="Meta.HLevel.Base.html" class="Module">Meta.HLevel.Base</a> <a id="407" class="Keyword">public</a>
<a id="414" class="Keyword">open</a> <a id="419" class="Keyword">import</a> <a id="426" href="Meta.Reflection.html" class="Module">Meta.Reflection</a>

<a id="443" class="Keyword">open</a> <a id="448" class="Keyword">import</a> <a id="455" href="Structures.n-Type.html" class="Module">Structures.n-Type</a>

<a id="474" class="Keyword">open</a> <a id="479" class="Keyword">import</a> <a id="486" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="501" class="Keyword">open</a> <a id="506" class="Keyword">import</a> <a id="513" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="528" class="Keyword">open</a> <a id="533" class="Keyword">import</a> <a id="540" href="Data.List.Operations.html" class="Module">Data.List.Operations</a>
<a id="561" class="Keyword">open</a> <a id="566" class="Keyword">import</a> <a id="573" href="Data.List.Instances.Foldable.html" class="Module">Data.List.Instances.Foldable</a>
<a id="602" class="Keyword">open</a> <a id="607" class="Keyword">import</a> <a id="614" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="646" class="Keyword">open</a> <a id="651" class="Keyword">import</a> <a id="658" href="Data.List.Instances.Idiom.html" class="Module">Data.List.Instances.Idiom</a>
<a id="684" class="Keyword">open</a> <a id="689" class="Keyword">import</a> <a id="696" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="712" class="Keyword">open</a> <a id="717" class="Keyword">import</a> <a id="724" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>

<a id="739" class="Comment">{-
Tactic for generating readable h-level proofs automatically. Contains an
essential reimplementation of the instance search mechanism, with
support for arbitrary level offsets (`level-minus) and searching under
binders (`search-under). Ambiguity is explicitly supported: the first
goal for which we can complete a proof tree is the one we go with.

The tactic works in a naÏve way, trying h-level lemmas until one
succeeds. There are three ways of making progress: Using a *projection
hint*, using a *decomposition hint*, or by falling back to instance
selection. The instance selection fallback is self-explanatory.

Projection hints handle the situation is-hlevel (X .p) n, where X
inhabits a record that contains evidence of its hlevel. If there is a
projection hint with `underlying-type == p`, then we use `has-level
(get-argument (X .p))` as the solution. Being a base case, projection
hints also handle raising h-levels: If `get-level (X .p) &lt; n`, we solve
by raising `has-level ...` the appropriate amount.

Decomposition hints are slightly more interesting. Decomposition hints
apply to a type, say P, and instruct the tactic on how to build an
application of type (is-hlevel P n). The way this application is built
is customizable.

Finding rules
-------------

Rules are found using instance search, specifically for the
&#39;hlevel-decomposition&#39; and &#39;hlevel-projection&#39; types. The
hlevel-projection type is flat, so the runtime of
projection-decomposition is *linear in the number of possible
projections*.

The hlevel-decomposition type is more interesting, since it is indexed
by the type that it can decompose. That way, we can use Agda&#39;s own
instance selection mechanism to narrow down to relevant decompositions.

Nondeterminism
--------------

In case more than one projection and/or decomposition hint is possible,
they will all be tried in order. This allows the tactic to generate
sensible-looking code, by trying simpler decompositions first. As an
example, the non-dependent lemmas for → and × will be tried before those
for Π and Σ, just like a human would.
-}</a>

<a id="2824" class="Comment">-- | Specifies how an argument should be filled in during elaboration of</a>
<a id="2897" class="Comment">-- an h-level lemma.</a>
<a id="2918" class="Keyword">data</a> <a id="Arg-spec"></a><a id="2923" href="Meta.HLevel.Reflection.html#2923" class="Datatype">Arg-spec</a> <a id="2932" class="Symbol">:</a> <a id="2934" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="2939" class="Keyword">where</a>
  <a id="Arg-spec.`level-minus"></a><a id="2947" href="Meta.HLevel.Reflection.html#2947" class="InductiveConstructor">`level-minus</a>  <a id="2961" class="Symbol">:</a> <a id="2963" class="Symbol">(</a><a id="2964" href="Meta.HLevel.Reflection.html#2964" class="Bound">n</a> <a id="2966" class="Symbol">:</a> <a id="2968" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2969" class="Symbol">)</a> <a id="2971" class="Symbol">→</a> <a id="2973" href="Meta.HLevel.Reflection.html#2923" class="Datatype">Arg-spec</a>
  <a id="2984" class="Comment">-- ^ Insert the level we&#39;re solving for minus the given offset (note</a>
  <a id="3055" class="Comment">-- that this is the wonky subtraction operation, &quot;monus&quot;) at this</a>
  <a id="3123" class="Comment">-- argument position</a>

  <a id="Arg-spec.`search-under"></a><a id="3147" href="Meta.HLevel.Reflection.html#3147" class="InductiveConstructor">`search-under</a> <a id="3161" class="Symbol">:</a> <a id="3163" class="Symbol">(</a><a id="3164" href="Meta.HLevel.Reflection.html#3164" class="Bound">n</a> <a id="3166" class="Symbol">:</a> <a id="3168" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3169" class="Symbol">)</a> <a id="3171" class="Symbol">→</a> <a id="3173" href="Meta.HLevel.Reflection.html#2923" class="Datatype">Arg-spec</a>
  <a id="3184" class="Comment">-- ^ Recursively search for an h-level witness, under @n@ visible</a>
  <a id="3252" class="Comment">-- lambdas. This is suitable for lemmas of type</a>
  <a id="3302" class="Comment">-- (∀ x y z → is-hlevel ...) → is-hlevel ...</a>

  <a id="Arg-spec.`meta"></a><a id="3350" href="Meta.HLevel.Reflection.html#3350" class="InductiveConstructor">`meta</a>         <a id="3364" class="Symbol">:</a> <a id="3366" href="Meta.HLevel.Reflection.html#2923" class="Datatype">Arg-spec</a>
  <a id="3377" class="Comment">-- ^ Insert a meta at this argument position. No search will be</a>
  <a id="3443" class="Comment">-- performed for this meta, so it must be solved from the context in</a>
  <a id="3514" class="Comment">-- which the lemma is used.</a>

<a id="3543" class="Comment">-- Common patterns: Keep the level, search in the current scope.</a>
<a id="3608" class="Keyword">pattern</a> <a id="`search"></a><a id="3616" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="3624" class="Symbol">=</a> <a id="3626" href="Meta.HLevel.Reflection.html#3147" class="InductiveConstructor">`search-under</a> <a id="3640" class="Number">0</a>
<a id="3642" class="Keyword">pattern</a> <a id="`level"></a><a id="3650" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="3657" class="Symbol">=</a> <a id="3659" href="Meta.HLevel.Reflection.html#2947" class="InductiveConstructor">`level-minus</a> <a id="3672" class="Number">0</a>

<a id="3675" class="Comment">-- | A specification for how to decompose the type @T@ into</a>
<a id="3735" class="Comment">-- sub-components, to establish an h-level result.</a>
<a id="3786" class="Keyword">data</a> <a id="hlevel-decomposition"></a><a id="3791" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="3812" class="Symbol">{</a><a id="3813" href="Meta.HLevel.Reflection.html#3813" class="Bound">ℓ</a><a id="3814" class="Symbol">}</a> <a id="3816" class="Symbol">(</a><a id="3817" href="Meta.HLevel.Reflection.html#3817" class="Bound">T</a> <a id="3819" class="Symbol">:</a> <a id="3821" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3826" href="Meta.HLevel.Reflection.html#3813" class="Bound">ℓ</a><a id="3827" class="Symbol">)</a> <a id="3829" class="Symbol">:</a> <a id="3831" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3836" class="Keyword">where</a>
  <a id="hlevel-decomposition.decomp"></a><a id="3844" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a>
    <a id="3855" class="Symbol">:</a> <a id="3857" class="Symbol">(</a><a id="3858" href="Meta.HLevel.Reflection.html#3858" class="Bound">h-level-lemma</a> <a id="3872" class="Symbol">:</a> <a id="3874" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="3878" class="Symbol">)</a> <a id="3880" class="Symbol">(</a><a id="3881" href="Meta.HLevel.Reflection.html#3881" class="Bound">arguments</a> <a id="3891" class="Symbol">:</a> <a id="3893" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3898" href="Meta.HLevel.Reflection.html#2923" class="Datatype">Arg-spec</a><a id="3906" class="Symbol">)</a>
    <a id="3912" class="Symbol">→</a> <a id="3914" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="3935" href="Meta.HLevel.Reflection.html#3817" class="Bound">T</a>
  <a id="3939" class="Comment">-- To prove that T has a given h-level, we can invoke the</a>
  <a id="3999" class="Comment">-- @h-level-lemma@ with the specified @arguments@.</a>

<a id="4051" class="Comment">-- | How to decompose an application of a record selector into something</a>
<a id="4124" class="Comment">-- which might have an h-level.</a>
<a id="4156" class="Keyword">record</a> <a id="hlevel-projection"></a><a id="4163" href="Meta.HLevel.Reflection.html#4163" class="Record">hlevel-projection</a> <a id="4181" class="Symbol">(</a><a id="4182" href="Meta.HLevel.Reflection.html#4182" class="Bound">proj</a> <a id="4187" class="Symbol">:</a> <a id="4189" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="4193" class="Symbol">)</a> <a id="4195" class="Symbol">:</a> <a id="4197" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="4202" class="Keyword">where</a>
  <a id="4210" class="Keyword">field</a>
    <a id="hlevel-projection.has-level"></a><a id="4220" href="Meta.HLevel.Reflection.html#4220" class="Field">has-level</a> <a id="4230" class="Symbol">:</a> <a id="4232" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
    <a id="4241" class="Comment">-- ^ The name of the h-level lemma. It must be sufficient to apply</a>
    <a id="4312" class="Comment">-- this name to the argument (see get-argument below); arg specs are</a>
    <a id="4385" class="Comment">-- not supported.</a>
    <a id="hlevel-projection.get-level"></a><a id="4407" href="Meta.HLevel.Reflection.html#4407" class="Field">get-level</a> <a id="4417" class="Symbol">:</a> <a id="4419" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="4424" class="Symbol">→</a> <a id="4426" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4429" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4438" class="Comment">-- ^ Given an application of underlying-type, what h-level does this</a>
    <a id="4511" class="Comment">-- type have? Necessary for computing lifts.</a>
    <a id="hlevel-projection.get-argument"></a><a id="4560" href="Meta.HLevel.Reflection.html#4560" class="Field">get-argument</a> <a id="4573" class="Symbol">:</a> <a id="4575" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4580" class="Symbol">(</a><a id="4581" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4585" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="4589" class="Symbol">)</a> <a id="4591" class="Symbol">→</a> <a id="4593" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4596" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4605" class="Comment">-- ^ Extract the argument out from under the application.</a>
<a id="4663" class="Comment">{-
Using projections
-----------------

Projection decomposition happens as follows; suppose we have some
neutral

  n = def (quote X) as

in order, every &#39;hlevel-projection&#39; instance definition will be tried;
Let us call a generic instance I. If I.underlying-type == X, then we&#39;ll
use this instance, otherwise, we fail (i.e. backtrack and try another
projection).

To use this instance, the get-level and get-argument functions are
involved; get-argument must take &#39;as&#39; and return some representative
sub-expression e. get-level will receive e&#39;s inferred type and must
return the h-level of the type n. Finally, we return

  I.has-level (get-argument e),

possibly wrapped in (k - get-level (get-argument e)) applications of
is-hlevel-suc.
-}</a>

<a id="5408" class="Keyword">open</a> <a id="5413" href="Meta.HLevel.Reflection.html#4163" class="Module">hlevel-projection</a>
<a id="5431" class="Keyword">private</a>
  <a id="5441" class="Comment">-- Throw an empty type error to try another alternative, stating the</a>
  <a id="5512" class="Comment">-- purpose of backtracking for debugging:</a>
  <a id="backtrack"></a><a id="5556" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="5566" class="Symbol">:</a> <a id="5568" class="Symbol">∀</a> <a id="5570" class="Symbol">{</a><a id="5571" href="Meta.HLevel.Reflection.html#5571" class="Bound">ℓ</a><a id="5572" class="Symbol">}</a> <a id="5574" class="Symbol">{</a><a id="5575" href="Meta.HLevel.Reflection.html#5575" class="Bound">A</a> <a id="5577" class="Symbol">:</a> <a id="5579" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="5584" href="Meta.HLevel.Reflection.html#5571" class="Bound">ℓ</a><a id="5585" class="Symbol">}</a> <a id="5587" class="Symbol">→</a> <a id="5589" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5594" href="Agda.Builtin.Reflection.html#7893" class="Datatype">ErrorPart</a> <a id="5604" class="Symbol">→</a> <a id="5606" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="5609" href="Meta.HLevel.Reflection.html#5575" class="Bound">A</a>
  <a id="5613" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="5623" href="Meta.HLevel.Reflection.html#5623" class="Bound">note</a> <a id="5628" class="Symbol">=</a> <a id="5630" class="Keyword">do</a>
    <a id="5637" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="5648" class="String">&quot;tactic.hlevel&quot;</a> <a id="5664" class="Number">10</a> <a id="5667" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="5669" class="String">&quot;Backtracking search... &quot;</a> <a id="5695" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5697" href="Meta.HLevel.Reflection.html#5623" class="Bound">note</a>
    <a id="5706" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="5716" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="5718" class="String">&quot;Search hit a dead-end: &quot;</a> <a id="5744" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5746" href="Meta.HLevel.Reflection.html#5623" class="Bound">note</a>

  <a id="5754" class="Comment">-- A list of names which we should not reduce while trying to invert</a>
  <a id="5825" class="Comment">-- an application of is-hlevel/is-prop/is-set into an &#39;underlying</a>
  <a id="5893" class="Comment">-- type&#39; and level arguments.</a>
  <a id="atoms"></a><a id="5925" href="Meta.HLevel.Reflection.html#5925" class="Function">atoms</a> <a id="5931" class="Symbol">:</a> <a id="5933" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5938" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
  <a id="5945" href="Meta.HLevel.Reflection.html#5925" class="Function">atoms</a> <a id="5951" class="Symbol">=</a> <a id="5953" href="Meta.Literals.FromProduct.html#317" class="Function Operator">[</a> <a id="5955" class="Keyword">quote</a> <a id="5961" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a>
          <a id="5984" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5986" class="Keyword">quote</a> <a id="5992" href="Foundations.Base.html#12783" class="Function">is-prop</a>
          <a id="6010" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6012" class="Keyword">quote</a> <a id="6018" href="Foundations.Base.html#12852" class="Function">is-set</a>
          <a id="6035" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6037" class="Keyword">quote</a> <a id="6043" href="Foundations.Prim.Equiv.html#481" class="Function Operator">_≃_</a>
          <a id="6057" href="Meta.Literals.FromProduct.html#317" class="Function Operator">]</a>

  <a id="6062" class="Keyword">pattern</a> <a id="nat-lit"></a><a id="6070" href="Meta.HLevel.Reflection.html#6070" class="InductiveConstructor">nat-lit</a> <a id="6078" href="Meta.HLevel.Reflection.html#6135" class="Bound">n</a> <a id="6080" class="Symbol">=</a>
    <a id="6086" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6090" class="Symbol">(</a><a id="6091" class="Keyword">quote</a> <a id="6097" href="Agda.Builtin.FromNat.html#281" class="Field">Number.fromNat</a><a id="6111" class="Symbol">)</a> <a id="6113" class="Symbol">(_</a> <a id="6116" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6118" class="Symbol">_</a> <a id="6120" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6122" class="Symbol">_</a> <a id="6124" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6126" class="InductiveConstructor">lit</a> <a id="6130" class="Symbol">(</a><a id="6131" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="6135" href="Meta.HLevel.Reflection.html#6135" class="Bound">n</a><a id="6136" class="Symbol">)</a> <a id="6138" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6141" class="Symbol">_)</a>

  <a id="6147" class="Comment">-- Decompose an application of is-hlevel and/or one of the other</a>
  <a id="6214" class="Comment">-- &#39;hlevel-types&#39; into its constituent parts. Invariant:</a>
  <a id="6273" class="Comment">--</a>
  <a id="6278" class="Comment">--    decompose-is-hlevel′ t = (n , a) ⊢ t = is-of-hlevel n a</a>
  <a id="decompose-is-hlevel′"></a><a id="6342" href="Meta.HLevel.Reflection.html#6342" class="Function">decompose-is-hlevel′</a> <a id="6363" class="Symbol">:</a> <a id="6365" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6370" class="Symbol">→</a> <a id="6372" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6375" class="Symbol">(</a><a id="6376" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6381" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6383" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6387" class="Symbol">)</a>

  <a id="6392" class="Comment">-- Infer the type of the given term, and decompose it according to</a>
  <a id="6461" class="Comment">-- decompose-is-hlevel′.</a>
  <a id="decompose-is-hlevel"></a><a id="6488" href="Meta.HLevel.Reflection.html#6488" class="Function">decompose-is-hlevel</a> <a id="6508" class="Symbol">:</a> <a id="6510" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6515" class="Symbol">→</a> <a id="6517" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6520" class="Symbol">(</a><a id="6521" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6526" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6528" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6532" class="Symbol">)</a>
  <a id="6536" href="Meta.HLevel.Reflection.html#6488" class="Function">decompose-is-hlevel</a> <a id="6556" href="Meta.HLevel.Reflection.html#6556" class="Bound">goal</a> <a id="6561" class="Symbol">=</a> <a id="6563" class="Keyword">do</a>
    <a id="6570" href="Meta.HLevel.Reflection.html#6570" class="Bound">ty</a> <a id="6573" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6575" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="6590" class="Symbol">(</a><a id="6591" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="6597" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6599" href="Meta.HLevel.Reflection.html#5925" class="Function">atoms</a><a id="6604" class="Symbol">)</a> <a id="6606" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="6608" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="6618" href="Meta.HLevel.Reflection.html#6556" class="Bound">goal</a> <a id="6623" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="6627" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
    <a id="6638" href="Meta.HLevel.Reflection.html#6342" class="Function">decompose-is-hlevel′</a> <a id="6659" href="Meta.HLevel.Reflection.html#6570" class="Bound">ty</a>

  <a id="6665" href="Meta.HLevel.Reflection.html#6342" class="Function">decompose-is-hlevel′</a> <a id="6686" href="Meta.HLevel.Reflection.html#6686" class="Bound">ty</a> <a id="6689" class="Symbol">=</a> <a id="6691" class="Keyword">do</a>
    <a id="6698" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6702" class="Symbol">(</a><a id="6703" class="Keyword">quote</a> <a id="6709" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a><a id="6721" class="Symbol">)</a> <a id="6723" class="Symbol">(_</a> <a id="6726" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6728" href="Meta.HLevel.Reflection.html#6728" class="Bound">lv</a> <a id="6731" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6734" href="Meta.HLevel.Reflection.html#6734" class="Bound">ty</a> <a id="6737" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6740" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6742" class="Symbol">)</a> <a id="6744" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6746" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6751" href="Meta.HLevel.Reflection.html#6686" class="Bound">ty</a>
      <a id="6760" class="Keyword">where</a>
        <a id="6774" class="Comment">-- Handle the ones with special names:</a>
        <a id="6821" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6825" class="Symbol">(</a><a id="6826" class="Keyword">quote</a> <a id="6832" href="Foundations.Base.html#12852" class="Function">is-set</a><a id="6838" class="Symbol">)</a> <a id="6840" class="Symbol">(_</a> <a id="6843" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6845" href="Meta.HLevel.Reflection.html#6845" class="Bound">ty</a> <a id="6848" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6851" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6853" class="Symbol">)</a> <a id="6855" class="Symbol">→</a> <a id="6857" class="Keyword">do</a>
          <a id="6870" href="Meta.HLevel.Reflection.html#6870" class="Bound">ty</a> <a id="6873" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6875" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="6891" href="Meta.HLevel.Reflection.html#6845" class="Bound">ty</a>
          <a id="6904" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6909" class="Symbol">(</a><a id="6910" class="Keyword">quoteTerm</a> <a id="6920" class="Number">2</a> <a id="6922" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6924" href="Meta.HLevel.Reflection.html#6870" class="Bound">ty</a><a id="6926" class="Symbol">)</a>

        <a id="6937" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6941" class="Symbol">(</a><a id="6942" class="Keyword">quote</a> <a id="6948" href="Foundations.Base.html#12783" class="Function">is-prop</a><a id="6955" class="Symbol">)</a> <a id="6957" class="Symbol">(_</a> <a id="6960" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6962" href="Meta.HLevel.Reflection.html#6962" class="Bound">ty</a> <a id="6965" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6968" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6970" class="Symbol">)</a> <a id="6972" class="Symbol">→</a> <a id="6974" class="Keyword">do</a>
          <a id="6987" href="Meta.HLevel.Reflection.html#6987" class="Bound">ty</a> <a id="6990" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6992" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="7008" href="Meta.HLevel.Reflection.html#6962" class="Bound">ty</a>
          <a id="7021" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7026" class="Symbol">(</a><a id="7027" class="Keyword">quoteTerm</a> <a id="7037" class="Number">1</a> <a id="7039" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7041" href="Meta.HLevel.Reflection.html#6987" class="Bound">ty</a><a id="7043" class="Symbol">)</a>

        <a id="7054" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="7058" class="Symbol">(</a><a id="7059" class="Keyword">quote</a> <a id="7065" href="Foundations.Base.html#12639" class="Function">is-contr</a><a id="7073" class="Symbol">)</a> <a id="7075" class="Symbol">(_</a> <a id="7078" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="7080" href="Meta.HLevel.Reflection.html#7080" class="Bound">ty</a> <a id="7083" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="7086" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7088" class="Symbol">)</a> <a id="7090" class="Symbol">→</a> <a id="7092" class="Keyword">do</a>
          <a id="7105" href="Meta.HLevel.Reflection.html#7105" class="Bound">ty</a> <a id="7108" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7110" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="7126" href="Meta.HLevel.Reflection.html#7080" class="Bound">ty</a>
          <a id="7139" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7144" class="Symbol">(</a><a id="7145" class="Keyword">quoteTerm</a> <a id="7155" class="Number">0</a> <a id="7157" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7159" href="Meta.HLevel.Reflection.html#7105" class="Bound">ty</a><a id="7161" class="Symbol">)</a>

        <a id="7172" class="CatchallClause Symbol">_</a> <a id="7174" class="Symbol">→</a> <a id="7176" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="7186" class="String">&quot;Goal type isn&#39;t is-hlevel&quot;</a>

    <a id="7219" class="Comment">-- To support having bare hlevel! in the source file, we need to</a>
    <a id="7288" class="Comment">-- block decomposition on having a rigid-ish type at the</a>
    <a id="7349" class="Comment">-- top-level. Otherwise the first hint that matches will get</a>
    <a id="7414" class="Comment">-- matched endlessly until we run out of fuel!</a>
    <a id="7465" href="Meta.HLevel.Reflection.html#7465" class="Bound">ty</a> <a id="7468" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7470" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="7486" href="Meta.HLevel.Reflection.html#6734" class="Bound">ty</a>
    <a id="7493" href="Meta.HLevel.Reflection.html#7493" class="Bound">lv</a> <a id="7496" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7498" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="7514" href="Meta.HLevel.Reflection.html#6728" class="Bound">lv</a>
    <a id="7521" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7526" class="Symbol">(</a><a id="7527" href="Meta.HLevel.Reflection.html#7493" class="Bound">lv</a> <a id="7530" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7532" href="Meta.HLevel.Reflection.html#7465" class="Bound">ty</a><a id="7534" class="Symbol">)</a>

<a id="7537" class="Comment">{-
Lifting n-Types
---------------

The n-types are the leaves of the hlevel solving process, so they&#39;re
pretty much our only opportunity to adjust levels in a big way. Suppose
you have

  T = def (quote X) as

with
  get-level (get-argument T) = n
  w : is-of-hlevel n T

but what you want is a witness of is-of-hlevel (k + n) T, where k is some
numeral? Well, the solution is obvious: we can compute k - n and lift
T&#39;s witness (k - n) levels. Right?

No: we&#39;re dealing with potential open naturals, so we have to be careful
about performing ‘symbolic’ subtractions. The way we do this is with,
essentially, a loop: If w doesn&#39;t work, then try

  is-hlevel-suc n w : is-hlevel (suc n) T

until you reach a sucᵏ n = k + n. Actually, slightly more efficient, we
keep around a counter k′ for the number of tries, and transfer successors
from the wanted level (k + n) until is-of-hlevel-+ n (sucᵏ′ n) w works.
-}</a>
  <a id="lift-sol"></a><a id="8449" href="Meta.HLevel.Reflection.html#8449" class="Function">lift-sol</a> <a id="8458" class="Symbol">:</a> <a id="8460" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8465" class="Symbol">→</a> <a id="8467" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8472" class="Symbol">→</a> <a id="8474" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8476" class="Symbol">→</a> <a id="8478" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8485" href="Meta.HLevel.Reflection.html#8449" class="Function">lift-sol</a> <a id="8494" href="Meta.HLevel.Reflection.html#8494" class="Bound">tm</a> <a id="8497" class="Symbol">_</a> <a id="8499" class="Number">0</a> <a id="8501" class="Symbol">=</a> <a id="8503" href="Meta.HLevel.Reflection.html#8494" class="Bound">tm</a>
  <a id="8508" href="Meta.HLevel.Reflection.html#8449" class="CatchallClause Function">lift-sol</a><a id="8516" class="CatchallClause"> </a><a id="8517" href="Meta.HLevel.Reflection.html#8517" class="CatchallClause Bound">tm</a><a id="8519" class="CatchallClause"> </a><a id="8520" href="Meta.HLevel.Reflection.html#8520" class="CatchallClause Bound">l1</a><a id="8522" class="CatchallClause"> </a><a id="8523" href="Meta.HLevel.Reflection.html#8523" class="CatchallClause Bound">l</a> <a id="8525" class="Symbol">=</a> <a id="8527" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="8531" class="Symbol">(</a><a id="8532" class="Keyword">quote</a> <a id="8538" href="Foundations.HLevel.Base.html#2678" class="Function">is-of-hlevel-+</a><a id="8552" class="Symbol">)</a> <a id="8554" class="Symbol">(</a><a id="8555" href="Meta.HLevel.Reflection.html#8520" class="Bound">l1</a> <a id="8558" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="8561" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8565" class="Symbol">(</a><a id="8566" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8570" href="Meta.HLevel.Reflection.html#8523" class="Bound">l</a><a id="8571" class="Symbol">)</a> <a id="8573" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="8576" href="Meta.HLevel.Reflection.html#8517" class="Bound">tm</a> <a id="8579" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="8582" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8584" class="Symbol">)</a>

  <a id="pred-term"></a><a id="8589" href="Meta.HLevel.Reflection.html#8589" class="Function">pred-term</a> <a id="8599" class="Symbol">:</a> <a id="8601" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8606" class="Symbol">→</a> <a id="8608" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="8614" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8621" href="Meta.HLevel.Reflection.html#8589" class="Function">pred-term</a> <a id="8631" class="Symbol">(</a><a id="8632" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="8636" class="Symbol">(</a><a id="8637" class="Keyword">quote</a> <a id="8643" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="8646" class="Symbol">)</a> <a id="8648" class="Symbol">(</a><a id="8649" href="Meta.HLevel.Reflection.html#8649" class="Bound">x</a> <a id="8651" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="8654" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8656" class="Symbol">))</a> <a id="8659" class="Symbol">=</a> <a id="8661" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8666" href="Meta.HLevel.Reflection.html#8649" class="Bound">x</a>
  <a id="8670" href="Meta.HLevel.Reflection.html#8589" class="Function">pred-term</a> <a id="8680" class="Symbol">(</a><a id="8681" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8685" class="Symbol">(</a><a id="8686" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8690" href="Meta.HLevel.Reflection.html#8690" class="Bound">n</a><a id="8691" class="Symbol">))</a> <a id="8694" class="Keyword">with</a> <a id="8699" href="Meta.HLevel.Reflection.html#8690" class="Bound">n</a>
  <a id="8703" class="Symbol">...</a> <a id="8707" class="Symbol">|</a> <a id="8709" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8713" href="Meta.HLevel.Reflection.html#8713" class="Bound">k</a> <a id="8715" class="Symbol">=</a> <a id="8717" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8722" class="Symbol">(</a><a id="8723" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8727" class="Symbol">(</a><a id="8728" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8732" href="Meta.HLevel.Reflection.html#8713" class="Bound">k</a><a id="8733" class="Symbol">))</a>
  <a id="8738" class="CatchallClause Symbol">...</a><a id="8741" class="CatchallClause"> </a><a id="8742" class="CatchallClause Symbol">|</a><a id="8743" class="CatchallClause"> </a><a id="8744" class="CatchallClause Symbol">_</a> <a id="8746" class="Symbol">=</a> <a id="8748" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
  <a id="8758" href="Meta.HLevel.Reflection.html#8589" class="CatchallClause Function">pred-term</a><a id="8767" class="CatchallClause"> </a><a id="8768" class="CatchallClause Symbol">_</a> <a id="8770" class="Symbol">=</a> <a id="8772" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="lifting-loop"></a><a id="8783" href="Meta.HLevel.Reflection.html#8783" class="Function">lifting-loop</a> <a id="8796" class="Symbol">:</a> <a id="8798" class="Symbol">(</a><a id="8799" href="Meta.HLevel.Reflection.html#8799" class="Bound">fuel</a> <a id="8804" class="Symbol">:</a> <a id="8806" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="8807" class="Symbol">)</a> <a id="8809" class="Symbol">→</a> <a id="8811" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8813" class="Symbol">→</a> <a id="8815" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8820" class="Symbol">→</a> <a id="8822" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8827" class="Symbol">→</a> <a id="8829" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8834" class="Symbol">→</a> <a id="8836" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8841" class="Symbol">→</a> <a id="8843" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="8846" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="8850" href="Meta.HLevel.Reflection.html#8783" class="Function">lifting-loop</a> <a id="8863" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="8868" class="Symbol">_</a> <a id="8870" class="Symbol">_</a> <a id="8872" class="Symbol">_</a> <a id="8874" class="Symbol">_</a> <a id="8876" class="Symbol">_</a> <a id="8878" class="Symbol">=</a> <a id="8880" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="8890" class="String">&quot;Lifting loop ran out of fuel&quot;</a>
  <a id="8923" href="Meta.HLevel.Reflection.html#8783" class="Function">lifting-loop</a> <a id="8936" class="Symbol">(</a><a id="8937" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8941" href="Meta.HLevel.Reflection.html#8941" class="Bound">fuel</a><a id="8945" class="Symbol">)</a> <a id="8947" href="Meta.HLevel.Reflection.html#8947" class="Bound">it</a> <a id="8950" href="Meta.HLevel.Reflection.html#8950" class="Bound">solution</a> <a id="8959" href="Meta.HLevel.Reflection.html#8959" class="Bound">goal</a> <a id="8964" href="Meta.HLevel.Reflection.html#8964" class="Bound">l1</a> <a id="8967" href="Meta.HLevel.Reflection.html#8967" class="Bound">l2</a> <a id="8970" class="Symbol">=</a>
    <a id="8976" href="Meta.HLevel.Reflection.html#9191" class="Function">let&#39;s-hope</a> <a id="8987" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="8991" class="Keyword">do</a>
      <a id="9000" class="Symbol">(</a><a id="9001" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="9006" href="Meta.HLevel.Reflection.html#9006" class="Bound">l2′</a><a id="9009" class="Symbol">)</a> <a id="9011" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="9013" href="Meta.HLevel.Reflection.html#8589" class="Function">pred-term</a> <a id="9023" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="9027" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="9037" href="Meta.HLevel.Reflection.html#8967" class="Bound">l2</a> <a id="9040" class="Keyword">where</a>
        <a id="9054" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="9062" class="Symbol">→</a> <a id="9064" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="9074" class="String">&quot;Lifting loop reached its end with no success&quot;</a>
      <a id="9127" href="Meta.HLevel.Reflection.html#8783" class="Function">lifting-loop</a> <a id="9140" href="Meta.HLevel.Reflection.html#8941" class="Bound">fuel</a> <a id="9145" class="Symbol">(</a><a id="9146" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9150" href="Meta.HLevel.Reflection.html#8947" class="Bound">it</a><a id="9152" class="Symbol">)</a> <a id="9154" href="Meta.HLevel.Reflection.html#8950" class="Bound">solution</a> <a id="9163" href="Meta.HLevel.Reflection.html#8959" class="Bound">goal</a> <a id="9168" href="Meta.HLevel.Reflection.html#8964" class="Bound">l1</a> <a id="9171" href="Meta.HLevel.Reflection.html#9006" class="Bound">l2′</a>
    <a id="9179" class="Keyword">where</a>
      <a id="9191" href="Meta.HLevel.Reflection.html#9191" class="Function">let&#39;s-hope</a> <a id="9202" class="Symbol">:</a> <a id="9204" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9207" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="9215" href="Meta.HLevel.Reflection.html#9191" class="Function">let&#39;s-hope</a> <a id="9226" class="Symbol">=</a> <a id="9228" class="Keyword">do</a>
        <a id="9239" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9250" class="String">&quot;tactic.hlevel&quot;</a> <a id="9266" class="Number">30</a> <a id="9269" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="9271" class="String">&quot;Lifting loop: Trying &quot;</a> <a id="9295" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9297" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9305" class="Symbol">(</a><a id="9306" href="Meta.HLevel.Reflection.html#8449" class="Function">lift-sol</a> <a id="9315" href="Meta.HLevel.Reflection.html#8950" class="Bound">solution</a> <a id="9324" href="Meta.HLevel.Reflection.html#8964" class="Bound">l1</a> <a id="9327" href="Meta.HLevel.Reflection.html#8947" class="Bound">it</a><a id="9329" class="Symbol">)</a> <a id="9331" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9333" class="String">&quot; for level &quot;</a> <a id="9347" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9349" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9357" href="Meta.HLevel.Reflection.html#8967" class="Bound">l2</a> <a id="9360" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9362" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="9373" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="9379" href="Meta.HLevel.Reflection.html#8959" class="Bound">goal</a> <a id="9384" class="Symbol">(</a><a id="9385" href="Meta.HLevel.Reflection.html#8449" class="Function">lift-sol</a> <a id="9394" href="Meta.HLevel.Reflection.html#8950" class="Bound">solution</a> <a id="9403" href="Meta.HLevel.Reflection.html#8964" class="Bound">l1</a> <a id="9406" href="Meta.HLevel.Reflection.html#8947" class="Bound">it</a><a id="9408" class="Symbol">)</a>
    <a id="9414" class="Comment">-- con (quote suc) (</a>

  <a id="9438" class="Comment">-- Projection decomposition.</a>
  <a id="treat-as-n-type"></a><a id="9469" href="Meta.HLevel.Reflection.html#9469" class="Function">treat-as-n-type</a> <a id="9485" class="Symbol">:</a> <a id="9487" class="Symbol">∀</a> <a id="9489" class="Symbol">{</a><a id="9490" href="Meta.HLevel.Reflection.html#9490" class="Bound">n</a><a id="9491" class="Symbol">}</a> <a id="9493" class="Symbol">→</a> <a id="9495" href="Meta.HLevel.Reflection.html#4163" class="Record">hlevel-projection</a> <a id="9513" href="Meta.HLevel.Reflection.html#9490" class="Bound">n</a> <a id="9515" class="Symbol">→</a> <a id="9517" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="9522" class="Symbol">→</a> <a id="9524" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9527" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="9531" href="Meta.HLevel.Reflection.html#9469" class="Function">treat-as-n-type</a> <a id="9547" href="Meta.HLevel.Reflection.html#9547" class="Bound">projection</a> <a id="9558" href="Meta.HLevel.Reflection.html#9558" class="Bound">goal</a> <a id="9563" class="Symbol">=</a> <a id="9565" class="Keyword">do</a>
    <a id="9572" class="Comment">-- First we must be looking at a goal which is of the type is-hlevel</a>
    <a id="9645" class="Comment">-- A n. We&#39;ll need both n and A.</a>
    <a id="9682" class="Symbol">(</a><a id="9683" href="Meta.HLevel.Reflection.html#9683" class="Bound">wanted-level</a> <a id="9696" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9698" href="Meta.HLevel.Reflection.html#9698" class="Bound">ty</a><a id="9700" class="Symbol">)</a> <a id="9702" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="9704" href="Meta.HLevel.Reflection.html#6488" class="Function">decompose-is-hlevel</a> <a id="9724" href="Meta.HLevel.Reflection.html#9558" class="Bound">goal</a>
    <a id="9733" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9744" class="String">&quot;tactic.hlevel&quot;</a> <a id="9760" class="Number">10</a> <a id="9763" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="9771" class="String">&quot;Attempting to treat as &quot;</a> <a id="9797" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9799" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9807" href="Meta.HLevel.Reflection.html#9683" class="Bound">wanted-level</a> <a id="9820" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9822" class="String">&quot;-Type: &quot;</a> <a id="9832" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9834" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9842" href="Meta.HLevel.Reflection.html#9698" class="Bound">ty</a> <a id="9845" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9847" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="9854" href="Meta.HLevel.Reflection.html#9854" class="Bound">ty</a> <a id="9857" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="9859" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="9866" href="Meta.HLevel.Reflection.html#9698" class="Bound">ty</a>

    <a id="9874" class="Comment">-- Reduce the type to whnf and check whether the outermost term</a>
    <a id="9942" class="Comment">-- constructor is an application of the projection we&#39;re looking</a>
    <a id="10011" class="Comment">-- for.</a>
    <a id="10023" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10027" href="Meta.HLevel.Reflection.html#10027" class="Bound">namen</a> <a id="10033" href="Meta.HLevel.Reflection.html#10033" class="Bound">args</a> <a id="10038" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10040" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="10049" href="Meta.HLevel.Reflection.html#9854" class="Bound">ty</a>
      <a id="10058" class="Keyword">where</a> <a id="10064" href="Meta.HLevel.Reflection.html#10064" class="CatchallClause Bound">what</a> <a id="10069" class="Symbol">→</a> <a id="10071" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="10081" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="10083" class="String">&quot;Thing isn&#39;t an application, it is &quot;</a> <a id="10120" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10122" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10130" href="Meta.HLevel.Reflection.html#10064" class="Bound">what</a> <a id="10135" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10137" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10145" href="Meta.HLevel.Reflection.html#10145" class="Bound">it</a> <a id="10148" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10150" href="Meta.HLevel.Reflection.html#9547" class="Bound">projection</a> <a id="10161" class="Symbol">.</a><a id="10162" href="Meta.HLevel.Reflection.html#4560" class="Field">get-argument</a> <a id="10175" href="Meta.HLevel.Reflection.html#10033" class="Bound">args</a>

    <a id="10185" class="Comment">-- And compute the level of the projected thing, in addition to a</a>
    <a id="10255" class="Comment">-- numeral form of the wanted level.</a>
    <a id="10296" href="Meta.HLevel.Reflection.html#10296" class="Bound">actual-level</a> <a id="10309" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10311" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="10321" href="Meta.HLevel.Reflection.html#10145" class="Bound">it</a> <a id="10324" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="10328" href="Meta.HLevel.Reflection.html#9547" class="Bound">projection</a> <a id="10339" class="Symbol">.</a><a id="10340" href="Meta.HLevel.Reflection.html#4407" class="Field">get-level</a>

    <a id="10355" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="10366" class="String">&quot;tactic.hlevel&quot;</a> <a id="10382" class="Number">10</a> <a id="10385" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="10393" class="String">&quot;... but it&#39;s actually a(n) &quot;</a> <a id="10423" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10425" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10433" href="Meta.HLevel.Reflection.html#10296" class="Bound">actual-level</a> <a id="10446" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10448" class="String">&quot;-Type&quot;</a> <a id="10456" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10458" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10466" href="Meta.HLevel.Reflection.html#10466" class="Bound">lv</a> <a id="10469" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10471" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10481" href="Meta.HLevel.Reflection.html#9683" class="Bound">wanted-level</a>
    <a id="10498" href="Meta.HLevel.Reflection.html#10498" class="Bound">lv′</a> <a id="10502" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10504" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10514" href="Meta.HLevel.Reflection.html#10296" class="Bound">actual-level</a>
    <a id="10531" href="Meta.HLevel.Reflection.html#8783" class="Function">lifting-loop</a> <a id="10544" class="Number">10000</a> <a id="10550" class="Number">0</a> <a id="10552" class="Symbol">(</a><a id="10553" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10557" class="Symbol">(</a><a id="10558" href="Meta.HLevel.Reflection.html#9547" class="Bound">projection</a> <a id="10569" class="Symbol">.</a><a id="10570" href="Meta.HLevel.Reflection.html#4220" class="Field">has-level</a><a id="10579" class="Symbol">)</a> <a id="10581" class="Symbol">(</a><a id="10582" href="Meta.HLevel.Reflection.html#10145" class="Bound">it</a> <a id="10585" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="10588" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10590" class="Symbol">))</a> <a id="10593" href="Meta.HLevel.Reflection.html#9558" class="Bound">goal</a> <a id="10598" href="Meta.HLevel.Reflection.html#10498" class="Bound">lv′</a> <a id="10602" href="Meta.HLevel.Reflection.html#10466" class="Bound">lv</a>

    <a id="10610" href="Agda.Builtin.Reflection.html#9521" class="Postulate">commitTC</a>

  <a id="10622" class="Comment">-- Fall back to Agda&#39;s instance search mechanism. This isn&#39;t as</a>
  <a id="10688" class="Comment">-- straightforward as just using the &#39;hlevel&#39; function for a couple of</a>
  <a id="10761" class="Comment">-- reasons.</a>
  <a id="use-instance-search"></a><a id="10775" href="Meta.HLevel.Reflection.html#10775" class="Function">use-instance-search</a> <a id="10795" class="Symbol">:</a> <a id="10797" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="10802" class="Symbol">→</a> <a id="10804" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="10809" class="Symbol">→</a> <a id="10811" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="10814" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="10818" href="Meta.HLevel.Reflection.html#10775" class="Function">use-instance-search</a> <a id="10838" href="Meta.HLevel.Reflection.html#10838" class="Bound">has-alts</a> <a id="10847" href="Meta.HLevel.Reflection.html#10847" class="Bound">goal</a> <a id="10852" class="Symbol">=</a> <a id="10854" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="10869" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="10871" class="Keyword">do</a>
    <a id="10878" class="Symbol">(</a><a id="10879" href="Meta.HLevel.Reflection.html#10879" class="Bound">lv</a> <a id="10882" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10884" href="Meta.HLevel.Reflection.html#10884" class="Bound">ty</a><a id="10886" class="Symbol">)</a> <a id="10888" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10890" href="Meta.HLevel.Reflection.html#6488" class="Function">decompose-is-hlevel</a> <a id="10910" href="Meta.HLevel.Reflection.html#10847" class="Bound">goal</a>
    <a id="10919" href="Meta.HLevel.Reflection.html#10919" class="Bound">solved</a><a id="10925" class="Symbol">@(</a><a id="10927" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="10932" href="Meta.HLevel.Reflection.html#10932" class="Bound">mv</a> <a id="10935" class="Symbol">_)</a> <a id="10938" href="Meta.Bind.html#190" class="Field Operator">←</a>
      <a id="10946" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="10955" class="Symbol">(</a><a id="10956" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10960" class="Symbol">(</a><a id="10961" class="Keyword">quote</a> <a id="10967" href="Meta.HLevel.Base.html#186" class="Record">H-Level</a><a id="10974" class="Symbol">)</a> <a id="10976" class="Symbol">(</a><a id="10977" href="Meta.HLevel.Reflection.html#10879" class="Bound">lv</a> <a id="10980" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="10983" href="Meta.HLevel.Reflection.html#10884" class="Bound">ty</a> <a id="10986" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="10989" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10991" class="Symbol">))</a> <a id="10994" class="Keyword">where</a> <a id="11000" class="CatchallClause Symbol">_</a> <a id="11002" class="Symbol">→</a> <a id="11004" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="11014" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="11021" href="Meta.HLevel.Reflection.html#11021" class="Bound">instances</a> <a id="11031" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="11033" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="11046" href="Meta.HLevel.Reflection.html#10932" class="Bound">mv</a>

    <a id="11054" href="Meta.HLevel.Reflection.html#11054" class="Bound">t</a> <a id="11056" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="11058" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="11066" href="Meta.HLevel.Reflection.html#11021" class="Bound">instances</a>
    <a id="11080" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="11091" class="String">&quot;tactic.hlevel&quot;</a> <a id="11107" class="Number">10</a> <a id="11110" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="11118" class="String">&quot;Using instance search for\n&quot;</a> <a id="11148" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11150" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11158" href="Meta.HLevel.Reflection.html#10884" class="Bound">ty</a> <a id="11161" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
      <a id="11169" class="String">&quot;\nFound candidates\n &quot;</a> <a id="11193" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11195" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11203" href="Meta.HLevel.Reflection.html#11054" class="Bound">t</a> <a id="11205" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11207" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="11215" class="Comment">-- We actually want to manage the instance searching ourselves,</a>
    <a id="11283" class="Comment">-- sorta, to avoid getting into situations where the macro has</a>
    <a id="11350" class="Comment">-- committed to instance search but Agda will disagree with it.</a>
    <a id="11418" class="Keyword">let</a>
      <a id="11428" href="Meta.HLevel.Reflection.html#11428" class="Bound">go</a> <a id="11431" class="Symbol">:</a> <a id="11433" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="11438" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="11443" class="Symbol">→</a> <a id="11445" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="11448" class="Symbol">(</a><a id="11449" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="11451" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="11453" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="11457" class="Symbol">)</a>
      <a id="11465" href="Meta.HLevel.Reflection.html#11428" class="Bound">go</a> <a id="11468" class="Symbol">=</a> <a id="11470" class="Symbol">λ</a> <a id="11472" class="Keyword">where</a>
        <a id="11486" class="Comment">-- If there is *exactly* one instance candidate for this goal,</a>
        <a id="11557" class="Comment">-- then we can go ahead and solve it. That&#39;s because having</a>
        <a id="11625" class="Comment">-- exactly one instance means Agda will solve using that</a>
        <a id="11690" class="Comment">-- instance!</a>
        <a id="11711" class="Symbol">(</a><a id="11712" href="Meta.HLevel.Reflection.html#11712" class="Bound">x</a> <a id="11714" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11716" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11718" class="Symbol">)</a> <a id="11720" class="Symbol">→</a> <a id="11722" class="Keyword">do</a>
          <a id="11735" class="Comment">-- Note that, since getInstances works by creating a new meta,</a>
          <a id="11808" class="Comment">-- we have to commit to the instance ourselves.</a>
          <a id="11866" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11872" href="Meta.HLevel.Reflection.html#10919" class="Bound">solved</a> <a id="11879" href="Meta.HLevel.Reflection.html#11712" class="Bound">x</a>
          <a id="11891" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="11906" class="Symbol">(</a><a id="11907" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="11913" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11915" class="Keyword">quote</a> <a id="11921" href="Meta.HLevel.Base.html#326" class="Function">hlevel</a> <a id="11928" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11930" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11932" class="Symbol">)</a> <a id="11934" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="11936" href="Agda.Builtin.Reflection.html#10063" class="Postulate">withReconstructed</a> <a id="11954" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="11959" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="11973" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11979" href="Meta.HLevel.Reflection.html#10847" class="Bound">goal</a> <a id="11984" class="Symbol">(</a><a id="11985" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="11989" class="Symbol">(</a><a id="11990" class="Keyword">quote</a> <a id="11996" href="Meta.HLevel.Base.html#326" class="Function">hlevel</a><a id="12002" class="Symbol">)</a> <a id="12004" class="Symbol">(</a><a id="12005" href="Meta.HLevel.Reflection.html#10879" class="Bound">lv</a> <a id="12008" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="12011" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="12013" class="Symbol">))</a>
          <a id="12026" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="12031" class="Symbol">(</a><a id="12032" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12035" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12037" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="12041" class="Symbol">)</a>

        <a id="12052" class="Comment">-- If there are any more alternatives to be tried after this</a>
        <a id="12121" class="Comment">-- one, then we fail (backtrack). Otherwise, we discard the TC</a>
        <a id="12192" class="Comment">-- state but indicate success: this will cause the meta to be</a>
        <a id="12262" class="Comment">-- solved with an interaction point (if using</a>
        <a id="12316" class="Comment">-- elaborate-and-give).</a>
        <a id="12348" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="12351" class="Symbol">→</a> <a id="12353" href="Data.Bool.Base.html#492" class="Function Operator">if</a> <a id="12356" href="Meta.HLevel.Reflection.html#10838" class="Bound">has-alts</a>
          <a id="12375" href="Data.Bool.Base.html#492" class="Function Operator">then</a> <a id="12380" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="12390" class="String">&quot;No possible instances, but have other decompositions to try&quot;</a>
          <a id="12462" href="Data.Bool.Base.html#492" class="Function Operator">else</a> <a id="12467" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="12472" class="Symbol">(</a><a id="12473" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12476" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12478" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="12483" class="Symbol">)</a>

        <a id="12494" class="CatchallClause Symbol">_</a> <a id="12496" class="Symbol">→</a> <a id="12498" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="12508" class="String">&quot;Too many possible instances; will not use instance search for this goal&quot;</a>
    <a id="12586" href="Meta.HLevel.Reflection.html#11428" class="Bound">go</a> <a id="12589" href="Meta.HLevel.Reflection.html#11021" class="Bound">instances</a>

  <a id="12602" class="Comment">-- Entry point for calling the tactic.</a>
  <a id="search"></a><a id="12643" href="Meta.HLevel.Reflection.html#12643" class="Function">search</a> <a id="12650" class="Symbol">:</a> <a id="12652" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="12657" class="Symbol">→</a> <a id="12659" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12664" class="Symbol">→</a> <a id="12666" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="12668" class="Symbol">→</a> <a id="12670" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12675" class="Symbol">→</a> <a id="12677" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="12680" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="12684" class="Comment">-- Give up if we&#39;re out of fuel:</a>
  <a id="12719" href="Meta.HLevel.Reflection.html#12643" class="Function">search</a> <a id="12726" href="Meta.HLevel.Reflection.html#12726" class="Bound">has-alts</a> <a id="12735" class="Symbol">_</a>     <a id="12741" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="12749" href="Meta.HLevel.Reflection.html#12749" class="Bound">goal</a> <a id="12754" class="Symbol">=</a> <a id="12756" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="12762" href="Meta.HLevel.Reflection.html#12749" class="Bound">goal</a> <a id="12767" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>

  <a id="12778" class="Comment">-- Actual main loop: try using the hints database, try treating the</a>
  <a id="12848" class="Comment">-- goal as an n-type, fall back to instance search.</a>
  <a id="12902" href="Meta.HLevel.Reflection.html#12643" class="Function">search</a> <a id="12909" href="Meta.HLevel.Reflection.html#12909" class="Bound">has-alts</a> <a id="12918" href="Meta.HLevel.Reflection.html#12918" class="Bound">level</a> <a id="12924" class="Symbol">(</a><a id="12925" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12929" href="Meta.HLevel.Reflection.html#12929" class="Bound">n</a><a id="12930" class="Symbol">)</a> <a id="12932" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a> <a id="12937" class="Symbol">=</a>
    <a id="12943" href="Meta.HLevel.Reflection.html#13261" class="Function">use-projections</a>
      <a id="12965" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="12969" href="Meta.HLevel.Reflection.html#21605" class="Function">use-hints</a>
      <a id="12985" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="12989" href="Meta.HLevel.Reflection.html#10775" class="Function">use-instance-search</a> <a id="13009" href="Meta.HLevel.Reflection.html#12909" class="Bound">has-alts</a> <a id="13018" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a>
      <a id="13029" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="13033" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="13043" class="String">&quot;Search failed!!&quot;</a>
    <a id="13065" class="Keyword">where</a>
      <a id="13077" class="Keyword">open</a> <a id="13082" href="Meta.HLevel.Reflection.html#4163" class="Module">hlevel-projection</a>

      <a id="13107" class="Comment">-- Nondeterministically use a projection for establishing the</a>
      <a id="13175" class="Comment">-- result. This follows the approach described in [Using</a>
      <a id="13238" class="Comment">-- projections].</a>
      <a id="13261" href="Meta.HLevel.Reflection.html#13261" class="Function">use-projections</a> <a id="13277" class="Symbol">:</a> <a id="13279" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="13282" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="13290" href="Meta.HLevel.Reflection.html#13261" class="Function">use-projections</a> <a id="13306" class="Symbol">=</a> <a id="13308" class="Keyword">do</a>
        <a id="13319" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13323" href="Meta.HLevel.Reflection.html#13323" class="Bound">qn</a> <a id="13326" class="Symbol">_</a> <a id="13328" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13330" class="Symbol">(</a><a id="13331" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="13335" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="13339" href="Meta.HLevel.Reflection.html#6488" class="Function">decompose-is-hlevel</a> <a id="13359" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a><a id="13363" class="Symbol">)</a> <a id="13365" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="13369" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
          <a id="13386" class="Keyword">where</a> <a id="13392" class="CatchallClause Symbol">_</a> <a id="13394" class="Symbol">→</a> <a id="13396" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="13406" class="String">&quot;Term is not headed by a definition; ignoring projections.&quot;</a>

        <a id="13475" href="Meta.HLevel.Reflection.html#13475" class="Bound">goalt</a> <a id="13481" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13483" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="13493" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a>
        <a id="13506" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="13517" class="String">&quot;tactic.hlevel&quot;</a> <a id="13533" class="Number">20</a> <a id="13536" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="13548" class="String">&quot;Will attempt to use projections for goal\n  &quot;</a> <a id="13595" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13597" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13605" href="Meta.HLevel.Reflection.html#13475" class="Bound">goalt</a> <a id="13611" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13613" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="13625" class="Symbol">(</a><a id="13626" href="Meta.HLevel.Reflection.html#13626" class="Bound">solved</a> <a id="13633" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13635" href="Meta.HLevel.Reflection.html#13635" class="Bound">instances</a><a id="13644" class="Symbol">)</a> <a id="13646" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13648" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="13663" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="13665" class="Keyword">do</a>
          <a id="13678" href="Meta.HLevel.Reflection.html#13678" class="Bound">solved</a><a id="13684" class="Symbol">@(</a><a id="13686" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="13691" href="Meta.HLevel.Reflection.html#13691" class="Bound">mv</a> <a id="13694" class="Symbol">_)</a> <a id="13697" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13699" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="13708" class="Symbol">(</a><a id="13709" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13713" class="Symbol">(</a><a id="13714" class="Keyword">quote</a> <a id="13720" href="Meta.HLevel.Reflection.html#4163" class="Record">hlevel-projection</a><a id="13737" class="Symbol">)</a> <a id="13739" class="Symbol">(</a><a id="13740" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="13744" class="Symbol">(</a><a id="13745" href="Agda.Builtin.Reflection.html#4283" class="InductiveConstructor">name</a> <a id="13750" href="Meta.HLevel.Reflection.html#13323" class="Bound">qn</a><a id="13752" class="Symbol">)</a> <a id="13754" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="13757" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13759" class="Symbol">))</a>
            <a id="13774" class="Keyword">where</a> <a id="13780" class="CatchallClause Symbol">_</a> <a id="13782" class="Symbol">→</a> <a id="13784" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="13794" class="Symbol">(</a><a id="13795" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13803" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a> <a id="13808" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13810" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13812" class="Symbol">)</a>

          <a id="13825" class="Comment">-- If there are some hints, then great, otherwise we discard</a>
          <a id="13896" class="Comment">-- the TC state.</a>
          <a id="13923" class="Symbol">(</a><a id="13924" href="Meta.HLevel.Reflection.html#13924" class="Bound">x</a> <a id="13926" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13928" href="Meta.HLevel.Reflection.html#13928" class="Bound">xs</a><a id="13930" class="Symbol">)</a> <a id="13932" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13934" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="13947" href="Meta.HLevel.Reflection.html#13691" class="Bound">mv</a>
            <a id="13962" class="Keyword">where</a> <a id="13968" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="13971" class="Symbol">→</a> <a id="13973" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="13978" class="Symbol">((</a><a id="13980" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="13988" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13990" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13992" class="Symbol">)</a> <a id="13994" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13996" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="14001" class="Symbol">)</a>

          <a id="14014" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="14019" class="Symbol">((</a><a id="14021" href="Meta.HLevel.Reflection.html#13678" class="Bound">solved</a> <a id="14028" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14030" href="Meta.HLevel.Reflection.html#13924" class="Bound">x</a> <a id="14032" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14034" href="Meta.HLevel.Reflection.html#13928" class="Bound">xs</a><a id="14036" class="Symbol">)</a> <a id="14038" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14040" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="14044" class="Symbol">)</a>

        <a id="14055" href="Meta.Foldable.html#489" class="Function">nondet</a> <a id="14062" class="Symbol">(</a><a id="14063" href="Meta.Idiom.html#121" class="InductiveConstructor">eff</a> <a id="14067" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="14071" class="Symbol">)</a> <a id="14073" href="Meta.HLevel.Reflection.html#13635" class="Bound">instances</a> <a id="14083" class="Symbol">λ</a> <a id="14085" href="Meta.HLevel.Reflection.html#14085" class="Bound">a</a> <a id="14087" class="Symbol">→</a> <a id="14089" class="Keyword">do</a>
          <a id="14102" href="Meta.HLevel.Reflection.html#14102" class="Bound">projection</a> <a id="14113" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="14115" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="14125" class="Symbol">{</a><a id="14126" class="Argument">A</a> <a id="14128" class="Symbol">=</a> <a id="14130" href="Meta.HLevel.Reflection.html#4163" class="Record">hlevel-projection</a> <a id="14148" href="Meta.HLevel.Reflection.html#13323" class="Bound">qn</a><a id="14150" class="Symbol">}</a> <a id="14152" href="Meta.HLevel.Reflection.html#14085" class="Bound">a</a>
          <a id="14164" href="Meta.HLevel.Reflection.html#14164" class="Bound">ty</a> <a id="14167" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="14169" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="14184" class="Symbol">(</a><a id="14185" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="14191" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14193" href="Meta.HLevel.Reflection.html#5925" class="Function">atoms</a><a id="14198" class="Symbol">)</a> <a id="14200" class="Symbol">(</a><a id="14201" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="14211" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a> <a id="14216" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="14220" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="14226" class="Symbol">)</a>
          <a id="14238" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="14249" class="String">&quot;tactic.hlevel&quot;</a> <a id="14265" class="Number">20</a> <a id="14268" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="14282" class="String">&quot;Outer type: &quot;</a> <a id="14297" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14299" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="14307" href="Meta.HLevel.Reflection.html#14164" class="Bound">ty</a> <a id="14310" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14312" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="14325" href="Meta.HLevel.Reflection.html#9469" class="Function">treat-as-n-type</a> <a id="14341" href="Meta.HLevel.Reflection.html#14102" class="Bound">projection</a> <a id="14352" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a> <a id="14357" href="Meta.Bind.html#296" class="Function Operator">&gt;&gt;</a> <a id="14360" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="14366" href="Meta.HLevel.Reflection.html#13626" class="Bound">solved</a> <a id="14373" href="Meta.HLevel.Reflection.html#14085" class="Bound">a</a>

      <a id="14382" class="Comment">-- Get rid of any invisible binders that lead the term.</a>
      <a id="14444" href="Meta.HLevel.Reflection.html#14444" class="Function">remove-invisible</a> <a id="14461" class="Symbol">:</a> <a id="14463" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14468" class="Symbol">→</a> <a id="14470" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14475" class="Symbol">→</a> <a id="14477" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="14480" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14491" href="Meta.HLevel.Reflection.html#14444" class="Function">remove-invisible</a>
        <a id="14516" class="Symbol">(</a><a id="14517" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14521" class="Symbol">_</a> <a id="14523" class="Symbol">(</a><a id="14524" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14528" class="Symbol">_</a> <a id="14530" href="Meta.HLevel.Reflection.html#14530" class="Bound">t</a><a id="14531" class="Symbol">))</a>
        <a id="14542" class="Symbol">(</a><a id="14543" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="14546" class="Symbol">(</a><a id="14547" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="14551" class="Symbol">(</a><a id="14552" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="14561" href="Meta.HLevel.Reflection.html#14561" class="Bound">invisible</a> <a id="14571" class="Symbol">_)</a> <a id="14574" class="Symbol">_)</a> <a id="14577" class="Symbol">(</a><a id="14578" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14582" class="Symbol">_</a> <a id="14584" href="Meta.HLevel.Reflection.html#14584" class="Bound">ret</a><a id="14587" class="Symbol">))</a>
        <a id="14598" class="Symbol">=</a> <a id="14600" href="Meta.HLevel.Reflection.html#14444" class="Function">remove-invisible</a> <a id="14617" href="Meta.HLevel.Reflection.html#14530" class="Bound">t</a> <a id="14619" href="Meta.HLevel.Reflection.html#14584" class="Bound">ret</a>
      <a id="14629" href="Meta.HLevel.Reflection.html#14444" class="CatchallClause Function">remove-invisible</a><a id="14645" class="CatchallClause"> </a><a id="14646" href="Meta.HLevel.Reflection.html#14646" class="CatchallClause Bound">inner</a><a id="14651" class="CatchallClause"> </a><a id="14652" class="CatchallClause Symbol">_</a> <a id="14654" class="Symbol">=</a> <a id="14656" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="14661" href="Meta.HLevel.Reflection.html#14646" class="Bound">inner</a>

      <a id="14674" class="Comment">-- Search using decompositions involves manipulating the scope,</a>
      <a id="14744" class="Comment">-- which is why it&#39;s spread over so many functions, and even then,</a>
      <a id="14817" class="Comment">-- some are too big.</a>

      <a id="14845" class="Comment">-- Wrap the given term in a series of visible lambdas.</a>
      <a id="14906" href="Meta.HLevel.Reflection.html#14906" class="Function">wrap-lams</a> <a id="14916" class="Symbol">:</a> <a id="14918" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="14920" class="Symbol">→</a> <a id="14922" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14927" class="Symbol">→</a> <a id="14929" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14940" href="Meta.HLevel.Reflection.html#14906" class="Function">wrap-lams</a> <a id="14950" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="14955" href="Meta.HLevel.Reflection.html#14955" class="Bound">r</a> <a id="14957" class="Symbol">=</a> <a id="14959" href="Meta.HLevel.Reflection.html#14955" class="Bound">r</a>
      <a id="14967" href="Meta.HLevel.Reflection.html#14906" class="Function">wrap-lams</a> <a id="14977" class="Symbol">(</a><a id="14978" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="14982" href="Meta.HLevel.Reflection.html#14982" class="Bound">x</a><a id="14983" class="Symbol">)</a> <a id="14985" href="Meta.HLevel.Reflection.html#14985" class="Bound">r</a> <a id="14987" class="Symbol">=</a> <a id="14989" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14993" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="15001" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15003" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="15007" class="String">&quot;a&quot;</a> <a id="15011" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15013" href="Meta.HLevel.Reflection.html#14906" class="Function">wrap-lams</a> <a id="15023" href="Meta.HLevel.Reflection.html#14982" class="Bound">x</a> <a id="15025" href="Meta.HLevel.Reflection.html#14985" class="Bound">r</a>

      <a id="15034" class="Comment">-- Compute a continuation which extends the context by n visible</a>
      <a id="15105" class="Comment">-- variables, all typed &#39;unknown&#39;.</a>
      <a id="15146" href="Meta.HLevel.Reflection.html#15146" class="Function">extend-n</a> <a id="15155" class="Symbol">:</a> <a id="15157" class="Symbol">∀</a> <a id="15159" class="Symbol">{</a><a id="15160" href="Meta.HLevel.Reflection.html#15160" class="Bound">ℓ</a><a id="15161" class="Symbol">}</a> <a id="15163" class="Symbol">→</a> <a id="15165" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="15167" class="Symbol">→</a> <a id="15169" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15172" class="Symbol">((</a><a id="15174" href="Meta.HLevel.Reflection.html#15174" class="Bound">A</a> <a id="15176" class="Symbol">:</a> <a id="15178" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="15183" href="Meta.HLevel.Reflection.html#15160" class="Bound">ℓ</a><a id="15184" class="Symbol">)</a> <a id="15186" class="Symbol">→</a> <a id="15188" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15191" href="Meta.HLevel.Reflection.html#15174" class="Bound">A</a> <a id="15193" class="Symbol">→</a> <a id="15195" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15198" href="Meta.HLevel.Reflection.html#15174" class="Bound">A</a><a id="15199" class="Symbol">)</a>
      <a id="15207" href="Meta.HLevel.Reflection.html#15146" class="Function">extend-n</a> <a id="15216" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="15221" class="Symbol">=</a> <a id="15223" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15228" class="Symbol">λ</a> <a id="15230" href="Meta.HLevel.Reflection.html#15230" class="Bound">_</a> <a id="15232" href="Meta.HLevel.Reflection.html#15232" class="Bound">x</a> <a id="15234" class="Symbol">→</a> <a id="15236" href="Meta.HLevel.Reflection.html#15232" class="Bound">x</a>
      <a id="15244" href="Meta.HLevel.Reflection.html#15146" class="Function">extend-n</a> <a id="15253" class="Symbol">(</a><a id="15254" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="15258" href="Meta.HLevel.Reflection.html#15258" class="Bound">n</a><a id="15259" class="Symbol">)</a> <a id="15261" class="Symbol">=</a> <a id="15263" class="Keyword">do</a>
        <a id="15274" href="Meta.HLevel.Reflection.html#15274" class="Bound">rest</a> <a id="15279" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="15281" href="Meta.HLevel.Reflection.html#15146" class="Function">extend-n</a> <a id="15290" href="Meta.HLevel.Reflection.html#15258" class="Bound">n</a>
        <a id="15300" href="Foundations.Prim.Type.html#599" class="InductiveConstructor">lift</a> <a id="15305" href="Meta.HLevel.Reflection.html#15305" class="Bound">mv</a> <a id="15308" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="15310" href="Meta.HLevel.Reflection.html#15274" class="Bound">rest</a> <a id="15315" class="Symbol">(</a><a id="15316" href="Foundations.Prim.Type.html#538" class="Record">Lift</a> <a id="15321" class="Symbol">_</a> <a id="15323" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15327" class="Symbol">)</a> <a id="15329" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15331" href="Foundations.Prim.Type.html#599" class="InductiveConstructor">lift</a> <a id="15336" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="15340" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="15349" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="15365" class="Keyword">let</a> <a id="15369" href="Meta.HLevel.Reflection.html#15369" class="Bound">domain</a> <a id="15376" class="Symbol">=</a> <a id="15378" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="15382" class="Symbol">(</a><a id="15383" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="15392" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="15400" class="Symbol">(</a><a id="15401" href="Agda.Builtin.Reflection.html#3463" class="InductiveConstructor">modality</a> <a id="15410" href="Agda.Builtin.Reflection.html#3019" class="InductiveConstructor">relevant</a> <a id="15419" href="Agda.Builtin.Reflection.html#3241" class="InductiveConstructor">quantity-ω</a><a id="15429" class="Symbol">))</a> <a id="15432" href="Meta.HLevel.Reflection.html#15305" class="Bound">mv</a>
        <a id="15443" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15448" class="Symbol">λ</a> <a id="15450" href="Meta.HLevel.Reflection.html#15450" class="Bound">a</a> <a id="15452" href="Meta.HLevel.Reflection.html#15452" class="Bound">k</a> <a id="15454" class="Symbol">→</a> <a id="15456" href="Meta.HLevel.Reflection.html#15274" class="Bound">rest</a> <a id="15461" href="Meta.HLevel.Reflection.html#15450" class="Bound">a</a> <a id="15463" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15465" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="15479" class="String">&quot;a&quot;</a> <a id="15483" href="Meta.HLevel.Reflection.html#15369" class="Bound">domain</a> <a id="15490" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15492" href="Meta.HLevel.Reflection.html#15452" class="Bound">k</a>

      <a id="15501" class="Comment">-- Given a list of argument specs, actually unify the goal with</a>
      <a id="15571" class="Comment">-- the solution of decomposition, and call a continuation to</a>
      <a id="15638" class="Comment">-- perform any outstanding searches.</a>
      <a id="15681" href="Meta.HLevel.Reflection.html#15681" class="Function">gen-args</a>
        <a id="15698" class="Symbol">:</a> <a id="15700" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>              <a id="15718" class="Comment">-- ^ Are there any alternatives after this one?</a>
        <a id="15774" class="Symbol">→</a> <a id="15776" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>              <a id="15794" class="Comment">-- ^ What level are we searching for?</a>

        <a id="15841" class="Symbol">→</a> <a id="15843" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>              <a id="15861" class="Comment">-- ^ Name of the lemma,</a>
        <a id="15893" class="Symbol">→</a> <a id="15895" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15900" href="Meta.HLevel.Reflection.html#2923" class="Datatype">Arg-spec</a>     <a id="15913" class="Comment">-- ^ and the arguments we should invent.</a>

        <a id="15963" class="Symbol">→</a> <a id="15965" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15970" class="Symbol">(</a><a id="15971" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="15975" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15979" class="Symbol">)</a>
        <a id="15989" class="Comment">-- ^ Accumulator: computed arguments (criminally, in reverse</a>
        <a id="16058" class="Comment">-- order)</a>
        <a id="16076" class="Symbol">→</a> <a id="16078" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="16081" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
          <a id="16093" class="Comment">-- ^ Accumulator/continuation: what do we need to do after</a>
          <a id="16162" class="Comment">-- unifying the goal with the lemma?. This is both</a>
          <a id="16223" class="Comment">-- continuation (it can be used to run something after the</a>
          <a id="16292" class="Comment">-- arguments are built) and accumulator (searching recursively</a>
          <a id="16365" class="Comment">-- is done last).</a>
        <a id="16391" class="Symbol">→</a> <a id="16393" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="16396" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>              <a id="16411" class="Comment">-- ^ Returns nada</a>
      <a id="16435" href="Meta.HLevel.Reflection.html#15681" class="Function">gen-args</a> <a id="16444" href="Meta.HLevel.Reflection.html#16444" class="Bound">has-alts</a> <a id="16453" href="Meta.HLevel.Reflection.html#16453" class="Bound">level</a> <a id="16459" href="Meta.HLevel.Reflection.html#16459" class="Bound">defn</a> <a id="16464" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="16467" href="Meta.HLevel.Reflection.html#16467" class="Bound">accum</a> <a id="16473" href="Meta.HLevel.Reflection.html#16473" class="Bound">cont</a> <a id="16478" class="Symbol">=</a> <a id="16480" class="Keyword">do</a>
        <a id="16491" class="Comment">-- If we have no arguments to generate, then we can go ahead and</a>
        <a id="16564" class="Comment">-- use the accumulator as-is.</a>
        <a id="16602" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="16608" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a> <a id="16613" class="Symbol">(</a><a id="16614" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16618" href="Meta.HLevel.Reflection.html#16459" class="Bound">defn</a> <a id="16623" class="Symbol">(</a><a id="16624" href="Data.List.Base.html#972" class="Function">reverse-fast</a> <a id="16637" href="Meta.HLevel.Reflection.html#16467" class="Bound">accum</a><a id="16642" class="Symbol">))</a>
        <a id="16653" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="16664" class="String">&quot;tactic.hlevel&quot;</a> <a id="16680" class="Number">10</a> <a id="16683" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="16695" class="String">&quot;Committed to solution: &quot;</a> <a id="16721" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16723" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="16731" class="Symbol">(</a><a id="16732" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16736" href="Meta.HLevel.Reflection.html#16459" class="Bound">defn</a> <a id="16741" class="Symbol">(</a><a id="16742" href="Data.List.Base.html#883" class="Function">reverse</a> <a id="16750" href="Meta.HLevel.Reflection.html#16467" class="Bound">accum</a><a id="16755" class="Symbol">))</a> <a id="16758" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16760" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="16771" href="Meta.HLevel.Reflection.html#16473" class="Bound">cont</a>

      <a id="16783" href="Meta.HLevel.Reflection.html#15681" class="Function">gen-args</a> <a id="16792" href="Meta.HLevel.Reflection.html#16792" class="Bound">has-alts</a> <a id="16801" href="Meta.HLevel.Reflection.html#16801" class="Bound">level</a> <a id="16807" href="Meta.HLevel.Reflection.html#16807" class="Bound">defn</a> <a id="16812" class="Symbol">(</a><a id="16813" href="Meta.HLevel.Reflection.html#16813" class="Bound">x</a> <a id="16815" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16817" href="Meta.HLevel.Reflection.html#16817" class="Bound">args</a><a id="16821" class="Symbol">)</a> <a id="16823" href="Meta.HLevel.Reflection.html#16823" class="Bound">accum</a> <a id="16829" href="Meta.HLevel.Reflection.html#16829" class="Bound">cont</a> <a id="16834" class="Keyword">with</a> <a id="16839" href="Meta.HLevel.Reflection.html#16813" class="Bound">x</a>
      <a id="16847" class="Comment">-- If we got asked for the level without an adjustment (i.e. monus</a>
      <a id="16920" class="Comment">-- by zero), then we may as well not bother *trying* to adjust it.</a>
      <a id="16993" class="Comment">-- Saves a bit of computation.</a>
      <a id="17030" class="Symbol">...</a> <a id="17034" class="Symbol">|</a> <a id="17036" href="Meta.HLevel.Reflection.html#2947" class="InductiveConstructor">`level-minus</a> <a id="17049" class="Number">0</a> <a id="17051" class="Symbol">=</a> <a id="17053" href="Meta.HLevel.Reflection.html#15681" class="Function">gen-args</a> <a id="17062" class="Bound">has-alts</a> <a id="17071" class="Bound">level</a> <a id="17077" class="Bound">defn</a> <a id="17082" class="Bound">args</a> <a id="17087" class="Symbol">(</a><a id="17088" class="Bound">level</a> <a id="17094" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="17097" class="Bound">accum</a><a id="17102" class="Symbol">)</a> <a id="17104" class="Bound">cont</a>
      <a id="17115" class="Comment">-- If we have to insert the level minus some offset, then we need</a>
      <a id="17187" class="Comment">-- to do the computation:</a>
      <a id="17219" class="Symbol">...</a> <a id="17223" class="Symbol">|</a> <a id="17225" href="Meta.HLevel.Reflection.html#2947" class="InductiveConstructor">`level-minus</a> <a id="17238" href="Meta.HLevel.Reflection.html#17238" class="Bound">n</a><a id="17239" class="Symbol">@(</a><a id="17241" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17245" class="Symbol">_)</a> <a id="17248" class="Symbol">=</a>
        <a id="17258" class="Keyword">do</a>
          <a id="17271" href="Meta.HLevel.Reflection.html#17271" class="Bound">level</a> <a id="17277" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="17279" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="17289" class="Bound">level</a>
          <a id="17305" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="17316" class="String">&quot;tactic.hlevel&quot;</a> <a id="17332" class="Number">10</a> <a id="17335" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="17349" class="String">&quot;Hint demands offset, performing symbolic monus, subtracting from\n  &quot;</a> <a id="17420" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17422" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="17430" href="Meta.HLevel.Reflection.html#17271" class="Bound">level</a> <a id="17436" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17438" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="17451" href="Meta.HLevel.Reflection.html#17451" class="Bound">level′′</a> <a id="17459" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="17461" href="Meta.HLevel.Reflection.html#18046" class="Function">monus</a> <a id="17467" href="Meta.HLevel.Reflection.html#17271" class="Bound">level</a> <a id="17473" href="Meta.HLevel.Reflection.html#17238" class="Bound">n</a>
          <a id="17485" class="Comment">-- Reduce otherwise we get Number.fromNat as the term</a>
          <a id="17549" href="Meta.HLevel.Reflection.html#15681" class="Function">gen-args</a> <a id="17558" class="Bound">has-alts</a> <a id="17567" href="Meta.HLevel.Reflection.html#17271" class="Bound">level</a> <a id="17573" class="Bound">defn</a> <a id="17578" class="Bound">args</a> <a id="17583" class="Symbol">(</a><a id="17584" href="Meta.HLevel.Reflection.html#17451" class="Bound">level′′</a> <a id="17592" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="17595" class="Bound">accum</a><a id="17600" class="Symbol">)</a> <a id="17602" class="Bound">cont</a>
        <a id="17615" class="Keyword">where</a>
          <a id="17631" class="Comment">-- A &#39;symbolic&#39; monus function. If we&#39;re looking at an actual</a>
          <a id="17703" class="Comment">-- number, then we can just do the computation in TC, but</a>
          <a id="17771" class="Comment">-- otherwise we have to reimplement the builtin subtraction,</a>
          <a id="17842" class="Comment">-- where the minuend is a *term* rather than a number. In</a>
          <a id="17910" class="Comment">-- addition to being a bad operation (monus, grr), it&#39;s</a>
          <a id="17976" class="Comment">-- *partial*. We can end up backtracking while subtracting.</a>
          <a id="18046" href="Meta.HLevel.Reflection.html#18046" class="Function">monus</a> <a id="18052" class="Symbol">:</a> <a id="18054" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="18059" class="Symbol">→</a> <a id="18061" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="18063" class="Symbol">→</a> <a id="18065" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="18068" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
          <a id="18083" href="Meta.HLevel.Reflection.html#18046" class="Function">monus</a> <a id="18089" class="Symbol">(</a><a id="18090" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="18094" class="Symbol">(</a><a id="18095" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18099" href="Meta.HLevel.Reflection.html#18099" class="Bound">n</a><a id="18100" class="Symbol">))</a> <a id="18103" href="Meta.HLevel.Reflection.html#18103" class="Bound">k</a> <a id="18105" class="Symbol">=</a> <a id="18107" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18112" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="18114" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="18118" class="Symbol">(</a><a id="18119" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18123" class="Symbol">(</a><a id="18124" href="Meta.HLevel.Reflection.html#18099" class="Bound">n</a> <a id="18126" href="Agda.Builtin.Nat.html#426" class="Primitive Operator">-</a> <a id="18128" href="Meta.HLevel.Reflection.html#18103" class="Bound">k</a><a id="18129" class="Symbol">))</a>
          <a id="18142" href="Meta.HLevel.Reflection.html#18046" class="CatchallClause Function">monus</a><a id="18147" class="CatchallClause"> </a><a id="18148" href="Meta.HLevel.Reflection.html#18148" class="CatchallClause Bound">tm</a><a id="18150" class="CatchallClause"> </a><a id="18151" href="Agda.Builtin.Nat.html#221" class="CatchallClause InductiveConstructor">zero</a> <a id="18156" class="Symbol">=</a> <a id="18158" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18163" href="Meta.HLevel.Reflection.html#18148" class="Bound">tm</a>
          <a id="18176" href="Meta.HLevel.Reflection.html#18046" class="Function">monus</a> <a id="18182" href="Meta.HLevel.Reflection.html#18182" class="Bound">thezero</a><a id="18189" class="Symbol">@(</a><a id="18191" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18195" class="Symbol">(</a><a id="18196" class="Keyword">quote</a> <a id="18202" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="18206" class="Symbol">)</a> <a id="18208" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18210" class="Symbol">)</a> <a id="18212" class="Symbol">(</a><a id="18213" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18217" href="Meta.HLevel.Reflection.html#18217" class="Bound">it</a><a id="18219" class="Symbol">)</a> <a id="18221" class="Symbol">=</a> <a id="18223" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18228" href="Meta.HLevel.Reflection.html#18182" class="Bound">thezero</a>
          <a id="18246" href="Meta.HLevel.Reflection.html#18046" class="Function">monus</a> <a id="18252" class="Symbol">(</a><a id="18253" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18257" class="Symbol">(</a><a id="18258" class="Keyword">quote</a> <a id="18264" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="18267" class="Symbol">)</a> <a id="18269" class="Symbol">(</a><a id="18270" href="Meta.HLevel.Reflection.html#18270" class="Bound">x</a> <a id="18272" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="18275" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18277" class="Symbol">))</a> <a id="18280" class="Symbol">(</a><a id="18281" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18285" href="Meta.HLevel.Reflection.html#18285" class="Bound">it</a><a id="18287" class="Symbol">)</a> <a id="18289" class="Symbol">=</a> <a id="18291" class="Keyword">do</a>
            <a id="18306" href="Meta.HLevel.Reflection.html#18306" class="Bound">x</a> <a id="18308" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="18310" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="18317" href="Meta.HLevel.Reflection.html#18270" class="Bound">x</a>
            <a id="18331" href="Meta.HLevel.Reflection.html#18046" class="Function">monus</a> <a id="18337" href="Meta.HLevel.Reflection.html#18306" class="Bound">x</a> <a id="18339" href="Meta.HLevel.Reflection.html#18285" class="Bound">it</a>
          <a id="18352" href="Meta.HLevel.Reflection.html#18046" class="CatchallClause Function">monus</a><a id="18357" class="CatchallClause"> </a><a id="18358" href="Meta.HLevel.Reflection.html#18358" class="CatchallClause Bound">tm</a><a id="18360" class="CatchallClause"> </a><a id="18361" class="CatchallClause Symbol">(</a><a id="18362" href="Agda.Builtin.Nat.html#234" class="CatchallClause InductiveConstructor">suc</a><a id="18365" class="CatchallClause"> </a><a id="18366" href="Meta.HLevel.Reflection.html#18366" class="CatchallClause Bound">it</a><a id="18368" class="CatchallClause Symbol">)</a> <a id="18370" class="Symbol">=</a> <a id="18372" class="Keyword">do</a>
            <a id="18387" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="18398" class="String">&quot;tactic.hlevel&quot;</a> <a id="18414" class="Number">10</a> <a id="18417" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="18419" class="String">&quot;Dunno how to take 1 from &quot;</a> <a id="18447" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18449" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="18457" href="Meta.HLevel.Reflection.html#18358" class="Bound">tm</a> <a id="18460" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18462" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
            <a id="18477" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="18487" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="18497" class="Comment">-- Insert a metavariable, to be solved by Agda. It&#39;d be sad if the</a>
      <a id="18570" class="Comment">-- macro handled everything!</a>
      <a id="18605" class="Symbol">...</a> <a id="18609" class="Symbol">|</a> <a id="18611" href="Meta.HLevel.Reflection.html#3350" class="InductiveConstructor">`meta</a> <a id="18617" class="Symbol">=</a> <a id="18619" href="Meta.HLevel.Reflection.html#15681" class="Function">gen-args</a> <a id="18628" class="Bound">has-alts</a> <a id="18637" class="Bound">level</a> <a id="18643" class="Bound">defn</a> <a id="18648" class="Bound">args</a> <a id="18653" class="Symbol">(</a><a id="18654" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="18662" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="18665" class="Bound">accum</a><a id="18670" class="Symbol">)</a> <a id="18672" class="Bound">cont</a>

      <a id="18684" class="Symbol">...</a> <a id="18688" class="Symbol">|</a> <a id="18690" href="Meta.HLevel.Reflection.html#3147" class="InductiveConstructor">`search-under</a> <a id="18704" href="Meta.HLevel.Reflection.html#18704" class="Bound">under</a> <a id="18710" class="Symbol">=</a> <a id="18712" class="Keyword">do</a>
        <a id="18723" class="Comment">-- To search under some variables, we work in a scope extended</a>
        <a id="18794" class="Comment">-- by &#39;under&#39;-many variables. The metavariable lives in that</a>
        <a id="18863" class="Comment">-- scope, so we have to quantify over the variables we</a>
        <a id="18926" class="Comment">-- introduced to use it outside, i.e., in the actual (outer)</a>
        <a id="18995" class="Comment">-- search problem.</a>
        <a id="19022" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19033" class="String">&quot;tactic.hlevel&quot;</a> <a id="19049" class="Number">10</a> <a id="19052" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19054" class="String">&quot;Going under &quot;</a> <a id="19069" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19071" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="19079" class="Symbol">(</a><a id="19080" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="19084" class="Symbol">(</a><a id="19085" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="19089" href="Meta.HLevel.Reflection.html#18704" class="Bound">under</a><a id="19094" class="Symbol">))</a> <a id="19097" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19099" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="19110" href="Meta.HLevel.Reflection.html#19110" class="Bound">gounder</a> <a id="19118" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="19120" href="Meta.HLevel.Reflection.html#15146" class="Function">extend-n</a> <a id="19129" href="Meta.HLevel.Reflection.html#18704" class="Bound">under</a>
        <a id="19143" href="Meta.HLevel.Reflection.html#19143" class="Bound">mv</a> <a id="19146" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="19148" href="Meta.HLevel.Reflection.html#19110" class="Bound">gounder</a> <a id="19156" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19161" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19163" class="Keyword">do</a>
          <a id="19176" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19187" class="String">&quot;tactic.hlevel&quot;</a> <a id="19203" class="Number">10</a> <a id="19206" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19208" class="String">&quot;In extended context&quot;</a>
          <a id="19240" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="19249" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="19265" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19276" class="String">&quot;tactic.hlevel&quot;</a> <a id="19292" class="Number">10</a> <a id="19295" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19297" class="String">&quot;Metavariable: &quot;</a> <a id="19314" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19316" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="19324" class="Symbol">(</a><a id="19325" href="Meta.HLevel.Reflection.html#14906" class="Function">wrap-lams</a> <a id="19335" href="Meta.HLevel.Reflection.html#18704" class="Bound">under</a> <a id="19341" href="Meta.HLevel.Reflection.html#19143" class="Bound">mv</a><a id="19343" class="Symbol">)</a> <a id="19345" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19347" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="19358" class="Comment">-- After we&#39;ve put the mv wrapped under some lambdas in the</a>
        <a id="19426" class="Comment">-- argument list,</a>
        <a id="19452" href="Meta.HLevel.Reflection.html#15681" class="Function">gen-args</a> <a id="19461" class="Bound">has-alts</a> <a id="19470" class="Bound">level</a> <a id="19476" class="Bound">defn</a> <a id="19481" class="Bound">args</a> <a id="19486" class="Symbol">(</a><a id="19487" href="Meta.HLevel.Reflection.html#14906" class="Function">wrap-lams</a> <a id="19497" href="Meta.HLevel.Reflection.html#18704" class="Bound">under</a> <a id="19503" href="Meta.HLevel.Reflection.html#19143" class="Bound">mv</a> <a id="19506" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="19509" class="Bound">accum</a><a id="19514" class="Symbol">)</a> <a id="19516" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19518" class="Keyword">do</a>
          <a id="19531" class="Comment">-- On our way back up, we do any more searching that needed to</a>
          <a id="19604" class="Comment">-- get done, and..</a>
          <a id="19633" class="Bound">cont</a>
          <a id="19648" class="Comment">-- go back under the new scope to recursively search for</a>
          <a id="19715" class="Comment">-- levels.</a>
          <a id="19736" href="Meta.HLevel.Reflection.html#19110" class="Bound">gounder</a> <a id="19744" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="19746" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19748" href="Meta.HLevel.Reflection.html#12643" class="Function">search</a> <a id="19755" class="Bound">has-alts</a> <a id="19764" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="19772" href="Meta.HLevel.Reflection.html#12929" class="Bound">n</a> <a id="19774" href="Meta.HLevel.Reflection.html#19143" class="Bound">mv</a>

      <a id="19784" class="Comment">-- Try all the candidate hints in order. This is a version of</a>
      <a id="19852" class="Comment">-- &#39;nondet&#39; which additionally threads whether we&#39;re looking at</a>
      <a id="19922" class="Comment">-- last alternative.</a>
      <a id="19949" href="Meta.HLevel.Reflection.html#19949" class="Function">use-decomp-hints</a> <a id="19966" class="Symbol">:</a> <a id="19968" class="Symbol">(</a><a id="19969" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19974" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="19976" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="19980" class="Symbol">)</a> <a id="19982" class="Symbol">→</a> <a id="19984" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19989" class="Symbol">→</a> <a id="19991" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="19996" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="20001" class="Symbol">→</a> <a id="20003" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="20006" class="Symbol">(</a><a id="20007" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="20009" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="20011" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="20015" class="Symbol">)</a>
      <a id="20023" href="Meta.HLevel.Reflection.html#19949" class="Function">use-decomp-hints</a> <a id="20040" class="Symbol">(</a><a id="20041" href="Meta.HLevel.Reflection.html#20041" class="Bound">lv</a> <a id="20044" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="20046" href="Meta.HLevel.Reflection.html#20046" class="Bound">goal-ty</a><a id="20053" class="Symbol">)</a> <a id="20055" href="Meta.HLevel.Reflection.html#20055" class="Bound">solved</a> <a id="20062" class="Symbol">(</a><a id="20063" href="Meta.HLevel.Reflection.html#20063" class="Bound">c1</a> <a id="20066" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20068" href="Meta.HLevel.Reflection.html#20068" class="Bound">cs</a><a id="20070" class="Symbol">)</a> <a id="20072" class="Symbol">=</a> <a id="20074" class="Keyword">do</a>
        <a id="20085" href="Meta.HLevel.Reflection.html#20085" class="Bound">ty</a> <a id="20088" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20090" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="20100" href="Meta.HLevel.Reflection.html#20063" class="Bound">c1</a>
        <a id="20111" href="Meta.HLevel.Reflection.html#20111" class="Bound">c1′</a> <a id="20115" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20117" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="20124" href="Meta.HLevel.Reflection.html#20063" class="Bound">c1</a>
        <a id="20135" class="Symbol">(</a><a id="20136" href="Meta.HLevel.Reflection.html#14444" class="Function">remove-invisible</a> <a id="20153" href="Meta.HLevel.Reflection.html#20111" class="Bound">c1′</a> <a id="20157" href="Meta.HLevel.Reflection.html#20085" class="Bound">ty</a> <a id="20160" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="20164" class="Symbol">λ</a> <a id="20166" class="Keyword">where</a>

          <a id="20183" class="Comment">-- If we have an actual decomp constructor, then we can try</a>
          <a id="20253" class="Comment">-- using its argument specification to construct a little</a>
          <a id="20321" class="Comment">-- h-level lemma</a>
          <a id="20348" class="Symbol">(</a><a id="20349" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="20353" class="Symbol">(</a><a id="20354" class="Keyword">quote</a> <a id="20360" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a><a id="20366" class="Symbol">)</a> <a id="20368" class="Symbol">(_</a> <a id="20371" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20373" class="Symbol">_</a> <a id="20375" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20377" href="Meta.HLevel.Reflection.html#20377" class="Bound">nm</a> <a id="20380" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="20383" href="Meta.HLevel.Reflection.html#20383" class="Bound">argspec</a> <a id="20391" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="20394" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20396" class="Symbol">))</a> <a id="20399" class="Symbol">→</a> <a id="20401" class="Keyword">do</a>
            <a id="20416" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="20427" class="String">&quot;tactic.hlevel&quot;</a> <a id="20443" class="Number">10</a> <a id="20446" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
              <a id="20462" class="String">&quot;Using &quot;</a> <a id="20471" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20473" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20481" href="Meta.HLevel.Reflection.html#20377" class="Bound">nm</a> <a id="20484" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20486" class="String">&quot; decomposition for:\n  &quot;</a>
              <a id="20526" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20528" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20536" class="Symbol">(</a><a id="20537" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="20541" class="Symbol">(</a><a id="20542" class="Keyword">quote</a> <a id="20548" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a><a id="20560" class="Symbol">)</a> <a id="20562" class="Symbol">(</a><a id="20563" href="Meta.HLevel.Reflection.html#20041" class="Bound">lv</a> <a id="20566" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="20569" href="Meta.HLevel.Reflection.html#20046" class="Bound">goal-ty</a> <a id="20577" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="20580" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20582" class="Symbol">))</a> <a id="20585" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20587" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

            <a id="20603" href="Meta.HLevel.Reflection.html#20603" class="Bound">nm′</a> <a id="20607" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20609" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20619" href="Meta.HLevel.Reflection.html#20377" class="Bound">nm</a>
            <a id="20634" href="Meta.HLevel.Reflection.html#20634" class="Bound">argsp</a> <a id="20640" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20642" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20652" href="Meta.HLevel.Reflection.html#20383" class="Bound">argspec</a>
            <a id="20672" class="Comment">-- Generate the argument spine, and discard the instance</a>
            <a id="20741" class="Comment">-- search meta.</a>
            <a id="20769" href="Meta.HLevel.Reflection.html#15681" class="Function">gen-args</a> <a id="20778" class="Symbol">(</a><a id="20779" href="Data.Bool.Base.html#169" class="Function">not</a> <a id="20783" class="Symbol">(</a><a id="20784" href="Data.List.Operations.html#440" class="Function">length</a> <a id="20791" href="Meta.HLevel.Reflection.html#20068" class="Bound">cs</a> <a id="20794" href="Agda.Builtin.Nat.html#631" class="Primitive Operator">==</a> <a id="20797" class="Number">0</a><a id="20798" class="Symbol">))</a> <a id="20801" href="Meta.HLevel.Reflection.html#20041" class="Bound">lv</a> <a id="20804" href="Meta.HLevel.Reflection.html#20603" class="Bound">nm′</a> <a id="20808" href="Meta.HLevel.Reflection.html#20634" class="Bound">argsp</a> <a id="20814" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="20817" class="Symbol">(</a><a id="20818" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="20827" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="20829" class="Symbol">)</a>
            <a id="20843" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="20849" href="Meta.HLevel.Reflection.html#20055" class="Bound">solved</a> <a id="20856" href="Meta.HLevel.Reflection.html#20063" class="Bound">c1</a>

            <a id="20872" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="20877" class="Symbol">(</a><a id="20878" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="20881" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="20883" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="20887" class="Symbol">)</a>

          <a id="20900" class="Comment">-- It&#39;s possible that this particular hint was a bust, i.e.</a>
          <a id="20970" class="Comment">-- because someone wasn&#39;t being careful with what</a>
          <a id="21030" class="Comment">-- hlevel-decomposition instances they&#39;ve defined. That&#39;s no</a>
          <a id="21101" class="Comment">-- matter: we can just ignore it.</a>
          <a id="21145" class="CatchallClause Symbol">_</a> <a id="21147" class="Symbol">→</a> <a id="21149" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="21159" class="String">&quot;Non-canonical hint&quot;</a><a id="21179" class="Symbol">)</a>
          <a id="21191" class="Comment">-- If we didn&#39;t manage to get the hint to work, for any</a>
          <a id="21257" class="Comment">-- reason, try again with the rest of the hints.</a>
          <a id="21316" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="21320" href="Meta.HLevel.Reflection.html#19949" class="Function">use-decomp-hints</a> <a id="21337" class="Symbol">(</a><a id="21338" href="Meta.HLevel.Reflection.html#20041" class="Bound">lv</a> <a id="21341" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21343" href="Meta.HLevel.Reflection.html#20046" class="Bound">goal-ty</a><a id="21350" class="Symbol">)</a> <a id="21352" href="Meta.HLevel.Reflection.html#20055" class="Bound">solved</a> <a id="21359" href="Meta.HLevel.Reflection.html#20068" class="Bound">cs</a>

      <a id="21369" href="Meta.HLevel.Reflection.html#19949" class="Function">use-decomp-hints</a> <a id="21386" class="Symbol">(_</a> <a id="21389" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21391" href="Meta.HLevel.Reflection.html#21391" class="Bound">goal-ty</a><a id="21398" class="Symbol">)</a> <a id="21400" class="Symbol">_</a> <a id="21402" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="21405" class="Symbol">=</a>
        <a id="21415" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="21425" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="21427" class="String">&quot;Ran out of decomposition hints for &quot;</a> <a id="21465" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21467" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="21475" href="Meta.HLevel.Reflection.html#21391" class="Bound">goal-ty</a> <a id="21483" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21485" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="21495" class="Comment">-- Using the hints involving querying Agda for potential</a>
      <a id="21558" class="Comment">-- instances, then trying each in order.</a>
      <a id="21605" href="Meta.HLevel.Reflection.html#21605" class="Function">use-hints</a> <a id="21615" class="Symbol">:</a> <a id="21617" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="21620" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="21628" href="Meta.HLevel.Reflection.html#21605" class="Function">use-hints</a> <a id="21638" class="Symbol">=</a> <a id="21640" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="21655" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="21657" class="Keyword">do</a>
        <a id="21668" class="Symbol">(</a><a id="21669" href="Meta.HLevel.Reflection.html#21669" class="Bound">lv</a> <a id="21672" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21674" href="Meta.HLevel.Reflection.html#21674" class="Bound">ty</a><a id="21676" class="Symbol">)</a> <a id="21678" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="21680" href="Meta.HLevel.Reflection.html#6488" class="Function">decompose-is-hlevel</a> <a id="21700" href="Meta.HLevel.Reflection.html#12932" class="Bound">goal</a>

        <a id="21714" class="Comment">-- Note that if the type here is a metavariable, the tactic is..</a>
        <a id="21787" class="Comment">-- loopy.</a>
        <a id="21805" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="21810" href="Meta.HLevel.Reflection.html#21674" class="Bound">ty</a> <a id="21813" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="21817" class="Symbol">λ</a> <a id="21819" class="Keyword">where</a>
          <a id="21835" class="Symbol">(</a><a id="21836" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="21841" href="Meta.HLevel.Reflection.html#21841" class="Bound">m</a> <a id="21843" class="Symbol">_)</a> <a id="21846" class="Symbol">→</a> <a id="21848" class="Keyword">do</a>
            <a id="21863" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="21874" class="String">&quot;tactic.hlevel&quot;</a> <a id="21890" class="Number">10</a>
              <a id="21907" class="String">&quot;Type under is-hlevel is metavariable, blocking to avoid infinite loop&quot;</a>
            <a id="21991" href="Agda.Builtin.Reflection.html#9468" class="Postulate">blockOnMeta</a> <a id="22003" href="Meta.HLevel.Reflection.html#21841" class="Bound">m</a>
          <a id="22015" class="CatchallClause Symbol">_</a> <a id="22017" class="Symbol">→</a> <a id="22019" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="22024" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>

        <a id="22036" class="Comment">-- Create a meta of type hlevel-decomposition to find any possible hints..</a>
        <a id="22119" href="Meta.HLevel.Reflection.html#22119" class="Bound">solved</a><a id="22125" class="Symbol">@(</a><a id="22127" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="22132" href="Meta.HLevel.Reflection.html#22132" class="Bound">mv</a> <a id="22135" class="Symbol">_)</a> <a id="22138" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22140" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="22149" class="Symbol">(</a><a id="22150" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="22154" class="Symbol">(</a><a id="22155" class="Keyword">quote</a> <a id="22161" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a><a id="22181" class="Symbol">)</a> <a id="22183" class="Symbol">(</a><a id="22184" href="Meta.HLevel.Reflection.html#21674" class="Bound">ty</a> <a id="22187" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="22190" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22192" class="Symbol">))</a>
          <a id="22205" class="Keyword">where</a> <a id="22211" class="CatchallClause Symbol">_</a> <a id="22213" class="Symbol">→</a> <a id="22215" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="22225" class="Symbol">(</a><a id="22226" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22234" href="Meta.HLevel.Reflection.html#21674" class="Bound">ty</a> <a id="22237" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22239" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22241" class="Symbol">)</a>
        <a id="22251" href="Meta.HLevel.Reflection.html#22251" class="Bound">instances</a> <a id="22261" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22263" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="22276" href="Meta.HLevel.Reflection.html#22132" class="Bound">mv</a>

        <a id="22288" href="Meta.HLevel.Reflection.html#22288" class="Bound">t</a> <a id="22290" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22292" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="22300" href="Meta.HLevel.Reflection.html#22251" class="Bound">instances</a>
        <a id="22318" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="22329" class="String">&quot;tactic.hlevel&quot;</a> <a id="22345" class="Number">10</a> <a id="22348" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="22360" class="String">&quot;Finding decompositions for\n&quot;</a> <a id="22391" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22403" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22411" href="Meta.HLevel.Reflection.html#21674" class="Bound">ty</a> <a id="22414" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22426" class="String">&quot;\nFound candidates\n &quot;</a> <a id="22450" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22462" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22470" href="Meta.HLevel.Reflection.html#22288" class="Bound">t</a> <a id="22472" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22474" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="22486" class="Comment">-- And try using the hints.</a>
        <a id="22522" href="Meta.HLevel.Reflection.html#19949" class="Function">use-decomp-hints</a> <a id="22539" class="Symbol">(</a><a id="22540" href="Meta.HLevel.Reflection.html#21669" class="Bound">lv</a> <a id="22543" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22545" href="Meta.HLevel.Reflection.html#21674" class="Bound">ty</a><a id="22547" class="Symbol">)</a> <a id="22549" href="Meta.HLevel.Reflection.html#22119" class="Bound">solved</a> <a id="22556" href="Meta.HLevel.Reflection.html#22251" class="Bound">instances</a>

  <a id="22569" class="Comment">-- At the top-level, our goal doesn&#39;t need to have literally the type</a>
  <a id="22641" class="Comment">-- is-hlevel A n. It can be under any number of Πs, both implicit and</a>
  <a id="22713" class="Comment">-- explicit. This means that a goal like (∀ x → is-hlevel T n) can be</a>
  <a id="22785" class="Comment">-- solved using just hlevel!, rather than λ _ → hlevel!. Of course,</a>
  <a id="22855" class="Comment">-- the effect is the same.</a>
  <a id="decompose-is-hlevel-top"></a><a id="22884" href="Meta.HLevel.Reflection.html#22884" class="Function">decompose-is-hlevel-top</a>
    <a id="22912" class="Symbol">:</a> <a id="22914" class="Symbol">∀</a> <a id="22916" class="Symbol">{</a><a id="22917" href="Meta.HLevel.Reflection.html#22917" class="Bound">ℓ</a><a id="22918" class="Symbol">}</a> <a id="22920" class="Symbol">{</a><a id="22921" href="Meta.HLevel.Reflection.html#22921" class="Bound">A</a> <a id="22923" class="Symbol">:</a> <a id="22925" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="22930" href="Meta.HLevel.Reflection.html#22917" class="Bound">ℓ</a><a id="22931" class="Symbol">}</a>
    <a id="22937" class="Symbol">→</a> <a id="22939" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22944" class="Symbol">→</a> <a id="22946" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22949" class="Symbol">(</a><a id="22950" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22955" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22957" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22962" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22964" class="Symbol">(</a><a id="22965" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22968" href="Meta.HLevel.Reflection.html#22921" class="Bound">A</a> <a id="22970" class="Symbol">→</a> <a id="22972" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22975" href="Meta.HLevel.Reflection.html#22921" class="Bound">A</a><a id="22976" class="Symbol">)</a> <a id="22978" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22980" class="Symbol">(</a><a id="22981" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22986" class="Symbol">→</a> <a id="22988" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="22992" class="Symbol">))</a>
  <a id="22997" href="Meta.HLevel.Reflection.html#22884" class="Function">decompose-is-hlevel-top</a> <a id="23021" href="Meta.HLevel.Reflection.html#23021" class="Bound">goal</a> <a id="23026" class="Symbol">=</a>
    <a id="23032" class="Keyword">do</a>
      <a id="23041" href="Meta.HLevel.Reflection.html#23041" class="Bound">ty</a> <a id="23044" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23046" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="23061" class="Symbol">(</a><a id="23062" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="23068" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23070" href="Meta.HLevel.Reflection.html#5925" class="Function">atoms</a><a id="23075" class="Symbol">)</a> <a id="23077" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
        <a id="23087" class="Symbol">(</a><a id="23088" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="23098" href="Meta.HLevel.Reflection.html#23021" class="Bound">goal</a> <a id="23103" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23107" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="23113" class="Symbol">)</a> <a id="23115" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23119" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a>
      <a id="23141" href="Meta.HLevel.Reflection.html#23163" class="Function">go</a> <a id="23144" href="Meta.HLevel.Reflection.html#23041" class="Bound">ty</a>
    <a id="23151" class="Keyword">where</a>
      <a id="23163" href="Meta.HLevel.Reflection.html#23163" class="Function">go</a> <a id="23166" class="Symbol">:</a> <a id="23168" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23173" class="Symbol">→</a> <a id="23175" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23178" class="Symbol">_</a>
      <a id="23186" href="Meta.HLevel.Reflection.html#23163" class="Function">go</a> <a id="23189" class="Symbol">(</a><a id="23190" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="23193" class="Symbol">(</a><a id="23194" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23198" href="Meta.HLevel.Reflection.html#23198" class="Bound">as</a> <a id="23201" href="Meta.HLevel.Reflection.html#23201" class="Bound">at</a><a id="23203" class="Symbol">)</a> <a id="23205" class="Symbol">(</a><a id="23206" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23210" href="Meta.HLevel.Reflection.html#23210" class="Bound">vn</a> <a id="23213" href="Meta.HLevel.Reflection.html#23213" class="Bound">cd</a><a id="23215" class="Symbol">))</a> <a id="23218" class="Symbol">=</a> <a id="23220" class="Keyword">do</a>
        <a id="23231" class="Symbol">(</a><a id="23232" href="Meta.HLevel.Reflection.html#23232" class="Bound">hlevel</a> <a id="23239" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23241" href="Meta.HLevel.Reflection.html#23241" class="Bound">inner</a> <a id="23247" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23249" href="Meta.HLevel.Reflection.html#23249" class="Bound">enter</a> <a id="23255" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23257" href="Meta.HLevel.Reflection.html#23257" class="Bound">leave</a><a id="23262" class="Symbol">)</a> <a id="23264" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23266" href="Meta.HLevel.Reflection.html#23163" class="Function">go</a> <a id="23269" href="Meta.HLevel.Reflection.html#23213" class="Bound">cd</a>
        <a id="23280" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23285" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23287" href="Meta.HLevel.Reflection.html#23232" class="Bound">hlevel</a> <a id="23294" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23296" href="Meta.HLevel.Reflection.html#23241" class="Bound">inner</a> <a id="23302" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23304" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="23318" href="Meta.HLevel.Reflection.html#23210" class="Bound">vn</a> <a id="23321" class="Symbol">(</a><a id="23322" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23326" href="Meta.HLevel.Reflection.html#23198" class="Bound">as</a> <a id="23329" href="Meta.HLevel.Reflection.html#23201" class="Bound">at</a><a id="23331" class="Symbol">)</a> <a id="23333" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23335" class="Symbol">λ</a> <a id="23337" href="Meta.HLevel.Reflection.html#23337" class="Bound">t</a> <a id="23339" class="Symbol">→</a> <a id="23341" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="23345" class="Symbol">(</a><a id="23346" href="Meta.Reflection.html#1207" class="Function">arg-vis</a> <a id="23354" href="Meta.HLevel.Reflection.html#23198" class="Bound">as</a><a id="23356" class="Symbol">)</a> <a id="23358" class="Symbol">(</a><a id="23359" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23363" href="Meta.HLevel.Reflection.html#23210" class="Bound">vn</a> <a id="23366" href="Meta.HLevel.Reflection.html#23337" class="Bound">t</a><a id="23367" class="Symbol">)</a>
      <a id="23375" href="Meta.HLevel.Reflection.html#23163" class="CatchallClause Function">go</a><a id="23377" class="CatchallClause"> </a><a id="23378" href="Meta.HLevel.Reflection.html#23378" class="CatchallClause Bound">tm</a> <a id="23381" class="Symbol">=</a> <a id="23383" class="Keyword">do</a>
        <a id="23394" class="Symbol">(</a><a id="23395" href="Meta.HLevel.Reflection.html#23395" class="Bound">hlevel</a> <a id="23402" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23404" href="Meta.HLevel.Reflection.html#23404" class="Bound">inner</a><a id="23409" class="Symbol">)</a> <a id="23411" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23413" href="Meta.HLevel.Reflection.html#6342" class="Function">decompose-is-hlevel′</a> <a id="23434" href="Meta.HLevel.Reflection.html#23378" class="Bound">tm</a>
        <a id="23445" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23450" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23452" href="Meta.HLevel.Reflection.html#23395" class="Bound">hlevel</a> <a id="23459" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23461" href="Meta.HLevel.Reflection.html#23404" class="Bound">inner</a> <a id="23467" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23469" class="Symbol">(λ</a> <a id="23472" href="Meta.HLevel.Reflection.html#23472" class="Bound">x</a> <a id="23474" class="Symbol">→</a> <a id="23476" href="Meta.HLevel.Reflection.html#23472" class="Bound">x</a><a id="23477" class="Symbol">)</a> <a id="23479" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23481" class="Symbol">(λ</a> <a id="23484" href="Meta.HLevel.Reflection.html#23484" class="Bound">x</a> <a id="23486" class="Symbol">→</a> <a id="23488" href="Meta.HLevel.Reflection.html#23484" class="Bound">x</a><a id="23489" class="Symbol">)</a>

<a id="23492" class="Comment">-- This is public so it&#39;s usable in tactic attributes. It decomposes the</a>
<a id="23565" class="Comment">-- top-level goal type and enters the search loop.</a>
<a id="hlevel-tactic-worker"></a><a id="23616" href="Meta.HLevel.Reflection.html#23616" class="Function">hlevel-tactic-worker</a> <a id="23637" class="Symbol">:</a> <a id="23639" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23644" class="Symbol">→</a> <a id="23646" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23649" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="23651" href="Meta.HLevel.Reflection.html#23616" class="Function">hlevel-tactic-worker</a> <a id="23672" href="Meta.HLevel.Reflection.html#23672" class="Bound">goal</a> <a id="23677" class="Symbol">=</a> <a id="23679" class="Keyword">do</a>
  <a id="23684" href="Meta.HLevel.Reflection.html#23684" class="Bound">ty</a> <a id="23687" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23689" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="23704" class="Symbol">(</a><a id="23705" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="23711" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23713" href="Meta.HLevel.Reflection.html#5925" class="Function">atoms</a><a id="23718" class="Symbol">)</a> <a id="23720" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23722" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="23732" href="Meta.HLevel.Reflection.html#23672" class="Bound">goal</a> <a id="23737" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23741" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
  <a id="23750" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="23761" class="String">&quot;tactic.hlevel&quot;</a> <a id="23777" class="Number">10</a> <a id="23780" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23782" class="String">&quot;Target type: &quot;</a> <a id="23798" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23800" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="23808" href="Meta.HLevel.Reflection.html#23684" class="Bound">ty</a> <a id="23811" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23813" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="23818" class="Symbol">(</a><a id="23819" href="Meta.HLevel.Reflection.html#23819" class="Bound">lv</a> <a id="23822" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23824" href="Meta.HLevel.Reflection.html#23824" class="Bound">ty</a> <a id="23827" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23829" href="Meta.HLevel.Reflection.html#23829" class="Bound">enter</a> <a id="23835" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23837" href="Meta.HLevel.Reflection.html#23837" class="Bound">leave</a><a id="23842" class="Symbol">)</a> <a id="23844" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23846" href="Meta.HLevel.Reflection.html#22884" class="Function">decompose-is-hlevel-top</a> <a id="23870" href="Meta.HLevel.Reflection.html#23672" class="Bound">goal</a> <a id="23875" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a>
    <a id="23883" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a>
      <a id="23899" class="Symbol">(</a> <a id="23901" class="String">&quot;Goal type is not of the form ``is-hlevel A n&#39;&#39;:\n&quot;</a>
      <a id="23959" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23961" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="23969" href="Meta.HLevel.Reflection.html#23684" class="Bound">ty</a>
      <a id="23978" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23980" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="23982" class="Symbol">)</a>

  <a id="23987" class="Comment">-- 10 units of fuel isn&#39;t too many but it&#39;s enough for any realistic</a>
  <a id="24058" class="Comment">-- use-case. Note the scope nonsense: we have to &#39;enter&#39; to get under</a>
  <a id="24130" class="Comment">-- the Πs (extend the scope with their argument types), then &#39;leave&#39;</a>
  <a id="24201" class="Comment">-- (wrap in lambdas) to get back out.</a>
  <a id="24241" href="Meta.HLevel.Reflection.html#24241" class="Bound">solved</a> <a id="24248" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="24250" href="Meta.HLevel.Reflection.html#23829" class="Bound">enter</a> <a id="24256" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="24258" class="Keyword">do</a>
    <a id="24265" href="Meta.HLevel.Reflection.html#24265" class="Bound">goal′</a> <a id="24271" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="24273" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="24282" class="Symbol">(</a><a id="24283" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="24287" class="Symbol">(</a><a id="24288" class="Keyword">quote</a> <a id="24294" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a><a id="24306" class="Symbol">)</a> <a id="24308" class="Symbol">(</a><a id="24309" href="Meta.HLevel.Reflection.html#23819" class="Bound">lv</a> <a id="24312" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="24315" href="Meta.HLevel.Reflection.html#23824" class="Bound">ty</a> <a id="24318" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="24321" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="24323" class="Symbol">))</a>
    <a id="24330" href="Meta.HLevel.Reflection.html#12643" class="Function">search</a> <a id="24337" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="24343" href="Meta.HLevel.Reflection.html#23819" class="Bound">lv</a> <a id="24346" class="Number">10</a> <a id="24349" href="Meta.HLevel.Reflection.html#24265" class="Bound">goal′</a>
    <a id="24359" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="24364" href="Meta.HLevel.Reflection.html#24265" class="Bound">goal′</a>
  <a id="24372" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="24378" href="Meta.HLevel.Reflection.html#23672" class="Bound">goal</a> <a id="24383" class="Symbol">(</a><a id="24384" href="Meta.HLevel.Reflection.html#23837" class="Bound">leave</a> <a id="24390" href="Meta.HLevel.Reflection.html#24241" class="Bound">solved</a><a id="24396" class="Symbol">)</a>

<a id="24399" class="Comment">-- Entry points to the macro</a>
<a id="24428" class="Comment">----------------------------</a>
<a id="24457" class="Keyword">macro</a> <a id="hlevel!"></a><a id="24463" href="Meta.HLevel.Reflection.html#24463" class="Function">hlevel!</a> <a id="24471" class="Symbol">=</a> <a id="24473" href="Meta.HLevel.Reflection.html#23616" class="Function">hlevel-tactic-worker</a>

<a id="24495" class="Keyword">private</a> <a id="24503" class="Keyword">variable</a>
  <a id="24514" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a> <a id="24516" href="Meta.HLevel.Reflection.html#24516" class="Generalizable">ℓ′</a> <a id="24519" href="Meta.HLevel.Reflection.html#24519" class="Generalizable">ℓa</a> <a id="24522" href="Meta.HLevel.Reflection.html#24522" class="Generalizable">ℓb</a> <a id="24525" href="Meta.HLevel.Reflection.html#24525" class="Generalizable">ℓc</a> <a id="24528" href="Meta.HLevel.Reflection.html#24528" class="Generalizable">ℓd</a> <a id="24531" class="Symbol">:</a> <a id="24533" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="24541" href="Meta.HLevel.Reflection.html#24541" class="Generalizable">T</a> <a id="24543" class="Symbol">:</a> <a id="24545" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24550" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a>
  <a id="24554" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="24556" class="Symbol">:</a> <a id="24558" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24563" href="Meta.HLevel.Reflection.html#24519" class="Generalizable">ℓa</a>
  <a id="24568" href="Meta.HLevel.Reflection.html#24568" class="Generalizable">B</a> <a id="24570" class="Symbol">:</a> <a id="24572" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="24574" class="Symbol">→</a> <a id="24576" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24581" href="Meta.HLevel.Reflection.html#24522" class="Generalizable">ℓb</a>
  <a id="24586" href="Meta.HLevel.Reflection.html#24586" class="Generalizable">C</a> <a id="24588" class="Symbol">:</a> <a id="24590" class="Symbol">(</a><a id="24591" href="Meta.HLevel.Reflection.html#24591" class="Bound">a</a> <a id="24593" class="Symbol">:</a> <a id="24595" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a><a id="24596" class="Symbol">)</a> <a id="24598" class="Symbol">(</a><a id="24599" href="Meta.HLevel.Reflection.html#24599" class="Bound">b</a> <a id="24601" class="Symbol">:</a> <a id="24603" href="Meta.HLevel.Reflection.html#24568" class="Generalizable">B</a> <a id="24605" href="Meta.HLevel.Reflection.html#24591" class="Bound">a</a><a id="24606" class="Symbol">)</a> <a id="24608" class="Symbol">→</a> <a id="24610" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24615" href="Meta.HLevel.Reflection.html#24525" class="Generalizable">ℓc</a>
  <a id="24620" href="Meta.HLevel.Reflection.html#24620" class="Generalizable">D</a> <a id="24622" class="Symbol">:</a> <a id="24624" class="Symbol">(</a><a id="24625" href="Meta.HLevel.Reflection.html#24625" class="Bound">a</a> <a id="24627" class="Symbol">:</a> <a id="24629" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a><a id="24630" class="Symbol">)</a> <a id="24632" class="Symbol">(</a><a id="24633" href="Meta.HLevel.Reflection.html#24633" class="Bound">b</a> <a id="24635" class="Symbol">:</a> <a id="24637" href="Meta.HLevel.Reflection.html#24568" class="Generalizable">B</a> <a id="24639" href="Meta.HLevel.Reflection.html#24625" class="Bound">a</a><a id="24640" class="Symbol">)</a> <a id="24642" class="Symbol">(</a><a id="24643" href="Meta.HLevel.Reflection.html#24643" class="Bound">c</a> <a id="24645" class="Symbol">:</a> <a id="24647" href="Meta.HLevel.Reflection.html#24586" class="Generalizable">C</a> <a id="24649" href="Meta.HLevel.Reflection.html#24625" class="Bound">a</a> <a id="24651" href="Meta.HLevel.Reflection.html#24633" class="Bound">b</a><a id="24652" class="Symbol">)</a> <a id="24654" class="Symbol">→</a> <a id="24656" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24661" href="Meta.HLevel.Reflection.html#24528" class="Generalizable">ℓd</a>
  <a id="24666" href="Meta.HLevel.Reflection.html#24666" class="Generalizable">n</a> <a id="24668" class="Symbol">:</a> <a id="24670" href="Foundations.HLevel.Base.html#211" class="Function">HLevel</a>

<a id="24678" class="Comment">-- In addition to using the macro as a.. well, macro, it can be used as</a>
<a id="24750" class="Comment">-- a tactic argument, to replace instance search by the more powerful</a>
<a id="24820" class="Comment">-- decomposition-projection mechanism of the tactic. We provide only</a>
<a id="24889" class="Comment">-- some of the most common helpers:</a>
<a id="el!"></a><a id="24925" href="Meta.HLevel.Reflection.html#24925" class="Function">el!</a> <a id="24929" class="Symbol">:</a> <a id="24931" class="Symbol">(</a><a id="24932" href="Meta.HLevel.Reflection.html#24932" class="Bound">A</a> <a id="24934" class="Symbol">:</a> <a id="24936" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24941" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a><a id="24942" class="Symbol">)</a> <a id="24944" class="Symbol">{@(</a><a id="24947" class="Keyword">tactic</a> <a id="24954" href="Meta.HLevel.Reflection.html#23616" class="Function">hlevel-tactic-worker</a><a id="24974" class="Symbol">)</a> <a id="24976" href="Meta.HLevel.Reflection.html#24976" class="Bound">hl</a> <a id="24979" class="Symbol">:</a> <a id="24981" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="24994" href="Meta.HLevel.Reflection.html#24666" class="Generalizable">n</a> <a id="24996" href="Meta.HLevel.Reflection.html#24932" class="Bound">A</a><a id="24997" class="Symbol">}</a> <a id="24999" class="Symbol">→</a> <a id="25001" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="25008" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a> <a id="25010" href="Meta.HLevel.Reflection.html#24666" class="Generalizable">n</a>
<a id="25012" href="Meta.HLevel.Reflection.html#24925" class="Function">el!</a> <a id="25016" href="Meta.HLevel.Reflection.html#25016" class="Bound">A</a> <a id="25018" class="Symbol">{</a><a id="25019" href="Meta.HLevel.Reflection.html#25019" class="Bound">hl</a><a id="25021" class="Symbol">}</a> <a id="25023" class="Symbol">.</a><a id="25024" href="Structures.n-Type.html#377" class="Field">n-Type.typ</a> <a id="25035" class="Symbol">=</a> <a id="25037" href="Meta.HLevel.Reflection.html#25016" class="Bound">A</a>
<a id="25039" href="Meta.HLevel.Reflection.html#24925" class="Function">el!</a> <a id="25043" href="Meta.HLevel.Reflection.html#25043" class="Bound">A</a> <a id="25045" class="Symbol">{</a><a id="25046" href="Meta.HLevel.Reflection.html#25046" class="Bound">hl</a><a id="25048" class="Symbol">}</a> <a id="25050" class="Symbol">.</a><a id="25051" href="Structures.n-Type.html#396" class="Field">n-Type.is-tr</a> <a id="25064" class="Symbol">=</a> <a id="25066" href="Meta.HLevel.Reflection.html#25046" class="Bound">hl</a>

<a id="prop-extₑ!"></a><a id="25070" href="Meta.HLevel.Reflection.html#25070" class="Function">prop-extₑ!</a>
  <a id="25083" class="Symbol">:</a> <a id="25085" class="Symbol">{</a><a id="25086" href="Meta.HLevel.Reflection.html#25086" class="Bound">B</a> <a id="25088" class="Symbol">:</a> <a id="25090" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="25095" href="Meta.HLevel.Reflection.html#24522" class="Generalizable">ℓb</a><a id="25097" class="Symbol">}</a>
    <a id="25103" class="Symbol">{@(</a><a id="25106" class="Keyword">tactic</a> <a id="25113" href="Meta.HLevel.Reflection.html#23616" class="Function">hlevel-tactic-worker</a><a id="25133" class="Symbol">)</a> <a id="25135" href="Meta.HLevel.Reflection.html#25135" class="Bound">aprop</a> <a id="25141" class="Symbol">:</a> <a id="25143" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="25156" class="Number">1</a> <a id="25158" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a><a id="25159" class="Symbol">}</a>
    <a id="25165" class="Symbol">{@(</a><a id="25168" class="Keyword">tactic</a> <a id="25175" href="Meta.HLevel.Reflection.html#23616" class="Function">hlevel-tactic-worker</a><a id="25195" class="Symbol">)</a> <a id="25197" href="Meta.HLevel.Reflection.html#25197" class="Bound">bprop</a> <a id="25203" class="Symbol">:</a> <a id="25205" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="25218" class="Number">1</a> <a id="25220" href="Meta.HLevel.Reflection.html#25086" class="Bound">B</a><a id="25221" class="Symbol">}</a>
  <a id="25225" class="Symbol">→</a> <a id="25227" class="Symbol">(</a><a id="25228" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="25230" class="Symbol">→</a> <a id="25232" href="Meta.HLevel.Reflection.html#25086" class="Bound">B</a><a id="25233" class="Symbol">)</a> <a id="25235" class="Symbol">→</a> <a id="25237" class="Symbol">(</a><a id="25238" href="Meta.HLevel.Reflection.html#25086" class="Bound">B</a> <a id="25240" class="Symbol">→</a> <a id="25242" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a><a id="25243" class="Symbol">)</a>
  <a id="25247" class="Symbol">→</a> <a id="25249" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="25251" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="25253" href="Meta.HLevel.Reflection.html#25086" class="Bound">B</a>
<a id="25255" href="Meta.HLevel.Reflection.html#25070" class="Function">prop-extₑ!</a> <a id="25266" class="Symbol">{</a><a id="25267" href="Meta.HLevel.Reflection.html#25267" class="Bound">aprop</a><a id="25272" class="Symbol">}</a> <a id="25274" class="Symbol">{</a><a id="25275" href="Meta.HLevel.Reflection.html#25275" class="Bound">bprop</a><a id="25280" class="Symbol">}</a> <a id="25282" class="Symbol">=</a> <a id="25284" href="Foundations.Equiv.Properties.html#2530" class="Function">prop-extₑ</a> <a id="25294" href="Meta.HLevel.Reflection.html#25267" class="Bound">aprop</a> <a id="25300" href="Meta.HLevel.Reflection.html#25275" class="Bound">bprop</a>

<a id="Σ-prop-path!"></a><a id="25307" href="Meta.HLevel.Reflection.html#25307" class="Function">Σ-prop-path!</a>
  <a id="25322" class="Symbol">:</a> <a id="25324" class="Symbol">{@(</a><a id="25327" class="Keyword">tactic</a> <a id="25334" href="Meta.HLevel.Reflection.html#23616" class="Function">hlevel-tactic-worker</a><a id="25354" class="Symbol">)</a> <a id="25356" href="Meta.HLevel.Reflection.html#25356" class="Bound">bxprop</a> <a id="25363" class="Symbol">:</a> <a id="25365" class="Symbol">∀</a> <a id="25367" href="Meta.HLevel.Reflection.html#25367" class="Bound">x</a> <a id="25369" class="Symbol">→</a> <a id="25371" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="25384" class="Number">1</a> <a id="25386" class="Symbol">(</a><a id="25387" href="Meta.HLevel.Reflection.html#24568" class="Generalizable">B</a> <a id="25389" href="Meta.HLevel.Reflection.html#25367" class="Bound">x</a><a id="25390" class="Symbol">)}</a>
  <a id="25395" class="Symbol">→</a> <a id="25397" class="Symbol">{</a><a id="25398" href="Meta.HLevel.Reflection.html#25398" class="Bound">x</a> <a id="25400" href="Meta.HLevel.Reflection.html#25400" class="Bound">y</a> <a id="25402" class="Symbol">:</a> <a id="25404" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="25406" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="25408" href="Meta.HLevel.Reflection.html#24568" class="Generalizable">B</a><a id="25409" class="Symbol">}</a>
  <a id="25413" class="Symbol">→</a> <a id="25415" href="Meta.HLevel.Reflection.html#25398" class="Bound">x</a> <a id="25417" class="Symbol">.</a><a id="25418" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="25422" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25424" href="Meta.HLevel.Reflection.html#25400" class="Bound">y</a> <a id="25426" class="Symbol">.</a><a id="25427" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>
  <a id="25433" class="Symbol">→</a> <a id="25435" href="Meta.HLevel.Reflection.html#25398" class="Bound">x</a> <a id="25437" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25439" href="Meta.HLevel.Reflection.html#25400" class="Bound">y</a>
<a id="25441" href="Meta.HLevel.Reflection.html#25307" class="Function">Σ-prop-path!</a> <a id="25454" class="Symbol">{</a><a id="25455" href="Meta.HLevel.Reflection.html#25455" class="Bound">bxprop</a><a id="25461" class="Symbol">}</a> <a id="25463" class="Symbol">=</a> <a id="25465" href="Foundations.Sigma.Properties.html#3918" class="Function">Σ-prop-path</a> <a id="25477" href="Meta.HLevel.Reflection.html#25455" class="Bound">bxprop</a>

<a id="prop!"></a><a id="25485" href="Meta.HLevel.Reflection.html#25485" class="Function">prop!</a>
  <a id="25493" class="Symbol">:</a> <a id="25495" class="Symbol">{</a><a id="25496" href="Meta.HLevel.Reflection.html#25496" class="Bound">A</a> <a id="25498" class="Symbol">:</a> <a id="25500" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="25502" class="Symbol">→</a> <a id="25504" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="25509" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a><a id="25510" class="Symbol">}</a> <a id="25512" class="Symbol">{@(</a><a id="25515" class="Keyword">tactic</a> <a id="25522" href="Meta.HLevel.Reflection.html#23616" class="Function">hlevel-tactic-worker</a><a id="25542" class="Symbol">)</a> <a id="25544" href="Meta.HLevel.Reflection.html#25544" class="Bound">aip</a> <a id="25548" class="Symbol">:</a> <a id="25550" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="25563" class="Number">1</a> <a id="25565" class="Symbol">(</a><a id="25566" href="Meta.HLevel.Reflection.html#25496" class="Bound">A</a> <a id="25568" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25570" class="Symbol">)}</a>
  <a id="25575" class="Symbol">→</a> <a id="25577" class="Symbol">{</a><a id="25578" href="Meta.HLevel.Reflection.html#25578" class="Bound">x</a> <a id="25580" class="Symbol">:</a> <a id="25582" href="Meta.HLevel.Reflection.html#25496" class="Bound">A</a> <a id="25584" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25586" class="Symbol">}</a> <a id="25588" class="Symbol">{</a><a id="25589" href="Meta.HLevel.Reflection.html#25589" class="Bound">y</a> <a id="25591" class="Symbol">:</a> <a id="25593" href="Meta.HLevel.Reflection.html#25496" class="Bound">A</a> <a id="25595" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="25597" class="Symbol">}</a>
  <a id="25601" class="Symbol">→</a> <a id="25603" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="25609" href="Meta.HLevel.Reflection.html#25496" class="Bound">A</a> <a id="25611" href="Meta.HLevel.Reflection.html#25578" class="Bound">x</a> <a id="25613" href="Meta.HLevel.Reflection.html#25589" class="Bound">y</a>
<a id="25615" href="Meta.HLevel.Reflection.html#25485" class="Function">prop!</a> <a id="25621" class="Symbol">{</a><a id="25622" href="Meta.HLevel.Reflection.html#25622" class="Bound">A</a><a id="25623" class="Symbol">}</a> <a id="25625" class="Symbol">{</a><a id="25626" href="Meta.HLevel.Reflection.html#25626" class="Bound">aip</a><a id="25629" class="Symbol">}</a> <a id="25631" class="Symbol">{</a><a id="25632" href="Meta.HLevel.Reflection.html#25632" class="Bound">x</a><a id="25633" class="Symbol">}</a> <a id="25635" class="Symbol">{</a><a id="25636" href="Meta.HLevel.Reflection.html#25636" class="Bound">y</a><a id="25637" class="Symbol">}</a> <a id="25639" class="Symbol">=</a>
  <a id="25643" href="Foundations.HLevel.Base.html#1066" class="Function">is-prop→pathP</a> <a id="25657" class="Symbol">(λ</a> <a id="25660" href="Meta.HLevel.Reflection.html#25660" class="Bound">i</a> <a id="25662" class="Symbol">→</a> <a id="25664" href="Foundations.Base.html#17138" class="Function">coe0→i</a> <a id="25671" class="Symbol">(λ</a> <a id="25674" href="Meta.HLevel.Reflection.html#25674" class="Bound">j</a> <a id="25676" class="Symbol">→</a> <a id="25678" href="Foundations.Base.html#12783" class="Function">is-prop</a> <a id="25686" class="Symbol">(</a><a id="25687" href="Meta.HLevel.Reflection.html#25622" class="Bound">A</a> <a id="25689" href="Meta.HLevel.Reflection.html#25674" class="Bound">j</a><a id="25690" class="Symbol">))</a> <a id="25693" href="Meta.HLevel.Reflection.html#25660" class="Bound">i</a> <a id="25695" href="Meta.HLevel.Reflection.html#25626" class="Bound">aip</a><a id="25698" class="Symbol">)</a> <a id="25700" href="Meta.HLevel.Reflection.html#25632" class="Bound">x</a> <a id="25702" href="Meta.HLevel.Reflection.html#25636" class="Bound">y</a>

<a id="25705" class="Keyword">open</a> <a id="25710" href="Meta.HLevel.Reflection.html#4163" class="Module">hlevel-projection</a>

<a id="25729" class="Comment">-- Hint database bootstrap</a>
<a id="25756" class="Comment">--------------------------</a>
<a id="25783" class="Comment">-- This instance block contains most of the decompositions we have</a>
<a id="25850" class="Comment">-- defined in the dependencies of this module.</a>

<a id="25898" class="Keyword">instance</a>
  <a id="decomp-lift"></a><a id="25909" href="Meta.HLevel.Reflection.html#25909" class="Function">decomp-lift</a> <a id="25921" class="Symbol">:</a> <a id="25923" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="25944" class="Symbol">(</a><a id="25945" href="Foundations.Prim.Type.html#538" class="Record">Lift</a> <a id="25950" href="Meta.HLevel.Reflection.html#24516" class="Generalizable">ℓ′</a> <a id="25953" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a><a id="25954" class="Symbol">)</a>
  <a id="25958" href="Meta.HLevel.Reflection.html#25909" class="Function">decomp-lift</a> <a id="25970" class="Symbol">=</a> <a id="25972" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="25979" class="Symbol">(</a><a id="25980" class="Keyword">quote</a> <a id="25986" href="Foundations.HLevel.Retracts.html#5049" class="Function">Lift-is-of-hlevel</a><a id="26003" class="Symbol">)</a> <a id="26005" class="Symbol">(</a><a id="26006" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="26013" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26015" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="26023" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26025" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26027" class="Symbol">)</a>

  <a id="26032" class="Comment">-- Non-dependent Π and Σ for readability (lol) first</a>
  <a id="decomp-fun"></a><a id="26087" href="Meta.HLevel.Reflection.html#26087" class="Function">decomp-fun</a> <a id="26098" class="Symbol">:</a> <a id="26100" class="Symbol">{</a><a id="26101" href="Meta.HLevel.Reflection.html#26101" class="Bound">B</a> <a id="26103" class="Symbol">:</a> <a id="26105" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26110" href="Meta.HLevel.Reflection.html#24522" class="Generalizable">ℓb</a><a id="26112" class="Symbol">}</a> <a id="26114" class="Symbol">→</a> <a id="26116" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="26137" class="Symbol">(</a><a id="26138" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="26140" class="Symbol">→</a> <a id="26142" href="Meta.HLevel.Reflection.html#26101" class="Bound">B</a><a id="26143" class="Symbol">)</a>
  <a id="26147" href="Meta.HLevel.Reflection.html#26087" class="Function">decomp-fun</a> <a id="26158" class="Symbol">=</a> <a id="26160" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="26167" class="Symbol">(</a><a id="26168" class="Keyword">quote</a> <a id="26174" href="Foundations.HLevel.Retracts.html#4004" class="Function">fun-is-of-hlevel</a><a id="26190" class="Symbol">)</a> <a id="26192" class="Symbol">(</a><a id="26193" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="26200" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26202" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="26210" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26212" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26214" class="Symbol">)</a>

  <a id="decomp-prod"></a><a id="26219" href="Meta.HLevel.Reflection.html#26219" class="Function">decomp-prod</a> <a id="26231" class="Symbol">:</a> <a id="26233" class="Symbol">{</a><a id="26234" href="Meta.HLevel.Reflection.html#26234" class="Bound">B</a> <a id="26236" class="Symbol">:</a> <a id="26238" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26243" href="Meta.HLevel.Reflection.html#24522" class="Generalizable">ℓb</a><a id="26245" class="Symbol">}</a> <a id="26247" class="Symbol">→</a> <a id="26249" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="26270" class="Symbol">(</a><a id="26271" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="26273" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="26275" href="Meta.HLevel.Reflection.html#26234" class="Bound">B</a><a id="26276" class="Symbol">)</a>
  <a id="26280" href="Meta.HLevel.Reflection.html#26219" class="Function">decomp-prod</a> <a id="26292" class="Symbol">=</a> <a id="26294" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="26301" class="Symbol">(</a><a id="26302" class="Keyword">quote</a> <a id="26308" href="Foundations.HLevel.Retracts.html#4834" class="Function">×-is-of-hlevel</a><a id="26322" class="Symbol">)</a> <a id="26324" class="Symbol">(</a><a id="26325" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="26332" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26334" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="26342" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26344" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="26352" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26354" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26356" class="Symbol">)</a>

  <a id="26361" class="Comment">-- Dependent type formers:</a>
  <a id="decomp-pi³"></a><a id="26390" href="Meta.HLevel.Reflection.html#26390" class="Function">decomp-pi³</a> <a id="26401" class="Symbol">:</a> <a id="26403" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="26424" class="Symbol">(∀</a> <a id="26427" href="Meta.HLevel.Reflection.html#26427" class="Bound">a</a> <a id="26429" href="Meta.HLevel.Reflection.html#26429" class="Bound">b</a> <a id="26431" href="Meta.HLevel.Reflection.html#26431" class="Bound">c</a> <a id="26433" class="Symbol">→</a> <a id="26435" href="Meta.HLevel.Reflection.html#24620" class="Generalizable">D</a> <a id="26437" href="Meta.HLevel.Reflection.html#26427" class="Bound">a</a> <a id="26439" href="Meta.HLevel.Reflection.html#26429" class="Bound">b</a> <a id="26441" href="Meta.HLevel.Reflection.html#26431" class="Bound">c</a><a id="26442" class="Symbol">)</a>
  <a id="26446" href="Meta.HLevel.Reflection.html#26390" class="Function">decomp-pi³</a> <a id="26457" class="Symbol">=</a> <a id="26459" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="26466" class="Symbol">(</a><a id="26467" class="Keyword">quote</a> <a id="26473" href="Foundations.HLevel.Retracts.html#3719" class="Function">Π₃-is-of-hlevel</a><a id="26488" class="Symbol">)</a> <a id="26490" class="Symbol">(</a><a id="26491" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="26498" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26500" href="Meta.HLevel.Reflection.html#3147" class="InductiveConstructor">`search-under</a> <a id="26514" class="Number">3</a> <a id="26516" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26518" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26520" class="Symbol">)</a>

  <a id="decomp-pi²"></a><a id="26525" href="Meta.HLevel.Reflection.html#26525" class="Function">decomp-pi²</a> <a id="26536" class="Symbol">:</a> <a id="26538" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="26559" class="Symbol">(∀</a> <a id="26562" href="Meta.HLevel.Reflection.html#26562" class="Bound">a</a> <a id="26564" href="Meta.HLevel.Reflection.html#26564" class="Bound">b</a> <a id="26566" class="Symbol">→</a> <a id="26568" href="Meta.HLevel.Reflection.html#24586" class="Generalizable">C</a> <a id="26570" href="Meta.HLevel.Reflection.html#26562" class="Bound">a</a> <a id="26572" href="Meta.HLevel.Reflection.html#26564" class="Bound">b</a><a id="26573" class="Symbol">)</a>
  <a id="26577" href="Meta.HLevel.Reflection.html#26525" class="Function">decomp-pi²</a> <a id="26588" class="Symbol">=</a> <a id="26590" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="26597" class="Symbol">(</a><a id="26598" class="Keyword">quote</a> <a id="26604" href="Foundations.HLevel.Retracts.html#3483" class="Function">Π₂-is-of-hlevel</a><a id="26619" class="Symbol">)</a> <a id="26621" class="Symbol">(</a><a id="26622" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="26629" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26631" href="Meta.HLevel.Reflection.html#3147" class="InductiveConstructor">`search-under</a> <a id="26645" class="Number">2</a> <a id="26647" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26649" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26651" class="Symbol">)</a>

  <a id="decomp-pi"></a><a id="26656" href="Meta.HLevel.Reflection.html#26656" class="Function">decomp-pi</a> <a id="26666" class="Symbol">:</a> <a id="26668" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="26689" class="Symbol">(∀</a> <a id="26692" href="Meta.HLevel.Reflection.html#26692" class="Bound">a</a> <a id="26694" class="Symbol">→</a> <a id="26696" href="Meta.HLevel.Reflection.html#24568" class="Generalizable">B</a> <a id="26698" href="Meta.HLevel.Reflection.html#26692" class="Bound">a</a><a id="26699" class="Symbol">)</a>
  <a id="26703" href="Meta.HLevel.Reflection.html#26656" class="Function">decomp-pi</a> <a id="26713" class="Symbol">=</a> <a id="26715" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="26722" class="Symbol">(</a><a id="26723" class="Keyword">quote</a> <a id="26729" href="Foundations.HLevel.Retracts.html#2750" class="Function">Π-is-of-hlevel</a><a id="26743" class="Symbol">)</a> <a id="26745" class="Symbol">(</a><a id="26746" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="26753" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26755" href="Meta.HLevel.Reflection.html#3147" class="InductiveConstructor">`search-under</a> <a id="26769" class="Number">1</a> <a id="26771" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26773" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26775" class="Symbol">)</a>

  <a id="decomp-impl-pi"></a><a id="26780" href="Meta.HLevel.Reflection.html#26780" class="Function">decomp-impl-pi</a> <a id="26795" class="Symbol">:</a> <a id="26797" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="26818" class="Symbol">(∀</a> <a id="26821" class="Symbol">{</a><a id="26822" href="Meta.HLevel.Reflection.html#26822" class="Bound">a</a><a id="26823" class="Symbol">}</a> <a id="26825" class="Symbol">→</a> <a id="26827" href="Meta.HLevel.Reflection.html#24568" class="Generalizable">B</a> <a id="26829" href="Meta.HLevel.Reflection.html#26822" class="Bound">a</a><a id="26830" class="Symbol">)</a>
  <a id="26834" href="Meta.HLevel.Reflection.html#26780" class="Function">decomp-impl-pi</a> <a id="26849" class="Symbol">=</a> <a id="26851" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="26858" class="Symbol">(</a><a id="26859" class="Keyword">quote</a> <a id="26865" href="Foundations.HLevel.Retracts.html#3180" class="Function">Π-is-of-hlevel-implicit</a><a id="26888" class="Symbol">)</a> <a id="26890" class="Symbol">(</a><a id="26891" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="26898" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26900" href="Meta.HLevel.Reflection.html#3147" class="InductiveConstructor">`search-under</a> <a id="26914" class="Number">1</a> <a id="26916" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26918" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26920" class="Symbol">)</a>

  <a id="decomp-equiv-right"></a><a id="26925" href="Meta.HLevel.Reflection.html#26925" class="Function">decomp-equiv-right</a> <a id="26944" class="Symbol">:</a> <a id="26946" class="Symbol">{</a><a id="26947" href="Meta.HLevel.Reflection.html#26947" class="Bound">B</a> <a id="26949" class="Symbol">:</a> <a id="26951" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26956" href="Meta.HLevel.Reflection.html#24522" class="Generalizable">ℓb</a><a id="26958" class="Symbol">}</a> <a id="26960" class="Symbol">→</a> <a id="26962" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="26983" class="Symbol">(</a><a id="26984" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="26986" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="26988" href="Meta.HLevel.Reflection.html#26947" class="Bound">B</a><a id="26989" class="Symbol">)</a>
  <a id="26993" href="Meta.HLevel.Reflection.html#26925" class="Function">decomp-equiv-right</a> <a id="27012" class="Symbol">=</a> <a id="27014" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="27021" class="Symbol">(</a><a id="27022" class="Keyword">quote</a> <a id="27028" href="Foundations.HLevel.Retracts.html#6081" class="Function">≃-is-of-hlevel-right-suc</a><a id="27052" class="Symbol">)</a> <a id="27054" class="Symbol">(</a><a id="27055" href="Meta.HLevel.Reflection.html#2947" class="InductiveConstructor">`level-minus</a> <a id="27068" class="Number">1</a> <a id="27070" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27072" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="27080" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27082" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27084" class="Symbol">)</a>

  <a id="decomp-equiv-left"></a><a id="27089" href="Meta.HLevel.Reflection.html#27089" class="Function">decomp-equiv-left</a> <a id="27107" class="Symbol">:</a> <a id="27109" class="Symbol">{</a><a id="27110" href="Meta.HLevel.Reflection.html#27110" class="Bound">B</a> <a id="27112" class="Symbol">:</a> <a id="27114" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="27119" href="Meta.HLevel.Reflection.html#24522" class="Generalizable">ℓb</a><a id="27121" class="Symbol">}</a> <a id="27123" class="Symbol">→</a> <a id="27125" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="27146" class="Symbol">(</a><a id="27147" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="27149" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="27151" href="Meta.HLevel.Reflection.html#27110" class="Bound">B</a><a id="27152" class="Symbol">)</a>
  <a id="27156" href="Meta.HLevel.Reflection.html#27089" class="Function">decomp-equiv-left</a> <a id="27174" class="Symbol">=</a> <a id="27176" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="27183" class="Symbol">(</a><a id="27184" class="Keyword">quote</a> <a id="27190" href="Foundations.HLevel.Retracts.html#5741" class="Function">≃-is-of-hlevel-left-suc</a><a id="27213" class="Symbol">)</a> <a id="27215" class="Symbol">(</a><a id="27216" href="Meta.HLevel.Reflection.html#2947" class="InductiveConstructor">`level-minus</a> <a id="27229" class="Number">1</a> <a id="27231" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27233" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="27241" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27243" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27245" class="Symbol">)</a>

  <a id="decomp-equiv"></a><a id="27250" href="Meta.HLevel.Reflection.html#27250" class="Function">decomp-equiv</a> <a id="27263" class="Symbol">:</a> <a id="27265" class="Symbol">{</a><a id="27266" href="Meta.HLevel.Reflection.html#27266" class="Bound">B</a> <a id="27268" class="Symbol">:</a> <a id="27270" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="27275" href="Meta.HLevel.Reflection.html#24522" class="Generalizable">ℓb</a><a id="27277" class="Symbol">}</a> <a id="27279" class="Symbol">→</a> <a id="27281" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="27302" class="Symbol">(</a><a id="27303" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="27305" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="27307" href="Meta.HLevel.Reflection.html#27266" class="Bound">B</a><a id="27308" class="Symbol">)</a>
  <a id="27312" href="Meta.HLevel.Reflection.html#27250" class="Function">decomp-equiv</a> <a id="27325" class="Symbol">=</a> <a id="27327" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="27334" class="Symbol">(</a><a id="27335" class="Keyword">quote</a> <a id="27341" href="Foundations.HLevel.Retracts.html#5246" class="Function">≃-is-of-hlevel</a><a id="27355" class="Symbol">)</a> <a id="27357" class="Symbol">(</a><a id="27358" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="27365" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27367" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="27375" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27377" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="27385" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27387" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="27390" class="Symbol">)</a>

  <a id="decomp-sigma"></a><a id="27395" href="Meta.HLevel.Reflection.html#27395" class="Function">decomp-sigma</a> <a id="27408" class="Symbol">:</a> <a id="27410" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="27431" class="Symbol">(</a><a id="27432" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="27434" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a> <a id="27436" href="Meta.HLevel.Reflection.html#24568" class="Generalizable">B</a><a id="27437" class="Symbol">)</a>
  <a id="27441" href="Meta.HLevel.Reflection.html#27395" class="Function">decomp-sigma</a> <a id="27454" class="Symbol">=</a> <a id="27456" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="27463" class="Symbol">(</a><a id="27464" class="Keyword">quote</a> <a id="27470" href="Foundations.HLevel.Retracts.html#4155" class="Function">Σ-is-of-hlevel</a><a id="27484" class="Symbol">)</a> <a id="27486" class="Symbol">(</a><a id="27487" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="27494" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27496" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="27504" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27506" href="Meta.HLevel.Reflection.html#3147" class="InductiveConstructor">`search-under</a> <a id="27520" class="Number">1</a> <a id="27522" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27524" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27526" class="Symbol">)</a>

  <a id="27531" class="Comment">-- Path decomposition rules we have in scope. Note the use of</a>
  <a id="27595" class="Comment">-- nondeterminism: the following three instances both compete for</a>
  <a id="27663" class="Comment">-- solving the same goals --- but generally only one will be</a>
  <a id="27726" class="Comment">-- applicable. That way we don&#39;t have to juggle h-levels quite as</a>
  <a id="27794" class="Comment">-- much.</a>
  <a id="decomp-path′"></a><a id="27805" href="Meta.HLevel.Reflection.html#27805" class="Function">decomp-path′</a> <a id="27818" class="Symbol">:</a> <a id="27820" class="Symbol">{</a><a id="27821" href="Meta.HLevel.Reflection.html#27821" class="Bound">a</a> <a id="27823" href="Meta.HLevel.Reflection.html#27823" class="Bound">b</a> <a id="27825" class="Symbol">:</a> <a id="27827" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a><a id="27828" class="Symbol">}</a> <a id="27830" class="Symbol">→</a> <a id="27832" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="27853" class="Symbol">(</a><a id="27854" href="Meta.HLevel.Reflection.html#27821" class="Bound">a</a> <a id="27856" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27858" href="Meta.HLevel.Reflection.html#27823" class="Bound">b</a><a id="27859" class="Symbol">)</a>
  <a id="27863" href="Meta.HLevel.Reflection.html#27805" class="Function">decomp-path′</a> <a id="27876" class="Symbol">=</a> <a id="27878" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="27885" class="Symbol">(</a><a id="27886" class="Keyword">quote</a> <a id="27892" href="Foundations.HLevel.Base.html#3651" class="Function">path-is-of-hlevel′</a><a id="27910" class="Symbol">)</a> <a id="27912" class="Symbol">(</a><a id="27913" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="27920" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27922" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="27930" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27932" href="Meta.HLevel.Reflection.html#3350" class="InductiveConstructor">`meta</a> <a id="27938" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27940" href="Meta.HLevel.Reflection.html#3350" class="InductiveConstructor">`meta</a> <a id="27946" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27948" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27950" class="Symbol">)</a>

  <a id="decomp-path"></a><a id="27955" href="Meta.HLevel.Reflection.html#27955" class="Function">decomp-path</a> <a id="27967" class="Symbol">:</a> <a id="27969" class="Symbol">{</a><a id="27970" href="Meta.HLevel.Reflection.html#27970" class="Bound">a</a> <a id="27972" href="Meta.HLevel.Reflection.html#27972" class="Bound">b</a> <a id="27974" class="Symbol">:</a> <a id="27976" href="Meta.HLevel.Reflection.html#24554" class="Generalizable">A</a><a id="27977" class="Symbol">}</a> <a id="27979" class="Symbol">→</a> <a id="27981" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="28002" class="Symbol">(</a><a id="28003" href="Meta.HLevel.Reflection.html#27970" class="Bound">a</a> <a id="28005" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="28007" href="Meta.HLevel.Reflection.html#27972" class="Bound">b</a><a id="28008" class="Symbol">)</a>
  <a id="28012" href="Meta.HLevel.Reflection.html#27955" class="Function">decomp-path</a> <a id="28024" class="Symbol">=</a> <a id="28026" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="28033" class="Symbol">(</a><a id="28034" class="Keyword">quote</a> <a id="28040" href="Foundations.HLevel.Base.html#3076" class="Function">path-is-of-hlevel</a><a id="28057" class="Symbol">)</a> <a id="28059" class="Symbol">(</a><a id="28060" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="28067" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28069" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="28077" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28079" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28081" class="Symbol">)</a>

  <a id="decomp-univalence"></a><a id="28086" href="Meta.HLevel.Reflection.html#28086" class="Function">decomp-univalence</a> <a id="28104" class="Symbol">:</a> <a id="28106" class="Symbol">{</a><a id="28107" href="Meta.HLevel.Reflection.html#28107" class="Bound">A</a> <a id="28109" href="Meta.HLevel.Reflection.html#28109" class="Bound">B</a> <a id="28111" class="Symbol">:</a> <a id="28113" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="28118" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a><a id="28119" class="Symbol">}</a> <a id="28121" class="Symbol">→</a> <a id="28123" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="28144" class="Symbol">(</a><a id="28145" href="Meta.HLevel.Reflection.html#28107" class="Bound">A</a> <a id="28147" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="28149" href="Meta.HLevel.Reflection.html#28109" class="Bound">B</a><a id="28150" class="Symbol">)</a>
  <a id="28154" href="Meta.HLevel.Reflection.html#28086" class="Function">decomp-univalence</a> <a id="28172" class="Symbol">=</a> <a id="28174" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="28181" class="Symbol">(</a><a id="28182" class="Keyword">quote</a> <a id="28188" href="Structures.n-Type.html#672" class="Function">＝-is-of-hlevel</a><a id="28202" class="Symbol">)</a> <a id="28204" class="Symbol">(</a><a id="28205" href="Meta.HLevel.Reflection.html#3650" class="InductiveConstructor">`level</a> <a id="28212" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28214" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="28222" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28224" href="Meta.HLevel.Reflection.html#3616" class="InductiveConstructor">`search</a> <a id="28232" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28234" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="28237" class="Symbol">)</a>

  <a id="28242" class="Comment">-- This one really ought to work with instance selection only, but</a>
  <a id="28311" class="Comment">-- Agda has trouble with the (1 + k + n) level in H-Level-n-Type. The</a>
  <a id="28383" class="Comment">-- decomposition here is a bit more flexible.</a>
  <a id="decomp-ntype"></a><a id="28431" href="Meta.HLevel.Reflection.html#28431" class="Function">decomp-ntype</a> <a id="28444" class="Symbol">:</a> <a id="28446" href="Meta.HLevel.Reflection.html#3791" class="Datatype">hlevel-decomposition</a> <a id="28467" class="Symbol">(</a><a id="28468" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="28475" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a> <a id="28477" href="Meta.HLevel.Reflection.html#24666" class="Generalizable">n</a><a id="28478" class="Symbol">)</a>
  <a id="28482" href="Meta.HLevel.Reflection.html#28431" class="Function">decomp-ntype</a> <a id="28495" class="Symbol">=</a> <a id="28497" href="Meta.HLevel.Reflection.html#3844" class="InductiveConstructor">decomp</a> <a id="28504" class="Symbol">(</a><a id="28505" class="Keyword">quote</a> <a id="28511" href="Structures.n-Type.html#1850" class="Function">n-Type-is-of-hlevel</a><a id="28530" class="Symbol">)</a> <a id="28532" class="Symbol">(</a><a id="28533" href="Meta.HLevel.Reflection.html#2947" class="InductiveConstructor">`level-minus</a> <a id="28546" class="Number">1</a> <a id="28548" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28550" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28552" class="Symbol">)</a>

  <a id="hlevel-proj-n-type"></a><a id="28557" href="Meta.HLevel.Reflection.html#28557" class="Function">hlevel-proj-n-type</a> <a id="28576" class="Symbol">:</a> <a id="28578" href="Meta.HLevel.Reflection.html#4163" class="Record">hlevel-projection</a> <a id="28596" class="Symbol">(</a><a id="28597" class="Keyword">quote</a> <a id="28603" href="Structures.n-Type.html#377" class="Field">n-Type.typ</a><a id="28613" class="Symbol">)</a>
  <a id="28617" href="Meta.HLevel.Reflection.html#28557" class="Function">hlevel-proj-n-type</a> <a id="28636" class="Symbol">.</a><a id="28637" href="Meta.HLevel.Reflection.html#4220" class="Field">has-level</a> <a id="28647" class="Symbol">=</a> <a id="28649" class="Keyword">quote</a> <a id="28655" href="Structures.n-Type.html#396" class="Field">n-Type.is-tr</a>
  <a id="28670" href="Meta.HLevel.Reflection.html#28557" class="Function">hlevel-proj-n-type</a> <a id="28689" class="Symbol">.</a><a id="28690" href="Meta.HLevel.Reflection.html#4407" class="Field">get-level</a> <a id="28700" href="Meta.HLevel.Reflection.html#28700" class="Bound">ty</a> <a id="28703" class="Symbol">=</a> <a id="28705" class="Keyword">do</a>
    <a id="28712" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="28716" class="Symbol">(</a><a id="28717" class="Keyword">quote</a> <a id="28723" href="Structures.n-Type.html#297" class="Record">n-Type</a><a id="28729" class="Symbol">)</a> <a id="28731" class="Symbol">(</a><a id="28732" href="Meta.HLevel.Reflection.html#28732" class="Bound">ell</a> <a id="28736" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="28739" href="Meta.HLevel.Reflection.html#28739" class="Bound">lv′t</a> <a id="28744" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="28747" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28749" class="Symbol">)</a> <a id="28751" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="28753" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="28760" href="Meta.HLevel.Reflection.html#28700" class="Bound">ty</a>
      <a id="28769" class="Keyword">where</a> <a id="28775" class="CatchallClause Symbol">_</a> <a id="28777" class="Symbol">→</a> <a id="28779" href="Meta.HLevel.Reflection.html#5556" class="Function">backtrack</a> <a id="28789" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="28791" class="String">&quot;Type of thing isn&#39;t n-Type, it is &quot;</a> <a id="28828" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28830" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="28838" href="Meta.HLevel.Reflection.html#28700" class="Bound">ty</a> <a id="28841" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28843" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="28850" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="28860" href="Meta.HLevel.Reflection.html#28739" class="Bound">lv′t</a>
  <a id="28867" href="Meta.HLevel.Reflection.html#28557" class="Function">hlevel-proj-n-type</a> <a id="28886" class="Symbol">.</a><a id="28887" href="Meta.HLevel.Reflection.html#4560" class="Field">get-argument</a> <a id="28900" class="Symbol">(_</a> <a id="28903" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28905" class="Symbol">_</a> <a id="28907" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28909" href="Meta.HLevel.Reflection.html#28909" class="Bound">it</a> <a id="28912" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="28915" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28917" class="Symbol">)</a> <a id="28919" class="Symbol">=</a> <a id="28921" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="28926" href="Meta.HLevel.Reflection.html#28909" class="Bound">it</a>
  <a id="28931" href="Meta.HLevel.Reflection.html#28557" class="CatchallClause Function">hlevel-proj-n-type</a><a id="28949" class="CatchallClause"> </a><a id="28950" class="CatchallClause Symbol">.</a><a id="28951" href="Meta.HLevel.Reflection.html#4560" class="CatchallClause Field">get-argument</a><a id="28963" class="CatchallClause"> </a><a id="28964" class="CatchallClause Symbol">_</a> <a id="28966" class="Symbol">=</a> <a id="28968" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="28978" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>


<a id="28983" class="Comment">-- Usage</a>
<a id="28992" class="Keyword">private</a>
  <a id="29002" class="Keyword">module</a> <a id="29009" href="Meta.HLevel.Reflection.html#29009" class="Module">_</a> <a id="29011" class="Symbol">{</a><a id="29012" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29014" class="Symbol">:</a> <a id="29016" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="29023" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a> <a id="29025" class="Number">2</a><a id="29026" class="Symbol">}</a> <a id="29028" class="Symbol">{</a><a id="29029" href="Meta.HLevel.Reflection.html#29029" class="Bound">B</a> <a id="29031" class="Symbol">:</a> <a id="29033" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29035" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29037" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29039" class="Symbol">→</a> <a id="29041" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="29048" href="Meta.HLevel.Reflection.html#24514" class="Generalizable">ℓ</a> <a id="29050" class="Number">3</a><a id="29051" class="Symbol">}</a> <a id="29053" class="Keyword">where</a>
    <a id="29063" href="Meta.HLevel.Reflection.html#29063" class="Function">some-def</a> <a id="29072" class="Symbol">=</a> <a id="29074" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29076" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29078" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29084" href="Meta.HLevel.Reflection.html#29084" class="Function">_</a> <a id="29086" class="Symbol">:</a> <a id="29088" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29101" class="Number">2</a> <a id="29103" class="Symbol">(</a><a id="29104" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29106" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29108" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29110" class="Symbol">→</a> <a id="29112" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29114" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29116" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29118" class="Symbol">→</a> <a id="29120" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29122" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29124" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29126" class="Symbol">→</a> <a id="29128" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29130" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29132" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29133" class="Symbol">)</a>
    <a id="29139" class="Symbol">_</a> <a id="29141" class="Symbol">=</a> <a id="29143" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a>

    <a id="29156" href="Meta.HLevel.Reflection.html#29156" class="Function">_</a> <a id="29158" class="Symbol">:</a> <a id="29160" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29173" class="Number">3</a> <a id="29175" class="Symbol">(</a><a id="29176" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="29178" href="Meta.HLevel.Reflection.html#29063" class="Function">some-def</a> <a id="29187" class="Symbol">λ</a> <a id="29189" href="Meta.HLevel.Reflection.html#29189" class="Bound">x</a> <a id="29191" class="Symbol">→</a> <a id="29193" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29195" href="Meta.HLevel.Reflection.html#29029" class="Bound">B</a> <a id="29197" href="Meta.HLevel.Reflection.html#29189" class="Bound">x</a> <a id="29199" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29200" class="Symbol">)</a>
    <a id="29206" class="Symbol">_</a> <a id="29208" class="Symbol">=</a> <a id="29210" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a>

    <a id="29223" href="Meta.HLevel.Reflection.html#29223" class="Function">_</a> <a id="29225" class="Symbol">:</a> <a id="29227" class="Symbol">∀</a> <a id="29229" href="Meta.HLevel.Reflection.html#29229" class="Bound">a</a> <a id="29231" class="Symbol">→</a> <a id="29233" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29246" class="Number">5</a> <a id="29248" class="Symbol">(</a><a id="29249" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29251" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29253" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29255" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29257" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29259" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29261" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29263" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29265" class="Symbol">(</a><a id="29266" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29268" class="Symbol">→</a> <a id="29270" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29272" href="Meta.HLevel.Reflection.html#29029" class="Bound">B</a> <a id="29274" href="Meta.HLevel.Reflection.html#29229" class="Bound">a</a> <a id="29276" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29277" class="Symbol">))</a>
    <a id="29284" class="Symbol">_</a> <a id="29286" class="Symbol">=</a> <a id="29288" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a>

    <a id="29301" href="Meta.HLevel.Reflection.html#29301" class="Function">_</a> <a id="29303" class="Symbol">:</a> <a id="29305" class="Symbol">∀</a> <a id="29307" href="Meta.HLevel.Reflection.html#29307" class="Bound">a</a> <a id="29309" class="Symbol">→</a> <a id="29311" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29324" class="Number">3</a> <a id="29326" class="Symbol">(</a><a id="29327" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29329" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29331" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29333" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29335" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29337" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29339" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29341" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29343" class="Symbol">(</a><a id="29344" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29346" class="Symbol">→</a> <a id="29348" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29350" href="Meta.HLevel.Reflection.html#29029" class="Bound">B</a> <a id="29352" href="Meta.HLevel.Reflection.html#29307" class="Bound">a</a> <a id="29354" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29355" class="Symbol">))</a>
    <a id="29362" class="Symbol">_</a> <a id="29364" class="Symbol">=</a> <a id="29366" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a>

    <a id="29379" href="Meta.HLevel.Reflection.html#29379" class="Function">_</a> <a id="29381" class="Symbol">:</a> <a id="29383" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29396" class="Number">2</a> <a id="29398" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29400" href="Meta.HLevel.Reflection.html#29012" class="Bound">A</a> <a id="29402" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29408" class="Symbol">_</a> <a id="29410" class="Symbol">=</a> <a id="29412" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a>

    <a id="29425" class="Comment">-- this one uses `H-Level-nType` instance which is compile-time only</a>
    <a id="29498" class="Symbol">@</a><a id="29499" class="Number">0</a> <a id="29501" href="Meta.HLevel.Reflection.html#29501" class="Function">_</a> <a id="29503" class="Symbol">:</a> <a id="29505" class="Symbol">∀</a> <a id="29507" href="Meta.HLevel.Reflection.html#29507" class="Bound">n</a> <a id="29509" class="Symbol">→</a> <a id="29511" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29524" class="Symbol">(</a><a id="29525" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="29529" href="Meta.HLevel.Reflection.html#29507" class="Bound">n</a><a id="29530" class="Symbol">)</a> <a id="29532" class="Symbol">(</a><a id="29533" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="29540" href="Meta.HLevel.Reflection.html#29023" class="Bound">ℓ</a> <a id="29542" href="Meta.HLevel.Reflection.html#29507" class="Bound">n</a><a id="29543" class="Symbol">)</a>
    <a id="29549" class="Symbol">_</a> <a id="29551" class="Symbol">=</a> <a id="29553" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a>

    <a id="29566" href="Meta.HLevel.Reflection.html#29566" class="Function">_</a> <a id="29568" class="Symbol">:</a> <a id="29570" class="Symbol">∀</a> <a id="29572" href="Meta.HLevel.Reflection.html#29572" class="Bound">n</a> <a id="29574" class="Symbol">(</a><a id="29575" href="Meta.HLevel.Reflection.html#29575" class="Bound">x</a> <a id="29577" class="Symbol">:</a> <a id="29579" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="29586" href="Meta.HLevel.Reflection.html#29023" class="Bound">ℓ</a> <a id="29588" href="Meta.HLevel.Reflection.html#29572" class="Bound">n</a><a id="29589" class="Symbol">)</a> <a id="29591" class="Symbol">→</a> <a id="29593" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29606" class="Symbol">(</a><a id="29607" class="Number">2</a> <a id="29609" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="29611" href="Meta.HLevel.Reflection.html#29572" class="Bound">n</a><a id="29612" class="Symbol">)</a> <a id="29614" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29616" href="Meta.HLevel.Reflection.html#29575" class="Bound">x</a> <a id="29618" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29624" class="Symbol">_</a> <a id="29626" class="Symbol">=</a> <a id="29628" class="Symbol">λ</a> <a id="29630" href="Meta.HLevel.Reflection.html#29630" class="Bound">n</a> <a id="29632" href="Meta.HLevel.Reflection.html#29632" class="Bound">x</a> <a id="29634" class="Symbol">→</a> <a id="29636" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a>
</pre></body></html>