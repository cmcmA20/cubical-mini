<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.HLevel.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Comment">-- -vtactic.hlevel:20 -vtc.def:10</a>
<a id="58" class="Keyword">module</a> <a id="65" href="Meta.HLevel.Reflection.html" class="Module">Meta.HLevel.Reflection</a> <a id="88" class="Keyword">where</a>

<a id="95" class="Keyword">open</a> <a id="100" class="Keyword">import</a> <a id="107" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="124" class="Keyword">open</a> <a id="129" class="Keyword">import</a> <a id="136" href="Foundations.Equiv.html" class="Module">Foundations.Equiv</a>
<a id="154" class="Keyword">open</a> <a id="159" class="Keyword">import</a> <a id="166" href="Foundations.HLevel.html" class="Module">Foundations.HLevel</a>
<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Foundations.Pi.html" class="Module">Foundations.Pi</a>
<a id="212" class="Keyword">open</a> <a id="217" class="Keyword">import</a> <a id="224" href="Foundations.Sigma.html" class="Module">Foundations.Sigma</a>

<a id="243" class="Keyword">open</a> <a id="248" class="Keyword">import</a> <a id="255" href="Meta.Foldable.html" class="Module">Meta.Foldable</a>
<a id="269" class="Keyword">open</a> <a id="274" class="Keyword">import</a> <a id="281" href="Meta.FromProduct.html" class="Module">Meta.FromProduct</a>
<a id="298" class="Keyword">open</a> <a id="303" class="Keyword">import</a> <a id="310" href="Meta.HLevel.Base.html" class="Module">Meta.HLevel.Base</a> <a id="327" class="Keyword">public</a>
<a id="334" class="Keyword">open</a> <a id="339" class="Keyword">import</a> <a id="346" href="Meta.Reflection.html" class="Module">Meta.Reflection</a>

<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="Structures.n-Type.html" class="Module">Structures.n-Type</a>

<a id="394" class="Keyword">open</a> <a id="399" class="Keyword">import</a> <a id="406" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="421" class="Keyword">open</a> <a id="426" class="Keyword">import</a> <a id="433" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="448" class="Keyword">open</a> <a id="453" class="Keyword">import</a> <a id="460" href="Data.List.Operations.html" class="Module">Data.List.Operations</a>
<a id="481" class="Keyword">open</a> <a id="486" class="Keyword">import</a> <a id="493" href="Data.List.Instances.Foldable.html" class="Module">Data.List.Instances.Foldable</a>
<a id="522" class="Keyword">open</a> <a id="527" class="Keyword">import</a> <a id="534" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="566" class="Keyword">open</a> <a id="571" class="Keyword">import</a> <a id="578" href="Data.List.Instances.Idiom.html" class="Module">Data.List.Instances.Idiom</a>
<a id="604" class="Keyword">open</a> <a id="609" class="Keyword">import</a> <a id="616" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="632" class="Keyword">open</a> <a id="637" class="Keyword">import</a> <a id="644" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="658" class="Keyword">open</a> <a id="663" class="Keyword">import</a> <a id="670" href="Data.Nat.Instances.Number.html" class="Module">Data.Nat.Instances.Number</a>
<a id="696" class="Keyword">open</a> <a id="701" class="Keyword">import</a> <a id="708" href="Data.String.Instances.IsString.html" class="Module">Data.String.Instances.IsString</a>

<a id="740" class="Comment">{-
Tactic for generating readable h-level proofs automatically. Contains an
essential reimplementation of the instance search mechanism, with
support for arbitrary level offsets (`level-minus) and searching under
binders (`search-under). Ambiguity is explicitly supported: the first
goal for which we can complete a proof tree is the one we go with.

The tactic works in a naÏve way, trying h-level lemmas until one
succeeds. There are three ways of making progress: Using a *projection
hint*, using a *decomposition hint*, or by falling back to instance
selection. The instance selection fallback is self-explanatory.

Projection hints handle the situation is-hlevel (X .p) n, where X
inhabits a record that contains evidence of its hlevel. If there is a
projection hint with `underlying-type == p`, then we use `has-level
(get-argument (X .p))` as the solution. Being a base case, projection
hints also handle raising h-levels: If `get-level (X .p) &lt; n`, we solve
by raising `has-level ...` the appropriate amount.

Decomposition hints are slightly more interesting. Decomposition hints
apply to a type, say P, and instruct the tactic on how to build an
application of type (is-hlevel P n). The way this application is built
is customizable.

Finding rules
-------------

Rules are found using instance search, specifically for the
&#39;hlevel-decomposition&#39; and &#39;hlevel-projection&#39; types. The
hlevel-projection type is flat, so the runtime of
projection-decomposition is *linear in the number of possible
projections*.

The hlevel-decomposition type is more interesting, since it is indexed
by the type that it can decompose. That way, we can use Agda&#39;s own
instance selection mechanism to narrow down to relevant decompositions.

Nondeterminism
--------------

In case more than one projection and/or decomposition hint is possible,
they will all be tried in order. This allows the tactic to generate
sensible-looking code, by trying simpler decompositions first. As an
example, the non-dependent lemmas for → and × will be tried before those
for Π and Σ, just like a human would.
-}</a>

<a id="2825" class="Comment">-- | Specifies how an argument should be filled in during elaboration of</a>
<a id="2898" class="Comment">-- an h-level lemma.</a>
<a id="2919" class="Keyword">data</a> <a id="Arg-spec"></a><a id="2924" href="Meta.HLevel.Reflection.html#2924" class="Datatype">Arg-spec</a> <a id="2933" class="Symbol">:</a> <a id="2935" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="2940" class="Keyword">where</a>
  <a id="Arg-spec.`level-minus"></a><a id="2948" href="Meta.HLevel.Reflection.html#2948" class="InductiveConstructor">`level-minus</a>  <a id="2962" class="Symbol">:</a> <a id="2964" class="Symbol">(</a><a id="2965" href="Meta.HLevel.Reflection.html#2965" class="Bound">n</a> <a id="2967" class="Symbol">:</a> <a id="2969" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2970" class="Symbol">)</a> <a id="2972" class="Symbol">→</a> <a id="2974" href="Meta.HLevel.Reflection.html#2924" class="Datatype">Arg-spec</a>
  <a id="2985" class="Comment">-- ^ Insert the level we&#39;re solving for minus the given offset (note</a>
  <a id="3056" class="Comment">-- that this is the wonky subtraction operation, &quot;monus&quot;) at this</a>
  <a id="3124" class="Comment">-- argument position</a>

  <a id="Arg-spec.`search-under"></a><a id="3148" href="Meta.HLevel.Reflection.html#3148" class="InductiveConstructor">`search-under</a> <a id="3162" class="Symbol">:</a> <a id="3164" class="Symbol">(</a><a id="3165" href="Meta.HLevel.Reflection.html#3165" class="Bound">n</a> <a id="3167" class="Symbol">:</a> <a id="3169" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3170" class="Symbol">)</a> <a id="3172" class="Symbol">→</a> <a id="3174" href="Meta.HLevel.Reflection.html#2924" class="Datatype">Arg-spec</a>
  <a id="3185" class="Comment">-- ^ Recursively search for an h-level witness, under @n@ visible</a>
  <a id="3253" class="Comment">-- lambdas. This is suitable for lemmas of type</a>
  <a id="3303" class="Comment">-- (∀ x y z → is-hlevel ...) → is-hlevel ...</a>

  <a id="Arg-spec.`meta"></a><a id="3351" href="Meta.HLevel.Reflection.html#3351" class="InductiveConstructor">`meta</a>         <a id="3365" class="Symbol">:</a> <a id="3367" href="Meta.HLevel.Reflection.html#2924" class="Datatype">Arg-spec</a>
  <a id="3378" class="Comment">-- ^ Insert a meta at this argument position. No search will be</a>
  <a id="3444" class="Comment">-- performed for this meta, so it must be solved from the context in</a>
  <a id="3515" class="Comment">-- which the lemma is used.</a>

<a id="3544" class="Comment">-- Common patterns: Keep the level, search in the current scope.</a>
<a id="3609" class="Keyword">pattern</a> <a id="`search"></a><a id="3617" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="3625" class="Symbol">=</a> <a id="3627" href="Meta.HLevel.Reflection.html#3148" class="InductiveConstructor">`search-under</a> <a id="3641" class="Number">0</a>
<a id="3643" class="Keyword">pattern</a> <a id="`level"></a><a id="3651" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="3658" class="Symbol">=</a> <a id="3660" href="Meta.HLevel.Reflection.html#2948" class="InductiveConstructor">`level-minus</a> <a id="3673" class="Number">0</a>

<a id="3676" class="Comment">-- | A specification for how to decompose the type @T@ into</a>
<a id="3736" class="Comment">-- sub-components, to establish an h-level result.</a>
<a id="3787" class="Keyword">data</a> <a id="hlevel-decomposition"></a><a id="3792" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="3813" class="Symbol">{</a><a id="3814" href="Meta.HLevel.Reflection.html#3814" class="Bound">ℓ</a><a id="3815" class="Symbol">}</a> <a id="3817" class="Symbol">(</a><a id="3818" href="Meta.HLevel.Reflection.html#3818" class="Bound">T</a> <a id="3820" class="Symbol">:</a> <a id="3822" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3827" href="Meta.HLevel.Reflection.html#3814" class="Bound">ℓ</a><a id="3828" class="Symbol">)</a> <a id="3830" class="Symbol">:</a> <a id="3832" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3837" class="Keyword">where</a>
  <a id="hlevel-decomposition.decomp"></a><a id="3845" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a>
    <a id="3856" class="Symbol">:</a> <a id="3858" class="Symbol">(</a><a id="3859" href="Meta.HLevel.Reflection.html#3859" class="Bound">h-level-lemma</a> <a id="3873" class="Symbol">:</a> <a id="3875" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="3879" class="Symbol">)</a> <a id="3881" class="Symbol">(</a><a id="3882" href="Meta.HLevel.Reflection.html#3882" class="Bound">arguments</a> <a id="3892" class="Symbol">:</a> <a id="3894" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3899" href="Meta.HLevel.Reflection.html#2924" class="Datatype">Arg-spec</a><a id="3907" class="Symbol">)</a>
    <a id="3913" class="Symbol">→</a> <a id="3915" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="3936" href="Meta.HLevel.Reflection.html#3818" class="Bound">T</a>
  <a id="3940" class="Comment">-- To prove that T has a given h-level, we can invoke the</a>
  <a id="4000" class="Comment">-- @h-level-lemma@ with the specified @arguments@.</a>

<a id="4052" class="Comment">-- | How to decompose an application of a record selector into something</a>
<a id="4125" class="Comment">-- which might have an h-level.</a>
<a id="4157" class="Keyword">record</a> <a id="hlevel-projection"></a><a id="4164" href="Meta.HLevel.Reflection.html#4164" class="Record">hlevel-projection</a> <a id="4182" class="Symbol">(</a><a id="4183" href="Meta.HLevel.Reflection.html#4183" class="Bound">proj</a> <a id="4188" class="Symbol">:</a> <a id="4190" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="4194" class="Symbol">)</a> <a id="4196" class="Symbol">:</a> <a id="4198" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="4203" class="Keyword">where</a>
  <a id="4211" class="Keyword">field</a>
    <a id="hlevel-projection.has-level"></a><a id="4221" href="Meta.HLevel.Reflection.html#4221" class="Field">has-level</a> <a id="4231" class="Symbol">:</a> <a id="4233" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
    <a id="4242" class="Comment">-- ^ The name of the h-level lemma. It must be sufficient to apply</a>
    <a id="4313" class="Comment">-- this name to the argument (see get-argument below); arg specs are</a>
    <a id="4386" class="Comment">-- not supported.</a>
    <a id="hlevel-projection.get-level"></a><a id="4408" href="Meta.HLevel.Reflection.html#4408" class="Field">get-level</a> <a id="4418" class="Symbol">:</a> <a id="4420" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="4425" class="Symbol">→</a> <a id="4427" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4430" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4439" class="Comment">-- ^ Given an application of underlying-type, what h-level does this</a>
    <a id="4512" class="Comment">-- type have? Necessary for computing lifts.</a>
    <a id="hlevel-projection.get-argument"></a><a id="4561" href="Meta.HLevel.Reflection.html#4561" class="Field">get-argument</a> <a id="4574" class="Symbol">:</a> <a id="4576" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4581" class="Symbol">(</a><a id="4582" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4586" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="4590" class="Symbol">)</a> <a id="4592" class="Symbol">→</a> <a id="4594" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4597" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4606" class="Comment">-- ^ Extract the argument out from under the application.</a>
<a id="4664" class="Comment">{-
Using projections
-----------------

Projection decomposition happens as follows; suppose we have some
neutral

  n = def (quote X) as

in order, every &#39;hlevel-projection&#39; instance definition will be tried;
Let us call a generic instance I. If I.underlying-type == X, then we&#39;ll
use this instance, otherwise, we fail (i.e. backtrack and try another
projection).

To use this instance, the get-level and get-argument functions are
involved; get-argument must take &#39;as&#39; and return some representative
sub-expression e. get-level will receive e&#39;s inferred type and must
return the h-level of the type n. Finally, we return

  I.has-level (get-argument e),

possibly wrapped in (k - get-level (get-argument e)) applications of
is-hlevel-suc.
-}</a>

<a id="5409" class="Keyword">open</a> <a id="5414" href="Meta.HLevel.Reflection.html#4164" class="Module">hlevel-projection</a>
<a id="5432" class="Keyword">private</a>
  <a id="5442" class="Comment">-- Throw an empty type error to try another alternative, stating the</a>
  <a id="5513" class="Comment">-- purpose of backtracking for debugging:</a>
  <a id="backtrack"></a><a id="5557" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="5567" class="Symbol">:</a> <a id="5569" class="Symbol">∀</a> <a id="5571" class="Symbol">{</a><a id="5572" href="Meta.HLevel.Reflection.html#5572" class="Bound">ℓ</a><a id="5573" class="Symbol">}</a> <a id="5575" class="Symbol">{</a><a id="5576" href="Meta.HLevel.Reflection.html#5576" class="Bound">A</a> <a id="5578" class="Symbol">:</a> <a id="5580" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="5585" href="Meta.HLevel.Reflection.html#5572" class="Bound">ℓ</a><a id="5586" class="Symbol">}</a> <a id="5588" class="Symbol">→</a> <a id="5590" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5595" href="Agda.Builtin.Reflection.html#7893" class="Datatype">ErrorPart</a> <a id="5605" class="Symbol">→</a> <a id="5607" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="5610" href="Meta.HLevel.Reflection.html#5576" class="Bound">A</a>
  <a id="5614" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="5624" href="Meta.HLevel.Reflection.html#5624" class="Bound">note</a> <a id="5629" class="Symbol">=</a> <a id="5631" class="Keyword">do</a>
    <a id="5638" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="5649" class="String">&quot;tactic.hlevel&quot;</a> <a id="5665" class="Number">10</a> <a id="5668" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="5670" class="String">&quot;Backtracking search... &quot;</a> <a id="5696" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5698" href="Meta.HLevel.Reflection.html#5624" class="Bound">note</a>
    <a id="5707" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="5717" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="5719" class="String">&quot;Search hit a dead-end: &quot;</a> <a id="5745" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5747" href="Meta.HLevel.Reflection.html#5624" class="Bound">note</a>

  <a id="5755" class="Comment">-- A list of names which we should not reduce while trying to invert</a>
  <a id="5826" class="Comment">-- an application of is-hlevel/is-prop/is-set into an &#39;underlying</a>
  <a id="5894" class="Comment">-- type&#39; and level arguments.</a>
  <a id="atoms"></a><a id="5926" href="Meta.HLevel.Reflection.html#5926" class="Function">atoms</a> <a id="5932" class="Symbol">:</a> <a id="5934" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5939" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
  <a id="5946" href="Meta.HLevel.Reflection.html#5926" class="Function">atoms</a> <a id="5952" class="Symbol">=</a> <a id="5954" href="Meta.FromProduct.html#308" class="Function Operator">[</a> <a id="5956" class="Keyword">quote</a> <a id="5962" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a>
          <a id="5985" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5987" class="Keyword">quote</a> <a id="5993" href="Foundations.Base.html#12782" class="Function">is-prop</a>
          <a id="6011" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6013" class="Keyword">quote</a> <a id="6019" href="Foundations.Base.html#12851" class="Function">is-set</a>
          <a id="6036" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6038" class="Keyword">quote</a> <a id="6044" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">_≃_</a>
          <a id="6058" href="Meta.FromProduct.html#308" class="Function Operator">]</a>

  <a id="6063" class="Keyword">pattern</a> <a id="nat-lit"></a><a id="6071" href="Meta.HLevel.Reflection.html#6071" class="InductiveConstructor">nat-lit</a> <a id="6079" href="Meta.HLevel.Reflection.html#6136" class="Bound">n</a> <a id="6081" class="Symbol">=</a>
    <a id="6087" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6091" class="Symbol">(</a><a id="6092" class="Keyword">quote</a> <a id="6098" href="Agda.Builtin.FromNat.html#281" class="Field">Number.fromNat</a><a id="6112" class="Symbol">)</a> <a id="6114" class="Symbol">(_</a> <a id="6117" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6119" class="Symbol">_</a> <a id="6121" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6123" class="Symbol">_</a> <a id="6125" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6127" class="InductiveConstructor">lit</a> <a id="6131" class="Symbol">(</a><a id="6132" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="6136" href="Meta.HLevel.Reflection.html#6136" class="Bound">n</a><a id="6137" class="Symbol">)</a> <a id="6139" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="6142" class="Symbol">_)</a>

  <a id="6148" class="Comment">-- Decompose an application of is-hlevel and/or one of the other</a>
  <a id="6215" class="Comment">-- &#39;hlevel-types&#39; into its constituent parts. Invariant:</a>
  <a id="6274" class="Comment">--</a>
  <a id="6279" class="Comment">--    decompose-is-hlevel′ t = (n , a) ⊢ t = is-of-hlevel n a</a>
  <a id="decompose-is-hlevel′"></a><a id="6343" href="Meta.HLevel.Reflection.html#6343" class="Function">decompose-is-hlevel′</a> <a id="6364" class="Symbol">:</a> <a id="6366" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6371" class="Symbol">→</a> <a id="6373" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6376" class="Symbol">(</a><a id="6377" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6382" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6384" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6388" class="Symbol">)</a>

  <a id="6393" class="Comment">-- Infer the type of the given term, and decompose it according to</a>
  <a id="6462" class="Comment">-- decompose-is-hlevel′.</a>
  <a id="decompose-is-hlevel"></a><a id="6489" href="Meta.HLevel.Reflection.html#6489" class="Function">decompose-is-hlevel</a> <a id="6509" class="Symbol">:</a> <a id="6511" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6516" class="Symbol">→</a> <a id="6518" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6521" class="Symbol">(</a><a id="6522" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6527" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6529" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6533" class="Symbol">)</a>
  <a id="6537" href="Meta.HLevel.Reflection.html#6489" class="Function">decompose-is-hlevel</a> <a id="6557" href="Meta.HLevel.Reflection.html#6557" class="Bound">goal</a> <a id="6562" class="Symbol">=</a> <a id="6564" class="Keyword">do</a>
    <a id="6571" href="Meta.HLevel.Reflection.html#6571" class="Bound">ty</a> <a id="6574" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6576" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="6591" class="Symbol">(</a><a id="6592" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="6598" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6600" href="Meta.HLevel.Reflection.html#5926" class="Function">atoms</a><a id="6605" class="Symbol">)</a> <a id="6607" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="6609" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="6619" href="Meta.HLevel.Reflection.html#6557" class="Bound">goal</a> <a id="6624" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="6628" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
    <a id="6639" href="Meta.HLevel.Reflection.html#6343" class="Function">decompose-is-hlevel′</a> <a id="6660" href="Meta.HLevel.Reflection.html#6571" class="Bound">ty</a>

  <a id="6666" href="Meta.HLevel.Reflection.html#6343" class="Function">decompose-is-hlevel′</a> <a id="6687" href="Meta.HLevel.Reflection.html#6687" class="Bound">ty</a> <a id="6690" class="Symbol">=</a> <a id="6692" class="Keyword">do</a>
    <a id="6699" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6703" class="Symbol">(</a><a id="6704" class="Keyword">quote</a> <a id="6710" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a><a id="6722" class="Symbol">)</a> <a id="6724" class="Symbol">(_</a> <a id="6727" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6729" href="Meta.HLevel.Reflection.html#6729" class="Bound">lv</a> <a id="6732" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="6735" href="Meta.HLevel.Reflection.html#6735" class="Bound">ty</a> <a id="6738" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="6741" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6743" class="Symbol">)</a> <a id="6745" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6747" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6752" href="Meta.HLevel.Reflection.html#6687" class="Bound">ty</a>
      <a id="6761" class="Keyword">where</a>
        <a id="6775" class="Comment">-- Handle the ones with special names:</a>
        <a id="6822" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6826" class="Symbol">(</a><a id="6827" class="Keyword">quote</a> <a id="6833" href="Foundations.Base.html#12851" class="Function">is-set</a><a id="6839" class="Symbol">)</a> <a id="6841" class="Symbol">(_</a> <a id="6844" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6846" href="Meta.HLevel.Reflection.html#6846" class="Bound">ty</a> <a id="6849" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="6852" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6854" class="Symbol">)</a> <a id="6856" class="Symbol">→</a> <a id="6858" class="Keyword">do</a>
          <a id="6871" href="Meta.HLevel.Reflection.html#6871" class="Bound">ty</a> <a id="6874" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6876" href="Meta.Reflection.html#5447" class="Function">wait-just-a-bit</a> <a id="6892" href="Meta.HLevel.Reflection.html#6846" class="Bound">ty</a>
          <a id="6905" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6910" class="Symbol">(</a><a id="6911" class="Keyword">quoteTerm</a> <a id="6921" class="Number">2</a> <a id="6923" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6925" href="Meta.HLevel.Reflection.html#6871" class="Bound">ty</a><a id="6927" class="Symbol">)</a>

        <a id="6938" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6942" class="Symbol">(</a><a id="6943" class="Keyword">quote</a> <a id="6949" href="Foundations.Base.html#12782" class="Function">is-prop</a><a id="6956" class="Symbol">)</a> <a id="6958" class="Symbol">(_</a> <a id="6961" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6963" href="Meta.HLevel.Reflection.html#6963" class="Bound">ty</a> <a id="6966" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="6969" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6971" class="Symbol">)</a> <a id="6973" class="Symbol">→</a> <a id="6975" class="Keyword">do</a>
          <a id="6988" href="Meta.HLevel.Reflection.html#6988" class="Bound">ty</a> <a id="6991" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6993" href="Meta.Reflection.html#5447" class="Function">wait-just-a-bit</a> <a id="7009" href="Meta.HLevel.Reflection.html#6963" class="Bound">ty</a>
          <a id="7022" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7027" class="Symbol">(</a><a id="7028" class="Keyword">quoteTerm</a> <a id="7038" class="Number">1</a> <a id="7040" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7042" href="Meta.HLevel.Reflection.html#6988" class="Bound">ty</a><a id="7044" class="Symbol">)</a>

        <a id="7055" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="7059" class="Symbol">(</a><a id="7060" class="Keyword">quote</a> <a id="7066" href="Foundations.Base.html#12638" class="Function">is-contr</a><a id="7074" class="Symbol">)</a> <a id="7076" class="Symbol">(_</a> <a id="7079" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="7081" href="Meta.HLevel.Reflection.html#7081" class="Bound">ty</a> <a id="7084" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="7087" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7089" class="Symbol">)</a> <a id="7091" class="Symbol">→</a> <a id="7093" class="Keyword">do</a>
          <a id="7106" href="Meta.HLevel.Reflection.html#7106" class="Bound">ty</a> <a id="7109" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7111" href="Meta.Reflection.html#5447" class="Function">wait-just-a-bit</a> <a id="7127" href="Meta.HLevel.Reflection.html#7081" class="Bound">ty</a>
          <a id="7140" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7145" class="Symbol">(</a><a id="7146" class="Keyword">quoteTerm</a> <a id="7156" class="Number">0</a> <a id="7158" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7160" href="Meta.HLevel.Reflection.html#7106" class="Bound">ty</a><a id="7162" class="Symbol">)</a>

        <a id="7173" class="CatchallClause Symbol">_</a> <a id="7175" class="Symbol">→</a> <a id="7177" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="7187" class="String">&quot;Goal type isn&#39;t is-hlevel&quot;</a>

    <a id="7220" class="Comment">-- To support having bare hlevel! in the source file, we need to</a>
    <a id="7289" class="Comment">-- block decomposition on having a rigid-ish type at the</a>
    <a id="7350" class="Comment">-- top-level. Otherwise the first hint that matches will get</a>
    <a id="7415" class="Comment">-- matched endlessly until we run out of fuel!</a>
    <a id="7466" href="Meta.HLevel.Reflection.html#7466" class="Bound">ty</a> <a id="7469" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7471" href="Meta.Reflection.html#5447" class="Function">wait-just-a-bit</a> <a id="7487" href="Meta.HLevel.Reflection.html#6735" class="Bound">ty</a>
    <a id="7494" href="Meta.HLevel.Reflection.html#7494" class="Bound">lv</a> <a id="7497" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7499" href="Meta.Reflection.html#5447" class="Function">wait-just-a-bit</a> <a id="7515" href="Meta.HLevel.Reflection.html#6729" class="Bound">lv</a>
    <a id="7522" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7527" class="Symbol">(</a><a id="7528" href="Meta.HLevel.Reflection.html#7494" class="Bound">lv</a> <a id="7531" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7533" href="Meta.HLevel.Reflection.html#7466" class="Bound">ty</a><a id="7535" class="Symbol">)</a>

<a id="7538" class="Comment">{-
Lifting n-Types
---------------

The n-types are the leaves of the hlevel solving process, so they&#39;re
pretty much our only opportunity to adjust levels in a big way. Suppose
you have

  T = def (quote X) as

with
  get-level (get-argument T) = n
  w : is-of-hlevel n T

but what you want is a witness of is-of-hlevel (k + n) T, where k is some
numeral? Well, the solution is obvious: we can compute k - n and lift
T&#39;s witness (k - n) levels. Right?

No: we&#39;re dealing with potential open naturals, so we have to be careful
about performing ‘symbolic’ subtractions. The way we do this is with,
essentially, a loop: If w doesn&#39;t work, then try

  is-hlevel-suc n w : is-hlevel (suc n) T

until you reach a sucᵏ n = k + n. Actually, slightly more efficient, we
keep around a counter k′ for the number of tries, and transfer successors
from the wanted level (k + n) until is-of-hlevel-+ n (sucᵏ′ n) w works.
-}</a>
  <a id="lift-sol"></a><a id="8450" href="Meta.HLevel.Reflection.html#8450" class="Function">lift-sol</a> <a id="8459" class="Symbol">:</a> <a id="8461" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8466" class="Symbol">→</a> <a id="8468" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8473" class="Symbol">→</a> <a id="8475" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8477" class="Symbol">→</a> <a id="8479" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8486" href="Meta.HLevel.Reflection.html#8450" class="Function">lift-sol</a> <a id="8495" href="Meta.HLevel.Reflection.html#8495" class="Bound">tm</a> <a id="8498" class="Symbol">_</a> <a id="8500" class="Number">0</a> <a id="8502" class="Symbol">=</a> <a id="8504" href="Meta.HLevel.Reflection.html#8495" class="Bound">tm</a>
  <a id="8509" href="Meta.HLevel.Reflection.html#8450" class="CatchallClause Function">lift-sol</a><a id="8517" class="CatchallClause"> </a><a id="8518" href="Meta.HLevel.Reflection.html#8518" class="CatchallClause Bound">tm</a><a id="8520" class="CatchallClause"> </a><a id="8521" href="Meta.HLevel.Reflection.html#8521" class="CatchallClause Bound">l1</a><a id="8523" class="CatchallClause"> </a><a id="8524" href="Meta.HLevel.Reflection.html#8524" class="CatchallClause Bound">l</a> <a id="8526" class="Symbol">=</a> <a id="8528" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="8532" class="Symbol">(</a><a id="8533" class="Keyword">quote</a> <a id="8539" href="Foundations.HLevel.Base.html#2678" class="Function">is-of-hlevel-+</a><a id="8553" class="Symbol">)</a> <a id="8555" class="Symbol">(</a><a id="8556" href="Meta.HLevel.Reflection.html#8521" class="Bound">l1</a> <a id="8559" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="8562" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8566" class="Symbol">(</a><a id="8567" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8571" href="Meta.HLevel.Reflection.html#8524" class="Bound">l</a><a id="8572" class="Symbol">)</a> <a id="8574" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="8577" href="Meta.HLevel.Reflection.html#8518" class="Bound">tm</a> <a id="8580" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="8583" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8585" class="Symbol">)</a>

  <a id="pred-term"></a><a id="8590" href="Meta.HLevel.Reflection.html#8590" class="Function">pred-term</a> <a id="8600" class="Symbol">:</a> <a id="8602" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8607" class="Symbol">→</a> <a id="8609" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="8615" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8622" href="Meta.HLevel.Reflection.html#8590" class="Function">pred-term</a> <a id="8632" class="Symbol">(</a><a id="8633" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="8637" class="Symbol">(</a><a id="8638" class="Keyword">quote</a> <a id="8644" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="8647" class="Symbol">)</a> <a id="8649" class="Symbol">(</a><a id="8650" href="Meta.HLevel.Reflection.html#8650" class="Bound">x</a> <a id="8652" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="8655" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8657" class="Symbol">))</a> <a id="8660" class="Symbol">=</a> <a id="8662" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8667" href="Meta.HLevel.Reflection.html#8650" class="Bound">x</a>
  <a id="8671" href="Meta.HLevel.Reflection.html#8590" class="Function">pred-term</a> <a id="8681" class="Symbol">(</a><a id="8682" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8686" class="Symbol">(</a><a id="8687" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8691" href="Meta.HLevel.Reflection.html#8691" class="Bound">n</a><a id="8692" class="Symbol">))</a> <a id="8695" class="Keyword">with</a> <a id="8700" href="Meta.HLevel.Reflection.html#8691" class="Bound">n</a>
  <a id="8704" class="Symbol">...</a> <a id="8708" class="Symbol">|</a> <a id="8710" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8714" href="Meta.HLevel.Reflection.html#8714" class="Bound">k</a> <a id="8716" class="Symbol">=</a> <a id="8718" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8723" class="Symbol">(</a><a id="8724" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8728" class="Symbol">(</a><a id="8729" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8733" href="Meta.HLevel.Reflection.html#8714" class="Bound">k</a><a id="8734" class="Symbol">))</a>
  <a id="8739" class="CatchallClause Symbol">...</a><a id="8742" class="CatchallClause"> </a><a id="8743" class="CatchallClause Symbol">|</a><a id="8744" class="CatchallClause"> </a><a id="8745" class="CatchallClause Symbol">_</a> <a id="8747" class="Symbol">=</a> <a id="8749" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
  <a id="8759" href="Meta.HLevel.Reflection.html#8590" class="CatchallClause Function">pred-term</a><a id="8768" class="CatchallClause"> </a><a id="8769" class="CatchallClause Symbol">_</a> <a id="8771" class="Symbol">=</a> <a id="8773" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="lifting-loop"></a><a id="8784" href="Meta.HLevel.Reflection.html#8784" class="Function">lifting-loop</a> <a id="8797" class="Symbol">:</a> <a id="8799" class="Symbol">(</a><a id="8800" href="Meta.HLevel.Reflection.html#8800" class="Bound">fuel</a> <a id="8805" class="Symbol">:</a> <a id="8807" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="8808" class="Symbol">)</a> <a id="8810" class="Symbol">→</a> <a id="8812" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8814" class="Symbol">→</a> <a id="8816" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8821" class="Symbol">→</a> <a id="8823" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8828" class="Symbol">→</a> <a id="8830" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8835" class="Symbol">→</a> <a id="8837" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8842" class="Symbol">→</a> <a id="8844" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="8847" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="8851" href="Meta.HLevel.Reflection.html#8784" class="Function">lifting-loop</a> <a id="8864" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="8869" class="Symbol">_</a> <a id="8871" class="Symbol">_</a> <a id="8873" class="Symbol">_</a> <a id="8875" class="Symbol">_</a> <a id="8877" class="Symbol">_</a> <a id="8879" class="Symbol">=</a> <a id="8881" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="8891" class="String">&quot;Lifting loop ran out of fuel&quot;</a>
  <a id="8924" href="Meta.HLevel.Reflection.html#8784" class="Function">lifting-loop</a> <a id="8937" class="Symbol">(</a><a id="8938" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8942" href="Meta.HLevel.Reflection.html#8942" class="Bound">fuel</a><a id="8946" class="Symbol">)</a> <a id="8948" href="Meta.HLevel.Reflection.html#8948" class="Bound">it</a> <a id="8951" href="Meta.HLevel.Reflection.html#8951" class="Bound">solution</a> <a id="8960" href="Meta.HLevel.Reflection.html#8960" class="Bound">goal</a> <a id="8965" href="Meta.HLevel.Reflection.html#8965" class="Bound">l1</a> <a id="8968" href="Meta.HLevel.Reflection.html#8968" class="Bound">l2</a> <a id="8971" class="Symbol">=</a>
    <a id="8977" href="Meta.HLevel.Reflection.html#9192" class="Function">let&#39;s-hope</a> <a id="8988" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="8992" class="Keyword">do</a>
      <a id="9001" class="Symbol">(</a><a id="9002" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="9007" href="Meta.HLevel.Reflection.html#9007" class="Bound">l2′</a><a id="9010" class="Symbol">)</a> <a id="9012" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="9014" href="Meta.HLevel.Reflection.html#8590" class="Function">pred-term</a> <a id="9024" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="9028" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="9038" href="Meta.HLevel.Reflection.html#8968" class="Bound">l2</a> <a id="9041" class="Keyword">where</a>
        <a id="9055" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="9063" class="Symbol">→</a> <a id="9065" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="9075" class="String">&quot;Lifting loop reached its end with no success&quot;</a>
      <a id="9128" href="Meta.HLevel.Reflection.html#8784" class="Function">lifting-loop</a> <a id="9141" href="Meta.HLevel.Reflection.html#8942" class="Bound">fuel</a> <a id="9146" class="Symbol">(</a><a id="9147" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9151" href="Meta.HLevel.Reflection.html#8948" class="Bound">it</a><a id="9153" class="Symbol">)</a> <a id="9155" href="Meta.HLevel.Reflection.html#8951" class="Bound">solution</a> <a id="9164" href="Meta.HLevel.Reflection.html#8960" class="Bound">goal</a> <a id="9169" href="Meta.HLevel.Reflection.html#8965" class="Bound">l1</a> <a id="9172" href="Meta.HLevel.Reflection.html#9007" class="Bound">l2′</a>
    <a id="9180" class="Keyword">where</a>
      <a id="9192" href="Meta.HLevel.Reflection.html#9192" class="Function">let&#39;s-hope</a> <a id="9203" class="Symbol">:</a> <a id="9205" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9208" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="9216" href="Meta.HLevel.Reflection.html#9192" class="Function">let&#39;s-hope</a> <a id="9227" class="Symbol">=</a> <a id="9229" class="Keyword">do</a>
        <a id="9240" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9251" class="String">&quot;tactic.hlevel&quot;</a> <a id="9267" class="Number">30</a> <a id="9270" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="9272" class="String">&quot;Lifting loop: Trying &quot;</a> <a id="9296" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9298" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9306" class="Symbol">(</a><a id="9307" href="Meta.HLevel.Reflection.html#8450" class="Function">lift-sol</a> <a id="9316" href="Meta.HLevel.Reflection.html#8951" class="Bound">solution</a> <a id="9325" href="Meta.HLevel.Reflection.html#8965" class="Bound">l1</a> <a id="9328" href="Meta.HLevel.Reflection.html#8948" class="Bound">it</a><a id="9330" class="Symbol">)</a> <a id="9332" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9334" class="String">&quot; for level &quot;</a> <a id="9348" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9350" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9358" href="Meta.HLevel.Reflection.html#8968" class="Bound">l2</a> <a id="9361" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9363" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="9374" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="9380" href="Meta.HLevel.Reflection.html#8960" class="Bound">goal</a> <a id="9385" class="Symbol">(</a><a id="9386" href="Meta.HLevel.Reflection.html#8450" class="Function">lift-sol</a> <a id="9395" href="Meta.HLevel.Reflection.html#8951" class="Bound">solution</a> <a id="9404" href="Meta.HLevel.Reflection.html#8965" class="Bound">l1</a> <a id="9407" href="Meta.HLevel.Reflection.html#8948" class="Bound">it</a><a id="9409" class="Symbol">)</a>
    <a id="9415" class="Comment">-- con (quote suc) (</a>

  <a id="9439" class="Comment">-- Projection decomposition.</a>
  <a id="treat-as-n-type"></a><a id="9470" href="Meta.HLevel.Reflection.html#9470" class="Function">treat-as-n-type</a> <a id="9486" class="Symbol">:</a> <a id="9488" class="Symbol">∀</a> <a id="9490" class="Symbol">{</a><a id="9491" href="Meta.HLevel.Reflection.html#9491" class="Bound">n</a><a id="9492" class="Symbol">}</a> <a id="9494" class="Symbol">→</a> <a id="9496" href="Meta.HLevel.Reflection.html#4164" class="Record">hlevel-projection</a> <a id="9514" href="Meta.HLevel.Reflection.html#9491" class="Bound">n</a> <a id="9516" class="Symbol">→</a> <a id="9518" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="9523" class="Symbol">→</a> <a id="9525" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9528" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="9532" href="Meta.HLevel.Reflection.html#9470" class="Function">treat-as-n-type</a> <a id="9548" href="Meta.HLevel.Reflection.html#9548" class="Bound">projection</a> <a id="9559" href="Meta.HLevel.Reflection.html#9559" class="Bound">goal</a> <a id="9564" class="Symbol">=</a> <a id="9566" class="Keyword">do</a>
    <a id="9573" class="Comment">-- First we must be looking at a goal which is of the type is-hlevel</a>
    <a id="9646" class="Comment">-- A n. We&#39;ll need both n and A.</a>
    <a id="9683" class="Symbol">(</a><a id="9684" href="Meta.HLevel.Reflection.html#9684" class="Bound">wanted-level</a> <a id="9697" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9699" href="Meta.HLevel.Reflection.html#9699" class="Bound">ty</a><a id="9701" class="Symbol">)</a> <a id="9703" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="9705" href="Meta.HLevel.Reflection.html#6489" class="Function">decompose-is-hlevel</a> <a id="9725" href="Meta.HLevel.Reflection.html#9559" class="Bound">goal</a>
    <a id="9734" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9745" class="String">&quot;tactic.hlevel&quot;</a> <a id="9761" class="Number">10</a> <a id="9764" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="9772" class="String">&quot;Attempting to treat as &quot;</a> <a id="9798" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9800" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9808" href="Meta.HLevel.Reflection.html#9684" class="Bound">wanted-level</a> <a id="9821" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9823" class="String">&quot;-Type: &quot;</a> <a id="9833" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9835" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9843" href="Meta.HLevel.Reflection.html#9699" class="Bound">ty</a> <a id="9846" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9848" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="9855" href="Meta.HLevel.Reflection.html#9855" class="Bound">ty</a> <a id="9858" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="9860" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="9867" href="Meta.HLevel.Reflection.html#9699" class="Bound">ty</a>

    <a id="9875" class="Comment">-- Reduce the type to whnf and check whether the outermost term</a>
    <a id="9943" class="Comment">-- constructor is an application of the projection we&#39;re looking</a>
    <a id="10012" class="Comment">-- for.</a>
    <a id="10024" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10028" href="Meta.HLevel.Reflection.html#10028" class="Bound">namen</a> <a id="10034" href="Meta.HLevel.Reflection.html#10034" class="Bound">args</a> <a id="10039" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10041" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="10050" href="Meta.HLevel.Reflection.html#9855" class="Bound">ty</a>
      <a id="10059" class="Keyword">where</a> <a id="10065" href="Meta.HLevel.Reflection.html#10065" class="CatchallClause Bound">what</a> <a id="10070" class="Symbol">→</a> <a id="10072" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="10082" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="10084" class="String">&quot;Thing isn&#39;t an application, it is &quot;</a> <a id="10121" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10123" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10131" href="Meta.HLevel.Reflection.html#10065" class="Bound">what</a> <a id="10136" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10138" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10146" href="Meta.HLevel.Reflection.html#10146" class="Bound">it</a> <a id="10149" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10151" href="Meta.HLevel.Reflection.html#9548" class="Bound">projection</a> <a id="10162" class="Symbol">.</a><a id="10163" href="Meta.HLevel.Reflection.html#4561" class="Field">get-argument</a> <a id="10176" href="Meta.HLevel.Reflection.html#10034" class="Bound">args</a>

    <a id="10186" class="Comment">-- And compute the level of the projected thing, in addition to a</a>
    <a id="10256" class="Comment">-- numeral form of the wanted level.</a>
    <a id="10297" href="Meta.HLevel.Reflection.html#10297" class="Bound">actual-level</a> <a id="10310" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10312" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="10322" href="Meta.HLevel.Reflection.html#10146" class="Bound">it</a> <a id="10325" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="10329" href="Meta.HLevel.Reflection.html#9548" class="Bound">projection</a> <a id="10340" class="Symbol">.</a><a id="10341" href="Meta.HLevel.Reflection.html#4408" class="Field">get-level</a>

    <a id="10356" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="10367" class="String">&quot;tactic.hlevel&quot;</a> <a id="10383" class="Number">10</a> <a id="10386" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="10394" class="String">&quot;... but it&#39;s actually a(n) &quot;</a> <a id="10424" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10426" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10434" href="Meta.HLevel.Reflection.html#10297" class="Bound">actual-level</a> <a id="10447" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10449" class="String">&quot;-Type&quot;</a> <a id="10457" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10459" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10467" href="Meta.HLevel.Reflection.html#10467" class="Bound">lv</a> <a id="10470" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10472" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10482" href="Meta.HLevel.Reflection.html#9684" class="Bound">wanted-level</a>
    <a id="10499" href="Meta.HLevel.Reflection.html#10499" class="Bound">lv′</a> <a id="10503" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10505" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10515" href="Meta.HLevel.Reflection.html#10297" class="Bound">actual-level</a>
    <a id="10532" href="Meta.HLevel.Reflection.html#8784" class="Function">lifting-loop</a> <a id="10545" class="Number">10000</a> <a id="10551" class="Number">0</a> <a id="10553" class="Symbol">(</a><a id="10554" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10558" class="Symbol">(</a><a id="10559" href="Meta.HLevel.Reflection.html#9548" class="Bound">projection</a> <a id="10570" class="Symbol">.</a><a id="10571" href="Meta.HLevel.Reflection.html#4221" class="Field">has-level</a><a id="10580" class="Symbol">)</a> <a id="10582" class="Symbol">(</a><a id="10583" href="Meta.HLevel.Reflection.html#10146" class="Bound">it</a> <a id="10586" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="10589" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10591" class="Symbol">))</a> <a id="10594" href="Meta.HLevel.Reflection.html#9559" class="Bound">goal</a> <a id="10599" href="Meta.HLevel.Reflection.html#10499" class="Bound">lv′</a> <a id="10603" href="Meta.HLevel.Reflection.html#10467" class="Bound">lv</a>

    <a id="10611" href="Agda.Builtin.Reflection.html#9521" class="Postulate">commitTC</a>

  <a id="10623" class="Comment">-- Fall back to Agda&#39;s instance search mechanism. This isn&#39;t as</a>
  <a id="10689" class="Comment">-- straightforward as just using the &#39;hlevel&#39; function for a couple of</a>
  <a id="10762" class="Comment">-- reasons.</a>
  <a id="use-instance-search"></a><a id="10776" href="Meta.HLevel.Reflection.html#10776" class="Function">use-instance-search</a> <a id="10796" class="Symbol">:</a> <a id="10798" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="10803" class="Symbol">→</a> <a id="10805" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="10810" class="Symbol">→</a> <a id="10812" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="10815" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="10819" href="Meta.HLevel.Reflection.html#10776" class="Function">use-instance-search</a> <a id="10839" href="Meta.HLevel.Reflection.html#10839" class="Bound">has-alts</a> <a id="10848" href="Meta.HLevel.Reflection.html#10848" class="Bound">goal</a> <a id="10853" class="Symbol">=</a> <a id="10855" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="10870" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="10872" class="Keyword">do</a>
    <a id="10879" class="Symbol">(</a><a id="10880" href="Meta.HLevel.Reflection.html#10880" class="Bound">lv</a> <a id="10883" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10885" href="Meta.HLevel.Reflection.html#10885" class="Bound">ty</a><a id="10887" class="Symbol">)</a> <a id="10889" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10891" href="Meta.HLevel.Reflection.html#6489" class="Function">decompose-is-hlevel</a> <a id="10911" href="Meta.HLevel.Reflection.html#10848" class="Bound">goal</a>
    <a id="10920" href="Meta.HLevel.Reflection.html#10920" class="Bound">solved</a><a id="10926" class="Symbol">@(</a><a id="10928" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="10933" href="Meta.HLevel.Reflection.html#10933" class="Bound">mv</a> <a id="10936" class="Symbol">_)</a> <a id="10939" href="Meta.Bind.html#190" class="Field Operator">←</a>
      <a id="10947" href="Meta.Reflection.html#1925" class="Function">new-meta</a> <a id="10956" class="Symbol">(</a><a id="10957" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10961" class="Symbol">(</a><a id="10962" class="Keyword">quote</a> <a id="10968" href="Meta.HLevel.Base.html#186" class="Record">H-Level</a><a id="10975" class="Symbol">)</a> <a id="10977" class="Symbol">(</a><a id="10978" href="Meta.HLevel.Reflection.html#10880" class="Bound">lv</a> <a id="10981" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="10984" href="Meta.HLevel.Reflection.html#10885" class="Bound">ty</a> <a id="10987" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="10990" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10992" class="Symbol">))</a> <a id="10995" class="Keyword">where</a> <a id="11001" class="CatchallClause Symbol">_</a> <a id="11003" class="Symbol">→</a> <a id="11005" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="11015" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="11022" href="Meta.HLevel.Reflection.html#11022" class="Bound">instances</a> <a id="11032" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="11034" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="11047" href="Meta.HLevel.Reflection.html#10933" class="Bound">mv</a>

    <a id="11055" href="Meta.HLevel.Reflection.html#11055" class="Bound">t</a> <a id="11057" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="11059" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="11067" href="Meta.HLevel.Reflection.html#11022" class="Bound">instances</a>
    <a id="11081" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="11092" class="String">&quot;tactic.hlevel&quot;</a> <a id="11108" class="Number">10</a> <a id="11111" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="11119" class="String">&quot;Using instance search for\n&quot;</a> <a id="11149" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11151" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11159" href="Meta.HLevel.Reflection.html#10885" class="Bound">ty</a> <a id="11162" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
      <a id="11170" class="String">&quot;\nFound candidates\n &quot;</a> <a id="11194" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11196" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11204" href="Meta.HLevel.Reflection.html#11055" class="Bound">t</a> <a id="11206" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11208" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="11216" class="Comment">-- We actually want to manage the instance searching ourselves,</a>
    <a id="11284" class="Comment">-- sorta, to avoid getting into situations where the macro has</a>
    <a id="11351" class="Comment">-- committed to instance search but Agda will disagree with it.</a>
    <a id="11419" class="Keyword">let</a>
      <a id="11429" href="Meta.HLevel.Reflection.html#11429" class="Bound">go</a> <a id="11432" class="Symbol">:</a> <a id="11434" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="11439" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="11444" class="Symbol">→</a> <a id="11446" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="11449" class="Symbol">(</a><a id="11450" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="11452" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="11454" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="11458" class="Symbol">)</a>
      <a id="11466" href="Meta.HLevel.Reflection.html#11429" class="Bound">go</a> <a id="11469" class="Symbol">=</a> <a id="11471" class="Symbol">λ</a> <a id="11473" class="Keyword">where</a>
        <a id="11487" class="Comment">-- If there is *exactly* one instance candidate for this goal,</a>
        <a id="11558" class="Comment">-- then we can go ahead and solve it. That&#39;s because having</a>
        <a id="11626" class="Comment">-- exactly one instance means Agda will solve using that</a>
        <a id="11691" class="Comment">-- instance!</a>
        <a id="11712" class="Symbol">(</a><a id="11713" href="Meta.HLevel.Reflection.html#11713" class="Bound">x</a> <a id="11715" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11717" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11719" class="Symbol">)</a> <a id="11721" class="Symbol">→</a> <a id="11723" class="Keyword">do</a>
          <a id="11736" class="Comment">-- Note that, since getInstances works by creating a new meta,</a>
          <a id="11809" class="Comment">-- we have to commit to the instance ourselves.</a>
          <a id="11867" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11873" href="Meta.HLevel.Reflection.html#10920" class="Bound">solved</a> <a id="11880" href="Meta.HLevel.Reflection.html#11713" class="Bound">x</a>
          <a id="11892" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="11907" class="Symbol">(</a><a id="11908" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="11914" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11916" class="Keyword">quote</a> <a id="11922" href="Meta.HLevel.Base.html#326" class="Function">hlevel</a> <a id="11929" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11931" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11933" class="Symbol">)</a> <a id="11935" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="11937" href="Agda.Builtin.Reflection.html#10063" class="Postulate">withReconstructed</a> <a id="11955" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="11960" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="11974" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11980" href="Meta.HLevel.Reflection.html#10848" class="Bound">goal</a> <a id="11985" class="Symbol">(</a><a id="11986" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="11990" class="Symbol">(</a><a id="11991" class="Keyword">quote</a> <a id="11997" href="Meta.HLevel.Base.html#326" class="Function">hlevel</a><a id="12003" class="Symbol">)</a> <a id="12005" class="Symbol">(</a><a id="12006" href="Meta.HLevel.Reflection.html#10880" class="Bound">lv</a> <a id="12009" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="12012" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="12014" class="Symbol">))</a>
          <a id="12027" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="12032" class="Symbol">(</a><a id="12033" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12036" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12038" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="12042" class="Symbol">)</a>

        <a id="12053" class="Comment">-- If there are any more alternatives to be tried after this</a>
        <a id="12122" class="Comment">-- one, then we fail (backtrack). Otherwise, we discard the TC</a>
        <a id="12193" class="Comment">-- state but indicate success: this will cause the meta to be</a>
        <a id="12263" class="Comment">-- solved with an interaction point (if using</a>
        <a id="12317" class="Comment">-- elaborate-and-give).</a>
        <a id="12349" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="12352" class="Symbol">→</a> <a id="12354" href="Data.Bool.Base.html#492" class="Function Operator">if</a> <a id="12357" href="Meta.HLevel.Reflection.html#10839" class="Bound">has-alts</a>
          <a id="12376" href="Data.Bool.Base.html#492" class="Function Operator">then</a> <a id="12381" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="12391" class="String">&quot;No possible instances, but have other decompositions to try&quot;</a>
          <a id="12463" href="Data.Bool.Base.html#492" class="Function Operator">else</a> <a id="12468" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="12473" class="Symbol">(</a><a id="12474" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12477" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12479" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="12484" class="Symbol">)</a>

        <a id="12495" class="CatchallClause Symbol">_</a> <a id="12497" class="Symbol">→</a> <a id="12499" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="12509" class="String">&quot;Too many possible instances; will not use instance search for this goal&quot;</a>
    <a id="12587" href="Meta.HLevel.Reflection.html#11429" class="Bound">go</a> <a id="12590" href="Meta.HLevel.Reflection.html#11022" class="Bound">instances</a>

  <a id="12603" class="Comment">-- Entry point for calling the tactic.</a>
  <a id="search"></a><a id="12644" href="Meta.HLevel.Reflection.html#12644" class="Function">search</a> <a id="12651" class="Symbol">:</a> <a id="12653" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="12658" class="Symbol">→</a> <a id="12660" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12665" class="Symbol">→</a> <a id="12667" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="12669" class="Symbol">→</a> <a id="12671" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12676" class="Symbol">→</a> <a id="12678" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="12681" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="12685" class="Comment">-- Give up if we&#39;re out of fuel:</a>
  <a id="12720" href="Meta.HLevel.Reflection.html#12644" class="Function">search</a> <a id="12727" href="Meta.HLevel.Reflection.html#12727" class="Bound">has-alts</a> <a id="12736" class="Symbol">_</a>     <a id="12742" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="12750" href="Meta.HLevel.Reflection.html#12750" class="Bound">goal</a> <a id="12755" class="Symbol">=</a> <a id="12757" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="12763" href="Meta.HLevel.Reflection.html#12750" class="Bound">goal</a> <a id="12768" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>

  <a id="12779" class="Comment">-- Actual main loop: try using the hints database, try treating the</a>
  <a id="12849" class="Comment">-- goal as an n-type, fall back to instance search.</a>
  <a id="12903" href="Meta.HLevel.Reflection.html#12644" class="Function">search</a> <a id="12910" href="Meta.HLevel.Reflection.html#12910" class="Bound">has-alts</a> <a id="12919" href="Meta.HLevel.Reflection.html#12919" class="Bound">level</a> <a id="12925" class="Symbol">(</a><a id="12926" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12930" href="Meta.HLevel.Reflection.html#12930" class="Bound">n</a><a id="12931" class="Symbol">)</a> <a id="12933" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a> <a id="12938" class="Symbol">=</a>
    <a id="12944" href="Meta.HLevel.Reflection.html#13262" class="Function">use-projections</a>
      <a id="12966" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="12970" href="Meta.HLevel.Reflection.html#21606" class="Function">use-hints</a>
      <a id="12986" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="12990" href="Meta.HLevel.Reflection.html#10776" class="Function">use-instance-search</a> <a id="13010" href="Meta.HLevel.Reflection.html#12910" class="Bound">has-alts</a> <a id="13019" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a>
      <a id="13030" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="13034" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="13044" class="String">&quot;Search failed!!&quot;</a>
    <a id="13066" class="Keyword">where</a>
      <a id="13078" class="Keyword">open</a> <a id="13083" href="Meta.HLevel.Reflection.html#4164" class="Module">hlevel-projection</a>

      <a id="13108" class="Comment">-- Nondeterministically use a projection for establishing the</a>
      <a id="13176" class="Comment">-- result. This follows the approach described in [Using</a>
      <a id="13239" class="Comment">-- projections].</a>
      <a id="13262" href="Meta.HLevel.Reflection.html#13262" class="Function">use-projections</a> <a id="13278" class="Symbol">:</a> <a id="13280" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="13283" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="13291" href="Meta.HLevel.Reflection.html#13262" class="Function">use-projections</a> <a id="13307" class="Symbol">=</a> <a id="13309" class="Keyword">do</a>
        <a id="13320" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13324" href="Meta.HLevel.Reflection.html#13324" class="Bound">qn</a> <a id="13327" class="Symbol">_</a> <a id="13329" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13331" class="Symbol">(</a><a id="13332" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="13336" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="13340" href="Meta.HLevel.Reflection.html#6489" class="Function">decompose-is-hlevel</a> <a id="13360" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a><a id="13364" class="Symbol">)</a> <a id="13366" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="13370" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
          <a id="13387" class="Keyword">where</a> <a id="13393" class="CatchallClause Symbol">_</a> <a id="13395" class="Symbol">→</a> <a id="13397" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="13407" class="String">&quot;Term is not headed by a definition; ignoring projections.&quot;</a>

        <a id="13476" href="Meta.HLevel.Reflection.html#13476" class="Bound">goalt</a> <a id="13482" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13484" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="13494" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a>
        <a id="13507" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="13518" class="String">&quot;tactic.hlevel&quot;</a> <a id="13534" class="Number">20</a> <a id="13537" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="13549" class="String">&quot;Will attempt to use projections for goal\n  &quot;</a> <a id="13596" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13598" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13606" href="Meta.HLevel.Reflection.html#13476" class="Bound">goalt</a> <a id="13612" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13614" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="13626" class="Symbol">(</a><a id="13627" href="Meta.HLevel.Reflection.html#13627" class="Bound">solved</a> <a id="13634" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13636" href="Meta.HLevel.Reflection.html#13636" class="Bound">instances</a><a id="13645" class="Symbol">)</a> <a id="13647" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13649" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="13664" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="13666" class="Keyword">do</a>
          <a id="13679" href="Meta.HLevel.Reflection.html#13679" class="Bound">solved</a><a id="13685" class="Symbol">@(</a><a id="13687" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="13692" href="Meta.HLevel.Reflection.html#13692" class="Bound">mv</a> <a id="13695" class="Symbol">_)</a> <a id="13698" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13700" href="Meta.Reflection.html#1925" class="Function">new-meta</a> <a id="13709" class="Symbol">(</a><a id="13710" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13714" class="Symbol">(</a><a id="13715" class="Keyword">quote</a> <a id="13721" href="Meta.HLevel.Reflection.html#4164" class="Record">hlevel-projection</a><a id="13738" class="Symbol">)</a> <a id="13740" class="Symbol">(</a><a id="13741" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="13745" class="Symbol">(</a><a id="13746" href="Agda.Builtin.Reflection.html#4283" class="InductiveConstructor">name</a> <a id="13751" href="Meta.HLevel.Reflection.html#13324" class="Bound">qn</a><a id="13753" class="Symbol">)</a> <a id="13755" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="13758" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13760" class="Symbol">))</a>
            <a id="13775" class="Keyword">where</a> <a id="13781" class="CatchallClause Symbol">_</a> <a id="13783" class="Symbol">→</a> <a id="13785" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="13795" class="Symbol">(</a><a id="13796" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13804" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a> <a id="13809" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13811" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13813" class="Symbol">)</a>

          <a id="13826" class="Comment">-- If there are some hints, then great, otherwise we discard</a>
          <a id="13897" class="Comment">-- the TC state.</a>
          <a id="13924" class="Symbol">(</a><a id="13925" href="Meta.HLevel.Reflection.html#13925" class="Bound">x</a> <a id="13927" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13929" href="Meta.HLevel.Reflection.html#13929" class="Bound">xs</a><a id="13931" class="Symbol">)</a> <a id="13933" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13935" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="13948" href="Meta.HLevel.Reflection.html#13692" class="Bound">mv</a>
            <a id="13963" class="Keyword">where</a> <a id="13969" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="13972" class="Symbol">→</a> <a id="13974" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="13979" class="Symbol">((</a><a id="13981" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="13989" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13991" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13993" class="Symbol">)</a> <a id="13995" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13997" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="14002" class="Symbol">)</a>

          <a id="14015" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="14020" class="Symbol">((</a><a id="14022" href="Meta.HLevel.Reflection.html#13679" class="Bound">solved</a> <a id="14029" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14031" href="Meta.HLevel.Reflection.html#13925" class="Bound">x</a> <a id="14033" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14035" href="Meta.HLevel.Reflection.html#13929" class="Bound">xs</a><a id="14037" class="Symbol">)</a> <a id="14039" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14041" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="14045" class="Symbol">)</a>

        <a id="14056" href="Meta.Foldable.html#489" class="Function">nondet</a> <a id="14063" class="Symbol">(</a><a id="14064" href="Meta.Idiom.html#121" class="InductiveConstructor">eff</a> <a id="14068" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="14072" class="Symbol">)</a> <a id="14074" href="Meta.HLevel.Reflection.html#13636" class="Bound">instances</a> <a id="14084" class="Symbol">λ</a> <a id="14086" href="Meta.HLevel.Reflection.html#14086" class="Bound">a</a> <a id="14088" class="Symbol">→</a> <a id="14090" class="Keyword">do</a>
          <a id="14103" href="Meta.HLevel.Reflection.html#14103" class="Bound">projection</a> <a id="14114" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="14116" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="14126" class="Symbol">{</a><a id="14127" class="Argument">A</a> <a id="14129" class="Symbol">=</a> <a id="14131" href="Meta.HLevel.Reflection.html#4164" class="Record">hlevel-projection</a> <a id="14149" href="Meta.HLevel.Reflection.html#13324" class="Bound">qn</a><a id="14151" class="Symbol">}</a> <a id="14153" href="Meta.HLevel.Reflection.html#14086" class="Bound">a</a>
          <a id="14165" href="Meta.HLevel.Reflection.html#14165" class="Bound">ty</a> <a id="14168" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="14170" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="14185" class="Symbol">(</a><a id="14186" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="14192" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14194" href="Meta.HLevel.Reflection.html#5926" class="Function">atoms</a><a id="14199" class="Symbol">)</a> <a id="14201" class="Symbol">(</a><a id="14202" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="14212" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a> <a id="14217" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="14221" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="14227" class="Symbol">)</a>
          <a id="14239" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="14250" class="String">&quot;tactic.hlevel&quot;</a> <a id="14266" class="Number">20</a> <a id="14269" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="14283" class="String">&quot;Outer type: &quot;</a> <a id="14298" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14300" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="14308" href="Meta.HLevel.Reflection.html#14165" class="Bound">ty</a> <a id="14311" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14313" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="14326" href="Meta.HLevel.Reflection.html#9470" class="Function">treat-as-n-type</a> <a id="14342" href="Meta.HLevel.Reflection.html#14103" class="Bound">projection</a> <a id="14353" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a> <a id="14358" href="Meta.Bind.html#296" class="Function Operator">&gt;&gt;</a> <a id="14361" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="14367" href="Meta.HLevel.Reflection.html#13627" class="Bound">solved</a> <a id="14374" href="Meta.HLevel.Reflection.html#14086" class="Bound">a</a>

      <a id="14383" class="Comment">-- Get rid of any invisible binders that lead the term.</a>
      <a id="14445" href="Meta.HLevel.Reflection.html#14445" class="Function">remove-invisible</a> <a id="14462" class="Symbol">:</a> <a id="14464" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14469" class="Symbol">→</a> <a id="14471" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14476" class="Symbol">→</a> <a id="14478" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="14481" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14492" href="Meta.HLevel.Reflection.html#14445" class="Function">remove-invisible</a>
        <a id="14517" class="Symbol">(</a><a id="14518" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14522" class="Symbol">_</a> <a id="14524" class="Symbol">(</a><a id="14525" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14529" class="Symbol">_</a> <a id="14531" href="Meta.HLevel.Reflection.html#14531" class="Bound">t</a><a id="14532" class="Symbol">))</a>
        <a id="14543" class="Symbol">(</a><a id="14544" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="14547" class="Symbol">(</a><a id="14548" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="14552" class="Symbol">(</a><a id="14553" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="14562" href="Meta.HLevel.Reflection.html#14562" class="Bound">invisible</a> <a id="14572" class="Symbol">_)</a> <a id="14575" class="Symbol">_)</a> <a id="14578" class="Symbol">(</a><a id="14579" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14583" class="Symbol">_</a> <a id="14585" href="Meta.HLevel.Reflection.html#14585" class="Bound">ret</a><a id="14588" class="Symbol">))</a>
        <a id="14599" class="Symbol">=</a> <a id="14601" href="Meta.HLevel.Reflection.html#14445" class="Function">remove-invisible</a> <a id="14618" href="Meta.HLevel.Reflection.html#14531" class="Bound">t</a> <a id="14620" href="Meta.HLevel.Reflection.html#14585" class="Bound">ret</a>
      <a id="14630" href="Meta.HLevel.Reflection.html#14445" class="CatchallClause Function">remove-invisible</a><a id="14646" class="CatchallClause"> </a><a id="14647" href="Meta.HLevel.Reflection.html#14647" class="CatchallClause Bound">inner</a><a id="14652" class="CatchallClause"> </a><a id="14653" class="CatchallClause Symbol">_</a> <a id="14655" class="Symbol">=</a> <a id="14657" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="14662" href="Meta.HLevel.Reflection.html#14647" class="Bound">inner</a>

      <a id="14675" class="Comment">-- Search using decompositions involves manipulating the scope,</a>
      <a id="14745" class="Comment">-- which is why it&#39;s spread over so many functions, and even then,</a>
      <a id="14818" class="Comment">-- some are too big.</a>

      <a id="14846" class="Comment">-- Wrap the given term in a series of visible lambdas.</a>
      <a id="14907" href="Meta.HLevel.Reflection.html#14907" class="Function">wrap-lams</a> <a id="14917" class="Symbol">:</a> <a id="14919" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="14921" class="Symbol">→</a> <a id="14923" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14928" class="Symbol">→</a> <a id="14930" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14941" href="Meta.HLevel.Reflection.html#14907" class="Function">wrap-lams</a> <a id="14951" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="14956" href="Meta.HLevel.Reflection.html#14956" class="Bound">r</a> <a id="14958" class="Symbol">=</a> <a id="14960" href="Meta.HLevel.Reflection.html#14956" class="Bound">r</a>
      <a id="14968" href="Meta.HLevel.Reflection.html#14907" class="Function">wrap-lams</a> <a id="14978" class="Symbol">(</a><a id="14979" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="14983" href="Meta.HLevel.Reflection.html#14983" class="Bound">x</a><a id="14984" class="Symbol">)</a> <a id="14986" href="Meta.HLevel.Reflection.html#14986" class="Bound">r</a> <a id="14988" class="Symbol">=</a> <a id="14990" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14994" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="15002" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15004" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="15008" class="String">&quot;a&quot;</a> <a id="15012" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15014" href="Meta.HLevel.Reflection.html#14907" class="Function">wrap-lams</a> <a id="15024" href="Meta.HLevel.Reflection.html#14983" class="Bound">x</a> <a id="15026" href="Meta.HLevel.Reflection.html#14986" class="Bound">r</a>

      <a id="15035" class="Comment">-- Compute a continuation which extends the context by n visible</a>
      <a id="15106" class="Comment">-- variables, all typed &#39;unknown&#39;.</a>
      <a id="15147" href="Meta.HLevel.Reflection.html#15147" class="Function">extend-n</a> <a id="15156" class="Symbol">:</a> <a id="15158" class="Symbol">∀</a> <a id="15160" class="Symbol">{</a><a id="15161" href="Meta.HLevel.Reflection.html#15161" class="Bound">ℓ</a><a id="15162" class="Symbol">}</a> <a id="15164" class="Symbol">→</a> <a id="15166" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="15168" class="Symbol">→</a> <a id="15170" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15173" class="Symbol">((</a><a id="15175" href="Meta.HLevel.Reflection.html#15175" class="Bound">A</a> <a id="15177" class="Symbol">:</a> <a id="15179" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="15184" href="Meta.HLevel.Reflection.html#15161" class="Bound">ℓ</a><a id="15185" class="Symbol">)</a> <a id="15187" class="Symbol">→</a> <a id="15189" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15192" href="Meta.HLevel.Reflection.html#15175" class="Bound">A</a> <a id="15194" class="Symbol">→</a> <a id="15196" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15199" href="Meta.HLevel.Reflection.html#15175" class="Bound">A</a><a id="15200" class="Symbol">)</a>
      <a id="15208" href="Meta.HLevel.Reflection.html#15147" class="Function">extend-n</a> <a id="15217" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="15222" class="Symbol">=</a> <a id="15224" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15229" class="Symbol">λ</a> <a id="15231" href="Meta.HLevel.Reflection.html#15231" class="Bound">_</a> <a id="15233" href="Meta.HLevel.Reflection.html#15233" class="Bound">x</a> <a id="15235" class="Symbol">→</a> <a id="15237" href="Meta.HLevel.Reflection.html#15233" class="Bound">x</a>
      <a id="15245" href="Meta.HLevel.Reflection.html#15147" class="Function">extend-n</a> <a id="15254" class="Symbol">(</a><a id="15255" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="15259" href="Meta.HLevel.Reflection.html#15259" class="Bound">n</a><a id="15260" class="Symbol">)</a> <a id="15262" class="Symbol">=</a> <a id="15264" class="Keyword">do</a>
        <a id="15275" href="Meta.HLevel.Reflection.html#15275" class="Bound">rest</a> <a id="15280" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="15282" href="Meta.HLevel.Reflection.html#15147" class="Function">extend-n</a> <a id="15291" href="Meta.HLevel.Reflection.html#15259" class="Bound">n</a>
        <a id="15301" href="Foundations.Prim.Type.html#599" class="InductiveConstructor">lift</a> <a id="15306" href="Meta.HLevel.Reflection.html#15306" class="Bound">mv</a> <a id="15309" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="15311" href="Meta.HLevel.Reflection.html#15275" class="Bound">rest</a> <a id="15316" class="Symbol">(</a><a id="15317" href="Foundations.Prim.Type.html#538" class="Record">Lift</a> <a id="15322" class="Symbol">_</a> <a id="15324" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15328" class="Symbol">)</a> <a id="15330" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15332" href="Foundations.Prim.Type.html#599" class="InductiveConstructor">lift</a> <a id="15337" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="15341" href="Meta.Reflection.html#1925" class="Function">new-meta</a> <a id="15350" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="15366" class="Keyword">let</a> <a id="15370" href="Meta.HLevel.Reflection.html#15370" class="Bound">domain</a> <a id="15377" class="Symbol">=</a> <a id="15379" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="15383" class="Symbol">(</a><a id="15384" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="15393" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="15401" class="Symbol">(</a><a id="15402" href="Agda.Builtin.Reflection.html#3463" class="InductiveConstructor">modality</a> <a id="15411" href="Agda.Builtin.Reflection.html#3019" class="InductiveConstructor">relevant</a> <a id="15420" href="Agda.Builtin.Reflection.html#3241" class="InductiveConstructor">quantity-ω</a><a id="15430" class="Symbol">))</a> <a id="15433" href="Meta.HLevel.Reflection.html#15306" class="Bound">mv</a>
        <a id="15444" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15449" class="Symbol">λ</a> <a id="15451" href="Meta.HLevel.Reflection.html#15451" class="Bound">a</a> <a id="15453" href="Meta.HLevel.Reflection.html#15453" class="Bound">k</a> <a id="15455" class="Symbol">→</a> <a id="15457" href="Meta.HLevel.Reflection.html#15275" class="Bound">rest</a> <a id="15462" href="Meta.HLevel.Reflection.html#15451" class="Bound">a</a> <a id="15464" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15466" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="15480" class="String">&quot;a&quot;</a> <a id="15484" href="Meta.HLevel.Reflection.html#15370" class="Bound">domain</a> <a id="15491" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15493" href="Meta.HLevel.Reflection.html#15453" class="Bound">k</a>

      <a id="15502" class="Comment">-- Given a list of argument specs, actually unify the goal with</a>
      <a id="15572" class="Comment">-- the solution of decomposition, and call a continuation to</a>
      <a id="15639" class="Comment">-- perform any outstanding searches.</a>
      <a id="15682" href="Meta.HLevel.Reflection.html#15682" class="Function">gen-args</a>
        <a id="15699" class="Symbol">:</a> <a id="15701" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>              <a id="15719" class="Comment">-- ^ Are there any alternatives after this one?</a>
        <a id="15775" class="Symbol">→</a> <a id="15777" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>              <a id="15795" class="Comment">-- ^ What level are we searching for?</a>

        <a id="15842" class="Symbol">→</a> <a id="15844" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>              <a id="15862" class="Comment">-- ^ Name of the lemma,</a>
        <a id="15894" class="Symbol">→</a> <a id="15896" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15901" href="Meta.HLevel.Reflection.html#2924" class="Datatype">Arg-spec</a>     <a id="15914" class="Comment">-- ^ and the arguments we should invent.</a>

        <a id="15964" class="Symbol">→</a> <a id="15966" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15971" class="Symbol">(</a><a id="15972" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="15976" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15980" class="Symbol">)</a>
        <a id="15990" class="Comment">-- ^ Accumulator: computed arguments (criminally, in reverse</a>
        <a id="16059" class="Comment">-- order)</a>
        <a id="16077" class="Symbol">→</a> <a id="16079" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="16082" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
          <a id="16094" class="Comment">-- ^ Accumulator/continuation: what do we need to do after</a>
          <a id="16163" class="Comment">-- unifying the goal with the lemma?. This is both</a>
          <a id="16224" class="Comment">-- continuation (it can be used to run something after the</a>
          <a id="16293" class="Comment">-- arguments are built) and accumulator (searching recursively</a>
          <a id="16366" class="Comment">-- is done last).</a>
        <a id="16392" class="Symbol">→</a> <a id="16394" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="16397" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>              <a id="16412" class="Comment">-- ^ Returns nada</a>
      <a id="16436" href="Meta.HLevel.Reflection.html#15682" class="Function">gen-args</a> <a id="16445" href="Meta.HLevel.Reflection.html#16445" class="Bound">has-alts</a> <a id="16454" href="Meta.HLevel.Reflection.html#16454" class="Bound">level</a> <a id="16460" href="Meta.HLevel.Reflection.html#16460" class="Bound">defn</a> <a id="16465" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="16468" href="Meta.HLevel.Reflection.html#16468" class="Bound">accum</a> <a id="16474" href="Meta.HLevel.Reflection.html#16474" class="Bound">cont</a> <a id="16479" class="Symbol">=</a> <a id="16481" class="Keyword">do</a>
        <a id="16492" class="Comment">-- If we have no arguments to generate, then we can go ahead and</a>
        <a id="16565" class="Comment">-- use the accumulator as-is.</a>
        <a id="16603" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="16609" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a> <a id="16614" class="Symbol">(</a><a id="16615" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16619" href="Meta.HLevel.Reflection.html#16460" class="Bound">defn</a> <a id="16624" class="Symbol">(</a><a id="16625" href="Data.List.Base.html#972" class="Function">reverse-fast</a> <a id="16638" href="Meta.HLevel.Reflection.html#16468" class="Bound">accum</a><a id="16643" class="Symbol">))</a>
        <a id="16654" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="16665" class="String">&quot;tactic.hlevel&quot;</a> <a id="16681" class="Number">10</a> <a id="16684" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="16696" class="String">&quot;Committed to solution: &quot;</a> <a id="16722" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16724" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="16732" class="Symbol">(</a><a id="16733" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16737" href="Meta.HLevel.Reflection.html#16460" class="Bound">defn</a> <a id="16742" class="Symbol">(</a><a id="16743" href="Data.List.Base.html#883" class="Function">reverse</a> <a id="16751" href="Meta.HLevel.Reflection.html#16468" class="Bound">accum</a><a id="16756" class="Symbol">))</a> <a id="16759" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16761" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="16772" href="Meta.HLevel.Reflection.html#16474" class="Bound">cont</a>

      <a id="16784" href="Meta.HLevel.Reflection.html#15682" class="Function">gen-args</a> <a id="16793" href="Meta.HLevel.Reflection.html#16793" class="Bound">has-alts</a> <a id="16802" href="Meta.HLevel.Reflection.html#16802" class="Bound">level</a> <a id="16808" href="Meta.HLevel.Reflection.html#16808" class="Bound">defn</a> <a id="16813" class="Symbol">(</a><a id="16814" href="Meta.HLevel.Reflection.html#16814" class="Bound">x</a> <a id="16816" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16818" href="Meta.HLevel.Reflection.html#16818" class="Bound">args</a><a id="16822" class="Symbol">)</a> <a id="16824" href="Meta.HLevel.Reflection.html#16824" class="Bound">accum</a> <a id="16830" href="Meta.HLevel.Reflection.html#16830" class="Bound">cont</a> <a id="16835" class="Keyword">with</a> <a id="16840" href="Meta.HLevel.Reflection.html#16814" class="Bound">x</a>
      <a id="16848" class="Comment">-- If we got asked for the level without an adjustment (i.e. monus</a>
      <a id="16921" class="Comment">-- by zero), then we may as well not bother *trying* to adjust it.</a>
      <a id="16994" class="Comment">-- Saves a bit of computation.</a>
      <a id="17031" class="Symbol">...</a> <a id="17035" class="Symbol">|</a> <a id="17037" href="Meta.HLevel.Reflection.html#2948" class="InductiveConstructor">`level-minus</a> <a id="17050" class="Number">0</a> <a id="17052" class="Symbol">=</a> <a id="17054" href="Meta.HLevel.Reflection.html#15682" class="Function">gen-args</a> <a id="17063" class="Bound">has-alts</a> <a id="17072" class="Bound">level</a> <a id="17078" class="Bound">defn</a> <a id="17083" class="Bound">args</a> <a id="17088" class="Symbol">(</a><a id="17089" class="Bound">level</a> <a id="17095" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="17098" class="Bound">accum</a><a id="17103" class="Symbol">)</a> <a id="17105" class="Bound">cont</a>
      <a id="17116" class="Comment">-- If we have to insert the level minus some offset, then we need</a>
      <a id="17188" class="Comment">-- to do the computation:</a>
      <a id="17220" class="Symbol">...</a> <a id="17224" class="Symbol">|</a> <a id="17226" href="Meta.HLevel.Reflection.html#2948" class="InductiveConstructor">`level-minus</a> <a id="17239" href="Meta.HLevel.Reflection.html#17239" class="Bound">n</a><a id="17240" class="Symbol">@(</a><a id="17242" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17246" class="Symbol">_)</a> <a id="17249" class="Symbol">=</a>
        <a id="17259" class="Keyword">do</a>
          <a id="17272" href="Meta.HLevel.Reflection.html#17272" class="Bound">level</a> <a id="17278" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="17280" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="17290" class="Bound">level</a>
          <a id="17306" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="17317" class="String">&quot;tactic.hlevel&quot;</a> <a id="17333" class="Number">10</a> <a id="17336" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="17350" class="String">&quot;Hint demands offset, performing symbolic monus, subtracting from\n  &quot;</a> <a id="17421" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17423" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="17431" href="Meta.HLevel.Reflection.html#17272" class="Bound">level</a> <a id="17437" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17439" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="17452" href="Meta.HLevel.Reflection.html#17452" class="Bound">level′′</a> <a id="17460" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="17462" href="Meta.HLevel.Reflection.html#18047" class="Function">monus</a> <a id="17468" href="Meta.HLevel.Reflection.html#17272" class="Bound">level</a> <a id="17474" href="Meta.HLevel.Reflection.html#17239" class="Bound">n</a>
          <a id="17486" class="Comment">-- Reduce otherwise we get Number.fromNat as the term</a>
          <a id="17550" href="Meta.HLevel.Reflection.html#15682" class="Function">gen-args</a> <a id="17559" class="Bound">has-alts</a> <a id="17568" href="Meta.HLevel.Reflection.html#17272" class="Bound">level</a> <a id="17574" class="Bound">defn</a> <a id="17579" class="Bound">args</a> <a id="17584" class="Symbol">(</a><a id="17585" href="Meta.HLevel.Reflection.html#17452" class="Bound">level′′</a> <a id="17593" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="17596" class="Bound">accum</a><a id="17601" class="Symbol">)</a> <a id="17603" class="Bound">cont</a>
        <a id="17616" class="Keyword">where</a>
          <a id="17632" class="Comment">-- A &#39;symbolic&#39; monus function. If we&#39;re looking at an actual</a>
          <a id="17704" class="Comment">-- number, then we can just do the computation in TC, but</a>
          <a id="17772" class="Comment">-- otherwise we have to reimplement the builtin subtraction,</a>
          <a id="17843" class="Comment">-- where the minuend is a *term* rather than a number. In</a>
          <a id="17911" class="Comment">-- addition to being a bad operation (monus, grr), it&#39;s</a>
          <a id="17977" class="Comment">-- *partial*. We can end up backtracking while subtracting.</a>
          <a id="18047" href="Meta.HLevel.Reflection.html#18047" class="Function">monus</a> <a id="18053" class="Symbol">:</a> <a id="18055" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="18060" class="Symbol">→</a> <a id="18062" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="18064" class="Symbol">→</a> <a id="18066" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="18069" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
          <a id="18084" href="Meta.HLevel.Reflection.html#18047" class="Function">monus</a> <a id="18090" class="Symbol">(</a><a id="18091" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="18095" class="Symbol">(</a><a id="18096" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18100" href="Meta.HLevel.Reflection.html#18100" class="Bound">n</a><a id="18101" class="Symbol">))</a> <a id="18104" href="Meta.HLevel.Reflection.html#18104" class="Bound">k</a> <a id="18106" class="Symbol">=</a> <a id="18108" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18113" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="18115" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="18119" class="Symbol">(</a><a id="18120" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18124" class="Symbol">(</a><a id="18125" href="Meta.HLevel.Reflection.html#18100" class="Bound">n</a> <a id="18127" href="Agda.Builtin.Nat.html#426" class="Primitive Operator">-</a> <a id="18129" href="Meta.HLevel.Reflection.html#18104" class="Bound">k</a><a id="18130" class="Symbol">))</a>
          <a id="18143" href="Meta.HLevel.Reflection.html#18047" class="CatchallClause Function">monus</a><a id="18148" class="CatchallClause"> </a><a id="18149" href="Meta.HLevel.Reflection.html#18149" class="CatchallClause Bound">tm</a><a id="18151" class="CatchallClause"> </a><a id="18152" href="Agda.Builtin.Nat.html#221" class="CatchallClause InductiveConstructor">zero</a> <a id="18157" class="Symbol">=</a> <a id="18159" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18164" href="Meta.HLevel.Reflection.html#18149" class="Bound">tm</a>
          <a id="18177" href="Meta.HLevel.Reflection.html#18047" class="Function">monus</a> <a id="18183" href="Meta.HLevel.Reflection.html#18183" class="Bound">thezero</a><a id="18190" class="Symbol">@(</a><a id="18192" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18196" class="Symbol">(</a><a id="18197" class="Keyword">quote</a> <a id="18203" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="18207" class="Symbol">)</a> <a id="18209" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18211" class="Symbol">)</a> <a id="18213" class="Symbol">(</a><a id="18214" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18218" href="Meta.HLevel.Reflection.html#18218" class="Bound">it</a><a id="18220" class="Symbol">)</a> <a id="18222" class="Symbol">=</a> <a id="18224" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18229" href="Meta.HLevel.Reflection.html#18183" class="Bound">thezero</a>
          <a id="18247" href="Meta.HLevel.Reflection.html#18047" class="Function">monus</a> <a id="18253" class="Symbol">(</a><a id="18254" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18258" class="Symbol">(</a><a id="18259" class="Keyword">quote</a> <a id="18265" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="18268" class="Symbol">)</a> <a id="18270" class="Symbol">(</a><a id="18271" href="Meta.HLevel.Reflection.html#18271" class="Bound">x</a> <a id="18273" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="18276" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18278" class="Symbol">))</a> <a id="18281" class="Symbol">(</a><a id="18282" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18286" href="Meta.HLevel.Reflection.html#18286" class="Bound">it</a><a id="18288" class="Symbol">)</a> <a id="18290" class="Symbol">=</a> <a id="18292" class="Keyword">do</a>
            <a id="18307" href="Meta.HLevel.Reflection.html#18307" class="Bound">x</a> <a id="18309" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="18311" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="18318" href="Meta.HLevel.Reflection.html#18271" class="Bound">x</a>
            <a id="18332" href="Meta.HLevel.Reflection.html#18047" class="Function">monus</a> <a id="18338" href="Meta.HLevel.Reflection.html#18307" class="Bound">x</a> <a id="18340" href="Meta.HLevel.Reflection.html#18286" class="Bound">it</a>
          <a id="18353" href="Meta.HLevel.Reflection.html#18047" class="CatchallClause Function">monus</a><a id="18358" class="CatchallClause"> </a><a id="18359" href="Meta.HLevel.Reflection.html#18359" class="CatchallClause Bound">tm</a><a id="18361" class="CatchallClause"> </a><a id="18362" class="CatchallClause Symbol">(</a><a id="18363" href="Agda.Builtin.Nat.html#234" class="CatchallClause InductiveConstructor">suc</a><a id="18366" class="CatchallClause"> </a><a id="18367" href="Meta.HLevel.Reflection.html#18367" class="CatchallClause Bound">it</a><a id="18369" class="CatchallClause Symbol">)</a> <a id="18371" class="Symbol">=</a> <a id="18373" class="Keyword">do</a>
            <a id="18388" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="18399" class="String">&quot;tactic.hlevel&quot;</a> <a id="18415" class="Number">10</a> <a id="18418" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="18420" class="String">&quot;Dunno how to take 1 from &quot;</a> <a id="18448" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18450" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="18458" href="Meta.HLevel.Reflection.html#18359" class="Bound">tm</a> <a id="18461" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18463" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
            <a id="18478" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="18488" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="18498" class="Comment">-- Insert a metavariable, to be solved by Agda. It&#39;d be sad if the</a>
      <a id="18571" class="Comment">-- macro handled everything!</a>
      <a id="18606" class="Symbol">...</a> <a id="18610" class="Symbol">|</a> <a id="18612" href="Meta.HLevel.Reflection.html#3351" class="InductiveConstructor">`meta</a> <a id="18618" class="Symbol">=</a> <a id="18620" href="Meta.HLevel.Reflection.html#15682" class="Function">gen-args</a> <a id="18629" class="Bound">has-alts</a> <a id="18638" class="Bound">level</a> <a id="18644" class="Bound">defn</a> <a id="18649" class="Bound">args</a> <a id="18654" class="Symbol">(</a><a id="18655" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="18663" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="18666" class="Bound">accum</a><a id="18671" class="Symbol">)</a> <a id="18673" class="Bound">cont</a>

      <a id="18685" class="Symbol">...</a> <a id="18689" class="Symbol">|</a> <a id="18691" href="Meta.HLevel.Reflection.html#3148" class="InductiveConstructor">`search-under</a> <a id="18705" href="Meta.HLevel.Reflection.html#18705" class="Bound">under</a> <a id="18711" class="Symbol">=</a> <a id="18713" class="Keyword">do</a>
        <a id="18724" class="Comment">-- To search under some variables, we work in a scope extended</a>
        <a id="18795" class="Comment">-- by &#39;under&#39;-many variables. The metavariable lives in that</a>
        <a id="18864" class="Comment">-- scope, so we have to quantify over the variables we</a>
        <a id="18927" class="Comment">-- introduced to use it outside, i.e., in the actual (outer)</a>
        <a id="18996" class="Comment">-- search problem.</a>
        <a id="19023" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19034" class="String">&quot;tactic.hlevel&quot;</a> <a id="19050" class="Number">10</a> <a id="19053" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19055" class="String">&quot;Going under &quot;</a> <a id="19070" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19072" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="19080" class="Symbol">(</a><a id="19081" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="19085" class="Symbol">(</a><a id="19086" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="19090" href="Meta.HLevel.Reflection.html#18705" class="Bound">under</a><a id="19095" class="Symbol">))</a> <a id="19098" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19100" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="19111" href="Meta.HLevel.Reflection.html#19111" class="Bound">gounder</a> <a id="19119" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="19121" href="Meta.HLevel.Reflection.html#15147" class="Function">extend-n</a> <a id="19130" href="Meta.HLevel.Reflection.html#18705" class="Bound">under</a>
        <a id="19144" href="Meta.HLevel.Reflection.html#19144" class="Bound">mv</a> <a id="19147" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="19149" href="Meta.HLevel.Reflection.html#19111" class="Bound">gounder</a> <a id="19157" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19162" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19164" class="Keyword">do</a>
          <a id="19177" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19188" class="String">&quot;tactic.hlevel&quot;</a> <a id="19204" class="Number">10</a> <a id="19207" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19209" class="String">&quot;In extended context&quot;</a>
          <a id="19241" href="Meta.Reflection.html#1925" class="Function">new-meta</a> <a id="19250" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="19266" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19277" class="String">&quot;tactic.hlevel&quot;</a> <a id="19293" class="Number">10</a> <a id="19296" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19298" class="String">&quot;Metavariable: &quot;</a> <a id="19315" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19317" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="19325" class="Symbol">(</a><a id="19326" href="Meta.HLevel.Reflection.html#14907" class="Function">wrap-lams</a> <a id="19336" href="Meta.HLevel.Reflection.html#18705" class="Bound">under</a> <a id="19342" href="Meta.HLevel.Reflection.html#19144" class="Bound">mv</a><a id="19344" class="Symbol">)</a> <a id="19346" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19348" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="19359" class="Comment">-- After we&#39;ve put the mv wrapped under some lambdas in the</a>
        <a id="19427" class="Comment">-- argument list,</a>
        <a id="19453" href="Meta.HLevel.Reflection.html#15682" class="Function">gen-args</a> <a id="19462" class="Bound">has-alts</a> <a id="19471" class="Bound">level</a> <a id="19477" class="Bound">defn</a> <a id="19482" class="Bound">args</a> <a id="19487" class="Symbol">(</a><a id="19488" href="Meta.HLevel.Reflection.html#14907" class="Function">wrap-lams</a> <a id="19498" href="Meta.HLevel.Reflection.html#18705" class="Bound">under</a> <a id="19504" href="Meta.HLevel.Reflection.html#19144" class="Bound">mv</a> <a id="19507" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="19510" class="Bound">accum</a><a id="19515" class="Symbol">)</a> <a id="19517" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19519" class="Keyword">do</a>
          <a id="19532" class="Comment">-- On our way back up, we do any more searching that needed to</a>
          <a id="19605" class="Comment">-- get done, and..</a>
          <a id="19634" class="Bound">cont</a>
          <a id="19649" class="Comment">-- go back under the new scope to recursively search for</a>
          <a id="19716" class="Comment">-- levels.</a>
          <a id="19737" href="Meta.HLevel.Reflection.html#19111" class="Bound">gounder</a> <a id="19745" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="19747" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19749" href="Meta.HLevel.Reflection.html#12644" class="Function">search</a> <a id="19756" class="Bound">has-alts</a> <a id="19765" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="19773" href="Meta.HLevel.Reflection.html#12930" class="Bound">n</a> <a id="19775" href="Meta.HLevel.Reflection.html#19144" class="Bound">mv</a>

      <a id="19785" class="Comment">-- Try all the candidate hints in order. This is a version of</a>
      <a id="19853" class="Comment">-- &#39;nondet&#39; which additionally threads whether we&#39;re looking at</a>
      <a id="19923" class="Comment">-- last alternative.</a>
      <a id="19950" href="Meta.HLevel.Reflection.html#19950" class="Function">use-decomp-hints</a> <a id="19967" class="Symbol">:</a> <a id="19969" class="Symbol">(</a><a id="19970" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19975" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="19977" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="19981" class="Symbol">)</a> <a id="19983" class="Symbol">→</a> <a id="19985" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19990" class="Symbol">→</a> <a id="19992" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="19997" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="20002" class="Symbol">→</a> <a id="20004" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="20007" class="Symbol">(</a><a id="20008" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="20010" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="20012" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="20016" class="Symbol">)</a>
      <a id="20024" href="Meta.HLevel.Reflection.html#19950" class="Function">use-decomp-hints</a> <a id="20041" class="Symbol">(</a><a id="20042" href="Meta.HLevel.Reflection.html#20042" class="Bound">lv</a> <a id="20045" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="20047" href="Meta.HLevel.Reflection.html#20047" class="Bound">goal-ty</a><a id="20054" class="Symbol">)</a> <a id="20056" href="Meta.HLevel.Reflection.html#20056" class="Bound">solved</a> <a id="20063" class="Symbol">(</a><a id="20064" href="Meta.HLevel.Reflection.html#20064" class="Bound">c1</a> <a id="20067" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20069" href="Meta.HLevel.Reflection.html#20069" class="Bound">cs</a><a id="20071" class="Symbol">)</a> <a id="20073" class="Symbol">=</a> <a id="20075" class="Keyword">do</a>
        <a id="20086" href="Meta.HLevel.Reflection.html#20086" class="Bound">ty</a> <a id="20089" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20091" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="20101" href="Meta.HLevel.Reflection.html#20064" class="Bound">c1</a>
        <a id="20112" href="Meta.HLevel.Reflection.html#20112" class="Bound">c1′</a> <a id="20116" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20118" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="20125" href="Meta.HLevel.Reflection.html#20064" class="Bound">c1</a>
        <a id="20136" class="Symbol">(</a><a id="20137" href="Meta.HLevel.Reflection.html#14445" class="Function">remove-invisible</a> <a id="20154" href="Meta.HLevel.Reflection.html#20112" class="Bound">c1′</a> <a id="20158" href="Meta.HLevel.Reflection.html#20086" class="Bound">ty</a> <a id="20161" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="20165" class="Symbol">λ</a> <a id="20167" class="Keyword">where</a>

          <a id="20184" class="Comment">-- If we have an actual decomp constructor, then we can try</a>
          <a id="20254" class="Comment">-- using its argument specification to construct a little</a>
          <a id="20322" class="Comment">-- h-level lemma</a>
          <a id="20349" class="Symbol">(</a><a id="20350" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="20354" class="Symbol">(</a><a id="20355" class="Keyword">quote</a> <a id="20361" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a><a id="20367" class="Symbol">)</a> <a id="20369" class="Symbol">(_</a> <a id="20372" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20374" class="Symbol">_</a> <a id="20376" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20378" href="Meta.HLevel.Reflection.html#20378" class="Bound">nm</a> <a id="20381" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="20384" href="Meta.HLevel.Reflection.html#20384" class="Bound">argspec</a> <a id="20392" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="20395" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20397" class="Symbol">))</a> <a id="20400" class="Symbol">→</a> <a id="20402" class="Keyword">do</a>
            <a id="20417" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="20428" class="String">&quot;tactic.hlevel&quot;</a> <a id="20444" class="Number">10</a> <a id="20447" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
              <a id="20463" class="String">&quot;Using &quot;</a> <a id="20472" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20474" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20482" href="Meta.HLevel.Reflection.html#20378" class="Bound">nm</a> <a id="20485" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20487" class="String">&quot; decomposition for:\n  &quot;</a>
              <a id="20527" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20529" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20537" class="Symbol">(</a><a id="20538" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="20542" class="Symbol">(</a><a id="20543" class="Keyword">quote</a> <a id="20549" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a><a id="20561" class="Symbol">)</a> <a id="20563" class="Symbol">(</a><a id="20564" href="Meta.HLevel.Reflection.html#20042" class="Bound">lv</a> <a id="20567" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="20570" href="Meta.HLevel.Reflection.html#20047" class="Bound">goal-ty</a> <a id="20578" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="20581" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20583" class="Symbol">))</a> <a id="20586" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20588" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

            <a id="20604" href="Meta.HLevel.Reflection.html#20604" class="Bound">nm′</a> <a id="20608" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20610" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20620" href="Meta.HLevel.Reflection.html#20378" class="Bound">nm</a>
            <a id="20635" href="Meta.HLevel.Reflection.html#20635" class="Bound">argsp</a> <a id="20641" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20643" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20653" href="Meta.HLevel.Reflection.html#20384" class="Bound">argspec</a>
            <a id="20673" class="Comment">-- Generate the argument spine, and discard the instance</a>
            <a id="20742" class="Comment">-- search meta.</a>
            <a id="20770" href="Meta.HLevel.Reflection.html#15682" class="Function">gen-args</a> <a id="20779" class="Symbol">(</a><a id="20780" href="Data.Bool.Base.html#169" class="Function">not</a> <a id="20784" class="Symbol">(</a><a id="20785" href="Data.List.Operations.html#440" class="Function">length</a> <a id="20792" href="Meta.HLevel.Reflection.html#20069" class="Bound">cs</a> <a id="20795" href="Agda.Builtin.Nat.html#631" class="Primitive Operator">==</a> <a id="20798" class="Number">0</a><a id="20799" class="Symbol">))</a> <a id="20802" href="Meta.HLevel.Reflection.html#20042" class="Bound">lv</a> <a id="20805" href="Meta.HLevel.Reflection.html#20604" class="Bound">nm′</a> <a id="20809" href="Meta.HLevel.Reflection.html#20635" class="Bound">argsp</a> <a id="20815" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="20818" class="Symbol">(</a><a id="20819" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="20828" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="20830" class="Symbol">)</a>
            <a id="20844" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="20850" href="Meta.HLevel.Reflection.html#20056" class="Bound">solved</a> <a id="20857" href="Meta.HLevel.Reflection.html#20064" class="Bound">c1</a>

            <a id="20873" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="20878" class="Symbol">(</a><a id="20879" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="20882" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="20884" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="20888" class="Symbol">)</a>

          <a id="20901" class="Comment">-- It&#39;s possible that this particular hint was a bust, i.e.</a>
          <a id="20971" class="Comment">-- because someone wasn&#39;t being careful with what</a>
          <a id="21031" class="Comment">-- hlevel-decomposition instances they&#39;ve defined. That&#39;s no</a>
          <a id="21102" class="Comment">-- matter: we can just ignore it.</a>
          <a id="21146" class="CatchallClause Symbol">_</a> <a id="21148" class="Symbol">→</a> <a id="21150" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="21160" class="String">&quot;Non-canonical hint&quot;</a><a id="21180" class="Symbol">)</a>
          <a id="21192" class="Comment">-- If we didn&#39;t manage to get the hint to work, for any</a>
          <a id="21258" class="Comment">-- reason, try again with the rest of the hints.</a>
          <a id="21317" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="21321" href="Meta.HLevel.Reflection.html#19950" class="Function">use-decomp-hints</a> <a id="21338" class="Symbol">(</a><a id="21339" href="Meta.HLevel.Reflection.html#20042" class="Bound">lv</a> <a id="21342" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21344" href="Meta.HLevel.Reflection.html#20047" class="Bound">goal-ty</a><a id="21351" class="Symbol">)</a> <a id="21353" href="Meta.HLevel.Reflection.html#20056" class="Bound">solved</a> <a id="21360" href="Meta.HLevel.Reflection.html#20069" class="Bound">cs</a>

      <a id="21370" href="Meta.HLevel.Reflection.html#19950" class="Function">use-decomp-hints</a> <a id="21387" class="Symbol">(_</a> <a id="21390" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21392" href="Meta.HLevel.Reflection.html#21392" class="Bound">goal-ty</a><a id="21399" class="Symbol">)</a> <a id="21401" class="Symbol">_</a> <a id="21403" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="21406" class="Symbol">=</a>
        <a id="21416" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="21426" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="21428" class="String">&quot;Ran out of decomposition hints for &quot;</a> <a id="21466" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21468" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="21476" href="Meta.HLevel.Reflection.html#21392" class="Bound">goal-ty</a> <a id="21484" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21486" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="21496" class="Comment">-- Using the hints involving querying Agda for potential</a>
      <a id="21559" class="Comment">-- instances, then trying each in order.</a>
      <a id="21606" href="Meta.HLevel.Reflection.html#21606" class="Function">use-hints</a> <a id="21616" class="Symbol">:</a> <a id="21618" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="21621" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="21629" href="Meta.HLevel.Reflection.html#21606" class="Function">use-hints</a> <a id="21639" class="Symbol">=</a> <a id="21641" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="21656" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="21658" class="Keyword">do</a>
        <a id="21669" class="Symbol">(</a><a id="21670" href="Meta.HLevel.Reflection.html#21670" class="Bound">lv</a> <a id="21673" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21675" href="Meta.HLevel.Reflection.html#21675" class="Bound">ty</a><a id="21677" class="Symbol">)</a> <a id="21679" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="21681" href="Meta.HLevel.Reflection.html#6489" class="Function">decompose-is-hlevel</a> <a id="21701" href="Meta.HLevel.Reflection.html#12933" class="Bound">goal</a>

        <a id="21715" class="Comment">-- Note that if the type here is a metavariable, the tactic is..</a>
        <a id="21788" class="Comment">-- loopy.</a>
        <a id="21806" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="21811" href="Meta.HLevel.Reflection.html#21675" class="Bound">ty</a> <a id="21814" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="21818" class="Symbol">λ</a> <a id="21820" class="Keyword">where</a>
          <a id="21836" class="Symbol">(</a><a id="21837" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="21842" href="Meta.HLevel.Reflection.html#21842" class="Bound">m</a> <a id="21844" class="Symbol">_)</a> <a id="21847" class="Symbol">→</a> <a id="21849" class="Keyword">do</a>
            <a id="21864" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="21875" class="String">&quot;tactic.hlevel&quot;</a> <a id="21891" class="Number">10</a>
              <a id="21908" class="String">&quot;Type under is-hlevel is metavariable, blocking to avoid infinite loop&quot;</a>
            <a id="21992" href="Agda.Builtin.Reflection.html#9468" class="Postulate">blockOnMeta</a> <a id="22004" href="Meta.HLevel.Reflection.html#21842" class="Bound">m</a>
          <a id="22016" class="CatchallClause Symbol">_</a> <a id="22018" class="Symbol">→</a> <a id="22020" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="22025" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>

        <a id="22037" class="Comment">-- Create a meta of type hlevel-decomposition to find any possible hints..</a>
        <a id="22120" href="Meta.HLevel.Reflection.html#22120" class="Bound">solved</a><a id="22126" class="Symbol">@(</a><a id="22128" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="22133" href="Meta.HLevel.Reflection.html#22133" class="Bound">mv</a> <a id="22136" class="Symbol">_)</a> <a id="22139" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22141" href="Meta.Reflection.html#1925" class="Function">new-meta</a> <a id="22150" class="Symbol">(</a><a id="22151" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="22155" class="Symbol">(</a><a id="22156" class="Keyword">quote</a> <a id="22162" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a><a id="22182" class="Symbol">)</a> <a id="22184" class="Symbol">(</a><a id="22185" href="Meta.HLevel.Reflection.html#21675" class="Bound">ty</a> <a id="22188" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="22191" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22193" class="Symbol">))</a>
          <a id="22206" class="Keyword">where</a> <a id="22212" class="CatchallClause Symbol">_</a> <a id="22214" class="Symbol">→</a> <a id="22216" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="22226" class="Symbol">(</a><a id="22227" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22235" href="Meta.HLevel.Reflection.html#21675" class="Bound">ty</a> <a id="22238" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22240" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22242" class="Symbol">)</a>
        <a id="22252" href="Meta.HLevel.Reflection.html#22252" class="Bound">instances</a> <a id="22262" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22264" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="22277" href="Meta.HLevel.Reflection.html#22133" class="Bound">mv</a>

        <a id="22289" href="Meta.HLevel.Reflection.html#22289" class="Bound">t</a> <a id="22291" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22293" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="22301" href="Meta.HLevel.Reflection.html#22252" class="Bound">instances</a>
        <a id="22319" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="22330" class="String">&quot;tactic.hlevel&quot;</a> <a id="22346" class="Number">10</a> <a id="22349" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="22361" class="String">&quot;Finding decompositions for\n&quot;</a> <a id="22392" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22404" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22412" href="Meta.HLevel.Reflection.html#21675" class="Bound">ty</a> <a id="22415" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22427" class="String">&quot;\nFound candidates\n &quot;</a> <a id="22451" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22463" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22471" href="Meta.HLevel.Reflection.html#22289" class="Bound">t</a> <a id="22473" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22475" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="22487" class="Comment">-- And try using the hints.</a>
        <a id="22523" href="Meta.HLevel.Reflection.html#19950" class="Function">use-decomp-hints</a> <a id="22540" class="Symbol">(</a><a id="22541" href="Meta.HLevel.Reflection.html#21670" class="Bound">lv</a> <a id="22544" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22546" href="Meta.HLevel.Reflection.html#21675" class="Bound">ty</a><a id="22548" class="Symbol">)</a> <a id="22550" href="Meta.HLevel.Reflection.html#22120" class="Bound">solved</a> <a id="22557" href="Meta.HLevel.Reflection.html#22252" class="Bound">instances</a>

  <a id="22570" class="Comment">-- At the top-level, our goal doesn&#39;t need to have literally the type</a>
  <a id="22642" class="Comment">-- is-hlevel A n. It can be under any number of Πs, both implicit and</a>
  <a id="22714" class="Comment">-- explicit. This means that a goal like (∀ x → is-hlevel T n) can be</a>
  <a id="22786" class="Comment">-- solved using just hlevel!, rather than λ _ → hlevel!. Of course,</a>
  <a id="22856" class="Comment">-- the effect is the same.</a>
  <a id="decompose-is-hlevel-top"></a><a id="22885" href="Meta.HLevel.Reflection.html#22885" class="Function">decompose-is-hlevel-top</a>
    <a id="22913" class="Symbol">:</a> <a id="22915" class="Symbol">∀</a> <a id="22917" class="Symbol">{</a><a id="22918" href="Meta.HLevel.Reflection.html#22918" class="Bound">ℓ</a><a id="22919" class="Symbol">}</a> <a id="22921" class="Symbol">{</a><a id="22922" href="Meta.HLevel.Reflection.html#22922" class="Bound">A</a> <a id="22924" class="Symbol">:</a> <a id="22926" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="22931" href="Meta.HLevel.Reflection.html#22918" class="Bound">ℓ</a><a id="22932" class="Symbol">}</a>
    <a id="22938" class="Symbol">→</a> <a id="22940" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22945" class="Symbol">→</a> <a id="22947" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22950" class="Symbol">(</a><a id="22951" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22956" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22958" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22963" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22965" class="Symbol">(</a><a id="22966" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22969" href="Meta.HLevel.Reflection.html#22922" class="Bound">A</a> <a id="22971" class="Symbol">→</a> <a id="22973" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22976" href="Meta.HLevel.Reflection.html#22922" class="Bound">A</a><a id="22977" class="Symbol">)</a> <a id="22979" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22981" class="Symbol">(</a><a id="22982" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22987" class="Symbol">→</a> <a id="22989" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="22993" class="Symbol">))</a>
  <a id="22998" href="Meta.HLevel.Reflection.html#22885" class="Function">decompose-is-hlevel-top</a> <a id="23022" href="Meta.HLevel.Reflection.html#23022" class="Bound">goal</a> <a id="23027" class="Symbol">=</a>
    <a id="23033" class="Keyword">do</a>
      <a id="23042" href="Meta.HLevel.Reflection.html#23042" class="Bound">ty</a> <a id="23045" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23047" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="23062" class="Symbol">(</a><a id="23063" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="23069" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23071" href="Meta.HLevel.Reflection.html#5926" class="Function">atoms</a><a id="23076" class="Symbol">)</a> <a id="23078" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
        <a id="23088" class="Symbol">(</a><a id="23089" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="23099" href="Meta.HLevel.Reflection.html#23022" class="Bound">goal</a> <a id="23104" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23108" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="23114" class="Symbol">)</a> <a id="23116" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23120" href="Meta.Reflection.html#5447" class="Function">wait-just-a-bit</a>
      <a id="23142" href="Meta.HLevel.Reflection.html#23164" class="Function">go</a> <a id="23145" href="Meta.HLevel.Reflection.html#23042" class="Bound">ty</a>
    <a id="23152" class="Keyword">where</a>
      <a id="23164" href="Meta.HLevel.Reflection.html#23164" class="Function">go</a> <a id="23167" class="Symbol">:</a> <a id="23169" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23174" class="Symbol">→</a> <a id="23176" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23179" class="Symbol">_</a>
      <a id="23187" href="Meta.HLevel.Reflection.html#23164" class="Function">go</a> <a id="23190" class="Symbol">(</a><a id="23191" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="23194" class="Symbol">(</a><a id="23195" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23199" href="Meta.HLevel.Reflection.html#23199" class="Bound">as</a> <a id="23202" href="Meta.HLevel.Reflection.html#23202" class="Bound">at</a><a id="23204" class="Symbol">)</a> <a id="23206" class="Symbol">(</a><a id="23207" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23211" href="Meta.HLevel.Reflection.html#23211" class="Bound">vn</a> <a id="23214" href="Meta.HLevel.Reflection.html#23214" class="Bound">cd</a><a id="23216" class="Symbol">))</a> <a id="23219" class="Symbol">=</a> <a id="23221" class="Keyword">do</a>
        <a id="23232" class="Symbol">(</a><a id="23233" href="Meta.HLevel.Reflection.html#23233" class="Bound">hlevel</a> <a id="23240" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23242" href="Meta.HLevel.Reflection.html#23242" class="Bound">inner</a> <a id="23248" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23250" href="Meta.HLevel.Reflection.html#23250" class="Bound">enter</a> <a id="23256" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23258" href="Meta.HLevel.Reflection.html#23258" class="Bound">leave</a><a id="23263" class="Symbol">)</a> <a id="23265" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23267" href="Meta.HLevel.Reflection.html#23164" class="Function">go</a> <a id="23270" href="Meta.HLevel.Reflection.html#23214" class="Bound">cd</a>
        <a id="23281" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23286" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23288" href="Meta.HLevel.Reflection.html#23233" class="Bound">hlevel</a> <a id="23295" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23297" href="Meta.HLevel.Reflection.html#23242" class="Bound">inner</a> <a id="23303" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23305" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="23319" href="Meta.HLevel.Reflection.html#23211" class="Bound">vn</a> <a id="23322" class="Symbol">(</a><a id="23323" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23327" href="Meta.HLevel.Reflection.html#23199" class="Bound">as</a> <a id="23330" href="Meta.HLevel.Reflection.html#23202" class="Bound">at</a><a id="23332" class="Symbol">)</a> <a id="23334" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23336" class="Symbol">λ</a> <a id="23338" href="Meta.HLevel.Reflection.html#23338" class="Bound">t</a> <a id="23340" class="Symbol">→</a> <a id="23342" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="23346" class="Symbol">(</a><a id="23347" href="Meta.Reflection.html#1281" class="Function">arg-vis</a> <a id="23355" href="Meta.HLevel.Reflection.html#23199" class="Bound">as</a><a id="23357" class="Symbol">)</a> <a id="23359" class="Symbol">(</a><a id="23360" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23364" href="Meta.HLevel.Reflection.html#23211" class="Bound">vn</a> <a id="23367" href="Meta.HLevel.Reflection.html#23338" class="Bound">t</a><a id="23368" class="Symbol">)</a>
      <a id="23376" href="Meta.HLevel.Reflection.html#23164" class="CatchallClause Function">go</a><a id="23378" class="CatchallClause"> </a><a id="23379" href="Meta.HLevel.Reflection.html#23379" class="CatchallClause Bound">tm</a> <a id="23382" class="Symbol">=</a> <a id="23384" class="Keyword">do</a>
        <a id="23395" class="Symbol">(</a><a id="23396" href="Meta.HLevel.Reflection.html#23396" class="Bound">hlevel</a> <a id="23403" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23405" href="Meta.HLevel.Reflection.html#23405" class="Bound">inner</a><a id="23410" class="Symbol">)</a> <a id="23412" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23414" href="Meta.HLevel.Reflection.html#6343" class="Function">decompose-is-hlevel′</a> <a id="23435" href="Meta.HLevel.Reflection.html#23379" class="Bound">tm</a>
        <a id="23446" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23451" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23453" href="Meta.HLevel.Reflection.html#23396" class="Bound">hlevel</a> <a id="23460" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23462" href="Meta.HLevel.Reflection.html#23405" class="Bound">inner</a> <a id="23468" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23470" class="Symbol">(λ</a> <a id="23473" href="Meta.HLevel.Reflection.html#23473" class="Bound">x</a> <a id="23475" class="Symbol">→</a> <a id="23477" href="Meta.HLevel.Reflection.html#23473" class="Bound">x</a><a id="23478" class="Symbol">)</a> <a id="23480" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23482" class="Symbol">(λ</a> <a id="23485" href="Meta.HLevel.Reflection.html#23485" class="Bound">x</a> <a id="23487" class="Symbol">→</a> <a id="23489" href="Meta.HLevel.Reflection.html#23485" class="Bound">x</a><a id="23490" class="Symbol">)</a>

<a id="23493" class="Comment">-- This is public so it&#39;s usable in tactic attributes. It decomposes the</a>
<a id="23566" class="Comment">-- top-level goal type and enters the search loop.</a>
<a id="hlevel-tactic-worker"></a><a id="23617" href="Meta.HLevel.Reflection.html#23617" class="Function">hlevel-tactic-worker</a> <a id="23638" class="Symbol">:</a> <a id="23640" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23645" class="Symbol">→</a> <a id="23647" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23650" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="23652" href="Meta.HLevel.Reflection.html#23617" class="Function">hlevel-tactic-worker</a> <a id="23673" href="Meta.HLevel.Reflection.html#23673" class="Bound">goal</a> <a id="23678" class="Symbol">=</a> <a id="23680" class="Keyword">do</a>
  <a id="23685" href="Meta.HLevel.Reflection.html#23685" class="Bound">ty</a> <a id="23688" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23690" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="23705" class="Symbol">(</a><a id="23706" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="23712" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23714" href="Meta.HLevel.Reflection.html#5926" class="Function">atoms</a><a id="23719" class="Symbol">)</a> <a id="23721" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23723" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="23733" href="Meta.HLevel.Reflection.html#23673" class="Bound">goal</a> <a id="23738" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23742" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
  <a id="23751" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="23762" class="String">&quot;tactic.hlevel&quot;</a> <a id="23778" class="Number">10</a> <a id="23781" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23783" class="String">&quot;Target type: &quot;</a> <a id="23799" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23801" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="23809" href="Meta.HLevel.Reflection.html#23685" class="Bound">ty</a> <a id="23812" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23814" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="23819" class="Symbol">(</a><a id="23820" href="Meta.HLevel.Reflection.html#23820" class="Bound">lv</a> <a id="23823" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23825" href="Meta.HLevel.Reflection.html#23825" class="Bound">ty</a> <a id="23828" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23830" href="Meta.HLevel.Reflection.html#23830" class="Bound">enter</a> <a id="23836" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23838" href="Meta.HLevel.Reflection.html#23838" class="Bound">leave</a><a id="23843" class="Symbol">)</a> <a id="23845" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23847" href="Meta.HLevel.Reflection.html#22885" class="Function">decompose-is-hlevel-top</a> <a id="23871" href="Meta.HLevel.Reflection.html#23673" class="Bound">goal</a> <a id="23876" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a>
    <a id="23884" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a>
      <a id="23900" class="Symbol">(</a> <a id="23902" class="String">&quot;Goal type is not of the form ``is-hlevel A n&#39;&#39;:\n&quot;</a>
      <a id="23960" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23962" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="23970" href="Meta.HLevel.Reflection.html#23685" class="Bound">ty</a>
      <a id="23979" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23981" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="23983" class="Symbol">)</a>

  <a id="23988" class="Comment">-- 10 units of fuel isn&#39;t too many but it&#39;s enough for any realistic</a>
  <a id="24059" class="Comment">-- use-case. Note the scope nonsense: we have to &#39;enter&#39; to get under</a>
  <a id="24131" class="Comment">-- the Πs (extend the scope with their argument types), then &#39;leave&#39;</a>
  <a id="24202" class="Comment">-- (wrap in lambdas) to get back out.</a>
  <a id="24242" href="Meta.HLevel.Reflection.html#24242" class="Bound">solved</a> <a id="24249" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="24251" href="Meta.HLevel.Reflection.html#23830" class="Bound">enter</a> <a id="24257" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="24259" class="Keyword">do</a>
    <a id="24266" href="Meta.HLevel.Reflection.html#24266" class="Bound">goal′</a> <a id="24272" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="24274" href="Meta.Reflection.html#1925" class="Function">new-meta</a> <a id="24283" class="Symbol">(</a><a id="24284" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="24288" class="Symbol">(</a><a id="24289" class="Keyword">quote</a> <a id="24295" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a><a id="24307" class="Symbol">)</a> <a id="24309" class="Symbol">(</a><a id="24310" href="Meta.HLevel.Reflection.html#23820" class="Bound">lv</a> <a id="24313" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="24316" href="Meta.HLevel.Reflection.html#23825" class="Bound">ty</a> <a id="24319" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="24322" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="24324" class="Symbol">))</a>
    <a id="24331" href="Meta.HLevel.Reflection.html#12644" class="Function">search</a> <a id="24338" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="24344" href="Meta.HLevel.Reflection.html#23820" class="Bound">lv</a> <a id="24347" class="Number">10</a> <a id="24350" href="Meta.HLevel.Reflection.html#24266" class="Bound">goal′</a>
    <a id="24360" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="24365" href="Meta.HLevel.Reflection.html#24266" class="Bound">goal′</a>
  <a id="24373" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="24379" href="Meta.HLevel.Reflection.html#23673" class="Bound">goal</a> <a id="24384" class="Symbol">(</a><a id="24385" href="Meta.HLevel.Reflection.html#23838" class="Bound">leave</a> <a id="24391" href="Meta.HLevel.Reflection.html#24242" class="Bound">solved</a><a id="24397" class="Symbol">)</a>

<a id="24400" class="Comment">-- Entry points to the macro</a>
<a id="24429" class="Comment">----------------------------</a>
<a id="24458" class="Keyword">macro</a> <a id="hlevel!"></a><a id="24464" href="Meta.HLevel.Reflection.html#24464" class="Function">hlevel!</a> <a id="24472" class="Symbol">=</a> <a id="24474" href="Meta.HLevel.Reflection.html#23617" class="Function">hlevel-tactic-worker</a>

<a id="24496" class="Keyword">private</a> <a id="24504" class="Keyword">variable</a>
  <a id="24515" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a> <a id="24517" href="Meta.HLevel.Reflection.html#24517" class="Generalizable">ℓ′</a> <a id="24520" href="Meta.HLevel.Reflection.html#24520" class="Generalizable">ℓa</a> <a id="24523" href="Meta.HLevel.Reflection.html#24523" class="Generalizable">ℓb</a> <a id="24526" href="Meta.HLevel.Reflection.html#24526" class="Generalizable">ℓc</a> <a id="24529" href="Meta.HLevel.Reflection.html#24529" class="Generalizable">ℓd</a> <a id="24532" class="Symbol">:</a> <a id="24534" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="24542" href="Meta.HLevel.Reflection.html#24542" class="Generalizable">T</a> <a id="24544" class="Symbol">:</a> <a id="24546" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24551" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a>
  <a id="24555" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="24557" class="Symbol">:</a> <a id="24559" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24564" href="Meta.HLevel.Reflection.html#24520" class="Generalizable">ℓa</a>
  <a id="24569" href="Meta.HLevel.Reflection.html#24569" class="Generalizable">B</a> <a id="24571" class="Symbol">:</a> <a id="24573" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="24575" class="Symbol">→</a> <a id="24577" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24582" href="Meta.HLevel.Reflection.html#24523" class="Generalizable">ℓb</a>
  <a id="24587" href="Meta.HLevel.Reflection.html#24587" class="Generalizable">C</a> <a id="24589" class="Symbol">:</a> <a id="24591" class="Symbol">(</a><a id="24592" href="Meta.HLevel.Reflection.html#24592" class="Bound">a</a> <a id="24594" class="Symbol">:</a> <a id="24596" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a><a id="24597" class="Symbol">)</a> <a id="24599" class="Symbol">(</a><a id="24600" href="Meta.HLevel.Reflection.html#24600" class="Bound">b</a> <a id="24602" class="Symbol">:</a> <a id="24604" href="Meta.HLevel.Reflection.html#24569" class="Generalizable">B</a> <a id="24606" href="Meta.HLevel.Reflection.html#24592" class="Bound">a</a><a id="24607" class="Symbol">)</a> <a id="24609" class="Symbol">→</a> <a id="24611" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24616" href="Meta.HLevel.Reflection.html#24526" class="Generalizable">ℓc</a>
  <a id="24621" href="Meta.HLevel.Reflection.html#24621" class="Generalizable">D</a> <a id="24623" class="Symbol">:</a> <a id="24625" class="Symbol">(</a><a id="24626" href="Meta.HLevel.Reflection.html#24626" class="Bound">a</a> <a id="24628" class="Symbol">:</a> <a id="24630" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a><a id="24631" class="Symbol">)</a> <a id="24633" class="Symbol">(</a><a id="24634" href="Meta.HLevel.Reflection.html#24634" class="Bound">b</a> <a id="24636" class="Symbol">:</a> <a id="24638" href="Meta.HLevel.Reflection.html#24569" class="Generalizable">B</a> <a id="24640" href="Meta.HLevel.Reflection.html#24626" class="Bound">a</a><a id="24641" class="Symbol">)</a> <a id="24643" class="Symbol">(</a><a id="24644" href="Meta.HLevel.Reflection.html#24644" class="Bound">c</a> <a id="24646" class="Symbol">:</a> <a id="24648" href="Meta.HLevel.Reflection.html#24587" class="Generalizable">C</a> <a id="24650" href="Meta.HLevel.Reflection.html#24626" class="Bound">a</a> <a id="24652" href="Meta.HLevel.Reflection.html#24634" class="Bound">b</a><a id="24653" class="Symbol">)</a> <a id="24655" class="Symbol">→</a> <a id="24657" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24662" href="Meta.HLevel.Reflection.html#24529" class="Generalizable">ℓd</a>
  <a id="24667" href="Meta.HLevel.Reflection.html#24667" class="Generalizable">n</a> <a id="24669" class="Symbol">:</a> <a id="24671" href="Foundations.HLevel.Base.html#211" class="Function">HLevel</a>

<a id="24679" class="Comment">-- In addition to using the macro as a.. well, macro, it can be used as</a>
<a id="24751" class="Comment">-- a tactic argument, to replace instance search by the more powerful</a>
<a id="24821" class="Comment">-- decomposition-projection mechanism of the tactic. We provide only</a>
<a id="24890" class="Comment">-- some of the most common helpers:</a>
<a id="el!"></a><a id="24926" href="Meta.HLevel.Reflection.html#24926" class="Function">el!</a> <a id="24930" class="Symbol">:</a> <a id="24932" class="Symbol">(</a><a id="24933" href="Meta.HLevel.Reflection.html#24933" class="Bound">A</a> <a id="24935" class="Symbol">:</a> <a id="24937" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24942" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a><a id="24943" class="Symbol">)</a> <a id="24945" class="Symbol">{@(</a><a id="24948" class="Keyword">tactic</a> <a id="24955" href="Meta.HLevel.Reflection.html#23617" class="Function">hlevel-tactic-worker</a><a id="24975" class="Symbol">)</a> <a id="24977" href="Meta.HLevel.Reflection.html#24977" class="Bound">hl</a> <a id="24980" class="Symbol">:</a> <a id="24982" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="24995" href="Meta.HLevel.Reflection.html#24667" class="Generalizable">n</a> <a id="24997" href="Meta.HLevel.Reflection.html#24933" class="Bound">A</a><a id="24998" class="Symbol">}</a> <a id="25000" class="Symbol">→</a> <a id="25002" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="25009" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a> <a id="25011" href="Meta.HLevel.Reflection.html#24667" class="Generalizable">n</a>
<a id="25013" href="Meta.HLevel.Reflection.html#24926" class="Function">el!</a> <a id="25017" href="Meta.HLevel.Reflection.html#25017" class="Bound">A</a> <a id="25019" class="Symbol">{</a><a id="25020" href="Meta.HLevel.Reflection.html#25020" class="Bound">hl</a><a id="25022" class="Symbol">}</a> <a id="25024" class="Symbol">.</a><a id="25025" href="Structures.n-Type.html#377" class="Field">n-Type.typ</a> <a id="25036" class="Symbol">=</a> <a id="25038" href="Meta.HLevel.Reflection.html#25017" class="Bound">A</a>
<a id="25040" href="Meta.HLevel.Reflection.html#24926" class="Function">el!</a> <a id="25044" href="Meta.HLevel.Reflection.html#25044" class="Bound">A</a> <a id="25046" class="Symbol">{</a><a id="25047" href="Meta.HLevel.Reflection.html#25047" class="Bound">hl</a><a id="25049" class="Symbol">}</a> <a id="25051" class="Symbol">.</a><a id="25052" href="Structures.n-Type.html#396" class="Field">n-Type.is-tr</a> <a id="25065" class="Symbol">=</a> <a id="25067" href="Meta.HLevel.Reflection.html#25047" class="Bound">hl</a>

<a id="prop-extₑ!"></a><a id="25071" href="Meta.HLevel.Reflection.html#25071" class="Function">prop-extₑ!</a>
  <a id="25084" class="Symbol">:</a> <a id="25086" class="Symbol">{</a><a id="25087" href="Meta.HLevel.Reflection.html#25087" class="Bound">B</a> <a id="25089" class="Symbol">:</a> <a id="25091" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="25096" href="Meta.HLevel.Reflection.html#24523" class="Generalizable">ℓb</a><a id="25098" class="Symbol">}</a>
    <a id="25104" class="Symbol">{@(</a><a id="25107" class="Keyword">tactic</a> <a id="25114" href="Meta.HLevel.Reflection.html#23617" class="Function">hlevel-tactic-worker</a><a id="25134" class="Symbol">)</a> <a id="25136" href="Meta.HLevel.Reflection.html#25136" class="Bound">aprop</a> <a id="25142" class="Symbol">:</a> <a id="25144" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="25157" class="Number">1</a> <a id="25159" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a><a id="25160" class="Symbol">}</a>
    <a id="25166" class="Symbol">{@(</a><a id="25169" class="Keyword">tactic</a> <a id="25176" href="Meta.HLevel.Reflection.html#23617" class="Function">hlevel-tactic-worker</a><a id="25196" class="Symbol">)</a> <a id="25198" href="Meta.HLevel.Reflection.html#25198" class="Bound">bprop</a> <a id="25204" class="Symbol">:</a> <a id="25206" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="25219" class="Number">1</a> <a id="25221" href="Meta.HLevel.Reflection.html#25087" class="Bound">B</a><a id="25222" class="Symbol">}</a>
  <a id="25226" class="Symbol">→</a> <a id="25228" class="Symbol">(</a><a id="25229" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="25231" class="Symbol">→</a> <a id="25233" href="Meta.HLevel.Reflection.html#25087" class="Bound">B</a><a id="25234" class="Symbol">)</a> <a id="25236" class="Symbol">→</a> <a id="25238" class="Symbol">(</a><a id="25239" href="Meta.HLevel.Reflection.html#25087" class="Bound">B</a> <a id="25241" class="Symbol">→</a> <a id="25243" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a><a id="25244" class="Symbol">)</a>
  <a id="25248" class="Symbol">→</a> <a id="25250" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="25252" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="25254" href="Meta.HLevel.Reflection.html#25087" class="Bound">B</a>
<a id="25256" href="Meta.HLevel.Reflection.html#25071" class="Function">prop-extₑ!</a> <a id="25267" class="Symbol">{</a><a id="25268" href="Meta.HLevel.Reflection.html#25268" class="Bound">aprop</a><a id="25273" class="Symbol">}</a> <a id="25275" class="Symbol">{</a><a id="25276" href="Meta.HLevel.Reflection.html#25276" class="Bound">bprop</a><a id="25281" class="Symbol">}</a> <a id="25283" class="Symbol">=</a> <a id="25285" href="Foundations.Equiv.Properties.html#2526" class="Function">prop-extₑ</a> <a id="25295" href="Meta.HLevel.Reflection.html#25268" class="Bound">aprop</a> <a id="25301" href="Meta.HLevel.Reflection.html#25276" class="Bound">bprop</a>

<a id="Σ-prop-path!"></a><a id="25308" href="Meta.HLevel.Reflection.html#25308" class="Function">Σ-prop-path!</a>
  <a id="25323" class="Symbol">:</a> <a id="25325" class="Symbol">{@(</a><a id="25328" class="Keyword">tactic</a> <a id="25335" href="Meta.HLevel.Reflection.html#23617" class="Function">hlevel-tactic-worker</a><a id="25355" class="Symbol">)</a> <a id="25357" href="Meta.HLevel.Reflection.html#25357" class="Bound">bxprop</a> <a id="25364" class="Symbol">:</a> <a id="25366" class="Symbol">∀</a> <a id="25368" href="Meta.HLevel.Reflection.html#25368" class="Bound">x</a> <a id="25370" class="Symbol">→</a> <a id="25372" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="25385" class="Number">1</a> <a id="25387" class="Symbol">(</a><a id="25388" href="Meta.HLevel.Reflection.html#24569" class="Generalizable">B</a> <a id="25390" href="Meta.HLevel.Reflection.html#25368" class="Bound">x</a><a id="25391" class="Symbol">)}</a>
  <a id="25396" class="Symbol">→</a> <a id="25398" class="Symbol">{</a><a id="25399" href="Meta.HLevel.Reflection.html#25399" class="Bound">x</a> <a id="25401" href="Meta.HLevel.Reflection.html#25401" class="Bound">y</a> <a id="25403" class="Symbol">:</a> <a id="25405" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="25407" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="25409" href="Meta.HLevel.Reflection.html#24569" class="Generalizable">B</a><a id="25410" class="Symbol">}</a>
  <a id="25414" class="Symbol">→</a> <a id="25416" href="Meta.HLevel.Reflection.html#25399" class="Bound">x</a> <a id="25418" class="Symbol">.</a><a id="25419" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="25423" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25425" href="Meta.HLevel.Reflection.html#25401" class="Bound">y</a> <a id="25427" class="Symbol">.</a><a id="25428" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>
  <a id="25434" class="Symbol">→</a> <a id="25436" href="Meta.HLevel.Reflection.html#25399" class="Bound">x</a> <a id="25438" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25440" href="Meta.HLevel.Reflection.html#25401" class="Bound">y</a>
<a id="25442" href="Meta.HLevel.Reflection.html#25308" class="Function">Σ-prop-path!</a> <a id="25455" class="Symbol">{</a><a id="25456" href="Meta.HLevel.Reflection.html#25456" class="Bound">bxprop</a><a id="25462" class="Symbol">}</a> <a id="25464" class="Symbol">=</a> <a id="25466" href="Foundations.Sigma.Properties.html#3918" class="Function">Σ-prop-path</a> <a id="25478" href="Meta.HLevel.Reflection.html#25456" class="Bound">bxprop</a>

<a id="prop!"></a><a id="25486" href="Meta.HLevel.Reflection.html#25486" class="Function">prop!</a>
  <a id="25494" class="Symbol">:</a> <a id="25496" class="Symbol">{</a><a id="25497" href="Meta.HLevel.Reflection.html#25497" class="Bound">A</a> <a id="25499" class="Symbol">:</a> <a id="25501" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="25503" class="Symbol">→</a> <a id="25505" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="25510" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a><a id="25511" class="Symbol">}</a> <a id="25513" class="Symbol">{@(</a><a id="25516" class="Keyword">tactic</a> <a id="25523" href="Meta.HLevel.Reflection.html#23617" class="Function">hlevel-tactic-worker</a><a id="25543" class="Symbol">)</a> <a id="25545" href="Meta.HLevel.Reflection.html#25545" class="Bound">aip</a> <a id="25549" class="Symbol">:</a> <a id="25551" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="25564" class="Number">1</a> <a id="25566" class="Symbol">(</a><a id="25567" href="Meta.HLevel.Reflection.html#25497" class="Bound">A</a> <a id="25569" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25571" class="Symbol">)}</a>
  <a id="25576" class="Symbol">→</a> <a id="25578" class="Symbol">{</a><a id="25579" href="Meta.HLevel.Reflection.html#25579" class="Bound">x</a> <a id="25581" class="Symbol">:</a> <a id="25583" href="Meta.HLevel.Reflection.html#25497" class="Bound">A</a> <a id="25585" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25587" class="Symbol">}</a> <a id="25589" class="Symbol">{</a><a id="25590" href="Meta.HLevel.Reflection.html#25590" class="Bound">y</a> <a id="25592" class="Symbol">:</a> <a id="25594" href="Meta.HLevel.Reflection.html#25497" class="Bound">A</a> <a id="25596" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="25598" class="Symbol">}</a>
  <a id="25602" class="Symbol">→</a> <a id="25604" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="25610" href="Meta.HLevel.Reflection.html#25497" class="Bound">A</a> <a id="25612" href="Meta.HLevel.Reflection.html#25579" class="Bound">x</a> <a id="25614" href="Meta.HLevel.Reflection.html#25590" class="Bound">y</a>
<a id="25616" href="Meta.HLevel.Reflection.html#25486" class="Function">prop!</a> <a id="25622" class="Symbol">{</a><a id="25623" href="Meta.HLevel.Reflection.html#25623" class="Bound">A</a><a id="25624" class="Symbol">}</a> <a id="25626" class="Symbol">{</a><a id="25627" href="Meta.HLevel.Reflection.html#25627" class="Bound">aip</a><a id="25630" class="Symbol">}</a> <a id="25632" class="Symbol">{</a><a id="25633" href="Meta.HLevel.Reflection.html#25633" class="Bound">x</a><a id="25634" class="Symbol">}</a> <a id="25636" class="Symbol">{</a><a id="25637" href="Meta.HLevel.Reflection.html#25637" class="Bound">y</a><a id="25638" class="Symbol">}</a> <a id="25640" class="Symbol">=</a>
  <a id="25644" href="Foundations.HLevel.Base.html#1066" class="Function">is-prop→pathP</a> <a id="25658" class="Symbol">(λ</a> <a id="25661" href="Meta.HLevel.Reflection.html#25661" class="Bound">i</a> <a id="25663" class="Symbol">→</a> <a id="25665" href="Foundations.Base.html#17137" class="Function">coe0→i</a> <a id="25672" class="Symbol">(λ</a> <a id="25675" href="Meta.HLevel.Reflection.html#25675" class="Bound">j</a> <a id="25677" class="Symbol">→</a> <a id="25679" href="Foundations.Base.html#12782" class="Function">is-prop</a> <a id="25687" class="Symbol">(</a><a id="25688" href="Meta.HLevel.Reflection.html#25623" class="Bound">A</a> <a id="25690" href="Meta.HLevel.Reflection.html#25675" class="Bound">j</a><a id="25691" class="Symbol">))</a> <a id="25694" href="Meta.HLevel.Reflection.html#25661" class="Bound">i</a> <a id="25696" href="Meta.HLevel.Reflection.html#25627" class="Bound">aip</a><a id="25699" class="Symbol">)</a> <a id="25701" href="Meta.HLevel.Reflection.html#25633" class="Bound">x</a> <a id="25703" href="Meta.HLevel.Reflection.html#25637" class="Bound">y</a>

<a id="25706" class="Keyword">open</a> <a id="25711" href="Meta.HLevel.Reflection.html#4164" class="Module">hlevel-projection</a>

<a id="25730" class="Comment">-- Hint database bootstrap</a>
<a id="25757" class="Comment">--------------------------</a>
<a id="25784" class="Comment">-- This instance block contains most of the decompositions we have</a>
<a id="25851" class="Comment">-- defined in the dependencies of this module.</a>

<a id="25899" class="Keyword">instance</a>
  <a id="decomp-lift"></a><a id="25910" href="Meta.HLevel.Reflection.html#25910" class="Function">decomp-lift</a> <a id="25922" class="Symbol">:</a> <a id="25924" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="25945" class="Symbol">(</a><a id="25946" href="Foundations.Prim.Type.html#538" class="Record">Lift</a> <a id="25951" href="Meta.HLevel.Reflection.html#24517" class="Generalizable">ℓ′</a> <a id="25954" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a><a id="25955" class="Symbol">)</a>
  <a id="25959" href="Meta.HLevel.Reflection.html#25910" class="Function">decomp-lift</a> <a id="25971" class="Symbol">=</a> <a id="25973" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="25980" class="Symbol">(</a><a id="25981" class="Keyword">quote</a> <a id="25987" href="Foundations.HLevel.Retracts.html#5049" class="Function">Lift-is-of-hlevel</a><a id="26004" class="Symbol">)</a> <a id="26006" class="Symbol">(</a><a id="26007" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="26014" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26016" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="26024" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26026" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26028" class="Symbol">)</a>

  <a id="26033" class="Comment">-- Non-dependent Π and Σ for readability (lol) first</a>
  <a id="decomp-fun"></a><a id="26088" href="Meta.HLevel.Reflection.html#26088" class="Function">decomp-fun</a> <a id="26099" class="Symbol">:</a> <a id="26101" class="Symbol">{</a><a id="26102" href="Meta.HLevel.Reflection.html#26102" class="Bound">B</a> <a id="26104" class="Symbol">:</a> <a id="26106" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26111" href="Meta.HLevel.Reflection.html#24523" class="Generalizable">ℓb</a><a id="26113" class="Symbol">}</a> <a id="26115" class="Symbol">→</a> <a id="26117" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="26138" class="Symbol">(</a><a id="26139" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="26141" class="Symbol">→</a> <a id="26143" href="Meta.HLevel.Reflection.html#26102" class="Bound">B</a><a id="26144" class="Symbol">)</a>
  <a id="26148" href="Meta.HLevel.Reflection.html#26088" class="Function">decomp-fun</a> <a id="26159" class="Symbol">=</a> <a id="26161" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="26168" class="Symbol">(</a><a id="26169" class="Keyword">quote</a> <a id="26175" href="Foundations.HLevel.Retracts.html#4004" class="Function">fun-is-of-hlevel</a><a id="26191" class="Symbol">)</a> <a id="26193" class="Symbol">(</a><a id="26194" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="26201" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26203" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="26211" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26213" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26215" class="Symbol">)</a>

  <a id="decomp-prod"></a><a id="26220" href="Meta.HLevel.Reflection.html#26220" class="Function">decomp-prod</a> <a id="26232" class="Symbol">:</a> <a id="26234" class="Symbol">{</a><a id="26235" href="Meta.HLevel.Reflection.html#26235" class="Bound">B</a> <a id="26237" class="Symbol">:</a> <a id="26239" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26244" href="Meta.HLevel.Reflection.html#24523" class="Generalizable">ℓb</a><a id="26246" class="Symbol">}</a> <a id="26248" class="Symbol">→</a> <a id="26250" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="26271" class="Symbol">(</a><a id="26272" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="26274" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="26276" href="Meta.HLevel.Reflection.html#26235" class="Bound">B</a><a id="26277" class="Symbol">)</a>
  <a id="26281" href="Meta.HLevel.Reflection.html#26220" class="Function">decomp-prod</a> <a id="26293" class="Symbol">=</a> <a id="26295" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="26302" class="Symbol">(</a><a id="26303" class="Keyword">quote</a> <a id="26309" href="Foundations.HLevel.Retracts.html#4834" class="Function">×-is-of-hlevel</a><a id="26323" class="Symbol">)</a> <a id="26325" class="Symbol">(</a><a id="26326" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="26333" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26335" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="26343" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26345" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="26353" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26355" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26357" class="Symbol">)</a>

  <a id="26362" class="Comment">-- Dependent type formers:</a>
  <a id="decomp-pi³"></a><a id="26391" href="Meta.HLevel.Reflection.html#26391" class="Function">decomp-pi³</a> <a id="26402" class="Symbol">:</a> <a id="26404" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="26425" class="Symbol">(∀</a> <a id="26428" href="Meta.HLevel.Reflection.html#26428" class="Bound">a</a> <a id="26430" href="Meta.HLevel.Reflection.html#26430" class="Bound">b</a> <a id="26432" href="Meta.HLevel.Reflection.html#26432" class="Bound">c</a> <a id="26434" class="Symbol">→</a> <a id="26436" href="Meta.HLevel.Reflection.html#24621" class="Generalizable">D</a> <a id="26438" href="Meta.HLevel.Reflection.html#26428" class="Bound">a</a> <a id="26440" href="Meta.HLevel.Reflection.html#26430" class="Bound">b</a> <a id="26442" href="Meta.HLevel.Reflection.html#26432" class="Bound">c</a><a id="26443" class="Symbol">)</a>
  <a id="26447" href="Meta.HLevel.Reflection.html#26391" class="Function">decomp-pi³</a> <a id="26458" class="Symbol">=</a> <a id="26460" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="26467" class="Symbol">(</a><a id="26468" class="Keyword">quote</a> <a id="26474" href="Foundations.HLevel.Retracts.html#3719" class="Function">Π₃-is-of-hlevel</a><a id="26489" class="Symbol">)</a> <a id="26491" class="Symbol">(</a><a id="26492" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="26499" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26501" href="Meta.HLevel.Reflection.html#3148" class="InductiveConstructor">`search-under</a> <a id="26515" class="Number">3</a> <a id="26517" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26519" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26521" class="Symbol">)</a>

  <a id="decomp-pi²"></a><a id="26526" href="Meta.HLevel.Reflection.html#26526" class="Function">decomp-pi²</a> <a id="26537" class="Symbol">:</a> <a id="26539" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="26560" class="Symbol">(∀</a> <a id="26563" href="Meta.HLevel.Reflection.html#26563" class="Bound">a</a> <a id="26565" href="Meta.HLevel.Reflection.html#26565" class="Bound">b</a> <a id="26567" class="Symbol">→</a> <a id="26569" href="Meta.HLevel.Reflection.html#24587" class="Generalizable">C</a> <a id="26571" href="Meta.HLevel.Reflection.html#26563" class="Bound">a</a> <a id="26573" href="Meta.HLevel.Reflection.html#26565" class="Bound">b</a><a id="26574" class="Symbol">)</a>
  <a id="26578" href="Meta.HLevel.Reflection.html#26526" class="Function">decomp-pi²</a> <a id="26589" class="Symbol">=</a> <a id="26591" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="26598" class="Symbol">(</a><a id="26599" class="Keyword">quote</a> <a id="26605" href="Foundations.HLevel.Retracts.html#3483" class="Function">Π₂-is-of-hlevel</a><a id="26620" class="Symbol">)</a> <a id="26622" class="Symbol">(</a><a id="26623" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="26630" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26632" href="Meta.HLevel.Reflection.html#3148" class="InductiveConstructor">`search-under</a> <a id="26646" class="Number">2</a> <a id="26648" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26650" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26652" class="Symbol">)</a>

  <a id="decomp-pi"></a><a id="26657" href="Meta.HLevel.Reflection.html#26657" class="Function">decomp-pi</a> <a id="26667" class="Symbol">:</a> <a id="26669" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="26690" class="Symbol">(∀</a> <a id="26693" href="Meta.HLevel.Reflection.html#26693" class="Bound">a</a> <a id="26695" class="Symbol">→</a> <a id="26697" href="Meta.HLevel.Reflection.html#24569" class="Generalizable">B</a> <a id="26699" href="Meta.HLevel.Reflection.html#26693" class="Bound">a</a><a id="26700" class="Symbol">)</a>
  <a id="26704" href="Meta.HLevel.Reflection.html#26657" class="Function">decomp-pi</a> <a id="26714" class="Symbol">=</a> <a id="26716" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="26723" class="Symbol">(</a><a id="26724" class="Keyword">quote</a> <a id="26730" href="Foundations.HLevel.Retracts.html#2750" class="Function">Π-is-of-hlevel</a><a id="26744" class="Symbol">)</a> <a id="26746" class="Symbol">(</a><a id="26747" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="26754" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26756" href="Meta.HLevel.Reflection.html#3148" class="InductiveConstructor">`search-under</a> <a id="26770" class="Number">1</a> <a id="26772" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26774" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26776" class="Symbol">)</a>

  <a id="decomp-impl-pi"></a><a id="26781" href="Meta.HLevel.Reflection.html#26781" class="Function">decomp-impl-pi</a> <a id="26796" class="Symbol">:</a> <a id="26798" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="26819" class="Symbol">(∀</a> <a id="26822" class="Symbol">{</a><a id="26823" href="Meta.HLevel.Reflection.html#26823" class="Bound">a</a><a id="26824" class="Symbol">}</a> <a id="26826" class="Symbol">→</a> <a id="26828" href="Meta.HLevel.Reflection.html#24569" class="Generalizable">B</a> <a id="26830" href="Meta.HLevel.Reflection.html#26823" class="Bound">a</a><a id="26831" class="Symbol">)</a>
  <a id="26835" href="Meta.HLevel.Reflection.html#26781" class="Function">decomp-impl-pi</a> <a id="26850" class="Symbol">=</a> <a id="26852" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="26859" class="Symbol">(</a><a id="26860" class="Keyword">quote</a> <a id="26866" href="Foundations.HLevel.Retracts.html#3180" class="Function">Π-is-of-hlevel-implicit</a><a id="26889" class="Symbol">)</a> <a id="26891" class="Symbol">(</a><a id="26892" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="26899" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26901" href="Meta.HLevel.Reflection.html#3148" class="InductiveConstructor">`search-under</a> <a id="26915" class="Number">1</a> <a id="26917" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26919" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26921" class="Symbol">)</a>

  <a id="decomp-equiv-right"></a><a id="26926" href="Meta.HLevel.Reflection.html#26926" class="Function">decomp-equiv-right</a> <a id="26945" class="Symbol">:</a> <a id="26947" class="Symbol">{</a><a id="26948" href="Meta.HLevel.Reflection.html#26948" class="Bound">B</a> <a id="26950" class="Symbol">:</a> <a id="26952" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26957" href="Meta.HLevel.Reflection.html#24523" class="Generalizable">ℓb</a><a id="26959" class="Symbol">}</a> <a id="26961" class="Symbol">→</a> <a id="26963" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="26984" class="Symbol">(</a><a id="26985" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="26987" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="26989" href="Meta.HLevel.Reflection.html#26948" class="Bound">B</a><a id="26990" class="Symbol">)</a>
  <a id="26994" href="Meta.HLevel.Reflection.html#26926" class="Function">decomp-equiv-right</a> <a id="27013" class="Symbol">=</a> <a id="27015" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="27022" class="Symbol">(</a><a id="27023" class="Keyword">quote</a> <a id="27029" href="Foundations.HLevel.Retracts.html#6081" class="Function">≃-is-of-hlevel-right-suc</a><a id="27053" class="Symbol">)</a> <a id="27055" class="Symbol">(</a><a id="27056" href="Meta.HLevel.Reflection.html#2948" class="InductiveConstructor">`level-minus</a> <a id="27069" class="Number">1</a> <a id="27071" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27073" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="27081" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27083" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27085" class="Symbol">)</a>

  <a id="decomp-equiv-left"></a><a id="27090" href="Meta.HLevel.Reflection.html#27090" class="Function">decomp-equiv-left</a> <a id="27108" class="Symbol">:</a> <a id="27110" class="Symbol">{</a><a id="27111" href="Meta.HLevel.Reflection.html#27111" class="Bound">B</a> <a id="27113" class="Symbol">:</a> <a id="27115" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="27120" href="Meta.HLevel.Reflection.html#24523" class="Generalizable">ℓb</a><a id="27122" class="Symbol">}</a> <a id="27124" class="Symbol">→</a> <a id="27126" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="27147" class="Symbol">(</a><a id="27148" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="27150" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="27152" href="Meta.HLevel.Reflection.html#27111" class="Bound">B</a><a id="27153" class="Symbol">)</a>
  <a id="27157" href="Meta.HLevel.Reflection.html#27090" class="Function">decomp-equiv-left</a> <a id="27175" class="Symbol">=</a> <a id="27177" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="27184" class="Symbol">(</a><a id="27185" class="Keyword">quote</a> <a id="27191" href="Foundations.HLevel.Retracts.html#5741" class="Function">≃-is-of-hlevel-left-suc</a><a id="27214" class="Symbol">)</a> <a id="27216" class="Symbol">(</a><a id="27217" href="Meta.HLevel.Reflection.html#2948" class="InductiveConstructor">`level-minus</a> <a id="27230" class="Number">1</a> <a id="27232" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27234" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="27242" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27244" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27246" class="Symbol">)</a>

  <a id="decomp-equiv"></a><a id="27251" href="Meta.HLevel.Reflection.html#27251" class="Function">decomp-equiv</a> <a id="27264" class="Symbol">:</a> <a id="27266" class="Symbol">{</a><a id="27267" href="Meta.HLevel.Reflection.html#27267" class="Bound">B</a> <a id="27269" class="Symbol">:</a> <a id="27271" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="27276" href="Meta.HLevel.Reflection.html#24523" class="Generalizable">ℓb</a><a id="27278" class="Symbol">}</a> <a id="27280" class="Symbol">→</a> <a id="27282" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="27303" class="Symbol">(</a><a id="27304" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="27306" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="27308" href="Meta.HLevel.Reflection.html#27267" class="Bound">B</a><a id="27309" class="Symbol">)</a>
  <a id="27313" href="Meta.HLevel.Reflection.html#27251" class="Function">decomp-equiv</a> <a id="27326" class="Symbol">=</a> <a id="27328" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="27335" class="Symbol">(</a><a id="27336" class="Keyword">quote</a> <a id="27342" href="Foundations.HLevel.Retracts.html#5246" class="Function">≃-is-of-hlevel</a><a id="27356" class="Symbol">)</a> <a id="27358" class="Symbol">(</a><a id="27359" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="27366" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27368" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="27376" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27378" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="27386" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27388" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="27391" class="Symbol">)</a>

  <a id="decomp-sigma"></a><a id="27396" href="Meta.HLevel.Reflection.html#27396" class="Function">decomp-sigma</a> <a id="27409" class="Symbol">:</a> <a id="27411" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="27432" class="Symbol">(</a><a id="27433" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="27435" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a> <a id="27437" href="Meta.HLevel.Reflection.html#24569" class="Generalizable">B</a><a id="27438" class="Symbol">)</a>
  <a id="27442" href="Meta.HLevel.Reflection.html#27396" class="Function">decomp-sigma</a> <a id="27455" class="Symbol">=</a> <a id="27457" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="27464" class="Symbol">(</a><a id="27465" class="Keyword">quote</a> <a id="27471" href="Foundations.HLevel.Retracts.html#4155" class="Function">Σ-is-of-hlevel</a><a id="27485" class="Symbol">)</a> <a id="27487" class="Symbol">(</a><a id="27488" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="27495" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27497" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="27505" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27507" href="Meta.HLevel.Reflection.html#3148" class="InductiveConstructor">`search-under</a> <a id="27521" class="Number">1</a> <a id="27523" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27525" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27527" class="Symbol">)</a>

  <a id="27532" class="Comment">-- Path decomposition rules we have in scope. Note the use of</a>
  <a id="27596" class="Comment">-- nondeterminism: the following three instances both compete for</a>
  <a id="27664" class="Comment">-- solving the same goals --- but generally only one will be</a>
  <a id="27727" class="Comment">-- applicable. That way we don&#39;t have to juggle h-levels quite as</a>
  <a id="27795" class="Comment">-- much.</a>
  <a id="decomp-path′"></a><a id="27806" href="Meta.HLevel.Reflection.html#27806" class="Function">decomp-path′</a> <a id="27819" class="Symbol">:</a> <a id="27821" class="Symbol">{</a><a id="27822" href="Meta.HLevel.Reflection.html#27822" class="Bound">a</a> <a id="27824" href="Meta.HLevel.Reflection.html#27824" class="Bound">b</a> <a id="27826" class="Symbol">:</a> <a id="27828" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a><a id="27829" class="Symbol">}</a> <a id="27831" class="Symbol">→</a> <a id="27833" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="27854" class="Symbol">(</a><a id="27855" href="Meta.HLevel.Reflection.html#27822" class="Bound">a</a> <a id="27857" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27859" href="Meta.HLevel.Reflection.html#27824" class="Bound">b</a><a id="27860" class="Symbol">)</a>
  <a id="27864" href="Meta.HLevel.Reflection.html#27806" class="Function">decomp-path′</a> <a id="27877" class="Symbol">=</a> <a id="27879" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="27886" class="Symbol">(</a><a id="27887" class="Keyword">quote</a> <a id="27893" href="Foundations.HLevel.Base.html#3651" class="Function">path-is-of-hlevel′</a><a id="27911" class="Symbol">)</a> <a id="27913" class="Symbol">(</a><a id="27914" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="27921" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27923" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="27931" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27933" href="Meta.HLevel.Reflection.html#3351" class="InductiveConstructor">`meta</a> <a id="27939" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27941" href="Meta.HLevel.Reflection.html#3351" class="InductiveConstructor">`meta</a> <a id="27947" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27949" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27951" class="Symbol">)</a>

  <a id="decomp-path"></a><a id="27956" href="Meta.HLevel.Reflection.html#27956" class="Function">decomp-path</a> <a id="27968" class="Symbol">:</a> <a id="27970" class="Symbol">{</a><a id="27971" href="Meta.HLevel.Reflection.html#27971" class="Bound">a</a> <a id="27973" href="Meta.HLevel.Reflection.html#27973" class="Bound">b</a> <a id="27975" class="Symbol">:</a> <a id="27977" href="Meta.HLevel.Reflection.html#24555" class="Generalizable">A</a><a id="27978" class="Symbol">}</a> <a id="27980" class="Symbol">→</a> <a id="27982" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="28003" class="Symbol">(</a><a id="28004" href="Meta.HLevel.Reflection.html#27971" class="Bound">a</a> <a id="28006" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="28008" href="Meta.HLevel.Reflection.html#27973" class="Bound">b</a><a id="28009" class="Symbol">)</a>
  <a id="28013" href="Meta.HLevel.Reflection.html#27956" class="Function">decomp-path</a> <a id="28025" class="Symbol">=</a> <a id="28027" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="28034" class="Symbol">(</a><a id="28035" class="Keyword">quote</a> <a id="28041" href="Foundations.HLevel.Base.html#3076" class="Function">path-is-of-hlevel</a><a id="28058" class="Symbol">)</a> <a id="28060" class="Symbol">(</a><a id="28061" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="28068" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28070" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="28078" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28080" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28082" class="Symbol">)</a>

  <a id="decomp-univalence"></a><a id="28087" href="Meta.HLevel.Reflection.html#28087" class="Function">decomp-univalence</a> <a id="28105" class="Symbol">:</a> <a id="28107" class="Symbol">{</a><a id="28108" href="Meta.HLevel.Reflection.html#28108" class="Bound">A</a> <a id="28110" href="Meta.HLevel.Reflection.html#28110" class="Bound">B</a> <a id="28112" class="Symbol">:</a> <a id="28114" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="28119" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a><a id="28120" class="Symbol">}</a> <a id="28122" class="Symbol">→</a> <a id="28124" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="28145" class="Symbol">(</a><a id="28146" href="Meta.HLevel.Reflection.html#28108" class="Bound">A</a> <a id="28148" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="28150" href="Meta.HLevel.Reflection.html#28110" class="Bound">B</a><a id="28151" class="Symbol">)</a>
  <a id="28155" href="Meta.HLevel.Reflection.html#28087" class="Function">decomp-univalence</a> <a id="28173" class="Symbol">=</a> <a id="28175" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="28182" class="Symbol">(</a><a id="28183" class="Keyword">quote</a> <a id="28189" href="Structures.n-Type.html#846" class="Function">＝-is-of-hlevel</a><a id="28203" class="Symbol">)</a> <a id="28205" class="Symbol">(</a><a id="28206" href="Meta.HLevel.Reflection.html#3651" class="InductiveConstructor">`level</a> <a id="28213" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28215" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="28223" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28225" href="Meta.HLevel.Reflection.html#3617" class="InductiveConstructor">`search</a> <a id="28233" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28235" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="28238" class="Symbol">)</a>

  <a id="28243" class="Comment">-- This one really ought to work with instance selection only, but</a>
  <a id="28312" class="Comment">-- Agda has trouble with the (1 + k + n) level in H-Level-n-Type. The</a>
  <a id="28384" class="Comment">-- decomposition here is a bit more flexible.</a>
  <a id="decomp-ntype"></a><a id="28432" href="Meta.HLevel.Reflection.html#28432" class="Function">decomp-ntype</a> <a id="28445" class="Symbol">:</a> <a id="28447" href="Meta.HLevel.Reflection.html#3792" class="Datatype">hlevel-decomposition</a> <a id="28468" class="Symbol">(</a><a id="28469" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="28476" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a> <a id="28478" href="Meta.HLevel.Reflection.html#24667" class="Generalizable">n</a><a id="28479" class="Symbol">)</a>
  <a id="28483" href="Meta.HLevel.Reflection.html#28432" class="Function">decomp-ntype</a> <a id="28496" class="Symbol">=</a> <a id="28498" href="Meta.HLevel.Reflection.html#3845" class="InductiveConstructor">decomp</a> <a id="28505" class="Symbol">(</a><a id="28506" class="Keyword">quote</a> <a id="28512" href="Structures.n-Type.html#2049" class="Function">n-Type-is-of-hlevel</a><a id="28531" class="Symbol">)</a> <a id="28533" class="Symbol">(</a><a id="28534" href="Meta.HLevel.Reflection.html#2948" class="InductiveConstructor">`level-minus</a> <a id="28547" class="Number">1</a> <a id="28549" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28551" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28553" class="Symbol">)</a>

  <a id="hlevel-proj-n-type"></a><a id="28558" href="Meta.HLevel.Reflection.html#28558" class="Function">hlevel-proj-n-type</a> <a id="28577" class="Symbol">:</a> <a id="28579" href="Meta.HLevel.Reflection.html#4164" class="Record">hlevel-projection</a> <a id="28597" class="Symbol">(</a><a id="28598" class="Keyword">quote</a> <a id="28604" href="Structures.n-Type.html#377" class="Field">n-Type.typ</a><a id="28614" class="Symbol">)</a>
  <a id="28618" href="Meta.HLevel.Reflection.html#28558" class="Function">hlevel-proj-n-type</a> <a id="28637" class="Symbol">.</a><a id="28638" href="Meta.HLevel.Reflection.html#4221" class="Field">has-level</a> <a id="28648" class="Symbol">=</a> <a id="28650" class="Keyword">quote</a> <a id="28656" href="Structures.n-Type.html#396" class="Field">n-Type.is-tr</a>
  <a id="28671" href="Meta.HLevel.Reflection.html#28558" class="Function">hlevel-proj-n-type</a> <a id="28690" class="Symbol">.</a><a id="28691" href="Meta.HLevel.Reflection.html#4408" class="Field">get-level</a> <a id="28701" href="Meta.HLevel.Reflection.html#28701" class="Bound">ty</a> <a id="28704" class="Symbol">=</a> <a id="28706" class="Keyword">do</a>
    <a id="28713" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="28717" class="Symbol">(</a><a id="28718" class="Keyword">quote</a> <a id="28724" href="Structures.n-Type.html#297" class="Record">n-Type</a><a id="28730" class="Symbol">)</a> <a id="28732" class="Symbol">(</a><a id="28733" href="Meta.HLevel.Reflection.html#28733" class="Bound">ell</a> <a id="28737" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="28740" href="Meta.HLevel.Reflection.html#28740" class="Bound">lv′t</a> <a id="28745" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="28748" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28750" class="Symbol">)</a> <a id="28752" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="28754" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="28761" href="Meta.HLevel.Reflection.html#28701" class="Bound">ty</a>
      <a id="28770" class="Keyword">where</a> <a id="28776" class="CatchallClause Symbol">_</a> <a id="28778" class="Symbol">→</a> <a id="28780" href="Meta.HLevel.Reflection.html#5557" class="Function">backtrack</a> <a id="28790" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="28792" class="String">&quot;Type of thing isn&#39;t n-Type, it is &quot;</a> <a id="28829" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28831" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="28839" href="Meta.HLevel.Reflection.html#28701" class="Bound">ty</a> <a id="28842" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28844" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="28851" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="28861" href="Meta.HLevel.Reflection.html#28740" class="Bound">lv′t</a>
  <a id="28868" href="Meta.HLevel.Reflection.html#28558" class="Function">hlevel-proj-n-type</a> <a id="28887" class="Symbol">.</a><a id="28888" href="Meta.HLevel.Reflection.html#4561" class="Field">get-argument</a> <a id="28901" class="Symbol">(_</a> <a id="28904" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28906" class="Symbol">_</a> <a id="28908" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28910" href="Meta.HLevel.Reflection.html#28910" class="Bound">it</a> <a id="28913" href="Meta.Reflection.html#2448" class="InductiveConstructor Operator">v∷</a> <a id="28916" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28918" class="Symbol">)</a> <a id="28920" class="Symbol">=</a> <a id="28922" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="28927" href="Meta.HLevel.Reflection.html#28910" class="Bound">it</a>
  <a id="28932" href="Meta.HLevel.Reflection.html#28558" class="CatchallClause Function">hlevel-proj-n-type</a><a id="28950" class="CatchallClause"> </a><a id="28951" class="CatchallClause Symbol">.</a><a id="28952" href="Meta.HLevel.Reflection.html#4561" class="CatchallClause Field">get-argument</a><a id="28964" class="CatchallClause"> </a><a id="28965" class="CatchallClause Symbol">_</a> <a id="28967" class="Symbol">=</a> <a id="28969" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="28979" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>


<a id="28984" class="Comment">-- Usage</a>
<a id="28993" class="Keyword">private</a>
  <a id="29003" class="Keyword">module</a> <a id="29010" href="Meta.HLevel.Reflection.html#29010" class="Module">_</a> <a id="29012" class="Symbol">{</a><a id="29013" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29015" class="Symbol">:</a> <a id="29017" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="29024" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a> <a id="29026" class="Number">2</a><a id="29027" class="Symbol">}</a> <a id="29029" class="Symbol">{</a><a id="29030" href="Meta.HLevel.Reflection.html#29030" class="Bound">B</a> <a id="29032" class="Symbol">:</a> <a id="29034" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29036" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29038" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29040" class="Symbol">→</a> <a id="29042" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="29049" href="Meta.HLevel.Reflection.html#24515" class="Generalizable">ℓ</a> <a id="29051" class="Number">3</a><a id="29052" class="Symbol">}</a> <a id="29054" class="Keyword">where</a>
    <a id="29064" href="Meta.HLevel.Reflection.html#29064" class="Function">some-def</a> <a id="29073" class="Symbol">=</a> <a id="29075" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29077" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29079" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29085" href="Meta.HLevel.Reflection.html#29085" class="Function">_</a> <a id="29087" class="Symbol">:</a> <a id="29089" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29102" class="Number">2</a> <a id="29104" class="Symbol">(</a><a id="29105" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29107" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29109" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29111" class="Symbol">→</a> <a id="29113" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29115" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29117" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29119" class="Symbol">→</a> <a id="29121" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29123" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29125" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29127" class="Symbol">→</a> <a id="29129" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29131" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29133" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29134" class="Symbol">)</a>
    <a id="29140" class="Symbol">_</a> <a id="29142" class="Symbol">=</a> <a id="29144" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a>

    <a id="29157" href="Meta.HLevel.Reflection.html#29157" class="Function">_</a> <a id="29159" class="Symbol">:</a> <a id="29161" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29174" class="Number">3</a> <a id="29176" class="Symbol">(</a><a id="29177" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="29179" href="Meta.HLevel.Reflection.html#29064" class="Function">some-def</a> <a id="29188" class="Symbol">λ</a> <a id="29190" href="Meta.HLevel.Reflection.html#29190" class="Bound">x</a> <a id="29192" class="Symbol">→</a> <a id="29194" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29196" href="Meta.HLevel.Reflection.html#29030" class="Bound">B</a> <a id="29198" href="Meta.HLevel.Reflection.html#29190" class="Bound">x</a> <a id="29200" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29201" class="Symbol">)</a>
    <a id="29207" class="Symbol">_</a> <a id="29209" class="Symbol">=</a> <a id="29211" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a>

    <a id="29224" href="Meta.HLevel.Reflection.html#29224" class="Function">_</a> <a id="29226" class="Symbol">:</a> <a id="29228" class="Symbol">∀</a> <a id="29230" href="Meta.HLevel.Reflection.html#29230" class="Bound">a</a> <a id="29232" class="Symbol">→</a> <a id="29234" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29247" class="Number">5</a> <a id="29249" class="Symbol">(</a><a id="29250" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29252" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29254" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29256" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29258" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29260" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29262" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29264" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29266" class="Symbol">(</a><a id="29267" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29269" class="Symbol">→</a> <a id="29271" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29273" href="Meta.HLevel.Reflection.html#29030" class="Bound">B</a> <a id="29275" href="Meta.HLevel.Reflection.html#29230" class="Bound">a</a> <a id="29277" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29278" class="Symbol">))</a>
    <a id="29285" class="Symbol">_</a> <a id="29287" class="Symbol">=</a> <a id="29289" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a>

    <a id="29302" href="Meta.HLevel.Reflection.html#29302" class="Function">_</a> <a id="29304" class="Symbol">:</a> <a id="29306" class="Symbol">∀</a> <a id="29308" href="Meta.HLevel.Reflection.html#29308" class="Bound">a</a> <a id="29310" class="Symbol">→</a> <a id="29312" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29325" class="Number">3</a> <a id="29327" class="Symbol">(</a><a id="29328" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29330" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29332" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29334" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29336" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29338" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29340" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29342" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29344" class="Symbol">(</a><a id="29345" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29347" class="Symbol">→</a> <a id="29349" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29351" href="Meta.HLevel.Reflection.html#29030" class="Bound">B</a> <a id="29353" href="Meta.HLevel.Reflection.html#29308" class="Bound">a</a> <a id="29355" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29356" class="Symbol">))</a>
    <a id="29363" class="Symbol">_</a> <a id="29365" class="Symbol">=</a> <a id="29367" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a>

    <a id="29380" href="Meta.HLevel.Reflection.html#29380" class="Function">_</a> <a id="29382" class="Symbol">:</a> <a id="29384" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29397" class="Number">2</a> <a id="29399" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29401" href="Meta.HLevel.Reflection.html#29013" class="Bound">A</a> <a id="29403" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29409" class="Symbol">_</a> <a id="29411" class="Symbol">=</a> <a id="29413" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a>

    <a id="29426" class="Comment">-- this one uses `H-Level-nType` instance which is compile-time only</a>
    <a id="29499" class="Symbol">@</a><a id="29500" class="Number">0</a> <a id="29502" href="Meta.HLevel.Reflection.html#29502" class="Function">_</a> <a id="29504" class="Symbol">:</a> <a id="29506" class="Symbol">∀</a> <a id="29508" href="Meta.HLevel.Reflection.html#29508" class="Bound">n</a> <a id="29510" class="Symbol">→</a> <a id="29512" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29525" class="Symbol">(</a><a id="29526" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="29530" href="Meta.HLevel.Reflection.html#29508" class="Bound">n</a><a id="29531" class="Symbol">)</a> <a id="29533" class="Symbol">(</a><a id="29534" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="29541" href="Meta.HLevel.Reflection.html#29024" class="Bound">ℓ</a> <a id="29543" href="Meta.HLevel.Reflection.html#29508" class="Bound">n</a><a id="29544" class="Symbol">)</a>
    <a id="29550" class="Symbol">_</a> <a id="29552" class="Symbol">=</a> <a id="29554" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a>

    <a id="29567" href="Meta.HLevel.Reflection.html#29567" class="Function">_</a> <a id="29569" class="Symbol">:</a> <a id="29571" class="Symbol">∀</a> <a id="29573" href="Meta.HLevel.Reflection.html#29573" class="Bound">n</a> <a id="29575" class="Symbol">(</a><a id="29576" href="Meta.HLevel.Reflection.html#29576" class="Bound">x</a> <a id="29578" class="Symbol">:</a> <a id="29580" href="Structures.n-Type.html#297" class="Record">n-Type</a> <a id="29587" href="Meta.HLevel.Reflection.html#29024" class="Bound">ℓ</a> <a id="29589" href="Meta.HLevel.Reflection.html#29573" class="Bound">n</a><a id="29590" class="Symbol">)</a> <a id="29592" class="Symbol">→</a> <a id="29594" href="Foundations.HLevel.Base.html#309" class="Function">is-of-hlevel</a> <a id="29607" class="Symbol">(</a><a id="29608" class="Number">2</a> <a id="29610" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="29612" href="Meta.HLevel.Reflection.html#29573" class="Bound">n</a><a id="29613" class="Symbol">)</a> <a id="29615" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29617" href="Meta.HLevel.Reflection.html#29576" class="Bound">x</a> <a id="29619" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29625" class="Symbol">_</a> <a id="29627" class="Symbol">=</a> <a id="29629" class="Symbol">λ</a> <a id="29631" href="Meta.HLevel.Reflection.html#29631" class="Bound">n</a> <a id="29633" href="Meta.HLevel.Reflection.html#29633" class="Bound">x</a> <a id="29635" class="Symbol">→</a> <a id="29637" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a>
</pre></body></html>