<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Truncation.Propositional.MagicTrick</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

Based on Nicolai Kraus&#39; blog post:
  The Truncation Map |_| : ℕ -&gt; ‖ℕ‖ is nearly Invertible
  https://homotopytypetheory.org/2013/10/28/the-truncation-map-_-ℕ-‖ℕ‖-is-nearly-invertible/

Defines [recover], which definitionally satisfies `recover ∣ x ∣ ≡ x` ([recover∣∣]) for homogeneous types

Also see the follow-up post by Jason Gross:
  Composition is not what you think it is! Why “nearly invertible” isn’t.
  https://homotopytypetheory.org/2014/02/24/composition-is-not-what-you-think-it-is-why-nearly-invertible-isnt/

-}</a>
<a id="532" class="Symbol">{-#</a> <a id="536" class="Keyword">OPTIONS</a> <a id="544" class="Pragma">--safe</a> <a id="551" class="Symbol">#-}</a>

<a id="556" class="Keyword">module</a> <a id="563" href="Cubical.Truncation.Propositional.MagicTrick.html" class="Module">Cubical.Truncation.Propositional.MagicTrick</a> <a id="607" class="Keyword">where</a>

<a id="614" class="Keyword">open</a> <a id="619" class="Keyword">import</a> <a id="626" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a>
<a id="654" class="Keyword">open</a> <a id="659" class="Keyword">import</a> <a id="666" href="Cubical.Foundations.Function.html" class="Module">Cubical.Foundations.Function</a>
<a id="695" class="Keyword">open</a> <a id="700" class="Keyword">import</a> <a id="707" href="Cubical.Foundations.Path.html" class="Module">Cubical.Foundations.Path</a>
<a id="732" class="Keyword">open</a> <a id="737" class="Keyword">import</a> <a id="744" href="Cubical.Foundations.Pointed.html" class="Module">Cubical.Foundations.Pointed</a>
<a id="772" class="Keyword">open</a> <a id="777" class="Keyword">import</a> <a id="784" href="Cubical.Foundations.Pointed.Homogeneous.html" class="Module">Cubical.Foundations.Pointed.Homogeneous</a>

<a id="825" class="Keyword">open</a> <a id="830" class="Keyword">import</a> <a id="837" href="Cubical.Truncation.Propositional.Base.html" class="Module">Cubical.Truncation.Propositional.Base</a>
<a id="875" class="Keyword">open</a> <a id="880" class="Keyword">import</a> <a id="887" href="Cubical.Truncation.Propositional.Properties.html" class="Module">Cubical.Truncation.Propositional.Properties</a>

<a id="932" class="Keyword">module</a> <a id="Recover"></a><a id="939" href="Cubical.Truncation.Propositional.MagicTrick.html#939" class="Module">Recover</a> <a id="947" class="Symbol">{</a><a id="948" href="Cubical.Truncation.Propositional.MagicTrick.html#948" class="Bound">ℓ</a><a id="949" class="Symbol">}</a> <a id="951" class="Symbol">(</a><a id="952" href="Cubical.Truncation.Propositional.MagicTrick.html#952" class="Bound">A∙</a> <a id="955" class="Symbol">:</a> <a id="957" href="Cubical.Foundations.Pointed.Base.html#464" class="Function">Pointed</a> <a id="965" href="Cubical.Truncation.Propositional.MagicTrick.html#948" class="Bound">ℓ</a><a id="966" class="Symbol">)</a> <a id="968" class="Symbol">(</a><a id="969" href="Cubical.Truncation.Propositional.MagicTrick.html#969" class="Bound">h</a> <a id="971" class="Symbol">:</a> <a id="973" href="Cubical.Foundations.Pointed.Homogeneous.html#1390" class="Function">isHomogeneous</a> <a id="987" href="Cubical.Truncation.Propositional.MagicTrick.html#952" class="Bound">A∙</a><a id="989" class="Symbol">)</a> <a id="991" class="Keyword">where</a>
  <a id="999" class="Keyword">private</a>
    <a id="Recover.A"></a><a id="1011" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a> <a id="1013" class="Symbol">=</a> <a id="1015" href="Cubical.Foundations.Structure.html#514" class="Function">typ</a> <a id="1019" href="Cubical.Truncation.Propositional.MagicTrick.html#952" class="Bound">A∙</a>
    <a id="Recover.a"></a><a id="1026" href="Cubical.Truncation.Propositional.MagicTrick.html#1026" class="Function">a</a> <a id="1028" class="Symbol">=</a> <a id="1030" href="Cubical.Foundations.Pointed.Base.html#540" class="Function">pt</a> <a id="1033" href="Cubical.Truncation.Propositional.MagicTrick.html#952" class="Bound">A∙</a>

  <a id="Recover.toEquivPtd"></a><a id="1039" href="Cubical.Truncation.Propositional.MagicTrick.html#1039" class="Function">toEquivPtd</a> <a id="1050" class="Symbol">:</a> <a id="1052" href="Cubical.Truncation.Propositional.Base.html#245" class="Datatype Operator">∥</a> <a id="1054" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a> <a id="1056" href="Cubical.Truncation.Propositional.Base.html#245" class="Datatype Operator">∥₁</a> <a id="1059" class="Symbol">→</a> <a id="1061" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="1064" href="Cubical.Truncation.Propositional.MagicTrick.html#1064" class="Bound">B∙</a> <a id="1067" href="Cubical.Core.Primitives.html#6268" class="Function">꞉</a> <a id="1069" href="Cubical.Foundations.Pointed.Base.html#464" class="Function">Pointed</a> <a id="1077" href="Cubical.Truncation.Propositional.MagicTrick.html#948" class="Bound">ℓ</a> <a id="1079" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="1081" class="Symbol">(</a><a id="1082" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a> <a id="1084" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1086" href="Cubical.Truncation.Propositional.MagicTrick.html#1026" class="Function">a</a><a id="1087" class="Symbol">)</a> <a id="1089" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1091" href="Cubical.Truncation.Propositional.MagicTrick.html#1064" class="Bound">B∙</a>
  <a id="1096" href="Cubical.Truncation.Propositional.MagicTrick.html#1039" class="Function">toEquivPtd</a> <a id="1107" class="Symbol">=</a> <a id="1109" href="Cubical.Truncation.Propositional.Properties.html#882" class="Function">rec</a> <a id="1113" href="Cubical.Foundations.Prelude.html#19062" class="Function">isPropSingl</a> <a id="1125" class="Symbol">(λ</a> <a id="1128" href="Cubical.Truncation.Propositional.MagicTrick.html#1128" class="Bound">x</a> <a id="1130" class="Symbol">→</a> <a id="1132" class="Symbol">(</a><a id="1133" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a> <a id="1135" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1137" href="Cubical.Truncation.Propositional.MagicTrick.html#1128" class="Bound">x</a><a id="1138" class="Symbol">)</a> <a id="1140" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1142" href="Cubical.Truncation.Propositional.MagicTrick.html#969" class="Bound">h</a> <a id="1144" href="Cubical.Truncation.Propositional.MagicTrick.html#1128" class="Bound">x</a><a id="1145" class="Symbol">)</a>
  <a id="1149" class="Keyword">private</a>
    <a id="Recover.B∙"></a><a id="1161" href="Cubical.Truncation.Propositional.MagicTrick.html#1161" class="Function">B∙</a> <a id="1164" class="Symbol">:</a> <a id="1166" href="Cubical.Truncation.Propositional.Base.html#245" class="Datatype Operator">∥</a> <a id="1168" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a> <a id="1170" href="Cubical.Truncation.Propositional.Base.html#245" class="Datatype Operator">∥₁</a> <a id="1173" class="Symbol">→</a> <a id="1175" href="Cubical.Foundations.Pointed.Base.html#464" class="Function">Pointed</a> <a id="1183" href="Cubical.Truncation.Propositional.MagicTrick.html#948" class="Bound">ℓ</a>
    <a id="1189" href="Cubical.Truncation.Propositional.MagicTrick.html#1161" class="Function">B∙</a> <a id="1192" href="Cubical.Truncation.Propositional.MagicTrick.html#1192" class="Bound">tx</a> <a id="1195" class="Symbol">=</a> <a id="1197" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="1201" class="Symbol">(</a><a id="1202" href="Cubical.Truncation.Propositional.MagicTrick.html#1039" class="Function">toEquivPtd</a> <a id="1213" href="Cubical.Truncation.Propositional.MagicTrick.html#1192" class="Bound">tx</a><a id="1215" class="Symbol">)</a>

  <a id="1220" class="Comment">-- the key observation is that B∙ ∣ x ∣₁ is definitionally equal to (A , x)</a>
  <a id="1298" class="Keyword">private</a>
    <a id="Recover.obvs"></a><a id="1310" href="Cubical.Truncation.Propositional.MagicTrick.html#1310" class="Function">obvs</a> <a id="1315" class="Symbol">:</a> <a id="1317" class="Symbol">∀</a> <a id="1319" href="Cubical.Truncation.Propositional.MagicTrick.html#1319" class="Bound">x</a> <a id="1321" class="Symbol">→</a> <a id="1323" href="Cubical.Truncation.Propositional.MagicTrick.html#1161" class="Function">B∙</a> <a id="1326" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣</a> <a id="1328" href="Cubical.Truncation.Propositional.MagicTrick.html#1319" class="Bound">x</a> <a id="1330" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣₁</a> <a id="1333" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1335" class="Symbol">(</a><a id="1336" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a> <a id="1338" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1340" href="Cubical.Truncation.Propositional.MagicTrick.html#1319" class="Bound">x</a><a id="1341" class="Symbol">)</a>
    <a id="1347" href="Cubical.Truncation.Propositional.MagicTrick.html#1310" class="Function">obvs</a> <a id="1352" href="Cubical.Truncation.Propositional.MagicTrick.html#1352" class="Bound">x</a> <a id="1354" class="Symbol">=</a> <a id="1356" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a> <a id="1361" class="Comment">-- try it: `C-c C-n B∙ ∣ x ∣₁` gives `(A , x)`</a>

  <a id="1411" class="Comment">-- thus any truncated element (of a homogeneous type) can be recovered by agda&#39;s normalizer!</a>

  <a id="Recover.recover"></a><a id="1507" href="Cubical.Truncation.Propositional.MagicTrick.html#1507" class="Function">recover</a> <a id="1515" class="Symbol">:</a> <a id="1517" class="Symbol">∀</a> <a id="1519" class="Symbol">(</a><a id="1520" href="Cubical.Truncation.Propositional.MagicTrick.html#1520" class="Bound">tx</a> <a id="1523" class="Symbol">:</a> <a id="1525" href="Cubical.Truncation.Propositional.Base.html#245" class="Datatype Operator">∥</a> <a id="1527" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a> <a id="1529" href="Cubical.Truncation.Propositional.Base.html#245" class="Datatype Operator">∥₁</a><a id="1531" class="Symbol">)</a> <a id="1533" class="Symbol">→</a> <a id="1535" href="Cubical.Foundations.Structure.html#514" class="Function">typ</a> <a id="1539" class="Symbol">(</a><a id="1540" href="Cubical.Truncation.Propositional.MagicTrick.html#1161" class="Function">B∙</a> <a id="1543" href="Cubical.Truncation.Propositional.MagicTrick.html#1520" class="Bound">tx</a><a id="1545" class="Symbol">)</a>
  <a id="1549" href="Cubical.Truncation.Propositional.MagicTrick.html#1507" class="Function">recover</a> <a id="1557" href="Cubical.Truncation.Propositional.MagicTrick.html#1557" class="Bound">tx</a> <a id="1560" class="Symbol">=</a> <a id="1562" href="Cubical.Foundations.Pointed.Base.html#540" class="Function">pt</a> <a id="1565" class="Symbol">(</a><a id="1566" href="Cubical.Truncation.Propositional.MagicTrick.html#1161" class="Function">B∙</a> <a id="1569" href="Cubical.Truncation.Propositional.MagicTrick.html#1557" class="Bound">tx</a><a id="1571" class="Symbol">)</a>

  <a id="Recover.recover∣∣"></a><a id="1576" href="Cubical.Truncation.Propositional.MagicTrick.html#1576" class="Function">recover∣∣</a> <a id="1586" class="Symbol">:</a> <a id="1588" class="Symbol">∀</a> <a id="1590" class="Symbol">(</a><a id="1591" href="Cubical.Truncation.Propositional.MagicTrick.html#1591" class="Bound">x</a> <a id="1593" class="Symbol">:</a> <a id="1595" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a><a id="1596" class="Symbol">)</a> <a id="1598" class="Symbol">→</a> <a id="1600" href="Cubical.Truncation.Propositional.MagicTrick.html#1507" class="Function">recover</a> <a id="1608" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣</a> <a id="1610" href="Cubical.Truncation.Propositional.MagicTrick.html#1591" class="Bound">x</a> <a id="1612" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣₁</a> <a id="1615" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1617" href="Cubical.Truncation.Propositional.MagicTrick.html#1591" class="Bound">x</a>
  <a id="1621" href="Cubical.Truncation.Propositional.MagicTrick.html#1576" class="Function">recover∣∣</a> <a id="1631" href="Cubical.Truncation.Propositional.MagicTrick.html#1631" class="Bound">x</a> <a id="1633" class="Symbol">=</a> <a id="1635" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a> <a id="1640" class="Comment">-- try it: `C-c C-n recover ∣ x ∣₁` gives `x`</a>

  <a id="1689" class="Keyword">private</a>
    <a id="1701" class="Comment">-- notice that the following typechecks because typ (B∙ ∣ x ∣₁) is definitionally equal to to A, but</a>
    <a id="1806" class="Comment">--  `recover : ∥ A ∥₁ → A` does not because typ (B∙ tx) is not definitionally equal to A (though it is</a>
    <a id="1913" class="Comment">--  judegmentally equal to A by cong typ (snd (toEquivPtd tx)) : A ≡ typ (B∙ tx))</a>
    <a id="Recover.obvs2"></a><a id="1999" href="Cubical.Truncation.Propositional.MagicTrick.html#1999" class="Function">obvs2</a> <a id="2005" class="Symbol">:</a> <a id="2007" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a> <a id="2009" class="Symbol">→</a> <a id="2011" href="Cubical.Truncation.Propositional.MagicTrick.html#1011" class="Function">A</a>
    <a id="2017" href="Cubical.Truncation.Propositional.MagicTrick.html#1999" class="Function">obvs2</a> <a id="2023" class="Symbol">=</a> <a id="2025" href="Cubical.Truncation.Propositional.MagicTrick.html#1507" class="Function">recover</a> <a id="2033" href="Cubical.Foundations.Function.html#653" class="Function Operator">∘</a> <a id="2035" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣_∣₁</a>

    <a id="2045" class="Comment">-- one might wonder if (cong recover (squash₁ ∣ x ∣₁ ∣ y ∣₁)) therefore has type x ≡ y, but thankfully</a>
    <a id="2152" class="Comment">--  typ (B∙ (squash₁ ∣ x ∣₁ ∣ y ∣₁ i)) is *not* A (it&#39;s a messy hcomp involving h x and h y)</a>
    <a id="Recover.recover-squash₁"></a><a id="2249" href="Cubical.Truncation.Propositional.MagicTrick.html#2249" class="Function">recover-squash₁</a> <a id="2265" class="Symbol">:</a> <a id="2267" class="Symbol">∀</a> <a id="2269" href="Cubical.Truncation.Propositional.MagicTrick.html#2269" class="Bound">x</a> <a id="2271" href="Cubical.Truncation.Propositional.MagicTrick.html#2271" class="Bound">y</a> <a id="2273" class="Symbol">→</a> <a id="2275" class="Comment">-- x ≡ y -- this raises an error</a>
                             <a id="2337" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="2343" class="Symbol">(λ</a> <a id="2346" href="Cubical.Truncation.Propositional.MagicTrick.html#2346" class="Bound">i</a> <a id="2348" class="Symbol">→</a> <a id="2350" href="Cubical.Foundations.Structure.html#514" class="Function">typ</a> <a id="2354" class="Symbol">(</a><a id="2355" href="Cubical.Truncation.Propositional.MagicTrick.html#1161" class="Function">B∙</a> <a id="2358" class="Symbol">(</a><a id="2359" href="Cubical.Truncation.Propositional.Base.html#304" class="InductiveConstructor">squash₁</a> <a id="2367" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣</a> <a id="2369" href="Cubical.Truncation.Propositional.MagicTrick.html#2269" class="Bound">x</a> <a id="2371" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣₁</a> <a id="2374" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣</a> <a id="2376" href="Cubical.Truncation.Propositional.MagicTrick.html#2271" class="Bound">y</a> <a id="2378" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣₁</a> <a id="2381" href="Cubical.Truncation.Propositional.MagicTrick.html#2346" class="Bound">i</a><a id="2382" class="Symbol">)))</a> <a id="2386" href="Cubical.Truncation.Propositional.MagicTrick.html#2269" class="Bound">x</a> <a id="2388" href="Cubical.Truncation.Propositional.MagicTrick.html#2271" class="Bound">y</a>
    <a id="2394" href="Cubical.Truncation.Propositional.MagicTrick.html#2249" class="Function">recover-squash₁</a> <a id="2410" href="Cubical.Truncation.Propositional.MagicTrick.html#2410" class="Bound">x</a> <a id="2412" href="Cubical.Truncation.Propositional.MagicTrick.html#2412" class="Bound">y</a> <a id="2414" class="Symbol">=</a> <a id="2416" href="Cubical.Foundations.Prelude.html#1430" class="Function">cong</a> <a id="2421" href="Cubical.Truncation.Propositional.MagicTrick.html#1507" class="Function">recover</a> <a id="2429" class="Symbol">(</a><a id="2430" href="Cubical.Truncation.Propositional.Base.html#304" class="InductiveConstructor">squash₁</a> <a id="2438" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣</a> <a id="2440" href="Cubical.Truncation.Propositional.MagicTrick.html#2410" class="Bound">x</a> <a id="2442" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣₁</a> <a id="2445" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣</a> <a id="2447" href="Cubical.Truncation.Propositional.MagicTrick.html#2412" class="Bound">y</a> <a id="2449" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣₁</a><a id="2451" class="Symbol">)</a>


<a id="2455" class="Comment">-- Demo, adapted from:</a>
<a id="2478" class="Comment">-- https://bitbucket.org/nicolaikraus/agda/src/e30d70c72c6af8e62b72eefabcc57623dd921f04/trunc-inverse.lagda</a>

<a id="2587" class="Keyword">private</a>
  <a id="2597" class="Keyword">open</a> <a id="2602" class="Keyword">import</a> <a id="2609" href="Cubical.Data.Nat.html" class="Module">Cubical.Data.Nat</a>
  <a id="2628" class="Keyword">open</a> <a id="2633" class="Keyword">module</a> <a id="2640" class="Symbol">@</a><a id="2641" class="Symbol">0</a> <a id="R"></a><a id="2643" href="Cubical.Truncation.Propositional.MagicTrick.html#2643" class="Module">R</a> <a id="2645" class="Symbol">=</a> <a id="2647" href="Cubical.Truncation.Propositional.MagicTrick.html#939" class="Module">Recover</a> <a id="2655" class="Symbol">(</a><a id="2656" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2658" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2660" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="2664" class="Symbol">)</a> <a id="2666" class="Symbol">(</a><a id="2667" href="Cubical.Foundations.Pointed.Homogeneous.html#8583" class="Function">isHomogeneousDiscrete</a> <a id="2689" href="Cubical.Data.Nat.Properties.html#3348" class="Function">discreteℕ</a><a id="2698" class="Symbol">)</a>

  <a id="2703" class="Comment">-- only `∣hidden∣` is exported, `hidden` is no longer in scope</a>
  <a id="2768" class="Keyword">module</a> <a id="2775" href="Cubical.Truncation.Propositional.MagicTrick.html#2775" class="Module">_</a> <a id="2777" class="Keyword">where</a>
    <a id="2787" class="Keyword">private</a>
      <a id="2801" href="Cubical.Truncation.Propositional.MagicTrick.html#2801" class="Function">hidden</a> <a id="2808" class="Symbol">:</a> <a id="2810" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
      <a id="2818" href="Cubical.Truncation.Propositional.MagicTrick.html#2801" class="Function">hidden</a> <a id="2825" class="Symbol">=</a> <a id="2827" class="Number">17</a>

    <a id="2835" href="Cubical.Truncation.Propositional.MagicTrick.html#2835" class="Function">∣hidden∣</a> <a id="2844" class="Symbol">:</a> <a id="2846" href="Cubical.Truncation.Propositional.Base.html#245" class="Datatype Operator">∥</a> <a id="2848" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2850" href="Cubical.Truncation.Propositional.Base.html#245" class="Datatype Operator">∥₁</a>
    <a id="2857" href="Cubical.Truncation.Propositional.MagicTrick.html#2835" class="Function">∣hidden∣</a> <a id="2866" class="Symbol">=</a> <a id="2868" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣</a> <a id="2870" href="Cubical.Truncation.Propositional.MagicTrick.html#2801" class="Function">hidden</a> <a id="2877" href="Cubical.Truncation.Propositional.Base.html#284" class="InductiveConstructor Operator">∣₁</a>

  <a id="2883" class="Comment">-- we can still recover the value, even though agda can no longer see `hidden`!</a>
  <a id="test"></a><a id="2965" href="Cubical.Truncation.Propositional.MagicTrick.html#2965" class="Function">test</a> <a id="2970" class="Symbol">:</a> <a id="2972" href="Cubical.Truncation.Propositional.MagicTrick.html#1507" class="Function">recover</a> <a id="2980" href="Cubical.Truncation.Propositional.MagicTrick.html#2835" class="Function">∣hidden∣</a> <a id="2989" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2991" class="Number">17</a>
  <a id="2996" href="Cubical.Truncation.Propositional.MagicTrick.html#2965" class="Function">test</a> <a id="3001" class="Symbol">=</a> <a id="3003" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a> <a id="3008" class="Comment">-- try it: `C-c C-n recover ∣hidden∣` gives `17`</a>
              <a id="3071" class="Comment">--         `C-c C-n hidden` gives an error</a>

  <a id="3117" class="Comment">-- Finally, note that the definition of recover is independent of the proof that A is homogeneous. Thus we</a>
  <a id="3226" class="Comment">--  still can definitionally recover information hidden by ∣_∣₁ as long as we permit holes. Try replacing</a>
  <a id="3334" class="Comment">--  `isHomogeneousDiscrete discreteℕ` above with a hole (`?`) and notice that everything still works</a>
</pre></body></html>