<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Structures.FinSet</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Keyword">module</a> <a id="31" href="Structures.FinSet.html" class="Module">Structures.FinSet</a> <a id="49" class="Keyword">where</a>

<a id="56" class="Keyword">open</a> <a id="61" class="Keyword">import</a> <a id="68" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="85" class="Keyword">open</a> <a id="90" class="Keyword">import</a> <a id="97" href="Foundations.Sigma.html" class="Module">Foundations.Sigma</a>

<a id="116" class="Keyword">open</a> <a id="121" class="Keyword">import</a> <a id="128" href="Meta.Idiom.html" class="Module">Meta.Idiom</a>
<a id="139" class="Keyword">open</a> <a id="144" class="Keyword">import</a> <a id="151" href="Meta.Discrete.html" class="Module">Meta.Discrete</a>
<a id="165" class="Keyword">open</a> <a id="170" class="Keyword">import</a> <a id="177" href="Meta.HLevel.html" class="Module">Meta.HLevel</a>
<a id="189" class="Keyword">open</a> <a id="194" class="Keyword">import</a> <a id="201" href="Meta.Finite.html" class="Module">Meta.Finite</a>     <a id="217" class="Keyword">public</a>
<a id="224" class="Keyword">open</a> <a id="229" class="Keyword">import</a> <a id="236" href="Meta.Underlying.html" class="Module">Meta.Underlying</a> <a id="252" class="Keyword">public</a>

<a id="260" class="Keyword">open</a> <a id="265" class="Keyword">import</a> <a id="272" href="Structures.n-Type.html" class="Module">Structures.n-Type</a>

<a id="291" class="Keyword">open</a> <a id="296" class="Keyword">import</a> <a id="303" href="Correspondences.Nullary.Omniscience.html" class="Module">Correspondences.Nullary.Omniscience</a>
<a id="339" class="Keyword">open</a> <a id="344" class="Keyword">import</a> <a id="351" href="Correspondences.Unary.Decidable.html" class="Module">Correspondences.Unary.Decidable</a>

<a id="384" class="Keyword">import</a>      <a id="396" href="Data.Dec.Base.html" class="Module">Data.Dec.Base</a> <a id="410" class="Symbol">as</a> <a id="413" class="Module">Dec</a>
<a id="417" class="Keyword">open</a> <a id="422" class="Keyword">import</a> <a id="429" href="Data.Dec.Properties.html" class="Module">Data.Dec.Properties</a>
<a id="449" class="Keyword">open</a> <a id="454" class="Keyword">import</a> <a id="461" href="Data.Dec.Instances.HLevel.html" class="Module">Data.Dec.Instances.HLevel</a>
<a id="487" class="Keyword">open</a> <a id="492" class="Keyword">import</a> <a id="499" href="Data.Empty.html" class="Module">Data.Empty</a>
<a id="510" class="Keyword">open</a> <a id="515" class="Keyword">import</a> <a id="522" href="Data.Fin.html" class="Module">Data.Fin</a>
<a id="531" class="Keyword">open</a> <a id="536" class="Keyword">import</a> <a id="543" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="552" class="Keyword">open</a> <a id="557" class="Keyword">import</a> <a id="564" href="Data.Vec.html" class="Module">Data.Vec</a>
<a id="573" class="Keyword">open</a> <a id="578" class="Keyword">import</a> <a id="585" href="Data.Vec.Correspondences.Unary.Any.html" class="Module">Data.Vec.Correspondences.Unary.Any</a>

<a id="621" class="Keyword">import</a> <a id="628" href="Truncation.Propositional.html" class="Module">Truncation.Propositional</a> <a id="653" class="Symbol">as</a> <a id="656" class="Module">∥-∥₁</a>
<a id="661" class="Keyword">open</a> <a id="666" href="Truncation.Propositional.html" class="Module">∥-∥₁</a>

<a id="672" class="Keyword">private</a> <a id="680" class="Keyword">variable</a>
  <a id="691" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a> <a id="693" href="Structures.FinSet.html#693" class="Generalizable">ℓ′</a> <a id="696" class="Symbol">:</a> <a id="698" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="706" href="Structures.FinSet.html#706" class="Generalizable">A</a> <a id="708" class="Symbol">:</a> <a id="710" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="715" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a>

<a id="Fin-ordered"></a><a id="718" href="Structures.FinSet.html#718" class="Function">Fin-ordered</a> <a id="730" class="Symbol">:</a> <a id="732" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="737" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a> <a id="739" class="Symbol">→</a> <a id="741" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="746" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a>
<a id="748" href="Structures.FinSet.html#718" class="Function">Fin-ordered</a> <a id="760" href="Structures.FinSet.html#760" class="Bound">A</a> <a id="762" class="Symbol">=</a> <a id="764" href="Foundations.Sigma.Base.html#152" class="Function">Σ[</a> <a id="767" href="Structures.FinSet.html#767" class="Bound">n</a> <a id="769" href="Foundations.Sigma.Base.html#152" class="Function">꞉</a> <a id="771" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="773" href="Foundations.Sigma.Base.html#152" class="Function">]</a> <a id="775" href="Structures.FinSet.html#760" class="Bound">A</a> <a id="777" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="779" href="Data.Fin.Base.html#184" class="Datatype">Fin</a> <a id="783" href="Structures.FinSet.html#767" class="Bound">n</a>

<a id="fin-ordered-is-set"></a><a id="786" href="Structures.FinSet.html#786" class="Function">fin-ordered-is-set</a> <a id="805" class="Symbol">:</a> <a id="807" href="Foundations.Base.html#12851" class="Function">is-set</a> <a id="814" class="Symbol">(</a><a id="815" href="Structures.FinSet.html#718" class="Function">Fin-ordered</a> <a id="827" href="Structures.FinSet.html#706" class="Generalizable">A</a><a id="828" class="Symbol">)</a>
<a id="830" href="Structures.FinSet.html#786" class="Function">fin-ordered-is-set</a> <a id="849" class="Symbol">=</a> <a id="851" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a>

<a id="is-fin-set"></a><a id="860" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="871" class="Symbol">:</a> <a id="873" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="878" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a> <a id="880" class="Symbol">→</a> <a id="882" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="887" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a>
<a id="889" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="900" href="Structures.FinSet.html#900" class="Bound">A</a> <a id="902" class="Symbol">=</a> <a id="904" href="Foundations.Sigma.Base.html#152" class="Function">Σ[</a> <a id="907" href="Structures.FinSet.html#907" class="Bound">n</a> <a id="909" href="Foundations.Sigma.Base.html#152" class="Function">꞉</a> <a id="911" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="913" href="Foundations.Sigma.Base.html#152" class="Function">]</a> <a id="915" href="Truncation.Propositional.Base.html#139" class="Datatype Operator">∥</a> <a id="917" href="Structures.FinSet.html#900" class="Bound">A</a> <a id="919" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="921" href="Data.Fin.Base.html#184" class="Datatype">Fin</a> <a id="925" href="Structures.FinSet.html#907" class="Bound">n</a> <a id="927" href="Truncation.Propositional.Base.html#139" class="Datatype Operator">∥₁</a>

<a id="is-fin-set-is-prop"></a><a id="931" href="Structures.FinSet.html#931" class="Function">is-fin-set-is-prop</a> <a id="950" class="Symbol">:</a> <a id="952" href="Foundations.Base.html#12782" class="Function">is-prop</a> <a id="960" class="Symbol">(</a><a id="961" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="972" href="Structures.FinSet.html#706" class="Generalizable">A</a><a id="973" class="Symbol">)</a>
<a id="975" href="Structures.FinSet.html#931" class="Function">is-fin-set-is-prop</a> <a id="994" class="Symbol">(</a><a id="995" href="Structures.FinSet.html#995" class="Bound">m</a> <a id="997" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="999" href="Structures.FinSet.html#999" class="Bound">∣p∣₁</a><a id="1003" class="Symbol">)</a> <a id="1005" class="Symbol">(</a><a id="1006" href="Structures.FinSet.html#1006" class="Bound">n</a> <a id="1008" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1010" href="Structures.FinSet.html#1010" class="Bound">∣q∣₁</a><a id="1014" class="Symbol">)</a> <a id="1016" class="Symbol">=</a>
  <a id="1020" href="Foundations.Sigma.Properties.html#4592" class="Function">Σ-prop-path-equiv</a> <a id="1038" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a> <a id="1046" class="Symbol">.</a><a id="1047" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="1051" href="Foundations.Pi.Base.html#813" class="Function Operator">$</a>
    <a id="1057" href="Truncation.Propositional.Properties.html#316" class="Function">∥-∥₁.elim₂</a> <a id="1068" class="Symbol">(λ</a> <a id="1071" href="Structures.FinSet.html#1071" class="Bound">_</a> <a id="1073" href="Structures.FinSet.html#1073" class="Bound">_</a> <a id="1075" class="Symbol">→</a> <a id="1077" href="Data.Nat.Path.html#1135" class="Function">ℕ-is-set</a> <a id="1086" href="Structures.FinSet.html#995" class="Bound">m</a> <a id="1088" href="Structures.FinSet.html#1006" class="Bound">n</a><a id="1089" class="Symbol">)</a>
               <a id="1106" class="Symbol">(λ</a> <a id="1109" href="Structures.FinSet.html#1109" class="Bound">p</a> <a id="1111" href="Structures.FinSet.html#1111" class="Bound">q</a> <a id="1113" class="Symbol">→</a> <a id="1115" href="Data.Fin.Properties.html#4419" class="Function">fin-injective</a> <a id="1129" class="Symbol">((</a><a id="1131" href="Structures.FinSet.html#1109" class="Bound">p</a> <a id="1133" href="Foundations.Equiv.Properties.html#332" class="Function Operator">ₑ⁻¹</a><a id="1136" class="Symbol">)</a> <a id="1138" href="Foundations.Equiv.Base.html#3636" class="Function Operator">∙ₑ</a> <a id="1141" href="Structures.FinSet.html#1111" class="Bound">q</a><a id="1142" class="Symbol">))</a>
               <a id="1160" href="Structures.FinSet.html#999" class="Bound">∣p∣₁</a>
               <a id="1180" href="Structures.FinSet.html#1010" class="Bound">∣q∣₁</a>

<a id="Finite→is-fin-set"></a><a id="1186" href="Structures.FinSet.html#1186" class="Function">Finite→is-fin-set</a> <a id="1204" class="Symbol">:</a> <a id="1206" href="Meta.Finite.html#505" class="Record">Finite</a> <a id="1213" href="Structures.FinSet.html#706" class="Generalizable">A</a> <a id="1215" class="Symbol">→</a> <a id="1217" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="1228" href="Structures.FinSet.html#706" class="Generalizable">A</a>
<a id="1230" href="Structures.FinSet.html#1186" class="Function">Finite→is-fin-set</a> <a id="1248" href="Structures.FinSet.html#1248" class="Bound">A-fin</a> <a id="1254" class="Symbol">=</a> <a id="1256" href="Structures.FinSet.html#1248" class="Bound">A-fin</a> <a id="1262" class="Symbol">.</a><a id="1263" href="Meta.Finite.html#575" class="Field">cardinality</a> <a id="1275" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1277" href="Structures.FinSet.html#1248" class="Bound">A-fin</a> <a id="1283" class="Symbol">.</a><a id="1284" href="Meta.Finite.html#596" class="Field">enumeration</a>

<a id="is-fin-set→is-set"></a><a id="1297" href="Structures.FinSet.html#1297" class="Function">is-fin-set→is-set</a> <a id="1315" class="Symbol">:</a> <a id="1317" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="1328" href="Structures.FinSet.html#706" class="Generalizable">A</a> <a id="1330" class="Symbol">→</a> <a id="1332" href="Foundations.Base.html#12851" class="Function">is-set</a> <a id="1339" href="Structures.FinSet.html#706" class="Generalizable">A</a>
<a id="1341" href="Structures.FinSet.html#1297" class="Function">is-fin-set→is-set</a> <a id="1359" class="Symbol">(_</a> <a id="1362" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1364" href="Structures.FinSet.html#1364" class="Bound">∣e∣₁</a><a id="1368" class="Symbol">)</a> <a id="1370" class="Symbol">=</a>
  <a id="1374" href="Truncation.Propositional.Base.html#295" class="Function">∥-∥₁.rec</a> <a id="1383" class="Symbol">(</a><a id="1384" href="Foundations.HLevel.Base.html#4600" class="Function">is-of-hlevel-is-prop</a> <a id="1405" class="Number">2</a><a id="1406" class="Symbol">)</a> <a id="1408" class="Symbol">(λ</a> <a id="1411" href="Structures.FinSet.html#1411" class="Bound">e</a> <a id="1413" class="Symbol">→</a> <a id="1415" href="Foundations.HLevel.Retracts.html#2387" class="Function">is-of-hlevel-≃</a> <a id="1430" class="Number">2</a> <a id="1432" href="Structures.FinSet.html#1411" class="Bound">e</a> <a id="1434" href="Meta.HLevel.Reflection.html#24464" class="Macro">hlevel!</a><a id="1441" class="Symbol">)</a> <a id="1443" href="Structures.FinSet.html#1364" class="Bound">∣e∣₁</a>

<a id="fin-ordered→is-fin-set"></a><a id="1449" href="Structures.FinSet.html#1449" class="Function">fin-ordered→is-fin-set</a> <a id="1472" class="Symbol">:</a> <a id="1474" href="Structures.FinSet.html#718" class="Function">Fin-ordered</a> <a id="1486" href="Structures.FinSet.html#706" class="Generalizable">A</a> <a id="1488" class="Symbol">→</a> <a id="1490" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="1501" href="Structures.FinSet.html#706" class="Generalizable">A</a>
<a id="1503" href="Structures.FinSet.html#1449" class="Function">fin-ordered→is-fin-set</a> <a id="1526" class="Symbol">(</a><a id="1527" href="Structures.FinSet.html#1527" class="Bound">n</a> <a id="1529" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1531" href="Structures.FinSet.html#1531" class="Bound">e</a><a id="1532" class="Symbol">)</a> <a id="1534" class="Symbol">=</a> <a id="1536" href="Structures.FinSet.html#1527" class="Bound">n</a> <a id="1538" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1540" href="Truncation.Propositional.Base.html#178" class="InductiveConstructor Operator">∣</a> <a id="1542" href="Structures.FinSet.html#1531" class="Bound">e</a> <a id="1544" href="Truncation.Propositional.Base.html#178" class="InductiveConstructor Operator">∣₁</a>

<a id="1548" class="Comment">-- TODO</a>
<a id="1556" class="Comment">-- fin-set→is-discrete : is-fin-set A → is-discrete A</a>
<a id="1610" class="Comment">-- fin-set→is-discrete A-f = {!!}</a>

<a id="fin-ordered→omniscient"></a><a id="1645" href="Structures.FinSet.html#1645" class="Function">fin-ordered→omniscient</a> <a id="1668" class="Symbol">:</a> <a id="1670" href="Structures.FinSet.html#718" class="Function">Fin-ordered</a> <a id="1682" href="Structures.FinSet.html#706" class="Generalizable">A</a> <a id="1684" class="Symbol">→</a> <a id="1686" href="Correspondences.Nullary.Omniscience.html#605" class="Function">Omniscient</a> <a id="1697" class="Symbol">{</a><a id="1698" class="Argument">ℓ′</a> <a id="1701" class="Symbol">=</a> <a id="1703" href="Structures.FinSet.html#693" class="Generalizable">ℓ′</a><a id="1705" class="Symbol">}</a> <a id="1707" href="Structures.FinSet.html#706" class="Generalizable">A</a>
<a id="1709" href="Structures.FinSet.html#1645" class="Function">fin-ordered→omniscient</a> <a id="1732" class="Symbol">{</a><a id="1733" href="Structures.FinSet.html#1733" class="Bound">A</a><a id="1734" class="Symbol">}</a> <a id="1736" class="Symbol">(</a><a id="1737" href="Structures.FinSet.html#1737" class="Bound">n</a> <a id="1739" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1741" href="Structures.FinSet.html#1741" class="Bound">aeq</a><a id="1744" class="Symbol">)</a> <a id="1746" class="Symbol">{</a><a id="1747" href="Structures.FinSet.html#1747" class="Bound">P</a><a id="1748" class="Symbol">}</a> <a id="1750" href="Structures.FinSet.html#1750" class="Bound">P?</a> <a id="1753" class="Symbol">=</a>
  <a id="1757" href="Data.Dec.Base.html#1545" class="Function">Dec.map</a> <a id="1765" href="Structures.FinSet.html#1926" class="Function">lemma₁</a> <a id="1772" href="Structures.FinSet.html#1979" class="Function">lemma₂</a> <a id="1779" class="Symbol">(</a><a id="1780" href="Data.Vec.Correspondences.Unary.Any.html#450" class="Function">any?</a> <a id="1785" href="Structures.FinSet.html#1750" class="Bound">P?</a> <a id="1788" href="Structures.FinSet.html#1865" class="Function">xs</a><a id="1790" class="Symbol">)</a> <a id="1792" class="Keyword">where</a>
    <a id="1802" class="Keyword">module</a> <a id="1809" href="Structures.FinSet.html#1809" class="Module">Ã</a> <a id="1812" class="Symbol">=</a> <a id="1814" href="Foundations.Equiv.Properties.html#1827" class="Module">Equiv</a> <a id="1820" href="Structures.FinSet.html#1741" class="Bound">aeq</a>
    <a id="1828" class="Keyword">module</a> <a id="1835" href="Structures.FinSet.html#1835" class="Module">Ṽ</a> <a id="1838" class="Symbol">=</a> <a id="1840" href="Foundations.Equiv.Properties.html#1827" class="Module">Equiv</a> <a id="1846" href="Data.Vec.Properties.html#966" class="Function">vec-fun-equiv</a>

    <a id="1865" href="Structures.FinSet.html#1865" class="Function">xs</a> <a id="1868" class="Symbol">:</a> <a id="1870" href="Data.Vec.Base.html#232" class="Datatype">Vec</a> <a id="1874" href="Structures.FinSet.html#1733" class="Bound">A</a> <a id="1876" href="Structures.FinSet.html#1737" class="Bound">n</a>
    <a id="1882" href="Structures.FinSet.html#1865" class="Function">xs</a> <a id="1885" class="Symbol">=</a> <a id="1887" href="Foundations.Equiv.Properties.html#2298" class="Function">Ṽ.inverse</a> <a id="1898" class="Symbol">.</a><a id="1899" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="1903" href="Foundations.Pi.Base.html#813" class="Function Operator">$</a> <a id="1905" href="Foundations.Equiv.Properties.html#2298" class="Function">Ã.inverse</a> <a id="1916" class="Symbol">.</a><a id="1917" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>

    <a id="1926" href="Structures.FinSet.html#1926" class="Function">lemma₁</a> <a id="1933" class="Symbol">:</a> <a id="1935" class="Symbol">_</a>
    <a id="1941" href="Structures.FinSet.html#1926" class="Function">lemma₁</a> <a id="1948" class="Symbol">(</a><a id="1949" href="Structures.FinSet.html#1949" class="Bound">i</a> <a id="1951" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1953" href="Structures.FinSet.html#1953" class="Bound">p</a><a id="1954" class="Symbol">)</a> <a id="1956" class="Symbol">=</a> <a id="1958" href="Data.Vec.Properties.html#844" class="Function">lookup</a> <a id="1965" href="Structures.FinSet.html#1865" class="Function">xs</a> <a id="1968" href="Structures.FinSet.html#1949" class="Bound">i</a> <a id="1970" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1972" href="Structures.FinSet.html#1953" class="Bound">p</a>

    <a id="1979" href="Structures.FinSet.html#1979" class="Function">lemma₂</a> <a id="1986" class="Symbol">:</a> <a id="1988" class="Symbol">_</a>
    <a id="1994" href="Structures.FinSet.html#1979" class="Function">lemma₂</a> <a id="2001" href="Structures.FinSet.html#2001" class="Bound">¬p</a> <a id="2004" class="Symbol">(</a><a id="2005" href="Structures.FinSet.html#2005" class="Bound">a</a> <a id="2007" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2009" href="Structures.FinSet.html#2009" class="Bound">pa</a><a id="2011" class="Symbol">)</a> <a id="2013" class="Symbol">=</a> <a id="2015" href="Structures.FinSet.html#2001" class="Bound">¬p</a> <a id="2018" href="Foundations.Pi.Base.html#813" class="Function Operator">$</a> <a id="2020" href="Foundations.Equiv.Properties.html#1853" class="Function">Ã.to</a> <a id="2026" href="Structures.FinSet.html#2005" class="Bound">a</a> <a id="2028" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2030" href="Foundations.Base.html#10677" class="Function">subst</a> <a id="2036" href="Structures.FinSet.html#1747" class="Bound">P</a> <a id="2038" class="Symbol">(</a><a id="2039" href="Foundations.Prim.Kan.html#1527" class="Function">sym</a> <a id="2043" class="Symbol">(</a><a id="2044" href="Foundations.Base.html#11932" class="Function">happly</a> <a id="2051" class="Symbol">(</a><a id="2052" href="Foundations.Equiv.Properties.html#1931" class="Function">Ṽ.ε</a> <a id="2057" class="Symbol">_)</a> <a id="2060" class="Symbol">_</a> <a id="2062" href="Foundations.Base.html#5663" class="Function Operator">∙</a> <a id="2064" href="Foundations.Equiv.Properties.html#1902" class="Function">Ã.η</a> <a id="2069" href="Structures.FinSet.html#2005" class="Bound">a</a><a id="2070" class="Symbol">))</a> <a id="2073" href="Structures.FinSet.html#2009" class="Bound">pa</a>

<a id="is-fin-set→omniscient₁"></a><a id="2077" href="Structures.FinSet.html#2077" class="Function">is-fin-set→omniscient₁</a> <a id="2100" class="Symbol">:</a> <a id="2102" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="2113" href="Structures.FinSet.html#706" class="Generalizable">A</a> <a id="2115" class="Symbol">→</a> <a id="2117" href="Correspondences.Nullary.Omniscience.html#1116" class="Function">Omniscient₁</a> <a id="2129" class="Symbol">{</a><a id="2130" class="Argument">ℓ′</a> <a id="2133" class="Symbol">=</a> <a id="2135" href="Structures.FinSet.html#693" class="Generalizable">ℓ′</a><a id="2137" class="Symbol">}</a> <a id="2139" href="Structures.FinSet.html#706" class="Generalizable">A</a>
<a id="2141" href="Structures.FinSet.html#2077" class="Function">is-fin-set→omniscient₁</a> <a id="2164" class="Symbol">{</a><a id="2165" href="Structures.FinSet.html#2165" class="Bound">A</a><a id="2166" class="Symbol">}</a> <a id="2168" class="Symbol">(</a><a id="2169" href="Structures.FinSet.html#2169" class="Bound">n</a> <a id="2171" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2173" href="Structures.FinSet.html#2173" class="Bound">∣aeq∣₁</a><a id="2179" class="Symbol">)</a> <a id="2181" class="Symbol">{</a><a id="2182" href="Structures.FinSet.html#2182" class="Bound">P</a><a id="2183" class="Symbol">}</a> <a id="2185" class="Symbol">=</a> <a id="2187" href="Truncation.Propositional.Properties.html#1041" class="Function">∥-∥₁.elim!</a> <a id="2198" href="Structures.FinSet.html#2229" class="Function">go</a> <a id="2201" class="Symbol">((</a><a id="2203" href="Structures.FinSet.html#2169" class="Bound">n</a> <a id="2205" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,_</a><a id="2207" class="Symbol">)</a> <a id="2209" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="2213" href="Structures.FinSet.html#2173" class="Bound">∣aeq∣₁</a><a id="2219" class="Symbol">)</a> <a id="2221" class="Keyword">where</a>
  <a id="2229" href="Structures.FinSet.html#2229" class="Function">go</a> <a id="2232" class="Symbol">:</a> <a id="2234" href="Foundations.Pi.Base.html#146" class="Function">Π[</a> <a id="2237" href="Structures.FinSet.html#2237" class="Bound">A-f</a> <a id="2241" href="Foundations.Pi.Base.html#146" class="Function">꞉</a> <a id="2243" href="Structures.FinSet.html#718" class="Function">Fin-ordered</a> <a id="2255" href="Structures.FinSet.html#2165" class="Bound">A</a> <a id="2257" href="Foundations.Pi.Base.html#146" class="Function">]</a> <a id="2259" class="Symbol">(</a><a id="2260" href="Correspondences.Unary.Decidable.html#316" class="Function">Decidable₁</a> <a id="2271" href="Structures.FinSet.html#2182" class="Bound">P</a> <a id="2273" class="Symbol">→</a> <a id="2275" href="Data.Dec.Base.html#1340" class="Record">Dec</a> <a id="2279" href="Truncation.Propositional.Base.html#139" class="Datatype Operator">∥</a> <a id="2281" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2283" href="Structures.FinSet.html#2165" class="Bound">A</a> <a id="2285" class="Symbol">_</a> <a id="2287" href="Truncation.Propositional.Base.html#139" class="Datatype Operator">∥₁</a><a id="2289" class="Symbol">)</a>
  <a id="2293" href="Structures.FinSet.html#2229" class="Function">go</a> <a id="2296" href="Structures.FinSet.html#2296" class="Bound">A-f</a> <a id="2300" class="Symbol">=</a> <a id="2302" href="Data.Dec.Base.html#1545" class="Function">Dec.map</a> <a id="2310" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="2315" href="Truncation.Propositional.Properties.html#910" class="Function">rec!</a> <a id="2320" href="Foundations.Pi.Base.html#906" class="Function Operator">∘</a> <a id="2322" href="Structures.FinSet.html#1645" class="Function">fin-ordered→omniscient</a> <a id="2345" href="Structures.FinSet.html#2296" class="Bound">A-f</a>

<a id="is-fin-set→exhaustible₁"></a><a id="2350" href="Structures.FinSet.html#2350" class="Function">is-fin-set→exhaustible₁</a> <a id="2374" class="Symbol">:</a> <a id="2376" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="2387" href="Structures.FinSet.html#706" class="Generalizable">A</a> <a id="2389" class="Symbol">→</a> <a id="2391" href="Correspondences.Nullary.Omniscience.html#971" class="Function">Exhaustible₁</a> <a id="2404" class="Symbol">{</a><a id="2405" class="Argument">ℓ′</a> <a id="2408" class="Symbol">=</a> <a id="2410" href="Structures.FinSet.html#693" class="Generalizable">ℓ′</a><a id="2412" class="Symbol">}</a> <a id="2414" href="Structures.FinSet.html#706" class="Generalizable">A</a>
<a id="2416" href="Structures.FinSet.html#2350" class="Function">is-fin-set→exhaustible₁</a> <a id="2440" class="Symbol">=</a> <a id="2442" href="Correspondences.Nullary.Omniscience.html#1278" class="Function">omniscient₁→exhaustible₁</a> <a id="2467" href="Foundations.Pi.Base.html#906" class="Function Operator">∘</a> <a id="2469" href="Structures.FinSet.html#2077" class="Function">is-fin-set→omniscient₁</a>

<a id="2493" class="Comment">-- is-fin-set→omniscient</a>
<a id="2518" class="Comment">--   : is-fin-set A → {P : Pred₁ ℓ′ A} → Decidable₁ P → Dec (Σ[ a ꞉ A ] ⌞ P a ⌟)</a>
<a id="2599" class="Comment">-- is-fin-set→omniscient A-fin P? with is-fin-set→omniscient₁ A-fin P?</a>
<a id="2670" class="Comment">-- ... | yes p = yes {!!}</a>
<a id="2696" class="Comment">-- ... | no ¬p = {!!}</a>

<a id="2719" class="Comment">-- is-fin-set→exhaustible₁</a>
<a id="2746" class="Comment">--   : is-fin-set A → {P : Pred₁ ℓ′ A} → Decidable₁ P → Dec (Π[ a ꞉ A ] ⌞ P a ⌟)</a>
<a id="2827" class="Comment">-- is-fin-set→exhaustible₁ A-fin {P} P? =</a>
<a id="2869" class="Comment">--   let z = omniscient₁→exhaustible₁ (is-fin-set→omniscient₁ A-fin) P?</a>
<a id="2941" class="Comment">-- --       w = ∥-∥₁.proj (Finite-choice ⦃ {!!} ⦄ λ x → (dec-∥-∥₁-equiv ₑ⁻¹) .fst x)</a>
<a id="3026" class="Comment">--   in omniscient→exhaustible {!!} P?</a>
<a id="3065" class="Comment">-- --     in ∥-∥₁.proj {!Finite-choice ? ?!} -- ((dec-∥-∥₁-equiv ₑ⁻¹) .fst z)</a>

<a id="3144" class="Keyword">record</a> <a id="FinSet"></a><a id="3151" href="Structures.FinSet.html#3151" class="Record">FinSet</a> <a id="3158" href="Structures.FinSet.html#3158" class="Bound">ℓ</a> <a id="3160" class="Symbol">:</a> <a id="3162" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3167" class="Symbol">(</a><a id="3168" href="Foundations.Prim.Type.html#375" class="Primitive">ℓsuc</a> <a id="3173" href="Structures.FinSet.html#3158" class="Bound">ℓ</a><a id="3174" class="Symbol">)</a> <a id="3176" class="Keyword">where</a>
  <a id="3184" class="Keyword">no-eta-equality</a>
  <a id="3202" class="Keyword">constructor</a> <a id="fin-set"></a><a id="3214" href="Structures.FinSet.html#3214" class="InductiveConstructor">fin-set</a>
  <a id="3224" class="Keyword">field</a>
    <a id="FinSet.typ"></a><a id="3234" href="Structures.FinSet.html#3234" class="Field">typ</a>            <a id="3249" class="Symbol">:</a> <a id="3251" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3256" href="Structures.FinSet.html#3158" class="Bound">ℓ</a>
    <a id="FinSet.has-is-fin-set"></a><a id="3262" href="Structures.FinSet.html#3262" class="Field">has-is-fin-set</a> <a id="3277" class="Symbol">:</a> <a id="3279" href="Structures.FinSet.html#860" class="Function">is-fin-set</a> <a id="3290" href="Structures.FinSet.html#3234" class="Field">typ</a>
  <a id="3296" class="Keyword">instance</a>
    <a id="FinSet.Finite-FinSet"></a><a id="3309" href="Structures.FinSet.html#3309" class="Function">Finite-FinSet</a> <a id="3323" class="Symbol">:</a> <a id="3325" href="Meta.Finite.html#505" class="Record">Finite</a> <a id="3332" href="Structures.FinSet.html#3234" class="Field">typ</a>
    <a id="3340" href="Structures.FinSet.html#3309" class="Function">Finite-FinSet</a> <a id="3354" class="Symbol">=</a> <a id="3356" href="Meta.Finite.html#558" class="InductiveConstructor">fin</a> <a id="3360" href="Foundations.Pi.Base.html#813" class="Function Operator">$</a> <a id="3362" href="Structures.FinSet.html#3262" class="Field">has-is-fin-set</a> <a id="3377" class="Symbol">.</a><a id="3378" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>

    <a id="FinSet.H-Level-FinSet"></a><a id="3387" href="Structures.FinSet.html#3387" class="Function">H-Level-FinSet</a> <a id="3402" class="Symbol">:</a> <a id="3404" class="Symbol">∀</a> <a id="3406" class="Symbol">{</a><a id="3407" href="Structures.FinSet.html#3407" class="Bound">n</a><a id="3408" class="Symbol">}</a> <a id="3410" class="Symbol">→</a> <a id="3412" href="Meta.HLevel.Base.html#186" class="Record">H-Level</a> <a id="3420" class="Symbol">(</a><a id="3421" class="Number">2</a> <a id="3423" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3425" href="Structures.FinSet.html#3407" class="Bound">n</a><a id="3426" class="Symbol">)</a> <a id="3428" href="Structures.FinSet.html#3234" class="Field">typ</a>
    <a id="3436" href="Structures.FinSet.html#3387" class="Function">H-Level-FinSet</a> <a id="3451" class="Symbol">=</a> <a id="3453" href="Meta.HLevel.Base.html#559" class="Function">basic-instance</a> <a id="3468" class="Number">2</a> <a id="3470" class="Symbol">(</a><a id="3471" href="Structures.FinSet.html#1297" class="Function">is-fin-set→is-set</a> <a id="3489" href="Structures.FinSet.html#3262" class="Field">has-is-fin-set</a><a id="3503" class="Symbol">)</a>

<a id="3506" class="Keyword">open</a> <a id="3511" href="Structures.FinSet.html#3151" class="Module">FinSet</a> <a id="3518" class="Keyword">public</a>
  <a id="3527" class="Keyword">using</a> <a id="3533" class="Symbol">(</a><a id="3534" href="Structures.FinSet.html#3309" class="Function">Finite-FinSet</a><a id="3547" class="Symbol">;</a> <a id="3549" href="Structures.FinSet.html#3387" class="Function">H-Level-FinSet</a><a id="3563" class="Symbol">)</a>
<a id="3565" class="Keyword">open</a> <a id="3570" href="Structures.FinSet.html#3151" class="Module">FinSet</a> <a id="3577" class="Keyword">using</a> <a id="3583" class="Symbol">(</a><a id="3584" href="Structures.FinSet.html#3234" class="Field">typ</a><a id="3587" class="Symbol">;</a> <a id="3589" href="Structures.FinSet.html#3262" class="Field">has-is-fin-set</a><a id="3603" class="Symbol">)</a>

<a id="fin-set!"></a><a id="3606" href="Structures.FinSet.html#3606" class="Function">fin-set!</a> <a id="3615" class="Symbol">:</a> <a id="3617" class="Symbol">(</a><a id="3618" href="Structures.FinSet.html#3618" class="Bound">A</a> <a id="3620" class="Symbol">:</a> <a id="3622" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3627" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a><a id="3628" class="Symbol">)</a> <a id="3630" class="Symbol">→</a> <a id="3632" class="Symbol">⦃</a> <a id="3634" href="Meta.Finite.html#505" class="Record">Finite</a> <a id="3641" href="Structures.FinSet.html#3618" class="Bound">A</a> <a id="3643" class="Symbol">⦄</a> <a id="3645" class="Symbol">→</a> <a id="3647" href="Structures.FinSet.html#3151" class="Record">FinSet</a> <a id="3654" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a>
<a id="3656" href="Structures.FinSet.html#3606" class="Function">fin-set!</a> <a id="3665" href="Structures.FinSet.html#3665" class="Bound">A</a> <a id="3667" class="Symbol">⦃</a> <a id="3669" class="Symbol">(</a><a id="3670" href="Structures.FinSet.html#3670" class="Bound">A-fin</a><a id="3675" class="Symbol">)</a> <a id="3677" class="Symbol">⦄</a> <a id="3679" class="Symbol">=</a> <a id="3681" href="Structures.FinSet.html#3214" class="InductiveConstructor">fin-set</a> <a id="3689" href="Structures.FinSet.html#3665" class="Bound">A</a> <a id="3691" class="Symbol">(</a><a id="3692" href="Structures.FinSet.html#1186" class="Function">Finite→is-fin-set</a> <a id="3710" href="Structures.FinSet.html#3670" class="Bound">A-fin</a><a id="3715" class="Symbol">)</a>

<a id="3718" class="Keyword">instance</a>
  <a id="Underlying-FinSet"></a><a id="3729" href="Structures.FinSet.html#3729" class="Function">Underlying-FinSet</a> <a id="3747" class="Symbol">:</a> <a id="3749" href="Meta.Underlying.html#91" class="Record">Underlying</a> <a id="3760" class="Symbol">(</a><a id="3761" href="Structures.FinSet.html#3151" class="Record">FinSet</a> <a id="3768" href="Structures.FinSet.html#691" class="Generalizable">ℓ</a><a id="3769" class="Symbol">)</a>
  <a id="3773" href="Structures.FinSet.html#3729" class="Function">Underlying-FinSet</a> <a id="3791" class="Symbol">{</a><a id="3792" href="Structures.FinSet.html#3792" class="Bound">ℓ</a><a id="3793" class="Symbol">}</a> <a id="3795" class="Symbol">.</a><a id="3796" href="Meta.Underlying.html#145" class="Field">Underlying.ℓ-underlying</a> <a id="3820" class="Symbol">=</a> <a id="3822" href="Structures.FinSet.html#3792" class="Bound">ℓ</a>
  <a id="3826" href="Structures.FinSet.html#3729" class="Function">Underlying-FinSet</a> <a id="3844" class="Symbol">.</a><a id="3845" href="Meta.Underlying.html#170" class="Field Operator">⌞_⌟</a> <a id="3849" class="Symbol">=</a> <a id="3851" href="Structures.FinSet.html#3234" class="Field">typ</a>


<a id="3857" class="Comment">-- TODO</a>
<a id="3865" class="Comment">-- fin-set-path : ⌞ X ⌟ ＝ ⌞ Y ⌟ → X ＝ Y</a>
<a id="3905" class="Comment">-- fin-set-path f i .typ = f i</a>
<a id="3936" class="Comment">-- fin-set-path {X} {Y} f i .has-is-fin-set = {!!} , {!!}</a>
<a id="3994" class="Comment">--   -- is-prop→pathP (λ i → is-of-hlevel-is-prop {A = f i} _) (X .is-tr) (Y .is-tr) i</a>

<a id="4082" class="Comment">-- @0 fin-set-ua : ⌞ X ⌟ ≃ ⌞ Y ⌟ → X ＝ Y</a>
<a id="4123" class="Comment">-- fin-set-ua f = n-path (ua f)</a>

<a id="4156" class="Comment">-- @0 fin-set-univalence : {X Y : n-Type ℓ n} → (⌞ X ⌟ ≃ ⌞ Y ⌟) ≃ (X ＝ Y)</a>
<a id="4230" class="Comment">-- fin-set-univalence {n} {X} {Y} = n-ua , is-iso→is-equiv isic where</a>
<a id="4300" class="Comment">--   inv : ∀ {Y} → X ＝ Y → ⌞ X ⌟ ≃ ⌞ Y ⌟</a>
<a id="4341" class="Comment">--   inv p = path→equiv (ap typ p)</a>

<a id="4377" class="Comment">--   linv : ∀ {Y} → (inv {Y}) is-left-inverse-of n-ua</a>
<a id="4431" class="Comment">--   linv x = Σ-prop-path is-equiv-is-prop (fun-ext λ x → transport-refl _)</a>

<a id="4508" class="Comment">--   rinv : ∀ {Y} → (inv {Y}) is-right-inverse-of n-ua</a>
<a id="4563" class="Comment">--   rinv = J (λ y p → n-ua (inv p) ＝ p) path where</a>
<a id="4615" class="Comment">--     path : n-ua (inv {X} refl) ＝ refl</a>
<a id="4656" class="Comment">--     path i j .typ = ua.ε refl i j</a>
<a id="4693" class="Comment">--     path i j .is-tr = is-prop→SquareP</a>
<a id="4734" class="Comment">--       (λ i j → is-of-hlevel-is-prop</a>
<a id="4773" class="Comment">--         {A = ua.ε {A = ⌞ X ⌟} refl i j } n)</a>
<a id="4820" class="Comment">--       (λ j → X .is-tr) (λ j → n-ua {X = X} {Y = X} (path→equiv refl) j .is-tr)</a>
<a id="4902" class="Comment">--       (λ j → X .is-tr) (λ j → X .is-tr)</a>
<a id="4945" class="Comment">--       i j</a>

<a id="4959" class="Comment">--   isic : is-iso n-ua</a>
<a id="4983" class="Comment">--   isic = iso inv rinv (linv {Y})</a>

<a id="5020" class="Comment">-- @0 fin-set-is-of-hlevel : ∀ n → is-of-hlevel (suc n) (n-Type ℓ n)</a>
<a id="5089" class="Comment">-- fin-set-is-of-hlevel zero x y = n-ua</a>
<a id="5129" class="Comment">--   ((λ _ → y .is-tr .fst) , is-contr→is-equiv (x .is-tr) (y .is-tr))</a>
<a id="5200" class="Comment">-- fin-set-is-of-hlevel (suc n) x y =</a>
<a id="5238" class="Comment">--   is-of-hlevel-≃ (suc n) (n-univalence ₑ⁻¹) (≃-is-of-hlevel (suc n) (x .is-tr) (y .is-tr))</a>

<a id="5333" class="Comment">-- instance</a>
<a id="5345" class="Comment">--   @0 H-Level-nType : ∀ {n k} → H-Level (1 + k + n) (n-Type ℓ k)</a>
<a id="5412" class="Comment">--   H-Level-nType {k} = basic-instance (1 + k) (n-Type-is-of-hlevel k)</a>

<a id="5485" class="Comment">--   H-Level-is-equiv</a>
<a id="5507" class="Comment">--     : {f : A → B} {n : HLevel}</a>
<a id="5541" class="Comment">--     → H-Level (suc n) (is-equiv f)</a>
<a id="5579" class="Comment">--   H-Level-is-equiv = prop-instance (is-equiv-is-prop _)</a>

<a id="5639" class="Comment">-- module _ {ℓ : Level} where private</a>
<a id="5677" class="Comment">--   open import Foundations.Univalence.SIP</a>
<a id="5721" class="Comment">--   _ : FinSet ℓ ≃ Type-with {S = is-fin-set} (HomT→Str λ _ _ _ → ⊤)</a>
<a id="5791" class="Comment">--   _ = iso→equiv the-iso</a>
<a id="5818" class="Comment">--     where</a>
<a id="5831" class="Comment">--       open import Meta.Reflection.Record</a>
<a id="5875" class="Comment">--       the-iso : Iso (FinSet ℓ) (Σ[ T ꞉ Type ℓ ] is-fin-set T)</a>
<a id="5940" class="Comment">--       unquoteDef the-iso = define-record-iso the-iso (quote FinSet)</a>
</pre></body></html>