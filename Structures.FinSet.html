<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Structures.FinSet</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Keyword">module</a> <a id="31" href="Structures.FinSet.html" class="Module">Structures.FinSet</a> <a id="49" class="Keyword">where</a>

<a id="56" class="Keyword">open</a> <a id="61" class="Keyword">import</a> <a id="68" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="85" class="Keyword">open</a> <a id="90" class="Keyword">import</a> <a id="97" href="Foundations.Sigma.html" class="Module">Foundations.Sigma</a>

<a id="116" class="Keyword">open</a> <a id="121" class="Keyword">import</a> <a id="128" href="Meta.Idiom.html" class="Module">Meta.Idiom</a>
<a id="139" class="Keyword">open</a> <a id="144" class="Keyword">import</a> <a id="151" href="Meta.Decision.html" class="Module">Meta.Decision</a>
<a id="165" class="Keyword">open</a> <a id="170" class="Keyword">import</a> <a id="177" href="Meta.HLevel.html" class="Module">Meta.HLevel</a>
<a id="189" class="Keyword">open</a> <a id="194" class="Keyword">import</a> <a id="201" href="Meta.Finite.html" class="Module">Meta.Finite</a>     <a id="217" class="Keyword">public</a>
<a id="224" class="Keyword">open</a> <a id="229" class="Keyword">import</a> <a id="236" href="Meta.Underlying.html" class="Module">Meta.Underlying</a> <a id="252" class="Keyword">public</a>

<a id="260" class="Keyword">open</a> <a id="265" class="Keyword">import</a> <a id="272" href="Structures.n-Type.html" class="Module">Structures.n-Type</a>

<a id="291" class="Keyword">open</a> <a id="296" class="Keyword">import</a> <a id="303" href="Correspondences.Nullary.Omniscience.html" class="Module">Correspondences.Nullary.Omniscience</a>
<a id="339" class="Keyword">open</a> <a id="344" class="Keyword">import</a> <a id="351" href="Correspondences.Unary.Decidable.html" class="Module">Correspondences.Unary.Decidable</a>

<a id="384" class="Keyword">import</a>      <a id="396" href="Data.Dec.Base.html" class="Module">Data.Dec.Base</a> <a id="410" class="Symbol">as</a> <a id="413" class="Module">Dec</a>
<a id="417" class="Keyword">open</a> <a id="422" href="Data.Dec.Base.html" class="Module">Dec</a>
<a id="426" class="Keyword">open</a> <a id="431" class="Keyword">import</a> <a id="438" href="Data.Dec.Properties.html" class="Module">Data.Dec.Properties</a>
<a id="458" class="Keyword">open</a> <a id="463" class="Keyword">import</a> <a id="470" href="Data.Dec.Instances.HLevel.html" class="Module">Data.Dec.Instances.HLevel</a>
<a id="496" class="Keyword">open</a> <a id="501" class="Keyword">import</a> <a id="508" href="Data.Empty.html" class="Module">Data.Empty</a>
<a id="519" class="Keyword">open</a> <a id="524" class="Keyword">import</a> <a id="531" href="Data.Fin.html" class="Module">Data.Fin</a>
<a id="540" class="Keyword">open</a> <a id="545" class="Keyword">import</a> <a id="552" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="561" class="Keyword">open</a> <a id="566" class="Keyword">import</a> <a id="573" href="Data.Vec.html" class="Module">Data.Vec</a>
<a id="582" class="Keyword">open</a> <a id="587" class="Keyword">import</a> <a id="594" href="Data.Vec.Correspondences.Unary.Any.html" class="Module">Data.Vec.Correspondences.Unary.Any</a>

<a id="630" class="Keyword">import</a> <a id="637" href="Truncation.Propositional.html" class="Module">Truncation.Propositional</a> <a id="662" class="Symbol">as</a> <a id="665" class="Module">∥-∥₁</a>
<a id="670" class="Keyword">open</a> <a id="675" href="Truncation.Propositional.html" class="Module">∥-∥₁</a>

<a id="681" class="Keyword">private</a> <a id="689" class="Keyword">variable</a>
  <a id="700" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a> <a id="702" href="Structures.FinSet.html#702" class="Generalizable">ℓ′</a> <a id="705" class="Symbol">:</a> <a id="707" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="715" href="Structures.FinSet.html#715" class="Generalizable">A</a> <a id="717" class="Symbol">:</a> <a id="719" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="724" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a>

<a id="Fin-ordered"></a><a id="727" href="Structures.FinSet.html#727" class="Function">Fin-ordered</a> <a id="739" class="Symbol">:</a> <a id="741" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="746" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a> <a id="748" class="Symbol">→</a> <a id="750" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="755" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a>
<a id="757" href="Structures.FinSet.html#727" class="Function">Fin-ordered</a> <a id="769" href="Structures.FinSet.html#769" class="Bound">A</a> <a id="771" class="Symbol">=</a> <a id="773" href="Foundations.Sigma.Base.html#152" class="Function">Σ[</a> <a id="776" href="Structures.FinSet.html#776" class="Bound">n</a> <a id="778" href="Foundations.Sigma.Base.html#152" class="Function">꞉</a> <a id="780" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="782" href="Foundations.Sigma.Base.html#152" class="Function">]</a> <a id="784" class="Symbol">(</a><a id="785" href="Structures.FinSet.html#769" class="Bound">A</a> <a id="787" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="789" href="Data.Fin.Base.html#187" class="Datatype">Fin</a> <a id="793" href="Structures.FinSet.html#776" class="Bound">n</a><a id="794" class="Symbol">)</a>

<a id="fin-ordered-is-set"></a><a id="797" href="Structures.FinSet.html#797" class="Function">fin-ordered-is-set</a> <a id="816" class="Symbol">:</a> <a id="818" href="Foundations.Base.html#12852" class="Function">is-set</a> <a id="825" class="Symbol">(</a><a id="826" href="Structures.FinSet.html#727" class="Function">Fin-ordered</a> <a id="838" href="Structures.FinSet.html#715" class="Generalizable">A</a><a id="839" class="Symbol">)</a>
<a id="841" href="Structures.FinSet.html#797" class="Function">fin-ordered-is-set</a> <a id="860" class="Symbol">=</a> <a id="862" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a>

<a id="is-fin-set"></a><a id="871" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="882" class="Symbol">:</a> <a id="884" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="889" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a> <a id="891" class="Symbol">→</a> <a id="893" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="898" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a>
<a id="900" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="911" href="Structures.FinSet.html#911" class="Bound">A</a> <a id="913" class="Symbol">=</a> <a id="915" href="Foundations.Sigma.Base.html#152" class="Function">Σ[</a> <a id="918" href="Structures.FinSet.html#918" class="Bound">n</a> <a id="920" href="Foundations.Sigma.Base.html#152" class="Function">꞉</a> <a id="922" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="924" href="Foundations.Sigma.Base.html#152" class="Function">]</a> <a id="926" href="Truncation.Propositional.Base.html#139" class="Datatype Operator">∥</a> <a id="928" href="Structures.FinSet.html#911" class="Bound">A</a> <a id="930" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="932" href="Data.Fin.Base.html#187" class="Datatype">Fin</a> <a id="936" href="Structures.FinSet.html#918" class="Bound">n</a> <a id="938" href="Truncation.Propositional.Base.html#139" class="Datatype Operator">∥₁</a>

<a id="is-fin-set-is-prop"></a><a id="942" href="Structures.FinSet.html#942" class="Function">is-fin-set-is-prop</a> <a id="961" class="Symbol">:</a> <a id="963" href="Foundations.Base.html#12783" class="Function">is-prop</a> <a id="971" class="Symbol">(</a><a id="972" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="983" href="Structures.FinSet.html#715" class="Generalizable">A</a><a id="984" class="Symbol">)</a>
<a id="986" href="Structures.FinSet.html#942" class="Function">is-fin-set-is-prop</a> <a id="1005" class="Symbol">(</a><a id="1006" href="Structures.FinSet.html#1006" class="Bound">m</a> <a id="1008" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1010" href="Structures.FinSet.html#1010" class="Bound">∣p∣₁</a><a id="1014" class="Symbol">)</a> <a id="1016" class="Symbol">(</a><a id="1017" href="Structures.FinSet.html#1017" class="Bound">n</a> <a id="1019" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1021" href="Structures.FinSet.html#1021" class="Bound">∣q∣₁</a><a id="1025" class="Symbol">)</a> <a id="1027" class="Symbol">=</a>
  <a id="1031" href="Foundations.Sigma.Properties.html#4626" class="Function">Σ-prop-path-equiv</a> <a id="1049" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a> <a id="1057" class="Symbol">.</a><a id="1058" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="1062" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
    <a id="1068" href="Truncation.Propositional.Properties.html#316" class="Function">∥-∥₁.elim₂</a> <a id="1079" class="Symbol">(λ</a> <a id="1082" href="Structures.FinSet.html#1082" class="Bound">_</a> <a id="1084" href="Structures.FinSet.html#1084" class="Bound">_</a> <a id="1086" class="Symbol">→</a> <a id="1088" href="Data.Nat.Path.html#1089" class="Function">ℕ-is-set</a> <a id="1097" href="Structures.FinSet.html#1006" class="Bound">m</a> <a id="1099" href="Structures.FinSet.html#1017" class="Bound">n</a><a id="1100" class="Symbol">)</a>
               <a id="1117" class="Symbol">(λ</a> <a id="1120" href="Structures.FinSet.html#1120" class="Bound">p</a> <a id="1122" href="Structures.FinSet.html#1122" class="Bound">q</a> <a id="1124" class="Symbol">→</a> <a id="1126" href="Data.Fin.Properties.html#4317" class="Function">fin-injective</a> <a id="1140" class="Symbol">((</a><a id="1142" href="Structures.FinSet.html#1120" class="Bound">p</a> <a id="1144" href="Foundations.Equiv.Properties.html#332" class="Function Operator">ₑ⁻¹</a><a id="1147" class="Symbol">)</a> <a id="1149" href="Foundations.Equiv.Base.html#3628" class="Function Operator">∙ₑ</a> <a id="1152" href="Structures.FinSet.html#1122" class="Bound">q</a><a id="1153" class="Symbol">))</a>
               <a id="1171" href="Structures.FinSet.html#1010" class="Bound">∣p∣₁</a>
               <a id="1191" href="Structures.FinSet.html#1021" class="Bound">∣q∣₁</a>

<a id="Finite→is-fin-set"></a><a id="1197" href="Structures.FinSet.html#1197" class="Function">Finite→is-fin-set</a> <a id="1215" class="Symbol">:</a> <a id="1217" href="Meta.Finite.html#505" class="Record">Finite</a> <a id="1224" href="Structures.FinSet.html#715" class="Generalizable">A</a> <a id="1226" class="Symbol">→</a> <a id="1228" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="1239" href="Structures.FinSet.html#715" class="Generalizable">A</a>
<a id="1241" href="Structures.FinSet.html#1197" class="Function">Finite→is-fin-set</a> <a id="1259" href="Structures.FinSet.html#1259" class="Bound">A-fin</a> <a id="1265" class="Symbol">=</a> <a id="1267" href="Structures.FinSet.html#1259" class="Bound">A-fin</a> <a id="1273" class="Symbol">.</a><a id="1274" href="Meta.Finite.html#575" class="Field">cardinality</a> <a id="1286" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1288" href="Structures.FinSet.html#1259" class="Bound">A-fin</a> <a id="1294" class="Symbol">.</a><a id="1295" href="Meta.Finite.html#596" class="Field">enumeration</a>

<a id="is-fin-set→is-set"></a><a id="1308" href="Structures.FinSet.html#1308" class="Function">is-fin-set→is-set</a> <a id="1326" class="Symbol">:</a> <a id="1328" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="1339" href="Structures.FinSet.html#715" class="Generalizable">A</a> <a id="1341" class="Symbol">→</a> <a id="1343" href="Foundations.Base.html#12852" class="Function">is-set</a> <a id="1350" href="Structures.FinSet.html#715" class="Generalizable">A</a>
<a id="1352" href="Structures.FinSet.html#1308" class="Function">is-fin-set→is-set</a> <a id="1370" class="Symbol">(_</a> <a id="1373" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1375" href="Structures.FinSet.html#1375" class="Bound">∣e∣₁</a><a id="1379" class="Symbol">)</a> <a id="1381" class="Symbol">=</a>
  <a id="1385" href="Truncation.Propositional.Base.html#295" class="Function">∥-∥₁.rec</a> <a id="1394" class="Symbol">(</a><a id="1395" href="Foundations.HLevel.Base.html#4578" class="Function">is-of-hlevel-is-prop</a> <a id="1416" class="Number">2</a><a id="1417" class="Symbol">)</a> <a id="1419" class="Symbol">(λ</a> <a id="1422" href="Structures.FinSet.html#1422" class="Bound">e</a> <a id="1424" class="Symbol">→</a> <a id="1426" href="Foundations.HLevel.Retracts.html#2387" class="Function">is-of-hlevel-≃</a> <a id="1441" class="Number">2</a> <a id="1443" href="Structures.FinSet.html#1422" class="Bound">e</a> <a id="1445" href="Meta.HLevel.Reflection.html#24463" class="Macro">hlevel!</a><a id="1452" class="Symbol">)</a> <a id="1454" href="Structures.FinSet.html#1375" class="Bound">∣e∣₁</a>

<a id="fin-ordered→is-fin-set"></a><a id="1460" href="Structures.FinSet.html#1460" class="Function">fin-ordered→is-fin-set</a> <a id="1483" class="Symbol">:</a> <a id="1485" href="Structures.FinSet.html#727" class="Function">Fin-ordered</a> <a id="1497" href="Structures.FinSet.html#715" class="Generalizable">A</a> <a id="1499" class="Symbol">→</a> <a id="1501" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="1512" href="Structures.FinSet.html#715" class="Generalizable">A</a>
<a id="1514" href="Structures.FinSet.html#1460" class="Function">fin-ordered→is-fin-set</a> <a id="1537" class="Symbol">(</a><a id="1538" href="Structures.FinSet.html#1538" class="Bound">n</a> <a id="1540" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1542" href="Structures.FinSet.html#1542" class="Bound">e</a><a id="1543" class="Symbol">)</a> <a id="1545" class="Symbol">=</a> <a id="1547" href="Structures.FinSet.html#1538" class="Bound">n</a> <a id="1549" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1551" href="Truncation.Propositional.Base.html#178" class="InductiveConstructor Operator">∣</a> <a id="1553" href="Structures.FinSet.html#1542" class="Bound">e</a> <a id="1555" href="Truncation.Propositional.Base.html#178" class="InductiveConstructor Operator">∣₁</a>

<a id="1559" class="Comment">-- TODO</a>
<a id="1567" class="Comment">-- fin-set→is-discrete : is-fin-set A → is-discrete A</a>
<a id="1621" class="Comment">-- fin-set→is-discrete A-f = {!!}</a>

<a id="fin-ordered→omniscient"></a><a id="1656" href="Structures.FinSet.html#1656" class="Function">fin-ordered→omniscient</a> <a id="1679" class="Symbol">:</a> <a id="1681" href="Structures.FinSet.html#727" class="Function">Fin-ordered</a> <a id="1693" href="Structures.FinSet.html#715" class="Generalizable">A</a> <a id="1695" class="Symbol">→</a> <a id="1697" href="Correspondences.Nullary.Omniscience.html#674" class="Function">Omniscient</a> <a id="1708" class="Symbol">{</a><a id="1709" class="Argument">ℓ′</a> <a id="1712" class="Symbol">=</a> <a id="1714" href="Structures.FinSet.html#702" class="Generalizable">ℓ′</a><a id="1716" class="Symbol">}</a> <a id="1718" href="Structures.FinSet.html#715" class="Generalizable">A</a>
<a id="1720" href="Structures.FinSet.html#1656" class="Function">fin-ordered→omniscient</a> <a id="1743" class="Symbol">{</a><a id="1744" href="Structures.FinSet.html#1744" class="Bound">A</a><a id="1745" class="Symbol">}</a> <a id="1747" class="Symbol">(</a><a id="1748" href="Structures.FinSet.html#1748" class="Bound">n</a> <a id="1750" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1752" href="Structures.FinSet.html#1752" class="Bound">aeq</a><a id="1755" class="Symbol">)</a> <a id="1757" class="Symbol">{</a><a id="1758" href="Structures.FinSet.html#1758" class="Bound">P</a><a id="1759" class="Symbol">}</a> <a id="1761" href="Structures.FinSet.html#1761" class="Bound">P?</a> <a id="1764" class="Symbol">=</a>
  <a id="1768" href="Data.Dec.Base.html#1513" class="Function">Dec.map</a> <a id="1776" href="Structures.FinSet.html#1937" class="Function">lemma₁</a> <a id="1783" href="Structures.FinSet.html#1990" class="Function">lemma₂</a> <a id="1790" class="Symbol">(</a><a id="1791" href="Data.Vec.Correspondences.Unary.Any.html#450" class="Function">any?</a> <a id="1796" href="Structures.FinSet.html#1761" class="Bound">P?</a> <a id="1799" href="Structures.FinSet.html#1876" class="Function">xs</a><a id="1801" class="Symbol">)</a> <a id="1803" class="Keyword">where</a>
    <a id="1813" class="Keyword">module</a> <a id="1820" href="Structures.FinSet.html#1820" class="Module">Ã</a> <a id="1823" class="Symbol">=</a> <a id="1825" href="Foundations.Equiv.Properties.html#1827" class="Module">Equiv</a> <a id="1831" href="Structures.FinSet.html#1752" class="Bound">aeq</a>
    <a id="1839" class="Keyword">module</a> <a id="1846" href="Structures.FinSet.html#1846" class="Module">Ṽ</a> <a id="1849" class="Symbol">=</a> <a id="1851" href="Foundations.Equiv.Properties.html#1827" class="Module">Equiv</a> <a id="1857" href="Data.Vec.Properties.html#966" class="Function">vec-fun-equiv</a>

    <a id="1876" href="Structures.FinSet.html#1876" class="Function">xs</a> <a id="1879" class="Symbol">:</a> <a id="1881" href="Data.Vec.Base.html#232" class="Datatype">Vec</a> <a id="1885" href="Structures.FinSet.html#1744" class="Bound">A</a> <a id="1887" href="Structures.FinSet.html#1748" class="Bound">n</a>
    <a id="1893" href="Structures.FinSet.html#1876" class="Function">xs</a> <a id="1896" class="Symbol">=</a> <a id="1898" href="Foundations.Equiv.Properties.html#2298" class="Function">Ṽ.inverse</a> <a id="1909" class="Symbol">.</a><a id="1910" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="1914" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="1916" href="Foundations.Equiv.Properties.html#2298" class="Function">Ã.inverse</a> <a id="1927" class="Symbol">.</a><a id="1928" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>

    <a id="1937" href="Structures.FinSet.html#1937" class="Function">lemma₁</a> <a id="1944" class="Symbol">:</a> <a id="1946" class="Symbol">_</a>
    <a id="1952" href="Structures.FinSet.html#1937" class="Function">lemma₁</a> <a id="1959" class="Symbol">(</a><a id="1960" href="Structures.FinSet.html#1960" class="Bound">i</a> <a id="1962" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1964" href="Structures.FinSet.html#1964" class="Bound">p</a><a id="1965" class="Symbol">)</a> <a id="1967" class="Symbol">=</a> <a id="1969" href="Data.Vec.Properties.html#844" class="Function">lookup</a> <a id="1976" href="Structures.FinSet.html#1876" class="Function">xs</a> <a id="1979" href="Structures.FinSet.html#1960" class="Bound">i</a> <a id="1981" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1983" href="Structures.FinSet.html#1964" class="Bound">p</a>

    <a id="1990" href="Structures.FinSet.html#1990" class="Function">lemma₂</a> <a id="1997" class="Symbol">:</a> <a id="1999" class="Symbol">_</a>
    <a id="2005" href="Structures.FinSet.html#1990" class="Function">lemma₂</a> <a id="2012" href="Structures.FinSet.html#2012" class="Bound">¬p</a> <a id="2015" class="Symbol">(</a><a id="2016" href="Structures.FinSet.html#2016" class="Bound">a</a> <a id="2018" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2020" href="Structures.FinSet.html#2020" class="Bound">pa</a><a id="2022" class="Symbol">)</a> <a id="2024" class="Symbol">=</a> <a id="2026" href="Structures.FinSet.html#2012" class="Bound">¬p</a> <a id="2029" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="2031" href="Foundations.Equiv.Properties.html#1853" class="Function">Ã.to</a> <a id="2037" href="Structures.FinSet.html#2016" class="Bound">a</a> <a id="2039" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2041" href="Foundations.Base.html#10678" class="Function">subst</a> <a id="2047" href="Structures.FinSet.html#1758" class="Bound">P</a> <a id="2049" class="Symbol">(</a><a id="2050" href="Foundations.Prim.Kan.html#1519" class="Function">sym</a> <a id="2054" class="Symbol">(</a><a id="2055" href="Foundations.Base.html#11933" class="Function">happly</a> <a id="2062" class="Symbol">(</a><a id="2063" href="Foundations.Equiv.Properties.html#1931" class="Function">Ṽ.ε</a> <a id="2068" class="Symbol">_)</a> <a id="2071" class="Symbol">_</a> <a id="2073" href="Foundations.Base.html#5664" class="Function Operator">∙</a> <a id="2075" href="Foundations.Equiv.Properties.html#1902" class="Function">Ã.η</a> <a id="2080" href="Structures.FinSet.html#2016" class="Bound">a</a><a id="2081" class="Symbol">))</a> <a id="2084" href="Structures.FinSet.html#2020" class="Bound">pa</a>

<a id="is-fin-set→omniscient₁"></a><a id="2088" href="Structures.FinSet.html#2088" class="Function">is-fin-set→omniscient₁</a> <a id="2111" class="Symbol">:</a> <a id="2113" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="2124" href="Structures.FinSet.html#715" class="Generalizable">A</a> <a id="2126" class="Symbol">→</a> <a id="2128" href="Correspondences.Nullary.Omniscience.html#1185" class="Function">Omniscient₁</a> <a id="2140" class="Symbol">{</a><a id="2141" class="Argument">ℓ′</a> <a id="2144" class="Symbol">=</a> <a id="2146" href="Structures.FinSet.html#702" class="Generalizable">ℓ′</a><a id="2148" class="Symbol">}</a> <a id="2150" href="Structures.FinSet.html#715" class="Generalizable">A</a>
<a id="2152" href="Structures.FinSet.html#2088" class="Function">is-fin-set→omniscient₁</a> <a id="2175" class="Symbol">{</a><a id="2176" href="Structures.FinSet.html#2176" class="Bound">A</a><a id="2177" class="Symbol">}</a> <a id="2179" class="Symbol">(</a><a id="2180" href="Structures.FinSet.html#2180" class="Bound">n</a> <a id="2182" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2184" href="Structures.FinSet.html#2184" class="Bound">∣aeq∣₁</a><a id="2190" class="Symbol">)</a> <a id="2192" class="Symbol">{</a><a id="2193" href="Structures.FinSet.html#2193" class="Bound">P</a><a id="2194" class="Symbol">}</a> <a id="2196" class="Symbol">=</a> <a id="2198" href="Truncation.Propositional.Properties.html#1041" class="Function">∥-∥₁.elim!</a> <a id="2209" href="Structures.FinSet.html#2240" class="Function">go</a> <a id="2212" class="Symbol">((</a><a id="2214" href="Structures.FinSet.html#2180" class="Bound">n</a> <a id="2216" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,_</a><a id="2218" class="Symbol">)</a> <a id="2220" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="2224" href="Structures.FinSet.html#2184" class="Bound">∣aeq∣₁</a><a id="2230" class="Symbol">)</a> <a id="2232" class="Keyword">where</a>
  <a id="2240" href="Structures.FinSet.html#2240" class="Function">go</a> <a id="2243" class="Symbol">:</a> <a id="2245" href="Foundations.Pi.Base.html#146" class="Function">Π[</a> <a id="2248" href="Structures.FinSet.html#2248" class="Bound">A-f</a> <a id="2252" href="Foundations.Pi.Base.html#146" class="Function">꞉</a> <a id="2254" href="Structures.FinSet.html#727" class="Function">Fin-ordered</a> <a id="2266" href="Structures.FinSet.html#2176" class="Bound">A</a> <a id="2268" href="Foundations.Pi.Base.html#146" class="Function">]</a> <a id="2270" class="Symbol">(</a><a id="2271" href="Correspondences.Unary.Decidable.html#316" class="Function">Decidable₁</a> <a id="2282" href="Structures.FinSet.html#2193" class="Bound">P</a> <a id="2284" class="Symbol">→</a> <a id="2286" href="Data.Dec.Base.html#1308" class="Record">Dec</a> <a id="2290" href="Truncation.Propositional.Base.html#139" class="Datatype Operator">∥</a> <a id="2292" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2294" href="Structures.FinSet.html#2176" class="Bound">A</a> <a id="2296" class="Symbol">_</a> <a id="2298" href="Truncation.Propositional.Base.html#139" class="Datatype Operator">∥₁</a><a id="2300" class="Symbol">)</a>
  <a id="2304" href="Structures.FinSet.html#2240" class="Function">go</a> <a id="2307" href="Structures.FinSet.html#2307" class="Bound">A-f</a> <a id="2311" class="Symbol">=</a> <a id="2313" href="Data.Dec.Base.html#1513" class="Function">Dec.map</a> <a id="2321" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="2326" href="Truncation.Propositional.Properties.html#910" class="Function">rec!</a> <a id="2331" href="Foundations.Pi.Base.html#1050" class="Function Operator">∘</a> <a id="2333" href="Structures.FinSet.html#1656" class="Function">fin-ordered→omniscient</a> <a id="2356" href="Structures.FinSet.html#2307" class="Bound">A-f</a>

<a id="is-fin-set→exhaustible₁"></a><a id="2361" href="Structures.FinSet.html#2361" class="Function">is-fin-set→exhaustible₁</a> <a id="2385" class="Symbol">:</a> <a id="2387" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="2398" href="Structures.FinSet.html#715" class="Generalizable">A</a> <a id="2400" class="Symbol">→</a> <a id="2402" href="Correspondences.Nullary.Omniscience.html#1040" class="Function">Exhaustible₁</a> <a id="2415" class="Symbol">{</a><a id="2416" class="Argument">ℓ′</a> <a id="2419" class="Symbol">=</a> <a id="2421" href="Structures.FinSet.html#702" class="Generalizable">ℓ′</a><a id="2423" class="Symbol">}</a> <a id="2425" href="Structures.FinSet.html#715" class="Generalizable">A</a>
<a id="2427" href="Structures.FinSet.html#2361" class="Function">is-fin-set→exhaustible₁</a> <a id="2451" class="Symbol">=</a> <a id="2453" href="Correspondences.Nullary.Omniscience.html#1347" class="Function">omniscient₁→exhaustible₁</a> <a id="2478" href="Foundations.Pi.Base.html#1050" class="Function Operator">∘</a> <a id="2480" href="Structures.FinSet.html#2088" class="Function">is-fin-set→omniscient₁</a>

<a id="2504" class="Comment">-- is-fin-set→omniscient</a>
<a id="2529" class="Comment">--   : is-fin-set A → {P : Pred₁ ℓ′ A} → Decidable₁ P → Dec (Σ[ a ꞉ A ] ⌞ P a ⌟)</a>
<a id="2610" class="Comment">-- is-fin-set→omniscient A-fin P? with is-fin-set→omniscient₁ A-fin P?</a>
<a id="2681" class="Comment">-- ... | yes p = yes {!!}</a>
<a id="2707" class="Comment">-- ... | no ¬p = {!!}</a>

<a id="2730" class="Comment">-- is-fin-set→exhaustible₁</a>
<a id="2757" class="Comment">--   : is-fin-set A → {P : Pred₁ ℓ′ A} → Decidable₁ P → Dec (Π[ a ꞉ A ] ⌞ P a ⌟)</a>
<a id="2838" class="Comment">-- is-fin-set→exhaustible₁ A-fin {P} P? =</a>
<a id="2880" class="Comment">--   let z = omniscient₁→exhaustible₁ (is-fin-set→omniscient₁ A-fin) P?</a>
<a id="2952" class="Comment">-- --       w = ∥-∥₁.proj (Finite-choice ⦃ {!!} ⦄ λ x → (dec-∥-∥₁-equiv ₑ⁻¹) .fst x)</a>
<a id="3037" class="Comment">--   in omniscient→exhaustible {!!} P?</a>
<a id="3076" class="Comment">-- --     in ∥-∥₁.proj {!Finite-choice ? ?!} -- ((dec-∥-∥₁-equiv ₑ⁻¹) .fst z)</a>

<a id="3155" class="Keyword">record</a> <a id="FinSet"></a><a id="3162" href="Structures.FinSet.html#3162" class="Record">FinSet</a> <a id="3169" href="Structures.FinSet.html#3169" class="Bound">ℓ</a> <a id="3171" class="Symbol">:</a> <a id="3173" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3178" class="Symbol">(</a><a id="3179" href="Foundations.Prim.Type.html#375" class="Primitive">ℓsuc</a> <a id="3184" href="Structures.FinSet.html#3169" class="Bound">ℓ</a><a id="3185" class="Symbol">)</a> <a id="3187" class="Keyword">where</a>
  <a id="3195" class="Keyword">no-eta-equality</a>
  <a id="3213" class="Keyword">constructor</a> <a id="fin-set"></a><a id="3225" href="Structures.FinSet.html#3225" class="InductiveConstructor">fin-set</a>
  <a id="3235" class="Keyword">field</a>
    <a id="FinSet.typ"></a><a id="3245" href="Structures.FinSet.html#3245" class="Field">typ</a>            <a id="3260" class="Symbol">:</a> <a id="3262" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3267" href="Structures.FinSet.html#3169" class="Bound">ℓ</a>
    <a id="FinSet.has-is-fin-set"></a><a id="3273" href="Structures.FinSet.html#3273" class="Field">has-is-fin-set</a> <a id="3288" class="Symbol">:</a> <a id="3290" href="Structures.FinSet.html#871" class="Function">is-fin-set</a> <a id="3301" href="Structures.FinSet.html#3245" class="Field">typ</a>
  <a id="3307" class="Keyword">instance</a>
    <a id="FinSet.Finite-FinSet"></a><a id="3320" href="Structures.FinSet.html#3320" class="Function">Finite-FinSet</a> <a id="3334" class="Symbol">:</a> <a id="3336" href="Meta.Finite.html#505" class="Record">Finite</a> <a id="3343" href="Structures.FinSet.html#3245" class="Field">typ</a>
    <a id="3351" href="Structures.FinSet.html#3320" class="Function">Finite-FinSet</a> <a id="3365" class="Symbol">=</a> <a id="3367" href="Meta.Finite.html#558" class="InductiveConstructor">fin</a> <a id="3371" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="3373" href="Structures.FinSet.html#3273" class="Field">has-is-fin-set</a> <a id="3388" class="Symbol">.</a><a id="3389" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>

    <a id="FinSet.H-Level-FinSet"></a><a id="3398" href="Structures.FinSet.html#3398" class="Function">H-Level-FinSet</a> <a id="3413" class="Symbol">:</a> <a id="3415" class="Symbol">∀</a> <a id="3417" class="Symbol">{</a><a id="3418" href="Structures.FinSet.html#3418" class="Bound">n</a><a id="3419" class="Symbol">}</a> <a id="3421" class="Symbol">→</a> <a id="3423" href="Meta.HLevel.Base.html#186" class="Record">H-Level</a> <a id="3431" class="Symbol">(</a><a id="3432" class="Number">2</a> <a id="3434" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3436" href="Structures.FinSet.html#3418" class="Bound">n</a><a id="3437" class="Symbol">)</a> <a id="3439" href="Structures.FinSet.html#3245" class="Field">typ</a>
    <a id="3447" href="Structures.FinSet.html#3398" class="Function">H-Level-FinSet</a> <a id="3462" class="Symbol">=</a> <a id="3464" href="Meta.HLevel.Base.html#559" class="Function">basic-instance</a> <a id="3479" class="Number">2</a> <a id="3481" class="Symbol">(</a><a id="3482" href="Structures.FinSet.html#1308" class="Function">is-fin-set→is-set</a> <a id="3500" href="Structures.FinSet.html#3273" class="Field">has-is-fin-set</a><a id="3514" class="Symbol">)</a>

<a id="3517" class="Keyword">open</a> <a id="3522" href="Structures.FinSet.html#3162" class="Module">FinSet</a> <a id="3529" class="Keyword">public</a>
  <a id="3538" class="Keyword">using</a> <a id="3544" class="Symbol">(</a><a id="3545" href="Structures.FinSet.html#3320" class="Function">Finite-FinSet</a><a id="3558" class="Symbol">;</a> <a id="3560" href="Structures.FinSet.html#3398" class="Function">H-Level-FinSet</a><a id="3574" class="Symbol">)</a>
<a id="3576" class="Keyword">open</a> <a id="3581" href="Structures.FinSet.html#3162" class="Module">FinSet</a> <a id="3588" class="Keyword">using</a> <a id="3594" class="Symbol">(</a><a id="3595" href="Structures.FinSet.html#3245" class="Field">typ</a><a id="3598" class="Symbol">;</a> <a id="3600" href="Structures.FinSet.html#3273" class="Field">has-is-fin-set</a><a id="3614" class="Symbol">)</a>

<a id="fin-set!"></a><a id="3617" href="Structures.FinSet.html#3617" class="Function">fin-set!</a> <a id="3626" class="Symbol">:</a> <a id="3628" class="Symbol">(</a><a id="3629" href="Structures.FinSet.html#3629" class="Bound">A</a> <a id="3631" class="Symbol">:</a> <a id="3633" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3638" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a><a id="3639" class="Symbol">)</a> <a id="3641" class="Symbol">→</a> <a id="3643" class="Symbol">⦃</a> <a id="3645" href="Meta.Finite.html#505" class="Record">Finite</a> <a id="3652" href="Structures.FinSet.html#3629" class="Bound">A</a> <a id="3654" class="Symbol">⦄</a> <a id="3656" class="Symbol">→</a> <a id="3658" href="Structures.FinSet.html#3162" class="Record">FinSet</a> <a id="3665" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a>
<a id="3667" href="Structures.FinSet.html#3617" class="Function">fin-set!</a> <a id="3676" href="Structures.FinSet.html#3676" class="Bound">A</a> <a id="3678" class="Symbol">⦃</a> <a id="3680" class="Symbol">(</a><a id="3681" href="Structures.FinSet.html#3681" class="Bound">A-fin</a><a id="3686" class="Symbol">)</a> <a id="3688" class="Symbol">⦄</a> <a id="3690" class="Symbol">=</a> <a id="3692" href="Structures.FinSet.html#3225" class="InductiveConstructor">fin-set</a> <a id="3700" href="Structures.FinSet.html#3676" class="Bound">A</a> <a id="3702" class="Symbol">(</a><a id="3703" href="Structures.FinSet.html#1197" class="Function">Finite→is-fin-set</a> <a id="3721" href="Structures.FinSet.html#3681" class="Bound">A-fin</a><a id="3726" class="Symbol">)</a>

<a id="3729" class="Keyword">instance</a>
  <a id="Underlying-FinSet"></a><a id="3740" href="Structures.FinSet.html#3740" class="Function">Underlying-FinSet</a> <a id="3758" class="Symbol">:</a> <a id="3760" href="Meta.Underlying.html#91" class="Record">Underlying</a> <a id="3771" class="Symbol">(</a><a id="3772" href="Structures.FinSet.html#3162" class="Record">FinSet</a> <a id="3779" href="Structures.FinSet.html#700" class="Generalizable">ℓ</a><a id="3780" class="Symbol">)</a>
  <a id="3784" href="Structures.FinSet.html#3740" class="Function">Underlying-FinSet</a> <a id="3802" class="Symbol">{</a><a id="3803" href="Structures.FinSet.html#3803" class="Bound">ℓ</a><a id="3804" class="Symbol">}</a> <a id="3806" class="Symbol">.</a><a id="3807" href="Meta.Underlying.html#145" class="Field">Underlying.ℓ-underlying</a> <a id="3831" class="Symbol">=</a> <a id="3833" href="Structures.FinSet.html#3803" class="Bound">ℓ</a>
  <a id="3837" href="Structures.FinSet.html#3740" class="Function">Underlying-FinSet</a> <a id="3855" class="Symbol">.</a><a id="3856" href="Meta.Underlying.html#170" class="Field Operator">⌞_⌟</a> <a id="3860" class="Symbol">=</a> <a id="3862" href="Structures.FinSet.html#3245" class="Field">typ</a>


<a id="3868" class="Comment">-- TODO</a>
<a id="3876" class="Comment">-- fin-set-path : ⌞ X ⌟ ＝ ⌞ Y ⌟ → X ＝ Y</a>
<a id="3916" class="Comment">-- fin-set-path f i .typ = f i</a>
<a id="3947" class="Comment">-- fin-set-path {X} {Y} f i .has-is-fin-set = {!!} , {!!}</a>
<a id="4005" class="Comment">--   -- is-prop→pathP (λ i → is-of-hlevel-is-prop {A = f i} _) (X .is-tr) (Y .is-tr) i</a>

<a id="4093" class="Comment">-- @0 fin-set-ua : ⌞ X ⌟ ≃ ⌞ Y ⌟ → X ＝ Y</a>
<a id="4134" class="Comment">-- fin-set-ua f = n-path (ua f)</a>

<a id="4167" class="Comment">-- @0 fin-set-univalence : {X Y : n-Type ℓ n} → (⌞ X ⌟ ≃ ⌞ Y ⌟) ≃ (X ＝ Y)</a>
<a id="4241" class="Comment">-- fin-set-univalence {n} {X} {Y} = n-ua , is-iso→is-equiv isic where</a>
<a id="4311" class="Comment">--   inv : ∀ {Y} → X ＝ Y → ⌞ X ⌟ ≃ ⌞ Y ⌟</a>
<a id="4352" class="Comment">--   inv p = path→equiv (ap typ p)</a>

<a id="4388" class="Comment">--   linv : ∀ {Y} → (inv {Y}) is-left-inverse-of n-ua</a>
<a id="4442" class="Comment">--   linv x = Σ-prop-path is-equiv-is-prop (fun-ext λ x → transport-refl _)</a>

<a id="4519" class="Comment">--   rinv : ∀ {Y} → (inv {Y}) is-right-inverse-of n-ua</a>
<a id="4574" class="Comment">--   rinv = J (λ y p → n-ua (inv p) ＝ p) path where</a>
<a id="4626" class="Comment">--     path : n-ua (inv {X} refl) ＝ refl</a>
<a id="4667" class="Comment">--     path i j .typ = ua.ε refl i j</a>
<a id="4704" class="Comment">--     path i j .is-tr = is-prop→SquareP</a>
<a id="4745" class="Comment">--       (λ i j → is-of-hlevel-is-prop</a>
<a id="4784" class="Comment">--         {A = ua.ε {A = ⌞ X ⌟} refl i j } n)</a>
<a id="4831" class="Comment">--       (λ j → X .is-tr) (λ j → n-ua {X = X} {Y = X} (path→equiv refl) j .is-tr)</a>
<a id="4913" class="Comment">--       (λ j → X .is-tr) (λ j → X .is-tr)</a>
<a id="4956" class="Comment">--       i j</a>

<a id="4970" class="Comment">--   isic : is-iso n-ua</a>
<a id="4994" class="Comment">--   isic = iso inv rinv (linv {Y})</a>

<a id="5031" class="Comment">-- @0 fin-set-is-of-hlevel : ∀ n → is-of-hlevel (suc n) (n-Type ℓ n)</a>
<a id="5100" class="Comment">-- fin-set-is-of-hlevel zero x y = n-ua</a>
<a id="5140" class="Comment">--   ((λ _ → y .is-tr .fst) , is-contr→is-equiv (x .is-tr) (y .is-tr))</a>
<a id="5211" class="Comment">-- fin-set-is-of-hlevel (suc n) x y =</a>
<a id="5249" class="Comment">--   is-of-hlevel-≃ (suc n) (n-univalence ₑ⁻¹) (≃-is-of-hlevel (suc n) (x .is-tr) (y .is-tr))</a>

<a id="5344" class="Comment">-- instance</a>
<a id="5356" class="Comment">--   @0 H-Level-nType : ∀ {n k} → H-Level (1 + k + n) (n-Type ℓ k)</a>
<a id="5423" class="Comment">--   H-Level-nType {k} = basic-instance (1 + k) (n-Type-is-of-hlevel k)</a>

<a id="5496" class="Comment">--   H-Level-is-equiv</a>
<a id="5518" class="Comment">--     : {f : A → B} {n : HLevel}</a>
<a id="5552" class="Comment">--     → H-Level (suc n) (is-equiv f)</a>
<a id="5590" class="Comment">--   H-Level-is-equiv = prop-instance (is-equiv-is-prop _)</a>

<a id="5650" class="Comment">-- module _ {ℓ : Level} where private</a>
<a id="5688" class="Comment">--   open import Foundations.Univalence.SIP</a>
<a id="5732" class="Comment">--   _ : FinSet ℓ ≃ Type-with {S = is-fin-set} (HomT→Str λ _ _ _ → ⊤)</a>
<a id="5802" class="Comment">--   _ = iso→equiv the-iso</a>
<a id="5829" class="Comment">--     where</a>
<a id="5842" class="Comment">--       open import Meta.Reflection.Record</a>
<a id="5886" class="Comment">--       the-iso : Iso (FinSet ℓ) (Σ[ T ꞉ Type ℓ ] is-fin-set T)</a>
<a id="5951" class="Comment">--       unquoteDef the-iso = define-record-iso the-iso (quote FinSet)</a>
</pre></body></html>