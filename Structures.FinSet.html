<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Structures.FinSet</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Keyword">module</a> <a id="31" href="Structures.FinSet.html" class="Module">Structures.FinSet</a> <a id="49" class="Keyword">where</a>

<a id="56" class="Keyword">open</a> <a id="61" class="Keyword">import</a> <a id="68" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="85" class="Keyword">open</a> <a id="90" class="Keyword">import</a> <a id="97" href="Foundations.Equiv.html" class="Module">Foundations.Equiv</a>

<a id="116" class="Keyword">open</a> <a id="121" class="Keyword">import</a> <a id="128" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>
<a id="142" class="Keyword">open</a> <a id="147" class="Keyword">import</a> <a id="154" href="Data.Fin.Finite.html" class="Module">Data.Fin.Finite</a>

<a id="171" class="Keyword">open</a> <a id="176" class="Keyword">import</a> <a id="183" href="Meta.HLevel.html" class="Module">Meta.HLevel</a>
<a id="195" class="Keyword">open</a> <a id="200" class="Keyword">import</a> <a id="207" href="Meta.Finite.html" class="Module">Meta.Finite</a>     <a id="223" class="Keyword">public</a>
<a id="230" class="Keyword">open</a> <a id="235" class="Keyword">import</a> <a id="242" href="Meta.Underlying.html" class="Module">Meta.Underlying</a> <a id="258" class="Keyword">public</a>

<a id="266" class="Keyword">open</a> <a id="271" class="Keyword">import</a> <a id="278" href="Truncation.Propositional.html" class="Module">Truncation.Propositional</a>

<a id="304" class="Keyword">record</a> <a id="FinSet"></a><a id="311" href="Structures.FinSet.html#311" class="Record">FinSet</a> <a id="318" href="Structures.FinSet.html#318" class="Bound">ℓ</a> <a id="320" class="Symbol">:</a> <a id="322" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="327" class="Symbol">(</a><a id="328" href="Foundations.Prim.Type.html#375" class="Primitive">ℓsuc</a> <a id="333" href="Structures.FinSet.html#318" class="Bound">ℓ</a><a id="334" class="Symbol">)</a> <a id="336" class="Keyword">where</a>
  <a id="344" class="Keyword">no-eta-equality</a>
  <a id="362" class="Keyword">constructor</a> <a id="fin-set"></a><a id="374" href="Structures.FinSet.html#374" class="InductiveConstructor">fin-set</a>
  <a id="384" class="Keyword">field</a>
    <a id="FinSet.typ"></a><a id="394" href="Structures.FinSet.html#394" class="Field">typ</a>            <a id="409" class="Symbol">:</a> <a id="411" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="416" href="Structures.FinSet.html#318" class="Bound">ℓ</a>
    <a id="FinSet.has-is-fin-set"></a><a id="422" href="Structures.FinSet.html#422" class="Field">has-is-fin-set</a> <a id="437" class="Symbol">:</a> <a id="439" href="Data.Fin.Finite.html#644" class="Function">is-fin-set</a> <a id="450" href="Structures.FinSet.html#394" class="Field">typ</a>
  <a id="456" class="Keyword">instance</a>
    <a id="FinSet.Finite-FinSet"></a><a id="469" href="Structures.FinSet.html#469" class="Function">Finite-FinSet</a> <a id="483" class="Symbol">:</a> <a id="485" href="Meta.Finite.html#477" class="Record">Finite</a> <a id="492" href="Structures.FinSet.html#394" class="Field">typ</a>
    <a id="500" href="Structures.FinSet.html#469" class="Function">Finite-FinSet</a> <a id="514" class="Symbol">=</a> <a id="516" href="Meta.Finite.html#530" class="InductiveConstructor">fin</a> <a id="520" href="Foundations.Pi.Base.html#813" class="Function Operator">$</a> <a id="522" href="Structures.FinSet.html#422" class="Field">has-is-fin-set</a> <a id="537" class="Symbol">.</a><a id="538" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>

    <a id="FinSet.H-Level-FinSet"></a><a id="547" href="Structures.FinSet.html#547" class="Function">H-Level-FinSet</a> <a id="562" class="Symbol">:</a> <a id="564" class="Symbol">∀</a> <a id="566" class="Symbol">{</a><a id="567" href="Structures.FinSet.html#567" class="Bound">n</a><a id="568" class="Symbol">}</a> <a id="570" class="Symbol">→</a> <a id="572" href="Meta.HLevel.html#181" class="Record">H-Level</a> <a id="580" class="Symbol">(</a><a id="581" class="Number">2</a> <a id="583" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="585" href="Structures.FinSet.html#567" class="Bound">n</a><a id="586" class="Symbol">)</a> <a id="588" href="Structures.FinSet.html#394" class="Field">typ</a>
    <a id="596" href="Structures.FinSet.html#547" class="Function">H-Level-FinSet</a> <a id="611" class="Symbol">=</a> <a id="613" href="Meta.HLevel.html#554" class="Function">basic-instance</a> <a id="628" class="Number">2</a> <a id="630" class="Symbol">(</a><a id="631" href="Data.Fin.Finite.html#970" class="Function">is-fin-set→is-set</a> <a id="649" href="Structures.FinSet.html#422" class="Field">has-is-fin-set</a><a id="663" class="Symbol">)</a>

<a id="666" class="Keyword">open</a> <a id="671" href="Structures.FinSet.html#311" class="Module">FinSet</a> <a id="678" class="Keyword">public</a>
  <a id="687" class="Keyword">using</a> <a id="693" class="Symbol">(</a><a id="694" href="Structures.FinSet.html#469" class="Function">Finite-FinSet</a><a id="707" class="Symbol">;</a> <a id="709" href="Structures.FinSet.html#547" class="Function">H-Level-FinSet</a><a id="723" class="Symbol">)</a>
<a id="725" class="Keyword">open</a> <a id="730" href="Structures.FinSet.html#311" class="Module">FinSet</a> <a id="737" class="Keyword">using</a> <a id="743" class="Symbol">(</a><a id="744" href="Structures.FinSet.html#394" class="Field">typ</a><a id="747" class="Symbol">;</a> <a id="749" href="Structures.FinSet.html#422" class="Field">has-is-fin-set</a><a id="763" class="Symbol">)</a>

<a id="766" class="Keyword">private</a> <a id="774" class="Keyword">variable</a>
  <a id="785" href="Structures.FinSet.html#785" class="Generalizable">ℓ</a> <a id="787" class="Symbol">:</a> <a id="789" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="797" href="Structures.FinSet.html#797" class="Generalizable">A</a> <a id="799" class="Symbol">:</a> <a id="801" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="806" href="Structures.FinSet.html#785" class="Generalizable">ℓ</a>

<a id="809" class="Keyword">instance</a>
  <a id="Underlying-FinSet"></a><a id="820" href="Structures.FinSet.html#820" class="Function">Underlying-FinSet</a> <a id="838" class="Symbol">:</a> <a id="840" href="Meta.Underlying.html#91" class="Record">Underlying</a> <a id="851" class="Symbol">(</a><a id="852" href="Structures.FinSet.html#311" class="Record">FinSet</a> <a id="859" href="Structures.FinSet.html#785" class="Generalizable">ℓ</a><a id="860" class="Symbol">)</a>
  <a id="864" href="Structures.FinSet.html#820" class="Function">Underlying-FinSet</a> <a id="882" class="Symbol">{</a><a id="883" href="Structures.FinSet.html#883" class="Bound">ℓ</a><a id="884" class="Symbol">}</a> <a id="886" class="Symbol">.</a><a id="887" href="Meta.Underlying.html#145" class="Field">Underlying.ℓ-underlying</a> <a id="911" class="Symbol">=</a> <a id="913" href="Structures.FinSet.html#883" class="Bound">ℓ</a>
  <a id="917" href="Structures.FinSet.html#820" class="Function">Underlying-FinSet</a> <a id="935" class="Symbol">.</a><a id="936" href="Meta.Underlying.html#170" class="Field Operator">⌞_⌟</a> <a id="940" class="Symbol">=</a> <a id="942" href="Structures.FinSet.html#394" class="Field">typ</a>


<a id="948" class="Comment">-- TODO</a>
<a id="956" class="Comment">-- fin-set-path : ⌞ X ⌟ ＝ ⌞ Y ⌟ → X ＝ Y</a>
<a id="996" class="Comment">-- fin-set-path f i .typ = f i</a>
<a id="1027" class="Comment">-- fin-set-path {X} {Y} f i .has-is-fin-set = {!!} , {!!}</a>
<a id="1085" class="Comment">--   -- is-prop→pathP (λ i → is-of-hlevel-is-prop {A = f i} _) (X .is-tr) (Y .is-tr) i</a>

<a id="1173" class="Comment">-- @0 fin-set-ua : ⌞ X ⌟ ≃ ⌞ Y ⌟ → X ＝ Y</a>
<a id="1214" class="Comment">-- fin-set-ua f = n-path (ua f)</a>

<a id="1247" class="Comment">-- @0 fin-set-univalence : {X Y : n-Type ℓ n} → (⌞ X ⌟ ≃ ⌞ Y ⌟) ≃ (X ＝ Y)</a>
<a id="1321" class="Comment">-- fin-set-univalence {n} {X} {Y} = n-ua , is-iso→is-equiv isic where</a>
<a id="1391" class="Comment">--   inv : ∀ {Y} → X ＝ Y → ⌞ X ⌟ ≃ ⌞ Y ⌟</a>
<a id="1432" class="Comment">--   inv p = path→equiv (ap typ p)</a>

<a id="1468" class="Comment">--   linv : ∀ {Y} → (inv {Y}) is-left-inverse-of n-ua</a>
<a id="1522" class="Comment">--   linv x = Σ-prop-path is-equiv-is-prop (fun-ext λ x → transport-refl _)</a>

<a id="1599" class="Comment">--   rinv : ∀ {Y} → (inv {Y}) is-right-inverse-of n-ua</a>
<a id="1654" class="Comment">--   rinv = J (λ y p → n-ua (inv p) ＝ p) path where</a>
<a id="1706" class="Comment">--     path : n-ua (inv {X} refl) ＝ refl</a>
<a id="1747" class="Comment">--     path i j .typ = ua.ε refl i j</a>
<a id="1784" class="Comment">--     path i j .is-tr = is-prop→SquareP</a>
<a id="1825" class="Comment">--       (λ i j → is-of-hlevel-is-prop</a>
<a id="1864" class="Comment">--         {A = ua.ε {A = ⌞ X ⌟} refl i j } n)</a>
<a id="1911" class="Comment">--       (λ j → X .is-tr) (λ j → n-ua {X = X} {Y = X} (path→equiv refl) j .is-tr)</a>
<a id="1993" class="Comment">--       (λ j → X .is-tr) (λ j → X .is-tr)</a>
<a id="2036" class="Comment">--       i j</a>

<a id="2050" class="Comment">--   isic : is-iso n-ua</a>
<a id="2074" class="Comment">--   isic = iso inv rinv (linv {Y})</a>

<a id="2111" class="Comment">-- @0 fin-set-is-of-hlevel : ∀ n → is-of-hlevel (suc n) (n-Type ℓ n)</a>
<a id="2180" class="Comment">-- fin-set-is-of-hlevel zero x y = n-ua</a>
<a id="2220" class="Comment">--   ((λ _ → y .is-tr .fst) , is-contr→is-equiv (x .is-tr) (y .is-tr))</a>
<a id="2291" class="Comment">-- fin-set-is-of-hlevel (suc n) x y =</a>
<a id="2329" class="Comment">--   is-of-hlevel-≃ (suc n) (n-univalence ₑ⁻¹) (≃-is-of-hlevel (suc n) (x .is-tr) (y .is-tr))</a>

<a id="2424" class="Comment">-- instance</a>
<a id="2436" class="Comment">--   @0 H-Level-nType : ∀ {n k} → H-Level (1 + k + n) (n-Type ℓ k)</a>
<a id="2503" class="Comment">--   H-Level-nType {k} = basic-instance (1 + k) (n-Type-is-of-hlevel k)</a>

<a id="2576" class="Comment">--   H-Level-is-equiv</a>
<a id="2598" class="Comment">--     : {f : A → B} {n : HLevel}</a>
<a id="2632" class="Comment">--     → H-Level (suc n) (is-equiv f)</a>
<a id="2670" class="Comment">--   H-Level-is-equiv = prop-instance (is-equiv-is-prop _)</a>

<a id="2730" class="Comment">-- module _ {ℓ : Level} where private</a>
<a id="2768" class="Comment">--   open import Foundations.Univalence.SIP</a>
<a id="2812" class="Comment">--   _ : FinSet ℓ ≃ Type-with {S = is-fin-set} (HomT→Str λ _ _ _ → ⊤)</a>
<a id="2882" class="Comment">--   _ = iso→equiv the-iso</a>
<a id="2909" class="Comment">--     where</a>
<a id="2922" class="Comment">--       open import Meta.Reflection.Record</a>
<a id="2966" class="Comment">--       the-iso : Iso (FinSet ℓ) (Σ[ T ꞉ Type ℓ ] is-fin-set T)</a>
<a id="3031" class="Comment">--       unquoteDef the-iso = define-record-iso the-iso (quote FinSet)</a>
</pre></body></html>