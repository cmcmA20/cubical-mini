<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Structures.FinSet</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Keyword">module</a> <a id="31" href="Structures.FinSet.html" class="Module">Structures.FinSet</a> <a id="49" class="Keyword">where</a>

<a id="56" class="Keyword">open</a> <a id="61" class="Keyword">import</a> <a id="68" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="85" class="Keyword">open</a> <a id="90" class="Keyword">import</a> <a id="97" href="Foundations.Equiv.html" class="Module">Foundations.Equiv</a>

<a id="116" class="Keyword">open</a> <a id="121" class="Keyword">import</a> <a id="128" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>

<a id="143" class="Keyword">open</a> <a id="148" class="Keyword">import</a> <a id="155" href="Meta.HLevel.html" class="Module">Meta.HLevel</a>
<a id="167" class="Keyword">open</a> <a id="172" class="Keyword">import</a> <a id="179" href="Meta.Finite.html" class="Module">Meta.Finite</a>     <a id="195" class="Keyword">public</a>
<a id="202" class="Keyword">open</a> <a id="207" class="Keyword">import</a> <a id="214" href="Meta.Underlying.html" class="Module">Meta.Underlying</a> <a id="230" class="Keyword">public</a>

<a id="238" class="Keyword">open</a> <a id="243" class="Keyword">import</a> <a id="250" href="Structures.Finite.html" class="Module">Structures.Finite</a>

<a id="269" class="Keyword">open</a> <a id="274" class="Keyword">import</a> <a id="281" href="Truncation.Propositional.html" class="Module">Truncation.Propositional</a>

<a id="307" class="Keyword">record</a> <a id="FinSet"></a><a id="314" href="Structures.FinSet.html#314" class="Record">FinSet</a> <a id="321" href="Structures.FinSet.html#321" class="Bound">ℓ</a> <a id="323" class="Symbol">:</a> <a id="325" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="330" class="Symbol">(</a><a id="331" href="Foundations.Prim.Type.html#375" class="Primitive">ℓsuc</a> <a id="336" href="Structures.FinSet.html#321" class="Bound">ℓ</a><a id="337" class="Symbol">)</a> <a id="339" class="Keyword">where</a>
  <a id="347" class="Keyword">no-eta-equality</a>
  <a id="365" class="Keyword">constructor</a> <a id="fin-set"></a><a id="377" href="Structures.FinSet.html#377" class="InductiveConstructor">fin-set</a>
  <a id="387" class="Keyword">field</a>
    <a id="FinSet.typ"></a><a id="397" href="Structures.FinSet.html#397" class="Field">typ</a>            <a id="412" class="Symbol">:</a> <a id="414" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="419" href="Structures.FinSet.html#321" class="Bound">ℓ</a>
    <a id="FinSet.has-is-fin-set"></a><a id="425" href="Structures.FinSet.html#425" class="Field">has-is-fin-set</a> <a id="440" class="Symbol">:</a> <a id="442" href="Structures.Finite.html#646" class="Function">is-fin-set</a> <a id="453" href="Structures.FinSet.html#397" class="Field">typ</a>
  <a id="459" class="Keyword">instance</a>
    <a id="FinSet.Finite-FinSet"></a><a id="472" href="Structures.FinSet.html#472" class="Function">Finite-FinSet</a> <a id="486" class="Symbol">:</a> <a id="488" href="Meta.Finite.html#477" class="Record">Finite</a> <a id="495" href="Structures.FinSet.html#397" class="Field">typ</a>
    <a id="503" href="Structures.FinSet.html#472" class="Function">Finite-FinSet</a> <a id="517" class="Symbol">=</a> <a id="519" href="Meta.Finite.html#530" class="InductiveConstructor">fin</a> <a id="523" href="Foundations.Pi.Base.html#813" class="Function Operator">$</a> <a id="525" href="Structures.FinSet.html#425" class="Field">has-is-fin-set</a> <a id="540" class="Symbol">.</a><a id="541" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a>

    <a id="FinSet.H-Level-FinSet"></a><a id="550" href="Structures.FinSet.html#550" class="Function">H-Level-FinSet</a> <a id="565" class="Symbol">:</a> <a id="567" class="Symbol">∀</a> <a id="569" class="Symbol">{</a><a id="570" href="Structures.FinSet.html#570" class="Bound">n</a><a id="571" class="Symbol">}</a> <a id="573" class="Symbol">→</a> <a id="575" href="Meta.HLevel.html#181" class="Record">H-Level</a> <a id="583" class="Symbol">(</a><a id="584" class="Number">2</a> <a id="586" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="588" href="Structures.FinSet.html#570" class="Bound">n</a><a id="589" class="Symbol">)</a> <a id="591" href="Structures.FinSet.html#397" class="Field">typ</a>
    <a id="599" href="Structures.FinSet.html#550" class="Function">H-Level-FinSet</a> <a id="614" class="Symbol">=</a> <a id="616" href="Meta.HLevel.html#554" class="Function">basic-instance</a> <a id="631" class="Number">2</a> <a id="633" class="Symbol">(</a><a id="634" href="Structures.Finite.html#972" class="Function">is-fin-set→is-set</a> <a id="652" href="Structures.FinSet.html#425" class="Field">has-is-fin-set</a><a id="666" class="Symbol">)</a>

<a id="669" class="Keyword">open</a> <a id="674" href="Structures.FinSet.html#314" class="Module">FinSet</a> <a id="681" class="Keyword">public</a>
  <a id="690" class="Keyword">using</a> <a id="696" class="Symbol">(</a><a id="697" href="Structures.FinSet.html#472" class="Function">Finite-FinSet</a><a id="710" class="Symbol">;</a> <a id="712" href="Structures.FinSet.html#550" class="Function">H-Level-FinSet</a><a id="726" class="Symbol">)</a>
<a id="728" class="Keyword">open</a> <a id="733" href="Structures.FinSet.html#314" class="Module">FinSet</a> <a id="740" class="Keyword">using</a> <a id="746" class="Symbol">(</a><a id="747" href="Structures.FinSet.html#397" class="Field">typ</a><a id="750" class="Symbol">;</a> <a id="752" href="Structures.FinSet.html#425" class="Field">has-is-fin-set</a><a id="766" class="Symbol">)</a>

<a id="769" class="Keyword">private</a> <a id="777" class="Keyword">variable</a>
  <a id="788" href="Structures.FinSet.html#788" class="Generalizable">ℓ</a> <a id="790" class="Symbol">:</a> <a id="792" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="800" href="Structures.FinSet.html#800" class="Generalizable">A</a> <a id="802" class="Symbol">:</a> <a id="804" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="809" href="Structures.FinSet.html#788" class="Generalizable">ℓ</a>

<a id="812" class="Keyword">instance</a>
  <a id="Underlying-FinSet"></a><a id="823" href="Structures.FinSet.html#823" class="Function">Underlying-FinSet</a> <a id="841" class="Symbol">:</a> <a id="843" href="Meta.Underlying.html#91" class="Record">Underlying</a> <a id="854" class="Symbol">(</a><a id="855" href="Structures.FinSet.html#314" class="Record">FinSet</a> <a id="862" href="Structures.FinSet.html#788" class="Generalizable">ℓ</a><a id="863" class="Symbol">)</a>
  <a id="867" href="Structures.FinSet.html#823" class="Function">Underlying-FinSet</a> <a id="885" class="Symbol">{</a><a id="886" href="Structures.FinSet.html#886" class="Bound">ℓ</a><a id="887" class="Symbol">}</a> <a id="889" class="Symbol">.</a><a id="890" href="Meta.Underlying.html#145" class="Field">Underlying.ℓ-underlying</a> <a id="914" class="Symbol">=</a> <a id="916" href="Structures.FinSet.html#886" class="Bound">ℓ</a>
  <a id="920" href="Structures.FinSet.html#823" class="Function">Underlying-FinSet</a> <a id="938" class="Symbol">.</a><a id="939" href="Meta.Underlying.html#170" class="Field Operator">⌞_⌟</a> <a id="943" class="Symbol">=</a> <a id="945" href="Structures.FinSet.html#397" class="Field">typ</a>


<a id="951" class="Comment">-- TODO</a>
<a id="959" class="Comment">-- fin-set-path : ⌞ X ⌟ ＝ ⌞ Y ⌟ → X ＝ Y</a>
<a id="999" class="Comment">-- fin-set-path f i .typ = f i</a>
<a id="1030" class="Comment">-- fin-set-path {X} {Y} f i .has-is-fin-set = {!!} , {!!}</a>
<a id="1088" class="Comment">--   -- is-prop→pathP (λ i → is-of-hlevel-is-prop {A = f i} _) (X .is-tr) (Y .is-tr) i</a>

<a id="1176" class="Comment">-- @0 fin-set-ua : ⌞ X ⌟ ≃ ⌞ Y ⌟ → X ＝ Y</a>
<a id="1217" class="Comment">-- fin-set-ua f = n-path (ua f)</a>

<a id="1250" class="Comment">-- @0 fin-set-univalence : {X Y : n-Type ℓ n} → (⌞ X ⌟ ≃ ⌞ Y ⌟) ≃ (X ＝ Y)</a>
<a id="1324" class="Comment">-- fin-set-univalence {n} {X} {Y} = n-ua , is-iso→is-equiv isic where</a>
<a id="1394" class="Comment">--   inv : ∀ {Y} → X ＝ Y → ⌞ X ⌟ ≃ ⌞ Y ⌟</a>
<a id="1435" class="Comment">--   inv p = path→equiv (ap typ p)</a>

<a id="1471" class="Comment">--   linv : ∀ {Y} → (inv {Y}) is-left-inverse-of n-ua</a>
<a id="1525" class="Comment">--   linv x = Σ-prop-path is-equiv-is-prop (fun-ext λ x → transport-refl _)</a>

<a id="1602" class="Comment">--   rinv : ∀ {Y} → (inv {Y}) is-right-inverse-of n-ua</a>
<a id="1657" class="Comment">--   rinv = J (λ y p → n-ua (inv p) ＝ p) path where</a>
<a id="1709" class="Comment">--     path : n-ua (inv {X} refl) ＝ refl</a>
<a id="1750" class="Comment">--     path i j .typ = ua.ε refl i j</a>
<a id="1787" class="Comment">--     path i j .is-tr = is-prop→SquareP</a>
<a id="1828" class="Comment">--       (λ i j → is-of-hlevel-is-prop</a>
<a id="1867" class="Comment">--         {A = ua.ε {A = ⌞ X ⌟} refl i j } n)</a>
<a id="1914" class="Comment">--       (λ j → X .is-tr) (λ j → n-ua {X = X} {Y = X} (path→equiv refl) j .is-tr)</a>
<a id="1996" class="Comment">--       (λ j → X .is-tr) (λ j → X .is-tr)</a>
<a id="2039" class="Comment">--       i j</a>

<a id="2053" class="Comment">--   isic : is-iso n-ua</a>
<a id="2077" class="Comment">--   isic = iso inv rinv (linv {Y})</a>

<a id="2114" class="Comment">-- @0 fin-set-is-of-hlevel : ∀ n → is-of-hlevel (suc n) (n-Type ℓ n)</a>
<a id="2183" class="Comment">-- fin-set-is-of-hlevel zero x y = n-ua</a>
<a id="2223" class="Comment">--   ((λ _ → y .is-tr .fst) , is-contr→is-equiv (x .is-tr) (y .is-tr))</a>
<a id="2294" class="Comment">-- fin-set-is-of-hlevel (suc n) x y =</a>
<a id="2332" class="Comment">--   is-of-hlevel-≃ (suc n) (n-univalence ₑ⁻¹) (≃-is-of-hlevel (suc n) (x .is-tr) (y .is-tr))</a>

<a id="2427" class="Comment">-- instance</a>
<a id="2439" class="Comment">--   @0 H-Level-nType : ∀ {n k} → H-Level (1 + k + n) (n-Type ℓ k)</a>
<a id="2506" class="Comment">--   H-Level-nType {k} = basic-instance (1 + k) (n-Type-is-of-hlevel k)</a>

<a id="2579" class="Comment">--   H-Level-is-equiv</a>
<a id="2601" class="Comment">--     : {f : A → B} {n : HLevel}</a>
<a id="2635" class="Comment">--     → H-Level (suc n) (is-equiv f)</a>
<a id="2673" class="Comment">--   H-Level-is-equiv = prop-instance (is-equiv-is-prop _)</a>

<a id="2733" class="Comment">-- module _ {ℓ : Level} where private</a>
<a id="2771" class="Comment">--   open import Foundations.Univalence.SIP</a>
<a id="2815" class="Comment">--   _ : FinSet ℓ ≃ Type-with {S = is-fin-set} (HomT→Str λ _ _ _ → ⊤)</a>
<a id="2885" class="Comment">--   _ = iso→equiv the-iso</a>
<a id="2912" class="Comment">--     where</a>
<a id="2925" class="Comment">--       open import Meta.Reflection.Record</a>
<a id="2969" class="Comment">--       the-iso : Iso (FinSet ℓ) (Σ[ T ꞉ Type ℓ ] is-fin-set T)</a>
<a id="3034" class="Comment">--       unquoteDef the-iso = define-record-iso the-iso (quote FinSet)</a>
</pre></body></html>