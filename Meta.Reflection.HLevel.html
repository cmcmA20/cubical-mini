<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Reflection.HLevel</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Comment">-- -vtactic.hlevel:20 -vtc.def:10</a>
<a id="58" class="Keyword">module</a> <a id="65" href="Meta.Reflection.HLevel.html" class="Module">Meta.Reflection.HLevel</a> <a id="88" class="Keyword">where</a>

<a id="95" class="Keyword">open</a> <a id="100" class="Keyword">import</a> <a id="107" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="124" class="Keyword">open</a> <a id="129" class="Keyword">import</a> <a id="136" href="Foundations.Equiv.html" class="Module">Foundations.Equiv</a>
<a id="154" class="Keyword">open</a> <a id="159" class="Keyword">import</a> <a id="166" href="Foundations.Sigma.Properties.html" class="Module">Foundations.Sigma.Properties</a>
<a id="195" class="Keyword">open</a> <a id="200" class="Keyword">import</a> <a id="207" href="Foundations.Pi.Properties.html" class="Module">Foundations.Pi.Properties</a>
<a id="233" class="Keyword">open</a> <a id="238" class="Keyword">import</a> <a id="245" href="Foundations.HLevel.html" class="Module">Foundations.HLevel</a>
<a id="264" class="Keyword">open</a> <a id="269" class="Keyword">import</a> <a id="276" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="291" class="Keyword">open</a> <a id="296" class="Keyword">import</a> <a id="303" href="Data.List.Operations.html" class="Module">Data.List.Operations</a>
<a id="324" class="Keyword">open</a> <a id="329" class="Keyword">import</a> <a id="336" href="Data.List.Instances.html" class="Module">Data.List.Instances</a>
<a id="356" class="Keyword">open</a> <a id="361" class="Keyword">import</a> <a id="368" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="384" class="Keyword">open</a> <a id="389" class="Keyword">import</a> <a id="396" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="411" class="Keyword">open</a> <a id="416" class="Keyword">import</a> <a id="423" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="437" class="Keyword">open</a> <a id="442" class="Keyword">import</a> <a id="449" href="Structures.n-Type.html" class="Module">Structures.n-Type</a>
<a id="467" class="Keyword">open</a> <a id="472" class="Keyword">import</a> <a id="479" href="Data.Nat.Instances.html" class="Module">Data.Nat.Instances</a>
<a id="498" class="Keyword">open</a> <a id="503" class="Keyword">import</a> <a id="510" href="Data.String.Instances.html" class="Module">Data.String.Instances</a>

<a id="533" class="Keyword">open</a> <a id="538" class="Keyword">import</a> <a id="545" href="Meta.HLevel.html" class="Module">Meta.HLevel</a>
<a id="557" class="Keyword">open</a> <a id="562" class="Keyword">import</a> <a id="569" href="Meta.Underlying.html" class="Module">Meta.Underlying</a>
<a id="585" class="Keyword">open</a> <a id="590" class="Keyword">import</a> <a id="597" href="Meta.Foldable.html" class="Module">Meta.Foldable</a>
<a id="611" class="Keyword">open</a> <a id="616" class="Keyword">import</a> <a id="623" href="Meta.Reflection.Base.html" class="Module">Meta.Reflection.Base</a>

<a id="645" class="Comment">{-
Tactic for generating readable h-level proofs automatically. Contains an
essential reimplementation of the instance search mechanism, with
support for arbitrary level offsets (`level-minus) and searching under
binders (`search-under). Ambiguity is explicitly supported: the first
goal for which we can complete a proof tree is the one we go with.

The tactic works in a naÏve way, trying h-level lemmas until one
succeeds. There are three ways of making progress: Using a *projection
hint*, using a *decomposition hint*, or by falling back to instance
selection. The instance selection fallback is self-explanatory.

Projection hints handle the situation is-hlevel (X .p) n, where X
inhabits a record that contains evidence of its hlevel. If there is a
projection hint with `underlying-type == p`, then we use `has-level
(get-argument (X .p))` as the solution. Being a base case, projection
hints also handle raising h-levels: If `get-level (X .p) &lt; n`, we solve
by raising `has-level ...` the appropriate amount.

Decomposition hints are slightly more interesting. Decomposition hints
apply to a type, say P, and instruct the tactic on how to build an
application of type (is-hlevel P n). The way this application is built
is customizable.

Finding rules
-------------

Rules are found using instance search, specifically for the
&#39;hlevel-decomposition&#39; and &#39;hlevel-projection&#39; types. The
hlevel-projection type is flat, so the runtime of
projection-decomposition is *linear in the number of possible
projections*.

The hlevel-decomposition type is more interesting, since it is indexed
by the type that it can decompose. That way, we can use Agda&#39;s own
instance selection mechanism to narrow down to relevant decompositions.

Nondeterminism
--------------

In case more than one projection and/or decomposition hint is possible,
they will all be tried in order. This allows the tactic to generate
sensible-looking code, by trying simpler decompositions first. As an
example, the non-dependent lemmas for → and × will be tried before those
for Π and Σ, just like a human would.
-}</a>

<a id="2730" class="Comment">-- | Specifies how an argument should be filled in during elaboration of</a>
<a id="2803" class="Comment">-- an h-level lemma.</a>
<a id="2824" class="Keyword">data</a> <a id="Arg-spec"></a><a id="2829" href="Meta.Reflection.HLevel.html#2829" class="Datatype">Arg-spec</a> <a id="2838" class="Symbol">:</a> <a id="2840" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="2845" class="Keyword">where</a>
  <a id="Arg-spec.`level-minus"></a><a id="2853" href="Meta.Reflection.HLevel.html#2853" class="InductiveConstructor">`level-minus</a>  <a id="2867" class="Symbol">:</a> <a id="2869" class="Symbol">(</a><a id="2870" href="Meta.Reflection.HLevel.html#2870" class="Bound">n</a> <a id="2872" class="Symbol">:</a> <a id="2874" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2875" class="Symbol">)</a> <a id="2877" class="Symbol">→</a> <a id="2879" href="Meta.Reflection.HLevel.html#2829" class="Datatype">Arg-spec</a>
  <a id="2890" class="Comment">-- ^ Insert the level we&#39;re solving for minus the given offset (note</a>
  <a id="2961" class="Comment">-- that this is the wonky subtraction operation, &quot;monus&quot;) at this</a>
  <a id="3029" class="Comment">-- argument position</a>

  <a id="Arg-spec.`search-under"></a><a id="3053" href="Meta.Reflection.HLevel.html#3053" class="InductiveConstructor">`search-under</a> <a id="3067" class="Symbol">:</a> <a id="3069" class="Symbol">(</a><a id="3070" href="Meta.Reflection.HLevel.html#3070" class="Bound">n</a> <a id="3072" class="Symbol">:</a> <a id="3074" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3075" class="Symbol">)</a> <a id="3077" class="Symbol">→</a> <a id="3079" href="Meta.Reflection.HLevel.html#2829" class="Datatype">Arg-spec</a>
  <a id="3090" class="Comment">-- ^ Recursively search for an h-level witness, under @n@ visible</a>
  <a id="3158" class="Comment">-- lambdas. This is suitable for lemmas of type</a>
  <a id="3208" class="Comment">-- (∀ x y z → is-hlevel ...) → is-hlevel ...</a>

  <a id="Arg-spec.`meta"></a><a id="3256" href="Meta.Reflection.HLevel.html#3256" class="InductiveConstructor">`meta</a>         <a id="3270" class="Symbol">:</a> <a id="3272" href="Meta.Reflection.HLevel.html#2829" class="Datatype">Arg-spec</a>
  <a id="3283" class="Comment">-- ^ Insert a meta at this argument position. No search will be</a>
  <a id="3349" class="Comment">-- performed for this meta, so it must be solved from the context in</a>
  <a id="3420" class="Comment">-- which the lemma is used.</a>

<a id="3449" class="Comment">-- Common patterns: Keep the level, search in the current scope.</a>
<a id="3514" class="Keyword">pattern</a> <a id="`search"></a><a id="3522" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="3530" class="Symbol">=</a> <a id="3532" href="Meta.Reflection.HLevel.html#3053" class="InductiveConstructor">`search-under</a> <a id="3546" class="Number">0</a>
<a id="3548" class="Keyword">pattern</a> <a id="`level"></a><a id="3556" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="3563" class="Symbol">=</a> <a id="3565" href="Meta.Reflection.HLevel.html#2853" class="InductiveConstructor">`level-minus</a> <a id="3578" class="Number">0</a>

<a id="3581" class="Comment">-- | A specification for how to decompose the type @T@ into</a>
<a id="3641" class="Comment">-- sub-components, to establish an h-level result.</a>
<a id="3692" class="Keyword">data</a> <a id="hlevel-decomposition"></a><a id="3697" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="3718" class="Symbol">{</a><a id="3719" href="Meta.Reflection.HLevel.html#3719" class="Bound">ℓ</a><a id="3720" class="Symbol">}</a> <a id="3722" class="Symbol">(</a><a id="3723" href="Meta.Reflection.HLevel.html#3723" class="Bound">T</a> <a id="3725" class="Symbol">:</a> <a id="3727" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="3732" href="Meta.Reflection.HLevel.html#3719" class="Bound">ℓ</a><a id="3733" class="Symbol">)</a> <a id="3735" class="Symbol">:</a> <a id="3737" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="3742" class="Keyword">where</a>
  <a id="hlevel-decomposition.decomp"></a><a id="3750" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a>
    <a id="3761" class="Symbol">:</a> <a id="3763" class="Symbol">(</a><a id="3764" href="Meta.Reflection.HLevel.html#3764" class="Bound">h-level-lemma</a> <a id="3778" class="Symbol">:</a> <a id="3780" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="3784" class="Symbol">)</a> <a id="3786" class="Symbol">(</a><a id="3787" href="Meta.Reflection.HLevel.html#3787" class="Bound">arguments</a> <a id="3797" class="Symbol">:</a> <a id="3799" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3804" href="Meta.Reflection.HLevel.html#2829" class="Datatype">Arg-spec</a><a id="3812" class="Symbol">)</a>
    <a id="3818" class="Symbol">→</a> <a id="3820" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="3841" href="Meta.Reflection.HLevel.html#3723" class="Bound">T</a>
  <a id="3845" class="Comment">-- To prove that T has a given h-level, we can invoke the</a>
  <a id="3905" class="Comment">-- @h-level-lemma@ with the specified @arguments@.</a>

<a id="3957" class="Comment">-- | How to decompose an application of a record selector into something</a>
<a id="4030" class="Comment">-- which might have an h-level.</a>
<a id="4062" class="Keyword">record</a> <a id="hlevel-projection"></a><a id="4069" href="Meta.Reflection.HLevel.html#4069" class="Record">hlevel-projection</a> <a id="4087" class="Symbol">(</a><a id="4088" href="Meta.Reflection.HLevel.html#4088" class="Bound">proj</a> <a id="4093" class="Symbol">:</a> <a id="4095" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="4099" class="Symbol">)</a> <a id="4101" class="Symbol">:</a> <a id="4103" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="4108" class="Keyword">where</a>
  <a id="4116" class="Keyword">field</a>
    <a id="hlevel-projection.has-level"></a><a id="4126" href="Meta.Reflection.HLevel.html#4126" class="Field">has-level</a> <a id="4136" class="Symbol">:</a> <a id="4138" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
    <a id="4147" class="Comment">-- ^ The name of the h-level lemma. It must be sufficient to apply</a>
    <a id="4218" class="Comment">-- this name to the argument (see get-argument below); arg specs are</a>
    <a id="4291" class="Comment">-- not supported.</a>
    <a id="hlevel-projection.get-level"></a><a id="4313" href="Meta.Reflection.HLevel.html#4313" class="Field">get-level</a> <a id="4323" class="Symbol">:</a> <a id="4325" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="4330" class="Symbol">→</a> <a id="4332" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4335" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4344" class="Comment">-- ^ Given an application of underlying-type, what h-level does this</a>
    <a id="4417" class="Comment">-- type have? Necessary for computing lifts.</a>
    <a id="hlevel-projection.get-argument"></a><a id="4466" href="Meta.Reflection.HLevel.html#4466" class="Field">get-argument</a> <a id="4479" class="Symbol">:</a> <a id="4481" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4486" class="Symbol">(</a><a id="4487" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4491" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="4495" class="Symbol">)</a> <a id="4497" class="Symbol">→</a> <a id="4499" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4502" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4511" class="Comment">-- ^ Extract the argument out from under the application.</a>
<a id="4569" class="Comment">{-
Using projections
-----------------

Projection decomposition happens as follows; suppose we have some
neutral

  n = def (quote X) as

in order, every &#39;hlevel-projection&#39; instance definition will be tried;
Let us call a generic instance I. If I.underlying-type == X, then we&#39;ll
use this instance, otherwise, we fail (i.e. backtrack and try another
projection).

To use this instance, the get-level and get-argument functions are
involved; get-argument must take &#39;as&#39; and return some representative
sub-expression e. get-level will receive e&#39;s inferred type and must
return the h-level of the type n. Finally, we return

  I.has-level (get-argument e),

possibly wrapped in (k - get-level (get-argument e)) applications of
is-hlevel-suc.
-}</a>

<a id="5314" class="Keyword">open</a> <a id="5319" href="Meta.Reflection.HLevel.html#4069" class="Module">hlevel-projection</a>
<a id="5337" class="Keyword">private</a>
  <a id="5347" class="Comment">-- Throw an empty type error to try another alternative, stating the</a>
  <a id="5418" class="Comment">-- purpose of backtracking for debugging:</a>
  <a id="backtrack"></a><a id="5462" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="5472" class="Symbol">:</a> <a id="5474" class="Symbol">∀</a> <a id="5476" class="Symbol">{</a><a id="5477" href="Meta.Reflection.HLevel.html#5477" class="Bound">ℓ</a><a id="5478" class="Symbol">}</a> <a id="5480" class="Symbol">{</a><a id="5481" href="Meta.Reflection.HLevel.html#5481" class="Bound">A</a> <a id="5483" class="Symbol">:</a> <a id="5485" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="5490" href="Meta.Reflection.HLevel.html#5477" class="Bound">ℓ</a><a id="5491" class="Symbol">}</a> <a id="5493" class="Symbol">→</a> <a id="5495" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5500" href="Agda.Builtin.Reflection.html#7893" class="Datatype">ErrorPart</a> <a id="5510" class="Symbol">→</a> <a id="5512" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="5515" href="Meta.Reflection.HLevel.html#5481" class="Bound">A</a>
  <a id="5519" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="5529" href="Meta.Reflection.HLevel.html#5529" class="Bound">note</a> <a id="5534" class="Symbol">=</a> <a id="5536" class="Keyword">do</a>
    <a id="5543" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="5554" class="String">&quot;tactic.hlevel&quot;</a> <a id="5570" class="Number">10</a> <a id="5573" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="5575" class="String">&quot;Backtracking search... &quot;</a> <a id="5601" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5603" href="Meta.Reflection.HLevel.html#5529" class="Bound">note</a>
    <a id="5612" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="5622" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="5624" class="String">&quot;Search hit a dead-end: &quot;</a> <a id="5650" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5652" href="Meta.Reflection.HLevel.html#5529" class="Bound">note</a>

  <a id="5660" class="Comment">-- A list of names which we should not reduce while trying to invert</a>
  <a id="5731" class="Comment">-- an application of is-hlevel/is-prop/is-set into an &#39;underlying</a>
  <a id="5799" class="Comment">-- type&#39; and level arguments.</a>
  <a id="hlevel-types"></a><a id="5831" href="Meta.Reflection.HLevel.html#5831" class="Function">hlevel-types</a> <a id="5844" class="Symbol">:</a> <a id="5846" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5851" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
  <a id="5858" href="Meta.Reflection.HLevel.html#5831" class="Function">hlevel-types</a> <a id="5871" class="Symbol">=</a> <a id="5873" class="Keyword">quote</a> <a id="5879" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="5892" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5894" class="Keyword">quote</a> <a id="5900" href="Foundations.Base.html#12784" class="Function">is-prop</a> <a id="5908" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5910" class="Keyword">quote</a> <a id="5916" href="Foundations.Base.html#12853" class="Function">is-set</a> <a id="5923" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5925" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

  <a id="5931" class="Keyword">pattern</a> <a id="nat-lit"></a><a id="5939" href="Meta.Reflection.HLevel.html#5939" class="InductiveConstructor">nat-lit</a> <a id="5947" href="Meta.Reflection.HLevel.html#6004" class="Bound">n</a> <a id="5949" class="Symbol">=</a>
    <a id="5955" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="5959" class="Symbol">(</a><a id="5960" class="Keyword">quote</a> <a id="5966" href="Agda.Builtin.FromNat.html#281" class="Field">Number.fromNat</a><a id="5980" class="Symbol">)</a> <a id="5982" class="Symbol">(_</a> <a id="5985" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5987" class="Symbol">_</a> <a id="5989" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5991" class="Symbol">_</a> <a id="5993" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5995" class="InductiveConstructor">lit</a> <a id="5999" class="Symbol">(</a><a id="6000" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="6004" href="Meta.Reflection.HLevel.html#6004" class="Bound">n</a><a id="6005" class="Symbol">)</a> <a id="6007" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="6010" class="Symbol">_)</a>

  <a id="6016" class="Comment">-- Decompose an application of is-hlevel and/or one of the other</a>
  <a id="6083" class="Comment">-- &#39;hlevel-types&#39; into its constituent parts. Invariant:</a>
  <a id="6142" class="Comment">--</a>
  <a id="6147" class="Comment">--    decompose-is-hlevel′ t = (n , a) ⊢ t = is-of-hlevel n a</a>
  <a id="decompose-is-hlevel′"></a><a id="6211" href="Meta.Reflection.HLevel.html#6211" class="Function">decompose-is-hlevel′</a> <a id="6232" class="Symbol">:</a> <a id="6234" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6239" class="Symbol">→</a> <a id="6241" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6244" class="Symbol">(</a><a id="6245" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6250" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6252" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6256" class="Symbol">)</a>

  <a id="6261" class="Comment">-- Infer the type of the given term, and decompose it according to</a>
  <a id="6330" class="Comment">-- decompose-is-hlevel′.</a>
  <a id="decompose-is-hlevel"></a><a id="6357" href="Meta.Reflection.HLevel.html#6357" class="Function">decompose-is-hlevel</a> <a id="6377" class="Symbol">:</a> <a id="6379" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6384" class="Symbol">→</a> <a id="6386" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6389" class="Symbol">(</a><a id="6390" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6395" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6397" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6401" class="Symbol">)</a>
  <a id="6405" href="Meta.Reflection.HLevel.html#6357" class="Function">decompose-is-hlevel</a> <a id="6425" href="Meta.Reflection.HLevel.html#6425" class="Bound">goal</a> <a id="6430" class="Symbol">=</a> <a id="6432" class="Keyword">do</a>
    <a id="6439" href="Meta.Reflection.HLevel.html#6439" class="Bound">ty</a> <a id="6442" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6444" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="6459" class="Symbol">(</a><a id="6460" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="6466" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6468" href="Meta.Reflection.HLevel.html#5831" class="Function">hlevel-types</a><a id="6480" class="Symbol">)</a> <a id="6482" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="6484" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="6494" href="Meta.Reflection.HLevel.html#6425" class="Bound">goal</a> <a id="6499" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="6503" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
    <a id="6514" href="Meta.Reflection.HLevel.html#6211" class="Function">decompose-is-hlevel′</a> <a id="6535" href="Meta.Reflection.HLevel.html#6439" class="Bound">ty</a>

  <a id="6541" href="Meta.Reflection.HLevel.html#6211" class="Function">decompose-is-hlevel′</a> <a id="6562" href="Meta.Reflection.HLevel.html#6562" class="Bound">ty</a> <a id="6565" class="Symbol">=</a> <a id="6567" class="Keyword">do</a>
    <a id="6574" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6578" class="Symbol">(</a><a id="6579" class="Keyword">quote</a> <a id="6585" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a><a id="6597" class="Symbol">)</a> <a id="6599" class="Symbol">(_</a> <a id="6602" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6604" href="Meta.Reflection.HLevel.html#6604" class="Bound">lv</a> <a id="6607" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="6610" href="Meta.Reflection.HLevel.html#6610" class="Bound">ty</a> <a id="6613" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="6616" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6618" class="Symbol">)</a> <a id="6620" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6622" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6627" href="Meta.Reflection.HLevel.html#6562" class="Bound">ty</a>
      <a id="6636" class="Keyword">where</a>
        <a id="6650" class="Comment">-- Handle the ones with special names:</a>
        <a id="6697" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6701" class="Symbol">(</a><a id="6702" class="Keyword">quote</a> <a id="6708" href="Foundations.Base.html#12853" class="Function">is-set</a><a id="6714" class="Symbol">)</a> <a id="6716" class="Symbol">(_</a> <a id="6719" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6721" href="Meta.Reflection.HLevel.html#6721" class="Bound">ty</a> <a id="6724" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="6727" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6729" class="Symbol">)</a> <a id="6731" class="Symbol">→</a> <a id="6733" class="Keyword">do</a>
          <a id="6746" href="Meta.Reflection.HLevel.html#6746" class="Bound">ty</a> <a id="6749" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6751" href="Meta.Reflection.Base.html#4396" class="Function">wait-just-a-bit</a> <a id="6767" href="Meta.Reflection.HLevel.html#6721" class="Bound">ty</a>
          <a id="6780" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6785" class="Symbol">(</a><a id="6786" class="Keyword">quoteTerm</a> <a id="6796" class="Number">2</a> <a id="6798" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6800" href="Meta.Reflection.HLevel.html#6746" class="Bound">ty</a><a id="6802" class="Symbol">)</a>

        <a id="6813" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6817" class="Symbol">(</a><a id="6818" class="Keyword">quote</a> <a id="6824" href="Foundations.Base.html#12784" class="Function">is-prop</a><a id="6831" class="Symbol">)</a> <a id="6833" class="Symbol">(_</a> <a id="6836" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6838" href="Meta.Reflection.HLevel.html#6838" class="Bound">ty</a> <a id="6841" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="6844" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6846" class="Symbol">)</a> <a id="6848" class="Symbol">→</a> <a id="6850" class="Keyword">do</a>
          <a id="6863" href="Meta.Reflection.HLevel.html#6863" class="Bound">ty</a> <a id="6866" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6868" href="Meta.Reflection.Base.html#4396" class="Function">wait-just-a-bit</a> <a id="6884" href="Meta.Reflection.HLevel.html#6838" class="Bound">ty</a>
          <a id="6897" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6902" class="Symbol">(</a><a id="6903" class="Keyword">quoteTerm</a> <a id="6913" class="Number">1</a> <a id="6915" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6917" href="Meta.Reflection.HLevel.html#6863" class="Bound">ty</a><a id="6919" class="Symbol">)</a>

        <a id="6930" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6934" class="Symbol">(</a><a id="6935" class="Keyword">quote</a> <a id="6941" href="Foundations.Base.html#12640" class="Function">is-contr</a><a id="6949" class="Symbol">)</a> <a id="6951" class="Symbol">(_</a> <a id="6954" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6956" href="Meta.Reflection.HLevel.html#6956" class="Bound">ty</a> <a id="6959" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="6962" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6964" class="Symbol">)</a> <a id="6966" class="Symbol">→</a> <a id="6968" class="Keyword">do</a>
          <a id="6981" href="Meta.Reflection.HLevel.html#6981" class="Bound">ty</a> <a id="6984" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6986" href="Meta.Reflection.Base.html#4396" class="Function">wait-just-a-bit</a> <a id="7002" href="Meta.Reflection.HLevel.html#6956" class="Bound">ty</a>
          <a id="7015" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7020" class="Symbol">(</a><a id="7021" class="Keyword">quoteTerm</a> <a id="7031" class="Number">0</a> <a id="7033" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7035" href="Meta.Reflection.HLevel.html#6981" class="Bound">ty</a><a id="7037" class="Symbol">)</a>

        <a id="7048" class="CatchallClause Symbol">_</a> <a id="7050" class="Symbol">→</a> <a id="7052" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="7062" class="String">&quot;Goal type isn&#39;t is-hlevel&quot;</a>

    <a id="7095" class="Comment">-- To support having bare hlevel! in the source file, we need to</a>
    <a id="7164" class="Comment">-- block decomposition on having a rigid-ish type at the</a>
    <a id="7225" class="Comment">-- top-level. Otherwise the first hint that matches will get</a>
    <a id="7290" class="Comment">-- matched endlessly until we run out of fuel!</a>
    <a id="7341" href="Meta.Reflection.HLevel.html#7341" class="Bound">ty</a> <a id="7344" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="7346" href="Meta.Reflection.Base.html#4396" class="Function">wait-just-a-bit</a> <a id="7362" href="Meta.Reflection.HLevel.html#6610" class="Bound">ty</a>
    <a id="7369" href="Meta.Reflection.HLevel.html#7369" class="Bound">lv</a> <a id="7372" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="7374" href="Meta.Reflection.Base.html#4396" class="Function">wait-just-a-bit</a> <a id="7390" href="Meta.Reflection.HLevel.html#6604" class="Bound">lv</a>
    <a id="7397" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7402" class="Symbol">(</a><a id="7403" href="Meta.Reflection.HLevel.html#7369" class="Bound">lv</a> <a id="7406" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7408" href="Meta.Reflection.HLevel.html#7341" class="Bound">ty</a><a id="7410" class="Symbol">)</a>

<a id="7413" class="Comment">{-
Lifting n-Types
---------------

The n-types are the leaves of the hlevel solving process, so they&#39;re
pretty much our only opportunity to adjust levels in a big way. Suppose
you have

  T = def (quote X) as

with
  get-level (get-argument T) = n
  w : is-of-hlevel n T

but what you want is a witness of is-of-hlevel (k + n) T, where k is some
numeral? Well, the solution is obvious: we can compute k - n and lift
T&#39;s witness (k - n) levels. Right?

No: we&#39;re dealing with potential open naturals, so we have to be careful
about performing ‘symbolic’ subtractions. The way we do this is with,
essentially, a loop: If w doesn&#39;t work, then try

  is-hlevel-suc n w : is-hlevel (suc n) T

until you reach a sucᵏ n = k + n. Actually, slightly more efficient, we
keep around a counter k′ for the number of tries, and transfer successors
from the wanted level (k + n) until is-of-hlevel-+ n (sucᵏ′ n) w works.
-}</a>
  <a id="lift-sol"></a><a id="8325" href="Meta.Reflection.HLevel.html#8325" class="Function">lift-sol</a> <a id="8334" class="Symbol">:</a> <a id="8336" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8341" class="Symbol">→</a> <a id="8343" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8348" class="Symbol">→</a> <a id="8350" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8352" class="Symbol">→</a> <a id="8354" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8361" href="Meta.Reflection.HLevel.html#8325" class="Function">lift-sol</a> <a id="8370" href="Meta.Reflection.HLevel.html#8370" class="Bound">tm</a> <a id="8373" class="Symbol">_</a> <a id="8375" class="Number">0</a> <a id="8377" class="Symbol">=</a> <a id="8379" href="Meta.Reflection.HLevel.html#8370" class="Bound">tm</a>
  <a id="8384" href="Meta.Reflection.HLevel.html#8325" class="CatchallClause Function">lift-sol</a><a id="8392" class="CatchallClause"> </a><a id="8393" href="Meta.Reflection.HLevel.html#8393" class="CatchallClause Bound">tm</a><a id="8395" class="CatchallClause"> </a><a id="8396" href="Meta.Reflection.HLevel.html#8396" class="CatchallClause Bound">l1</a><a id="8398" class="CatchallClause"> </a><a id="8399" href="Meta.Reflection.HLevel.html#8399" class="CatchallClause Bound">l</a> <a id="8401" class="Symbol">=</a> <a id="8403" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="8407" class="Symbol">(</a><a id="8408" class="Keyword">quote</a> <a id="8414" href="Foundations.HLevel.Base.html#2253" class="Function">is-of-hlevel-+</a><a id="8428" class="Symbol">)</a> <a id="8430" class="Symbol">(</a><a id="8431" href="Meta.Reflection.HLevel.html#8396" class="Bound">l1</a> <a id="8434" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="8437" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8441" class="Symbol">(</a><a id="8442" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8446" href="Meta.Reflection.HLevel.html#8399" class="Bound">l</a><a id="8447" class="Symbol">)</a> <a id="8449" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="8452" href="Meta.Reflection.HLevel.html#8393" class="Bound">tm</a> <a id="8455" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="8458" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8460" class="Symbol">)</a>

  <a id="pred-term"></a><a id="8465" href="Meta.Reflection.HLevel.html#8465" class="Function">pred-term</a> <a id="8475" class="Symbol">:</a> <a id="8477" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8482" class="Symbol">→</a> <a id="8484" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="8490" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8497" href="Meta.Reflection.HLevel.html#8465" class="Function">pred-term</a> <a id="8507" class="Symbol">(</a><a id="8508" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="8512" class="Symbol">(</a><a id="8513" class="Keyword">quote</a> <a id="8519" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="8522" class="Symbol">)</a> <a id="8524" class="Symbol">(</a><a id="8525" href="Meta.Reflection.HLevel.html#8525" class="Bound">x</a> <a id="8527" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="8530" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8532" class="Symbol">))</a> <a id="8535" class="Symbol">=</a> <a id="8537" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8542" href="Meta.Reflection.HLevel.html#8525" class="Bound">x</a>
  <a id="8546" href="Meta.Reflection.HLevel.html#8465" class="Function">pred-term</a> <a id="8556" class="Symbol">(</a><a id="8557" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8561" class="Symbol">(</a><a id="8562" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8566" href="Meta.Reflection.HLevel.html#8566" class="Bound">n</a><a id="8567" class="Symbol">))</a> <a id="8570" class="Keyword">with</a> <a id="8575" href="Meta.Reflection.HLevel.html#8566" class="Bound">n</a>
  <a id="8579" class="Symbol">...</a> <a id="8583" class="Symbol">|</a> <a id="8585" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8589" href="Meta.Reflection.HLevel.html#8589" class="Bound">k</a> <a id="8591" class="Symbol">=</a> <a id="8593" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8598" class="Symbol">(</a><a id="8599" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8603" class="Symbol">(</a><a id="8604" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8608" href="Meta.Reflection.HLevel.html#8589" class="Bound">k</a><a id="8609" class="Symbol">))</a>
  <a id="8614" class="CatchallClause Symbol">...</a><a id="8617" class="CatchallClause"> </a><a id="8618" class="CatchallClause Symbol">|</a><a id="8619" class="CatchallClause"> </a><a id="8620" class="CatchallClause Symbol">_</a> <a id="8622" class="Symbol">=</a> <a id="8624" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
  <a id="8634" href="Meta.Reflection.HLevel.html#8465" class="CatchallClause Function">pred-term</a><a id="8643" class="CatchallClause"> </a><a id="8644" class="CatchallClause Symbol">_</a> <a id="8646" class="Symbol">=</a> <a id="8648" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="lifting-loop"></a><a id="8659" href="Meta.Reflection.HLevel.html#8659" class="Function">lifting-loop</a> <a id="8672" class="Symbol">:</a> <a id="8674" class="Symbol">(</a><a id="8675" href="Meta.Reflection.HLevel.html#8675" class="Bound">fuel</a> <a id="8680" class="Symbol">:</a> <a id="8682" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="8683" class="Symbol">)</a> <a id="8685" class="Symbol">→</a> <a id="8687" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8689" class="Symbol">→</a> <a id="8691" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8696" class="Symbol">→</a> <a id="8698" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8703" class="Symbol">→</a> <a id="8705" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8710" class="Symbol">→</a> <a id="8712" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8717" class="Symbol">→</a> <a id="8719" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="8722" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="8726" href="Meta.Reflection.HLevel.html#8659" class="Function">lifting-loop</a> <a id="8739" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="8744" class="Symbol">_</a> <a id="8746" class="Symbol">_</a> <a id="8748" class="Symbol">_</a> <a id="8750" class="Symbol">_</a> <a id="8752" class="Symbol">_</a> <a id="8754" class="Symbol">=</a> <a id="8756" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="8766" class="String">&quot;Lifting loop ran out of fuel&quot;</a>
  <a id="8799" href="Meta.Reflection.HLevel.html#8659" class="Function">lifting-loop</a> <a id="8812" class="Symbol">(</a><a id="8813" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8817" href="Meta.Reflection.HLevel.html#8817" class="Bound">fuel</a><a id="8821" class="Symbol">)</a> <a id="8823" href="Meta.Reflection.HLevel.html#8823" class="Bound">it</a> <a id="8826" href="Meta.Reflection.HLevel.html#8826" class="Bound">solution</a> <a id="8835" href="Meta.Reflection.HLevel.html#8835" class="Bound">goal</a> <a id="8840" href="Meta.Reflection.HLevel.html#8840" class="Bound">l1</a> <a id="8843" href="Meta.Reflection.HLevel.html#8843" class="Bound">l2</a> <a id="8846" class="Symbol">=</a>
    <a id="8852" href="Meta.Reflection.HLevel.html#9067" class="Function">let&#39;s-hope</a> <a id="8863" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="8867" class="Keyword">do</a>
      <a id="8876" class="Symbol">(</a><a id="8877" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8882" href="Meta.Reflection.HLevel.html#8882" class="Bound">l2′</a><a id="8885" class="Symbol">)</a> <a id="8887" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="8889" href="Meta.Reflection.HLevel.html#8465" class="Function">pred-term</a> <a id="8899" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="8903" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="8913" href="Meta.Reflection.HLevel.html#8843" class="Bound">l2</a> <a id="8916" class="Keyword">where</a>
        <a id="8930" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="8938" class="Symbol">→</a> <a id="8940" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="8950" class="String">&quot;Lifting loop reached its end with no success&quot;</a>
      <a id="9003" href="Meta.Reflection.HLevel.html#8659" class="Function">lifting-loop</a> <a id="9016" href="Meta.Reflection.HLevel.html#8817" class="Bound">fuel</a> <a id="9021" class="Symbol">(</a><a id="9022" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9026" href="Meta.Reflection.HLevel.html#8823" class="Bound">it</a><a id="9028" class="Symbol">)</a> <a id="9030" href="Meta.Reflection.HLevel.html#8826" class="Bound">solution</a> <a id="9039" href="Meta.Reflection.HLevel.html#8835" class="Bound">goal</a> <a id="9044" href="Meta.Reflection.HLevel.html#8840" class="Bound">l1</a> <a id="9047" href="Meta.Reflection.HLevel.html#8882" class="Bound">l2′</a>
    <a id="9055" class="Keyword">where</a>
      <a id="9067" href="Meta.Reflection.HLevel.html#9067" class="Function">let&#39;s-hope</a> <a id="9078" class="Symbol">:</a> <a id="9080" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9083" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="9091" href="Meta.Reflection.HLevel.html#9067" class="Function">let&#39;s-hope</a> <a id="9102" class="Symbol">=</a> <a id="9104" class="Keyword">do</a>
        <a id="9115" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9126" class="String">&quot;tactic.hlevel&quot;</a> <a id="9142" class="Number">30</a> <a id="9145" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="9147" class="String">&quot;Lifting loop: Trying &quot;</a> <a id="9171" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9173" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9181" class="Symbol">(</a><a id="9182" href="Meta.Reflection.HLevel.html#8325" class="Function">lift-sol</a> <a id="9191" href="Meta.Reflection.HLevel.html#8826" class="Bound">solution</a> <a id="9200" href="Meta.Reflection.HLevel.html#8840" class="Bound">l1</a> <a id="9203" href="Meta.Reflection.HLevel.html#8823" class="Bound">it</a><a id="9205" class="Symbol">)</a> <a id="9207" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9209" class="String">&quot; for level &quot;</a> <a id="9223" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9225" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9233" href="Meta.Reflection.HLevel.html#8843" class="Bound">l2</a> <a id="9236" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9238" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="9249" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="9255" href="Meta.Reflection.HLevel.html#8835" class="Bound">goal</a> <a id="9260" class="Symbol">(</a><a id="9261" href="Meta.Reflection.HLevel.html#8325" class="Function">lift-sol</a> <a id="9270" href="Meta.Reflection.HLevel.html#8826" class="Bound">solution</a> <a id="9279" href="Meta.Reflection.HLevel.html#8840" class="Bound">l1</a> <a id="9282" href="Meta.Reflection.HLevel.html#8823" class="Bound">it</a><a id="9284" class="Symbol">)</a>
    <a id="9290" class="Comment">-- con (quote suc) (</a>

  <a id="9314" class="Comment">-- Projection decomposition.</a>
  <a id="treat-as-n-type"></a><a id="9345" href="Meta.Reflection.HLevel.html#9345" class="Function">treat-as-n-type</a> <a id="9361" class="Symbol">:</a> <a id="9363" class="Symbol">∀</a> <a id="9365" class="Symbol">{</a><a id="9366" href="Meta.Reflection.HLevel.html#9366" class="Bound">n</a><a id="9367" class="Symbol">}</a> <a id="9369" class="Symbol">→</a> <a id="9371" href="Meta.Reflection.HLevel.html#4069" class="Record">hlevel-projection</a> <a id="9389" href="Meta.Reflection.HLevel.html#9366" class="Bound">n</a> <a id="9391" class="Symbol">→</a> <a id="9393" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="9398" class="Symbol">→</a> <a id="9400" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9403" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="9407" href="Meta.Reflection.HLevel.html#9345" class="Function">treat-as-n-type</a> <a id="9423" href="Meta.Reflection.HLevel.html#9423" class="Bound">projection</a> <a id="9434" href="Meta.Reflection.HLevel.html#9434" class="Bound">goal</a> <a id="9439" class="Symbol">=</a> <a id="9441" class="Keyword">do</a>
    <a id="9448" class="Comment">-- First we must be looking at a goal which is of the type is-hlevel</a>
    <a id="9521" class="Comment">-- A n. We&#39;ll need both n and A.</a>
    <a id="9558" class="Symbol">(</a><a id="9559" href="Meta.Reflection.HLevel.html#9559" class="Bound">wanted-level</a> <a id="9572" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9574" href="Meta.Reflection.HLevel.html#9574" class="Bound">ty</a><a id="9576" class="Symbol">)</a> <a id="9578" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="9580" href="Meta.Reflection.HLevel.html#6357" class="Function">decompose-is-hlevel</a> <a id="9600" href="Meta.Reflection.HLevel.html#9434" class="Bound">goal</a>
    <a id="9609" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9620" class="String">&quot;tactic.hlevel&quot;</a> <a id="9636" class="Number">10</a> <a id="9639" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
      <a id="9647" class="String">&quot;Attempting to treat as &quot;</a> <a id="9673" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9675" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9683" href="Meta.Reflection.HLevel.html#9559" class="Bound">wanted-level</a> <a id="9696" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9698" class="String">&quot;-Type: &quot;</a> <a id="9708" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9710" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9718" href="Meta.Reflection.HLevel.html#9574" class="Bound">ty</a> <a id="9721" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9723" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="9730" href="Meta.Reflection.HLevel.html#9730" class="Bound">ty</a> <a id="9733" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="9735" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="9742" href="Meta.Reflection.HLevel.html#9574" class="Bound">ty</a>

    <a id="9750" class="Comment">-- Reduce the type to whnf and check whether the outermost term</a>
    <a id="9818" class="Comment">-- constructor is an application of the projection we&#39;re looking</a>
    <a id="9887" class="Comment">-- for.</a>
    <a id="9899" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="9903" href="Meta.Reflection.HLevel.html#9903" class="Bound">namen</a> <a id="9909" href="Meta.Reflection.HLevel.html#9909" class="Bound">args</a> <a id="9914" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="9916" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="9925" href="Meta.Reflection.HLevel.html#9730" class="Bound">ty</a>
      <a id="9934" class="Keyword">where</a> <a id="9940" href="Meta.Reflection.HLevel.html#9940" class="CatchallClause Bound">what</a> <a id="9945" class="Symbol">→</a> <a id="9947" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="9957" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="9959" class="String">&quot;Thing isn&#39;t an application, it is &quot;</a> <a id="9996" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9998" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10006" href="Meta.Reflection.HLevel.html#9940" class="Bound">what</a> <a id="10011" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10013" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10021" href="Meta.Reflection.HLevel.html#10021" class="Bound">it</a> <a id="10024" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10026" href="Meta.Reflection.HLevel.html#9423" class="Bound">projection</a> <a id="10037" class="Symbol">.</a><a id="10038" href="Meta.Reflection.HLevel.html#4466" class="Field">get-argument</a> <a id="10051" href="Meta.Reflection.HLevel.html#9909" class="Bound">args</a>

    <a id="10061" class="Comment">-- And compute the level of the projected thing, in addition to a</a>
    <a id="10131" class="Comment">-- numeral form of the wanted level.</a>
    <a id="10172" href="Meta.Reflection.HLevel.html#10172" class="Bound">actual-level</a> <a id="10185" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10187" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="10197" href="Meta.Reflection.HLevel.html#10021" class="Bound">it</a> <a id="10200" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="10204" href="Meta.Reflection.HLevel.html#9423" class="Bound">projection</a> <a id="10215" class="Symbol">.</a><a id="10216" href="Meta.Reflection.HLevel.html#4313" class="Field">get-level</a>

    <a id="10231" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="10242" class="String">&quot;tactic.hlevel&quot;</a> <a id="10258" class="Number">10</a> <a id="10261" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
      <a id="10269" class="String">&quot;... but it&#39;s actually a(n) &quot;</a> <a id="10299" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10301" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10309" href="Meta.Reflection.HLevel.html#10172" class="Bound">actual-level</a> <a id="10322" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10324" class="String">&quot;-Type&quot;</a> <a id="10332" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10334" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10342" href="Meta.Reflection.HLevel.html#10342" class="Bound">lv</a> <a id="10345" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10347" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10357" href="Meta.Reflection.HLevel.html#9559" class="Bound">wanted-level</a>
    <a id="10374" href="Meta.Reflection.HLevel.html#10374" class="Bound">lv′</a> <a id="10378" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10380" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10390" href="Meta.Reflection.HLevel.html#10172" class="Bound">actual-level</a>
    <a id="10407" href="Meta.Reflection.HLevel.html#8659" class="Function">lifting-loop</a> <a id="10420" class="Number">10000</a> <a id="10426" class="Number">0</a> <a id="10428" class="Symbol">(</a><a id="10429" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10433" class="Symbol">(</a><a id="10434" href="Meta.Reflection.HLevel.html#9423" class="Bound">projection</a> <a id="10445" class="Symbol">.</a><a id="10446" href="Meta.Reflection.HLevel.html#4126" class="Field">has-level</a><a id="10455" class="Symbol">)</a> <a id="10457" class="Symbol">(</a><a id="10458" href="Meta.Reflection.HLevel.html#10021" class="Bound">it</a> <a id="10461" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="10464" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10466" class="Symbol">))</a> <a id="10469" href="Meta.Reflection.HLevel.html#9434" class="Bound">goal</a> <a id="10474" href="Meta.Reflection.HLevel.html#10374" class="Bound">lv′</a> <a id="10478" href="Meta.Reflection.HLevel.html#10342" class="Bound">lv</a>

    <a id="10486" href="Agda.Builtin.Reflection.html#9521" class="Postulate">commitTC</a>

  <a id="10498" class="Comment">-- Fall back to Agda&#39;s instance search mechanism. This isn&#39;t as</a>
  <a id="10564" class="Comment">-- straightforward as just using the &#39;hlevel&#39; function for a couple of</a>
  <a id="10637" class="Comment">-- reasons.</a>
  <a id="use-instance-search"></a><a id="10651" href="Meta.Reflection.HLevel.html#10651" class="Function">use-instance-search</a> <a id="10671" class="Symbol">:</a> <a id="10673" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="10678" class="Symbol">→</a> <a id="10680" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="10685" class="Symbol">→</a> <a id="10687" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="10690" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="10694" href="Meta.Reflection.HLevel.html#10651" class="Function">use-instance-search</a> <a id="10714" href="Meta.Reflection.HLevel.html#10714" class="Bound">has-alts</a> <a id="10723" href="Meta.Reflection.HLevel.html#10723" class="Bound">goal</a> <a id="10728" class="Symbol">=</a> <a id="10730" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="10745" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="10747" class="Keyword">do</a>
    <a id="10754" class="Symbol">(</a><a id="10755" href="Meta.Reflection.HLevel.html#10755" class="Bound">lv</a> <a id="10758" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10760" href="Meta.Reflection.HLevel.html#10760" class="Bound">ty</a><a id="10762" class="Symbol">)</a> <a id="10764" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10766" href="Meta.Reflection.HLevel.html#6357" class="Function">decompose-is-hlevel</a> <a id="10786" href="Meta.Reflection.HLevel.html#10723" class="Bound">goal</a>
    <a id="10795" href="Meta.Reflection.HLevel.html#10795" class="Bound">solved</a><a id="10801" class="Symbol">@(</a><a id="10803" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="10808" href="Meta.Reflection.HLevel.html#10808" class="Bound">mv</a> <a id="10811" class="Symbol">_)</a> <a id="10814" href="Meta.Bind.html#183" class="Field Operator">←</a>
      <a id="10822" href="Meta.Reflection.Base.html#1768" class="Function">new-meta</a> <a id="10831" class="Symbol">(</a><a id="10832" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10836" class="Symbol">(</a><a id="10837" class="Keyword">quote</a> <a id="10843" href="Meta.HLevel.html#174" class="Record">H-Level</a><a id="10850" class="Symbol">)</a> <a id="10852" class="Symbol">(</a><a id="10853" href="Meta.Reflection.HLevel.html#10755" class="Bound">lv</a> <a id="10856" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="10859" href="Meta.Reflection.HLevel.html#10760" class="Bound">ty</a> <a id="10862" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="10865" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10867" class="Symbol">))</a> <a id="10870" class="Keyword">where</a> <a id="10876" class="CatchallClause Symbol">_</a> <a id="10878" class="Symbol">→</a> <a id="10880" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="10890" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="10897" href="Meta.Reflection.HLevel.html#10897" class="Bound">instances</a> <a id="10907" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10909" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="10922" href="Meta.Reflection.HLevel.html#10808" class="Bound">mv</a>

    <a id="10930" href="Meta.Reflection.HLevel.html#10930" class="Bound">t</a> <a id="10932" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10934" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="10942" href="Meta.Reflection.HLevel.html#10897" class="Bound">instances</a>
    <a id="10956" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="10967" class="String">&quot;tactic.hlevel&quot;</a> <a id="10983" class="Number">10</a> <a id="10986" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
      <a id="10994" class="String">&quot;Using instance search for\n&quot;</a> <a id="11024" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11026" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11034" href="Meta.Reflection.HLevel.html#10760" class="Bound">ty</a> <a id="11037" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
      <a id="11045" class="String">&quot;\nFound candidates\n &quot;</a> <a id="11069" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11071" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11079" href="Meta.Reflection.HLevel.html#10930" class="Bound">t</a> <a id="11081" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11083" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="11091" class="Comment">-- We actually want to manage the instance searching ourselves,</a>
    <a id="11159" class="Comment">-- sorta, to avoid getting into situations where the macro has</a>
    <a id="11226" class="Comment">-- committed to instance search but Agda will disagree with it.</a>
    <a id="11294" class="Keyword">let</a>
      <a id="11304" href="Meta.Reflection.HLevel.html#11304" class="Bound">go</a> <a id="11307" class="Symbol">:</a> <a id="11309" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="11314" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="11319" class="Symbol">→</a> <a id="11321" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="11324" class="Symbol">(</a><a id="11325" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="11327" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="11329" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="11333" class="Symbol">)</a>
      <a id="11341" href="Meta.Reflection.HLevel.html#11304" class="Bound">go</a> <a id="11344" class="Symbol">=</a> <a id="11346" class="Symbol">λ</a> <a id="11348" class="Keyword">where</a>
        <a id="11362" class="Comment">-- If there is *exactly* one instance candidate for this goal,</a>
        <a id="11433" class="Comment">-- then we can go ahead and solve it. That&#39;s because having</a>
        <a id="11501" class="Comment">-- exactly one instance means Agda will solve using that</a>
        <a id="11566" class="Comment">-- instance!</a>
        <a id="11587" class="Symbol">(</a><a id="11588" href="Meta.Reflection.HLevel.html#11588" class="Bound">x</a> <a id="11590" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11592" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11594" class="Symbol">)</a> <a id="11596" class="Symbol">→</a> <a id="11598" class="Keyword">do</a>
          <a id="11611" class="Comment">-- Note that, since getInstances works by creating a new meta,</a>
          <a id="11684" class="Comment">-- we have to commit to the instance ourselves.</a>
          <a id="11742" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11748" href="Meta.Reflection.HLevel.html#10795" class="Bound">solved</a> <a id="11755" href="Meta.Reflection.HLevel.html#11588" class="Bound">x</a>
          <a id="11767" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="11782" class="Symbol">(</a><a id="11783" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="11789" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11791" class="Keyword">quote</a> <a id="11797" href="Meta.HLevel.html#314" class="Function">hlevel</a> <a id="11804" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11806" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11808" class="Symbol">)</a> <a id="11810" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="11812" href="Agda.Builtin.Reflection.html#10063" class="Postulate">withReconstructed</a> <a id="11830" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="11835" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
            <a id="11849" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11855" href="Meta.Reflection.HLevel.html#10723" class="Bound">goal</a> <a id="11860" class="Symbol">(</a><a id="11861" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="11865" class="Symbol">(</a><a id="11866" class="Keyword">quote</a> <a id="11872" href="Meta.HLevel.html#314" class="Function">hlevel</a><a id="11878" class="Symbol">)</a> <a id="11880" class="Symbol">(</a><a id="11881" href="Meta.Reflection.HLevel.html#10755" class="Bound">lv</a> <a id="11884" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="11887" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11889" class="Symbol">))</a>
          <a id="11902" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="11907" class="Symbol">(</a><a id="11908" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="11911" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11913" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="11917" class="Symbol">)</a>

        <a id="11928" class="Comment">-- If there are any more alternatives to be tried after this</a>
        <a id="11997" class="Comment">-- one, then we fail (backtrack). Otherwise, we discard the TC</a>
        <a id="12068" class="Comment">-- state but indicate success: this will cause the meta to be</a>
        <a id="12138" class="Comment">-- solved with an interaction point (if using</a>
        <a id="12192" class="Comment">-- elaborate-and-give).</a>
        <a id="12224" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="12227" class="Symbol">→</a> <a id="12229" href="Data.Bool.Base.html#492" class="Function Operator">if</a> <a id="12232" href="Meta.Reflection.HLevel.html#10714" class="Bound">has-alts</a>
          <a id="12251" href="Data.Bool.Base.html#492" class="Function Operator">then</a> <a id="12256" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="12266" class="String">&quot;No possible instances, but have other decompositions to try&quot;</a>
          <a id="12338" href="Data.Bool.Base.html#492" class="Function Operator">else</a> <a id="12343" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="12348" class="Symbol">(</a><a id="12349" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12352" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12354" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="12359" class="Symbol">)</a>

        <a id="12370" class="CatchallClause Symbol">_</a> <a id="12372" class="Symbol">→</a> <a id="12374" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="12384" class="String">&quot;Too many possible instances; will not use instance search for this goal&quot;</a>
    <a id="12462" href="Meta.Reflection.HLevel.html#11304" class="Bound">go</a> <a id="12465" href="Meta.Reflection.HLevel.html#10897" class="Bound">instances</a>

  <a id="12478" class="Comment">-- Entry point for calling the tactic.</a>
  <a id="search"></a><a id="12519" href="Meta.Reflection.HLevel.html#12519" class="Function">search</a> <a id="12526" class="Symbol">:</a> <a id="12528" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="12533" class="Symbol">→</a> <a id="12535" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12540" class="Symbol">→</a> <a id="12542" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="12544" class="Symbol">→</a> <a id="12546" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12551" class="Symbol">→</a> <a id="12553" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="12556" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="12560" class="Comment">-- Give up if we&#39;re out of fuel:</a>
  <a id="12595" href="Meta.Reflection.HLevel.html#12519" class="Function">search</a> <a id="12602" href="Meta.Reflection.HLevel.html#12602" class="Bound">has-alts</a> <a id="12611" class="Symbol">_</a>     <a id="12617" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="12625" href="Meta.Reflection.HLevel.html#12625" class="Bound">goal</a> <a id="12630" class="Symbol">=</a> <a id="12632" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="12638" href="Meta.Reflection.HLevel.html#12625" class="Bound">goal</a> <a id="12643" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>

  <a id="12654" class="Comment">-- Actual main loop: try using the hints database, try treating the</a>
  <a id="12724" class="Comment">-- goal as an n-type, fall back to instance search.</a>
  <a id="12778" href="Meta.Reflection.HLevel.html#12519" class="Function">search</a> <a id="12785" href="Meta.Reflection.HLevel.html#12785" class="Bound">has-alts</a> <a id="12794" href="Meta.Reflection.HLevel.html#12794" class="Bound">level</a> <a id="12800" class="Symbol">(</a><a id="12801" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12805" href="Meta.Reflection.HLevel.html#12805" class="Bound">n</a><a id="12806" class="Symbol">)</a> <a id="12808" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a> <a id="12813" class="Symbol">=</a>
    <a id="12819" href="Meta.Reflection.HLevel.html#13137" class="Function">use-projections</a>
      <a id="12841" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="12845" href="Meta.Reflection.HLevel.html#21483" class="Function">use-hints</a>
      <a id="12861" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="12865" href="Meta.Reflection.HLevel.html#10651" class="Function">use-instance-search</a> <a id="12885" href="Meta.Reflection.HLevel.html#12785" class="Bound">has-alts</a> <a id="12894" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a>
      <a id="12905" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="12909" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="12919" class="String">&quot;Search failed!!&quot;</a>
    <a id="12941" class="Keyword">where</a>
      <a id="12953" class="Keyword">open</a> <a id="12958" href="Meta.Reflection.HLevel.html#4069" class="Module">hlevel-projection</a>

      <a id="12983" class="Comment">-- Nondeterministically use a projection for establishing the</a>
      <a id="13051" class="Comment">-- result. This follows the approach described in [Using</a>
      <a id="13114" class="Comment">-- projections].</a>
      <a id="13137" href="Meta.Reflection.HLevel.html#13137" class="Function">use-projections</a> <a id="13153" class="Symbol">:</a> <a id="13155" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="13158" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="13166" href="Meta.Reflection.HLevel.html#13137" class="Function">use-projections</a> <a id="13182" class="Symbol">=</a> <a id="13184" class="Keyword">do</a>
        <a id="13195" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13199" href="Meta.Reflection.HLevel.html#13199" class="Bound">qn</a> <a id="13202" class="Symbol">_</a> <a id="13204" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13206" class="Symbol">(</a><a id="13207" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="13211" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="13215" href="Meta.Reflection.HLevel.html#6357" class="Function">decompose-is-hlevel</a> <a id="13235" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a><a id="13239" class="Symbol">)</a> <a id="13241" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="13245" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
          <a id="13262" class="Keyword">where</a> <a id="13268" class="CatchallClause Symbol">_</a> <a id="13270" class="Symbol">→</a> <a id="13272" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="13282" class="String">&quot;Term is not headed by a definition; ignoring projections.&quot;</a>

        <a id="13351" href="Meta.Reflection.HLevel.html#13351" class="Bound">goalt</a> <a id="13357" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13359" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="13369" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a>
        <a id="13382" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="13393" class="String">&quot;tactic.hlevel&quot;</a> <a id="13409" class="Number">20</a> <a id="13412" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
          <a id="13424" class="String">&quot;Will attempt to use projections for goal\n  &quot;</a> <a id="13471" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13473" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13481" href="Meta.Reflection.HLevel.html#13351" class="Bound">goalt</a> <a id="13487" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13489" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="13501" class="Symbol">(</a><a id="13502" href="Meta.Reflection.HLevel.html#13502" class="Bound">solved</a> <a id="13509" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13511" href="Meta.Reflection.HLevel.html#13511" class="Bound">instances</a><a id="13520" class="Symbol">)</a> <a id="13522" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13524" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="13539" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="13541" class="Keyword">do</a>
          <a id="13554" href="Meta.Reflection.HLevel.html#13554" class="Bound">solved</a><a id="13560" class="Symbol">@(</a><a id="13562" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="13567" href="Meta.Reflection.HLevel.html#13567" class="Bound">mv</a> <a id="13570" class="Symbol">_)</a> <a id="13573" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13575" href="Meta.Reflection.Base.html#1768" class="Function">new-meta</a> <a id="13584" class="Symbol">(</a><a id="13585" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13589" class="Symbol">(</a><a id="13590" class="Keyword">quote</a> <a id="13596" href="Meta.Reflection.HLevel.html#4069" class="Record">hlevel-projection</a><a id="13613" class="Symbol">)</a> <a id="13615" class="Symbol">(</a><a id="13616" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="13620" class="Symbol">(</a><a id="13621" href="Agda.Builtin.Reflection.html#4283" class="InductiveConstructor">name</a> <a id="13626" href="Meta.Reflection.HLevel.html#13199" class="Bound">qn</a><a id="13628" class="Symbol">)</a> <a id="13630" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="13633" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13635" class="Symbol">))</a>
            <a id="13650" class="Keyword">where</a> <a id="13656" class="CatchallClause Symbol">_</a> <a id="13658" class="Symbol">→</a> <a id="13660" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="13670" class="Symbol">(</a><a id="13671" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13679" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a> <a id="13684" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13686" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13688" class="Symbol">)</a>

          <a id="13701" class="Comment">-- If there are some hints, then great, otherwise we discard</a>
          <a id="13772" class="Comment">-- the TC state.</a>
          <a id="13799" class="Symbol">(</a><a id="13800" href="Meta.Reflection.HLevel.html#13800" class="Bound">x</a> <a id="13802" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13804" href="Meta.Reflection.HLevel.html#13804" class="Bound">xs</a><a id="13806" class="Symbol">)</a> <a id="13808" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13810" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="13823" href="Meta.Reflection.HLevel.html#13567" class="Bound">mv</a>
            <a id="13838" class="Keyword">where</a> <a id="13844" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="13847" class="Symbol">→</a> <a id="13849" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="13854" class="Symbol">((</a><a id="13856" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="13864" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13866" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13868" class="Symbol">)</a> <a id="13870" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13872" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="13877" class="Symbol">)</a>

          <a id="13890" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="13895" class="Symbol">((</a><a id="13897" href="Meta.Reflection.HLevel.html#13554" class="Bound">solved</a> <a id="13904" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13906" href="Meta.Reflection.HLevel.html#13800" class="Bound">x</a> <a id="13908" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13910" href="Meta.Reflection.HLevel.html#13804" class="Bound">xs</a><a id="13912" class="Symbol">)</a> <a id="13914" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13916" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="13920" class="Symbol">)</a>

        <a id="13931" href="Meta.Foldable.html#503" class="Function">nondet</a> <a id="13938" class="Symbol">(</a><a id="13939" href="Meta.Idiom.html#121" class="InductiveConstructor">eff</a> <a id="13943" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="13947" class="Symbol">)</a> <a id="13949" href="Meta.Reflection.HLevel.html#13511" class="Bound">instances</a> <a id="13959" class="Symbol">λ</a> <a id="13961" href="Meta.Reflection.HLevel.html#13961" class="Bound">a</a> <a id="13963" class="Symbol">→</a> <a id="13965" class="Keyword">do</a>
          <a id="13978" href="Meta.Reflection.HLevel.html#13978" class="Bound">projection</a> <a id="13989" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13991" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="14001" class="Symbol">{</a><a id="14002" class="Argument">A</a> <a id="14004" class="Symbol">=</a> <a id="14006" href="Meta.Reflection.HLevel.html#4069" class="Record">hlevel-projection</a> <a id="14024" href="Meta.Reflection.HLevel.html#13199" class="Bound">qn</a><a id="14026" class="Symbol">}</a> <a id="14028" href="Meta.Reflection.HLevel.html#13961" class="Bound">a</a>
          <a id="14040" href="Meta.Reflection.HLevel.html#14040" class="Bound">ty</a> <a id="14043" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="14045" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="14060" class="Symbol">(</a><a id="14061" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="14067" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14069" href="Meta.Reflection.HLevel.html#5831" class="Function">hlevel-types</a><a id="14081" class="Symbol">)</a> <a id="14083" class="Symbol">(</a><a id="14084" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="14094" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a> <a id="14099" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="14103" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="14109" class="Symbol">)</a>
          <a id="14121" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="14132" class="String">&quot;tactic.hlevel&quot;</a> <a id="14148" class="Number">20</a> <a id="14151" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
            <a id="14165" class="String">&quot;Outer type: &quot;</a> <a id="14180" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14182" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="14190" href="Meta.Reflection.HLevel.html#14040" class="Bound">ty</a> <a id="14193" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14195" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="14208" href="Meta.Reflection.HLevel.html#9345" class="Function">treat-as-n-type</a> <a id="14224" href="Meta.Reflection.HLevel.html#13978" class="Bound">projection</a> <a id="14235" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a> <a id="14240" href="Meta.Bind.html#289" class="Function Operator">&gt;&gt;</a> <a id="14243" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="14249" href="Meta.Reflection.HLevel.html#13502" class="Bound">solved</a> <a id="14256" href="Meta.Reflection.HLevel.html#13961" class="Bound">a</a>

      <a id="14265" class="Comment">-- Get rid of any invisible binders that lead the term.</a>
      <a id="14327" href="Meta.Reflection.HLevel.html#14327" class="Function">remove-invisible</a> <a id="14344" class="Symbol">:</a> <a id="14346" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14351" class="Symbol">→</a> <a id="14353" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14358" class="Symbol">→</a> <a id="14360" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="14363" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14374" href="Meta.Reflection.HLevel.html#14327" class="Function">remove-invisible</a>
        <a id="14399" class="Symbol">(</a><a id="14400" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14404" class="Symbol">_</a> <a id="14406" class="Symbol">(</a><a id="14407" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14411" class="Symbol">_</a> <a id="14413" href="Meta.Reflection.HLevel.html#14413" class="Bound">t</a><a id="14414" class="Symbol">))</a>
        <a id="14425" class="Symbol">(</a><a id="14426" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="14429" class="Symbol">(</a><a id="14430" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="14434" class="Symbol">(</a><a id="14435" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="14444" href="Meta.Reflection.HLevel.html#14444" class="Bound">invisible</a> <a id="14454" class="Symbol">_)</a> <a id="14457" class="Symbol">_)</a> <a id="14460" class="Symbol">(</a><a id="14461" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14465" class="Symbol">_</a> <a id="14467" href="Meta.Reflection.HLevel.html#14467" class="Bound">ret</a><a id="14470" class="Symbol">))</a>
        <a id="14481" class="Symbol">=</a> <a id="14483" href="Meta.Reflection.HLevel.html#14327" class="Function">remove-invisible</a> <a id="14500" href="Meta.Reflection.HLevel.html#14413" class="Bound">t</a> <a id="14502" href="Meta.Reflection.HLevel.html#14467" class="Bound">ret</a>
      <a id="14512" href="Meta.Reflection.HLevel.html#14327" class="CatchallClause Function">remove-invisible</a><a id="14528" class="CatchallClause"> </a><a id="14529" href="Meta.Reflection.HLevel.html#14529" class="CatchallClause Bound">inner</a><a id="14534" class="CatchallClause"> </a><a id="14535" class="CatchallClause Symbol">_</a> <a id="14537" class="Symbol">=</a> <a id="14539" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="14544" href="Meta.Reflection.HLevel.html#14529" class="Bound">inner</a>

      <a id="14557" class="Comment">-- Search using decompositions involves manipulating the scope,</a>
      <a id="14627" class="Comment">-- which is why it&#39;s spread over so many functions, and even then,</a>
      <a id="14700" class="Comment">-- some are too big.</a>

      <a id="14728" class="Comment">-- Wrap the given term in a series of visible lambdas.</a>
      <a id="14789" href="Meta.Reflection.HLevel.html#14789" class="Function">wrap-lams</a> <a id="14799" class="Symbol">:</a> <a id="14801" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="14803" class="Symbol">→</a> <a id="14805" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14810" class="Symbol">→</a> <a id="14812" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14823" href="Meta.Reflection.HLevel.html#14789" class="Function">wrap-lams</a> <a id="14833" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="14838" href="Meta.Reflection.HLevel.html#14838" class="Bound">r</a> <a id="14840" class="Symbol">=</a> <a id="14842" href="Meta.Reflection.HLevel.html#14838" class="Bound">r</a>
      <a id="14850" href="Meta.Reflection.HLevel.html#14789" class="Function">wrap-lams</a> <a id="14860" class="Symbol">(</a><a id="14861" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="14865" href="Meta.Reflection.HLevel.html#14865" class="Bound">x</a><a id="14866" class="Symbol">)</a> <a id="14868" href="Meta.Reflection.HLevel.html#14868" class="Bound">r</a> <a id="14870" class="Symbol">=</a> <a id="14872" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14876" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="14884" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="14886" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14890" class="String">&quot;a&quot;</a> <a id="14894" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="14896" href="Meta.Reflection.HLevel.html#14789" class="Function">wrap-lams</a> <a id="14906" href="Meta.Reflection.HLevel.html#14865" class="Bound">x</a> <a id="14908" href="Meta.Reflection.HLevel.html#14868" class="Bound">r</a>

      <a id="14917" class="Comment">-- Compute a continuation which extends the context by n visible</a>
      <a id="14988" class="Comment">-- variables, all typed &#39;unknown&#39;.</a>
      <a id="15029" href="Meta.Reflection.HLevel.html#15029" class="Function">extend-n</a> <a id="15038" class="Symbol">:</a> <a id="15040" class="Symbol">∀</a> <a id="15042" class="Symbol">{</a><a id="15043" href="Meta.Reflection.HLevel.html#15043" class="Bound">ℓ</a><a id="15044" class="Symbol">}</a> <a id="15046" class="Symbol">→</a> <a id="15048" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="15050" class="Symbol">→</a> <a id="15052" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15055" class="Symbol">((</a><a id="15057" href="Meta.Reflection.HLevel.html#15057" class="Bound">A</a> <a id="15059" class="Symbol">:</a> <a id="15061" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="15066" href="Meta.Reflection.HLevel.html#15043" class="Bound">ℓ</a><a id="15067" class="Symbol">)</a> <a id="15069" class="Symbol">→</a> <a id="15071" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15074" href="Meta.Reflection.HLevel.html#15057" class="Bound">A</a> <a id="15076" class="Symbol">→</a> <a id="15078" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15081" href="Meta.Reflection.HLevel.html#15057" class="Bound">A</a><a id="15082" class="Symbol">)</a>
      <a id="15090" href="Meta.Reflection.HLevel.html#15029" class="Function">extend-n</a> <a id="15099" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="15104" class="Symbol">=</a> <a id="15106" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15111" class="Symbol">λ</a> <a id="15113" href="Meta.Reflection.HLevel.html#15113" class="Bound">_</a> <a id="15115" href="Meta.Reflection.HLevel.html#15115" class="Bound">x</a> <a id="15117" class="Symbol">→</a> <a id="15119" href="Meta.Reflection.HLevel.html#15115" class="Bound">x</a>
      <a id="15127" href="Meta.Reflection.HLevel.html#15029" class="Function">extend-n</a> <a id="15136" class="Symbol">(</a><a id="15137" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="15141" href="Meta.Reflection.HLevel.html#15141" class="Bound">n</a><a id="15142" class="Symbol">)</a> <a id="15144" class="Symbol">=</a> <a id="15146" class="Keyword">do</a>
        <a id="15157" href="Meta.Reflection.HLevel.html#15157" class="Bound">rest</a> <a id="15162" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="15164" href="Meta.Reflection.HLevel.html#15029" class="Function">extend-n</a> <a id="15173" href="Meta.Reflection.HLevel.html#15141" class="Bound">n</a>
        <a id="15183" href="Foundations.Prim.Type.html#651" class="InductiveConstructor">lift</a> <a id="15188" href="Meta.Reflection.HLevel.html#15188" class="Bound">mv</a> <a id="15191" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="15193" href="Meta.Reflection.HLevel.html#15157" class="Bound">rest</a> <a id="15198" class="Symbol">(</a><a id="15199" href="Foundations.Prim.Type.html#590" class="Record">Lift</a> <a id="15204" class="Symbol">_</a> <a id="15206" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15210" class="Symbol">)</a> <a id="15212" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="15214" href="Foundations.Prim.Type.html#651" class="InductiveConstructor">lift</a> <a id="15219" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="15223" href="Meta.Reflection.Base.html#1768" class="Function">new-meta</a> <a id="15232" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="15248" class="Keyword">let</a> <a id="15252" href="Meta.Reflection.HLevel.html#15252" class="Bound">domain</a> <a id="15259" class="Symbol">=</a> <a id="15261" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="15265" class="Symbol">(</a><a id="15266" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="15275" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="15283" class="Symbol">(</a><a id="15284" href="Agda.Builtin.Reflection.html#3463" class="InductiveConstructor">modality</a> <a id="15293" href="Agda.Builtin.Reflection.html#3019" class="InductiveConstructor">relevant</a> <a id="15302" href="Agda.Builtin.Reflection.html#3241" class="InductiveConstructor">quantity-ω</a><a id="15312" class="Symbol">))</a> <a id="15315" href="Meta.Reflection.HLevel.html#15188" class="Bound">mv</a>
        <a id="15326" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15331" class="Symbol">λ</a> <a id="15333" href="Meta.Reflection.HLevel.html#15333" class="Bound">a</a> <a id="15335" href="Meta.Reflection.HLevel.html#15335" class="Bound">k</a> <a id="15337" class="Symbol">→</a> <a id="15339" href="Meta.Reflection.HLevel.html#15157" class="Bound">rest</a> <a id="15344" href="Meta.Reflection.HLevel.html#15333" class="Bound">a</a> <a id="15346" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="15348" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="15362" class="String">&quot;a&quot;</a> <a id="15366" href="Meta.Reflection.HLevel.html#15252" class="Bound">domain</a> <a id="15373" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="15375" href="Meta.Reflection.HLevel.html#15335" class="Bound">k</a>

      <a id="15384" class="Comment">-- Given a list of argument specs, actually unify the goal with</a>
      <a id="15454" class="Comment">-- the solution of decomposition, and call a continuation to</a>
      <a id="15521" class="Comment">-- perform any outstanding searches.</a>
      <a id="15564" href="Meta.Reflection.HLevel.html#15564" class="Function">gen-args</a>
        <a id="15581" class="Symbol">:</a> <a id="15583" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>              <a id="15601" class="Comment">-- ^ Are there any alternatives after this one?</a>
        <a id="15657" class="Symbol">→</a> <a id="15659" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>              <a id="15677" class="Comment">-- ^ What level are we searching for?</a>

        <a id="15724" class="Symbol">→</a> <a id="15726" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>              <a id="15744" class="Comment">-- ^ Name of the lemma,</a>
        <a id="15776" class="Symbol">→</a> <a id="15778" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15783" href="Meta.Reflection.HLevel.html#2829" class="Datatype">Arg-spec</a>     <a id="15796" class="Comment">-- ^ and the arguments we should invent.</a>

        <a id="15846" class="Symbol">→</a> <a id="15848" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15853" class="Symbol">(</a><a id="15854" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="15858" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15862" class="Symbol">)</a>
        <a id="15872" class="Comment">-- ^ Accumulator: computed arguments (criminally, in reverse</a>
        <a id="15941" class="Comment">-- order)</a>
        <a id="15959" class="Symbol">→</a> <a id="15961" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15964" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
          <a id="15976" class="Comment">-- ^ Accumulator/continuation: what do we need to do after</a>
          <a id="16045" class="Comment">-- unifying the goal with the lemma?. This is both</a>
          <a id="16106" class="Comment">-- continuation (it can be used to run something after the</a>
          <a id="16175" class="Comment">-- arguments are built) and accumulator (searching recursively</a>
          <a id="16248" class="Comment">-- is done last).</a>
        <a id="16274" class="Symbol">→</a> <a id="16276" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="16279" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>              <a id="16294" class="Comment">-- ^ Returns nada</a>
      <a id="16318" href="Meta.Reflection.HLevel.html#15564" class="Function">gen-args</a> <a id="16327" href="Meta.Reflection.HLevel.html#16327" class="Bound">has-alts</a> <a id="16336" href="Meta.Reflection.HLevel.html#16336" class="Bound">level</a> <a id="16342" href="Meta.Reflection.HLevel.html#16342" class="Bound">defn</a> <a id="16347" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="16350" href="Meta.Reflection.HLevel.html#16350" class="Bound">accum</a> <a id="16356" href="Meta.Reflection.HLevel.html#16356" class="Bound">cont</a> <a id="16361" class="Symbol">=</a> <a id="16363" class="Keyword">do</a>
        <a id="16374" class="Comment">-- If we have no arguments to generate, then we can go ahead and</a>
        <a id="16447" class="Comment">-- use the accumulator as-is.</a>
        <a id="16485" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="16491" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a> <a id="16496" class="Symbol">(</a><a id="16497" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16501" href="Meta.Reflection.HLevel.html#16342" class="Bound">defn</a> <a id="16506" class="Symbol">(</a><a id="16507" href="Data.List.Base.html#846" class="Function">reverse</a> <a id="16515" href="Meta.Reflection.HLevel.html#16350" class="Bound">accum</a><a id="16520" class="Symbol">))</a>
        <a id="16531" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="16542" class="String">&quot;tactic.hlevel&quot;</a> <a id="16558" class="Number">10</a> <a id="16561" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
          <a id="16573" class="String">&quot;Committed to solution: &quot;</a> <a id="16599" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16601" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="16609" class="Symbol">(</a><a id="16610" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16614" href="Meta.Reflection.HLevel.html#16342" class="Bound">defn</a> <a id="16619" class="Symbol">(</a><a id="16620" href="Data.List.Base.html#846" class="Function">reverse</a> <a id="16628" href="Meta.Reflection.HLevel.html#16350" class="Bound">accum</a><a id="16633" class="Symbol">))</a> <a id="16636" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16638" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="16649" href="Meta.Reflection.HLevel.html#16356" class="Bound">cont</a>

      <a id="16661" href="Meta.Reflection.HLevel.html#15564" class="Function">gen-args</a> <a id="16670" href="Meta.Reflection.HLevel.html#16670" class="Bound">has-alts</a> <a id="16679" href="Meta.Reflection.HLevel.html#16679" class="Bound">level</a> <a id="16685" href="Meta.Reflection.HLevel.html#16685" class="Bound">defn</a> <a id="16690" class="Symbol">(</a><a id="16691" href="Meta.Reflection.HLevel.html#16691" class="Bound">x</a> <a id="16693" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16695" href="Meta.Reflection.HLevel.html#16695" class="Bound">args</a><a id="16699" class="Symbol">)</a> <a id="16701" href="Meta.Reflection.HLevel.html#16701" class="Bound">accum</a> <a id="16707" href="Meta.Reflection.HLevel.html#16707" class="Bound">cont</a> <a id="16712" class="Keyword">with</a> <a id="16717" href="Meta.Reflection.HLevel.html#16691" class="Bound">x</a>
      <a id="16725" class="Comment">-- If we got asked for the level without an adjustment (i.e. monus</a>
      <a id="16798" class="Comment">-- by zero), then we may as well not bother *trying* to adjust it.</a>
      <a id="16871" class="Comment">-- Saves a bit of computation.</a>
      <a id="16908" class="Symbol">...</a> <a id="16912" class="Symbol">|</a> <a id="16914" href="Meta.Reflection.HLevel.html#2853" class="InductiveConstructor">`level-minus</a> <a id="16927" class="Number">0</a> <a id="16929" class="Symbol">=</a> <a id="16931" href="Meta.Reflection.HLevel.html#15564" class="Function">gen-args</a> <a id="16940" class="Bound">has-alts</a> <a id="16949" class="Bound">level</a> <a id="16955" class="Bound">defn</a> <a id="16960" class="Bound">args</a> <a id="16965" class="Symbol">(</a><a id="16966" class="Bound">level</a> <a id="16972" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="16975" class="Bound">accum</a><a id="16980" class="Symbol">)</a> <a id="16982" class="Bound">cont</a>
      <a id="16993" class="Comment">-- If we have to insert the level minus some offset, then we need</a>
      <a id="17065" class="Comment">-- to do the computation:</a>
      <a id="17097" class="Symbol">...</a> <a id="17101" class="Symbol">|</a> <a id="17103" href="Meta.Reflection.HLevel.html#2853" class="InductiveConstructor">`level-minus</a> <a id="17116" href="Meta.Reflection.HLevel.html#17116" class="Bound">n</a><a id="17117" class="Symbol">@(</a><a id="17119" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17123" class="Symbol">_)</a> <a id="17126" class="Symbol">=</a>
        <a id="17136" class="Keyword">do</a>
          <a id="17149" href="Meta.Reflection.HLevel.html#17149" class="Bound">level</a> <a id="17155" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="17157" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="17167" class="Bound">level</a>
          <a id="17183" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="17194" class="String">&quot;tactic.hlevel&quot;</a> <a id="17210" class="Number">10</a> <a id="17213" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
            <a id="17227" class="String">&quot;Hint demands offset, performing symbolic monus, subtracting from\n  &quot;</a> <a id="17298" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17300" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="17308" href="Meta.Reflection.HLevel.html#17149" class="Bound">level</a> <a id="17314" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17316" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="17329" href="Meta.Reflection.HLevel.html#17329" class="Bound">level′′</a> <a id="17337" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="17339" href="Meta.Reflection.HLevel.html#17924" class="Function">monus</a> <a id="17345" href="Meta.Reflection.HLevel.html#17149" class="Bound">level</a> <a id="17351" href="Meta.Reflection.HLevel.html#17116" class="Bound">n</a>
          <a id="17363" class="Comment">-- Reduce otherwise we get Number.fromNat as the term</a>
          <a id="17427" href="Meta.Reflection.HLevel.html#15564" class="Function">gen-args</a> <a id="17436" class="Bound">has-alts</a> <a id="17445" href="Meta.Reflection.HLevel.html#17149" class="Bound">level</a> <a id="17451" class="Bound">defn</a> <a id="17456" class="Bound">args</a> <a id="17461" class="Symbol">(</a><a id="17462" href="Meta.Reflection.HLevel.html#17329" class="Bound">level′′</a> <a id="17470" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="17473" class="Bound">accum</a><a id="17478" class="Symbol">)</a> <a id="17480" class="Bound">cont</a>
        <a id="17493" class="Keyword">where</a>
          <a id="17509" class="Comment">-- A &#39;symbolic&#39; monus function. If we&#39;re looking at an actual</a>
          <a id="17581" class="Comment">-- number, then we can just do the computation in TC, but</a>
          <a id="17649" class="Comment">-- otherwise we have to reimplement the builtin subtraction,</a>
          <a id="17720" class="Comment">-- where the minuend is a *term* rather than a number. In</a>
          <a id="17788" class="Comment">-- addition to being a bad operation (monus, grr), it&#39;s</a>
          <a id="17854" class="Comment">-- *partial*. We can end up backtracking while subtracting.</a>
          <a id="17924" href="Meta.Reflection.HLevel.html#17924" class="Function">monus</a> <a id="17930" class="Symbol">:</a> <a id="17932" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="17937" class="Symbol">→</a> <a id="17939" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="17941" class="Symbol">→</a> <a id="17943" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="17946" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
          <a id="17961" href="Meta.Reflection.HLevel.html#17924" class="Function">monus</a> <a id="17967" class="Symbol">(</a><a id="17968" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="17972" class="Symbol">(</a><a id="17973" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="17977" href="Meta.Reflection.HLevel.html#17977" class="Bound">n</a><a id="17978" class="Symbol">))</a> <a id="17981" href="Meta.Reflection.HLevel.html#17981" class="Bound">k</a> <a id="17983" class="Symbol">=</a> <a id="17985" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="17990" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="17992" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="17996" class="Symbol">(</a><a id="17997" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18001" class="Symbol">(</a><a id="18002" href="Meta.Reflection.HLevel.html#17977" class="Bound">n</a> <a id="18004" href="Agda.Builtin.Nat.html#426" class="Primitive Operator">-</a> <a id="18006" href="Meta.Reflection.HLevel.html#17981" class="Bound">k</a><a id="18007" class="Symbol">))</a>
          <a id="18020" href="Meta.Reflection.HLevel.html#17924" class="CatchallClause Function">monus</a><a id="18025" class="CatchallClause"> </a><a id="18026" href="Meta.Reflection.HLevel.html#18026" class="CatchallClause Bound">tm</a><a id="18028" class="CatchallClause"> </a><a id="18029" href="Agda.Builtin.Nat.html#221" class="CatchallClause InductiveConstructor">zero</a> <a id="18034" class="Symbol">=</a> <a id="18036" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18041" href="Meta.Reflection.HLevel.html#18026" class="Bound">tm</a>
          <a id="18054" href="Meta.Reflection.HLevel.html#17924" class="Function">monus</a> <a id="18060" href="Meta.Reflection.HLevel.html#18060" class="Bound">thezero</a><a id="18067" class="Symbol">@(</a><a id="18069" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18073" class="Symbol">(</a><a id="18074" class="Keyword">quote</a> <a id="18080" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="18084" class="Symbol">)</a> <a id="18086" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18088" class="Symbol">)</a> <a id="18090" class="Symbol">(</a><a id="18091" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18095" href="Meta.Reflection.HLevel.html#18095" class="Bound">it</a><a id="18097" class="Symbol">)</a> <a id="18099" class="Symbol">=</a> <a id="18101" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18106" href="Meta.Reflection.HLevel.html#18060" class="Bound">thezero</a>
          <a id="18124" href="Meta.Reflection.HLevel.html#17924" class="Function">monus</a> <a id="18130" class="Symbol">(</a><a id="18131" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18135" class="Symbol">(</a><a id="18136" class="Keyword">quote</a> <a id="18142" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="18145" class="Symbol">)</a> <a id="18147" class="Symbol">(</a><a id="18148" href="Meta.Reflection.HLevel.html#18148" class="Bound">x</a> <a id="18150" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="18153" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18155" class="Symbol">))</a> <a id="18158" class="Symbol">(</a><a id="18159" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18163" href="Meta.Reflection.HLevel.html#18163" class="Bound">it</a><a id="18165" class="Symbol">)</a> <a id="18167" class="Symbol">=</a> <a id="18169" class="Keyword">do</a>
            <a id="18184" href="Meta.Reflection.HLevel.html#18184" class="Bound">x</a> <a id="18186" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="18188" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="18195" href="Meta.Reflection.HLevel.html#18148" class="Bound">x</a>
            <a id="18209" href="Meta.Reflection.HLevel.html#17924" class="Function">monus</a> <a id="18215" href="Meta.Reflection.HLevel.html#18184" class="Bound">x</a> <a id="18217" href="Meta.Reflection.HLevel.html#18163" class="Bound">it</a>
          <a id="18230" href="Meta.Reflection.HLevel.html#17924" class="CatchallClause Function">monus</a><a id="18235" class="CatchallClause"> </a><a id="18236" href="Meta.Reflection.HLevel.html#18236" class="CatchallClause Bound">tm</a><a id="18238" class="CatchallClause"> </a><a id="18239" class="CatchallClause Symbol">(</a><a id="18240" href="Agda.Builtin.Nat.html#234" class="CatchallClause InductiveConstructor">suc</a><a id="18243" class="CatchallClause"> </a><a id="18244" href="Meta.Reflection.HLevel.html#18244" class="CatchallClause Bound">it</a><a id="18246" class="CatchallClause Symbol">)</a> <a id="18248" class="Symbol">=</a> <a id="18250" class="Keyword">do</a>
            <a id="18265" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="18276" class="String">&quot;tactic.hlevel&quot;</a> <a id="18292" class="Number">10</a> <a id="18295" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="18297" class="String">&quot;Dunno how to take 1 from &quot;</a> <a id="18325" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18327" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="18335" href="Meta.Reflection.HLevel.html#18236" class="Bound">tm</a> <a id="18338" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18340" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
            <a id="18355" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="18365" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="18375" class="Comment">-- Insert a metavariable, to be solved by Agda. It&#39;d be sad if the</a>
      <a id="18448" class="Comment">-- macro handled everything!</a>
      <a id="18483" class="Symbol">...</a> <a id="18487" class="Symbol">|</a> <a id="18489" href="Meta.Reflection.HLevel.html#3256" class="InductiveConstructor">`meta</a> <a id="18495" class="Symbol">=</a> <a id="18497" href="Meta.Reflection.HLevel.html#15564" class="Function">gen-args</a> <a id="18506" class="Bound">has-alts</a> <a id="18515" class="Bound">level</a> <a id="18521" class="Bound">defn</a> <a id="18526" class="Bound">args</a> <a id="18531" class="Symbol">(</a><a id="18532" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="18540" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="18543" class="Bound">accum</a><a id="18548" class="Symbol">)</a> <a id="18550" class="Bound">cont</a>

      <a id="18562" class="Symbol">...</a> <a id="18566" class="Symbol">|</a> <a id="18568" href="Meta.Reflection.HLevel.html#3053" class="InductiveConstructor">`search-under</a> <a id="18582" href="Meta.Reflection.HLevel.html#18582" class="Bound">under</a> <a id="18588" class="Symbol">=</a> <a id="18590" class="Keyword">do</a>
        <a id="18601" class="Comment">-- To search under some variables, we work in a scope extended</a>
        <a id="18672" class="Comment">-- by &#39;under&#39;-many variables. The metavariable lives in that</a>
        <a id="18741" class="Comment">-- scope, so we have to quantify over the variables we</a>
        <a id="18804" class="Comment">-- introduced to use it outside, i.e., in the actual (outer)</a>
        <a id="18873" class="Comment">-- search problem.</a>
        <a id="18900" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="18911" class="String">&quot;tactic.hlevel&quot;</a> <a id="18927" class="Number">10</a> <a id="18930" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="18932" class="String">&quot;Going under &quot;</a> <a id="18947" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18949" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="18957" class="Symbol">(</a><a id="18958" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="18962" class="Symbol">(</a><a id="18963" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18967" href="Meta.Reflection.HLevel.html#18582" class="Bound">under</a><a id="18972" class="Symbol">))</a> <a id="18975" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18977" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="18988" href="Meta.Reflection.HLevel.html#18988" class="Bound">gounder</a> <a id="18996" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="18998" href="Meta.Reflection.HLevel.html#15029" class="Function">extend-n</a> <a id="19007" href="Meta.Reflection.HLevel.html#18582" class="Bound">under</a>
        <a id="19021" href="Meta.Reflection.HLevel.html#19021" class="Bound">mv</a> <a id="19024" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="19026" href="Meta.Reflection.HLevel.html#18988" class="Bound">gounder</a> <a id="19034" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19039" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19041" class="Keyword">do</a>
          <a id="19054" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19065" class="String">&quot;tactic.hlevel&quot;</a> <a id="19081" class="Number">10</a> <a id="19084" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19086" class="String">&quot;In extended context&quot;</a>
          <a id="19118" href="Meta.Reflection.Base.html#1768" class="Function">new-meta</a> <a id="19127" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="19143" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19154" class="String">&quot;tactic.hlevel&quot;</a> <a id="19170" class="Number">10</a> <a id="19173" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19175" class="String">&quot;Metavariable: &quot;</a> <a id="19192" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19194" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="19202" class="Symbol">(</a><a id="19203" href="Meta.Reflection.HLevel.html#14789" class="Function">wrap-lams</a> <a id="19213" href="Meta.Reflection.HLevel.html#18582" class="Bound">under</a> <a id="19219" href="Meta.Reflection.HLevel.html#19021" class="Bound">mv</a><a id="19221" class="Symbol">)</a> <a id="19223" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19225" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="19236" class="Comment">-- After we&#39;ve put the mv wrapped under some lambdas in the</a>
        <a id="19304" class="Comment">-- argument list,</a>
        <a id="19330" href="Meta.Reflection.HLevel.html#15564" class="Function">gen-args</a> <a id="19339" class="Bound">has-alts</a> <a id="19348" class="Bound">level</a> <a id="19354" class="Bound">defn</a> <a id="19359" class="Bound">args</a> <a id="19364" class="Symbol">(</a><a id="19365" href="Meta.Reflection.HLevel.html#14789" class="Function">wrap-lams</a> <a id="19375" href="Meta.Reflection.HLevel.html#18582" class="Bound">under</a> <a id="19381" href="Meta.Reflection.HLevel.html#19021" class="Bound">mv</a> <a id="19384" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="19387" class="Bound">accum</a><a id="19392" class="Symbol">)</a> <a id="19394" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19396" class="Keyword">do</a>
          <a id="19409" class="Comment">-- On our way back up, we do any more searching that needed to</a>
          <a id="19482" class="Comment">-- get done, and..</a>
          <a id="19511" class="Bound">cont</a>
          <a id="19526" class="Comment">-- go back under the new scope to recursively search for</a>
          <a id="19593" class="Comment">-- levels.</a>
          <a id="19614" href="Meta.Reflection.HLevel.html#18988" class="Bound">gounder</a> <a id="19622" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="19624" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19626" href="Meta.Reflection.HLevel.html#12519" class="Function">search</a> <a id="19633" class="Bound">has-alts</a> <a id="19642" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="19650" href="Meta.Reflection.HLevel.html#12805" class="Bound">n</a> <a id="19652" href="Meta.Reflection.HLevel.html#19021" class="Bound">mv</a>

      <a id="19662" class="Comment">-- Try all the candidate hints in order. This is a version of</a>
      <a id="19730" class="Comment">-- &#39;nondet&#39; which additionally threads whether we&#39;re looking at</a>
      <a id="19800" class="Comment">-- last alternative.</a>
      <a id="19827" href="Meta.Reflection.HLevel.html#19827" class="Function">use-decomp-hints</a> <a id="19844" class="Symbol">:</a> <a id="19846" class="Symbol">(</a><a id="19847" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19852" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="19854" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="19858" class="Symbol">)</a> <a id="19860" class="Symbol">→</a> <a id="19862" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19867" class="Symbol">→</a> <a id="19869" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="19874" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19879" class="Symbol">→</a> <a id="19881" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="19884" class="Symbol">(</a><a id="19885" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="19887" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="19889" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="19893" class="Symbol">)</a>
      <a id="19901" href="Meta.Reflection.HLevel.html#19827" class="Function">use-decomp-hints</a> <a id="19918" class="Symbol">(</a><a id="19919" href="Meta.Reflection.HLevel.html#19919" class="Bound">lv</a> <a id="19922" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="19924" href="Meta.Reflection.HLevel.html#19924" class="Bound">goal-ty</a><a id="19931" class="Symbol">)</a> <a id="19933" href="Meta.Reflection.HLevel.html#19933" class="Bound">solved</a> <a id="19940" class="Symbol">(</a><a id="19941" href="Meta.Reflection.HLevel.html#19941" class="Bound">c1</a> <a id="19944" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19946" href="Meta.Reflection.HLevel.html#19946" class="Bound">cs</a><a id="19948" class="Symbol">)</a> <a id="19950" class="Symbol">=</a> <a id="19952" class="Keyword">do</a>
        <a id="19963" href="Meta.Reflection.HLevel.html#19963" class="Bound">ty</a> <a id="19966" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="19968" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="19978" href="Meta.Reflection.HLevel.html#19941" class="Bound">c1</a>
        <a id="19989" href="Meta.Reflection.HLevel.html#19989" class="Bound">c1′</a> <a id="19993" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="19995" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="20002" href="Meta.Reflection.HLevel.html#19941" class="Bound">c1</a>
        <a id="20013" class="Symbol">(</a><a id="20014" href="Meta.Reflection.HLevel.html#14327" class="Function">remove-invisible</a> <a id="20031" href="Meta.Reflection.HLevel.html#19989" class="Bound">c1′</a> <a id="20035" href="Meta.Reflection.HLevel.html#19963" class="Bound">ty</a> <a id="20038" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="20042" class="Symbol">λ</a> <a id="20044" class="Keyword">where</a>

          <a id="20061" class="Comment">-- If we have an actual decomp constructor, then we can try</a>
          <a id="20131" class="Comment">-- using its argument specification to construct a little</a>
          <a id="20199" class="Comment">-- h-level lemma</a>
          <a id="20226" class="Symbol">(</a><a id="20227" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="20231" class="Symbol">(</a><a id="20232" class="Keyword">quote</a> <a id="20238" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a><a id="20244" class="Symbol">)</a> <a id="20246" class="Symbol">(_</a> <a id="20249" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20251" class="Symbol">_</a> <a id="20253" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20255" href="Meta.Reflection.HLevel.html#20255" class="Bound">nm</a> <a id="20258" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="20261" href="Meta.Reflection.HLevel.html#20261" class="Bound">argspec</a> <a id="20269" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="20272" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20274" class="Symbol">))</a> <a id="20277" class="Symbol">→</a> <a id="20279" class="Keyword">do</a>
            <a id="20294" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="20305" class="String">&quot;tactic.hlevel&quot;</a> <a id="20321" class="Number">10</a> <a id="20324" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
              <a id="20340" class="String">&quot;Using &quot;</a> <a id="20349" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20351" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20359" href="Meta.Reflection.HLevel.html#20255" class="Bound">nm</a> <a id="20362" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20364" class="String">&quot; decomposition for:\n  &quot;</a>
              <a id="20404" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20406" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20414" class="Symbol">(</a><a id="20415" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="20419" class="Symbol">(</a><a id="20420" class="Keyword">quote</a> <a id="20426" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a><a id="20438" class="Symbol">)</a> <a id="20440" class="Symbol">(</a><a id="20441" href="Meta.Reflection.HLevel.html#19919" class="Bound">lv</a> <a id="20444" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="20447" href="Meta.Reflection.HLevel.html#19924" class="Bound">goal-ty</a> <a id="20455" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="20458" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20460" class="Symbol">))</a> <a id="20463" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20465" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

            <a id="20481" href="Meta.Reflection.HLevel.html#20481" class="Bound">nm′</a> <a id="20485" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="20487" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20497" href="Meta.Reflection.HLevel.html#20255" class="Bound">nm</a>
            <a id="20512" href="Meta.Reflection.HLevel.html#20512" class="Bound">argsp</a> <a id="20518" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="20520" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20530" href="Meta.Reflection.HLevel.html#20261" class="Bound">argspec</a>
            <a id="20550" class="Comment">-- Generate the argument spine, and discard the instance</a>
            <a id="20619" class="Comment">-- search meta.</a>
            <a id="20647" href="Meta.Reflection.HLevel.html#15564" class="Function">gen-args</a> <a id="20656" class="Symbol">(</a><a id="20657" href="Data.Bool.Base.html#169" class="Function">not</a> <a id="20661" class="Symbol">(</a><a id="20662" href="Data.List.Operations.html#439" class="Function">length</a> <a id="20669" href="Meta.Reflection.HLevel.html#19946" class="Bound">cs</a> <a id="20672" href="Agda.Builtin.Nat.html#631" class="Primitive Operator">==</a> <a id="20675" class="Number">0</a><a id="20676" class="Symbol">))</a> <a id="20679" href="Meta.Reflection.HLevel.html#19919" class="Bound">lv</a> <a id="20682" href="Meta.Reflection.HLevel.html#20481" class="Bound">nm′</a> <a id="20686" href="Meta.Reflection.HLevel.html#20512" class="Bound">argsp</a> <a id="20692" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="20695" class="Symbol">(</a><a id="20696" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="20705" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="20707" class="Symbol">)</a>
            <a id="20721" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="20727" href="Meta.Reflection.HLevel.html#19933" class="Bound">solved</a> <a id="20734" href="Meta.Reflection.HLevel.html#19941" class="Bound">c1</a>

            <a id="20750" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="20755" class="Symbol">(</a><a id="20756" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="20759" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="20761" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="20765" class="Symbol">)</a>

          <a id="20778" class="Comment">-- It&#39;s possible that this particular hint was a bust, i.e.</a>
          <a id="20848" class="Comment">-- because someone wasn&#39;t being careful with what</a>
          <a id="20908" class="Comment">-- hlevel-decomposition instances they&#39;ve defined. That&#39;s no</a>
          <a id="20979" class="Comment">-- matter: we can just ignore it.</a>
          <a id="21023" class="CatchallClause Symbol">_</a> <a id="21025" class="Symbol">→</a> <a id="21027" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="21037" class="String">&quot;Non-canonical hint&quot;</a><a id="21057" class="Symbol">)</a>
          <a id="21069" class="Comment">-- If we didn&#39;t manage to get the hint to work, for any</a>
          <a id="21135" class="Comment">-- reason, try again with the rest of the hints.</a>
          <a id="21194" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="21198" href="Meta.Reflection.HLevel.html#19827" class="Function">use-decomp-hints</a> <a id="21215" class="Symbol">(</a><a id="21216" href="Meta.Reflection.HLevel.html#19919" class="Bound">lv</a> <a id="21219" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21221" href="Meta.Reflection.HLevel.html#19924" class="Bound">goal-ty</a><a id="21228" class="Symbol">)</a> <a id="21230" href="Meta.Reflection.HLevel.html#19933" class="Bound">solved</a> <a id="21237" href="Meta.Reflection.HLevel.html#19946" class="Bound">cs</a>

      <a id="21247" href="Meta.Reflection.HLevel.html#19827" class="Function">use-decomp-hints</a> <a id="21264" class="Symbol">(_</a> <a id="21267" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21269" href="Meta.Reflection.HLevel.html#21269" class="Bound">goal-ty</a><a id="21276" class="Symbol">)</a> <a id="21278" class="Symbol">_</a> <a id="21280" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="21283" class="Symbol">=</a>
        <a id="21293" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="21303" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="21305" class="String">&quot;Ran out of decomposition hints for &quot;</a> <a id="21343" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21345" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="21353" href="Meta.Reflection.HLevel.html#21269" class="Bound">goal-ty</a> <a id="21361" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21363" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="21373" class="Comment">-- Using the hints involving querying Agda for potential</a>
      <a id="21436" class="Comment">-- instances, then trying each in order.</a>
      <a id="21483" href="Meta.Reflection.HLevel.html#21483" class="Function">use-hints</a> <a id="21493" class="Symbol">:</a> <a id="21495" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="21498" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="21506" href="Meta.Reflection.HLevel.html#21483" class="Function">use-hints</a> <a id="21516" class="Symbol">=</a> <a id="21518" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="21533" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="21535" class="Keyword">do</a>
        <a id="21546" class="Symbol">(</a><a id="21547" href="Meta.Reflection.HLevel.html#21547" class="Bound">lv</a> <a id="21550" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21552" href="Meta.Reflection.HLevel.html#21552" class="Bound">ty</a><a id="21554" class="Symbol">)</a> <a id="21556" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="21558" href="Meta.Reflection.HLevel.html#6357" class="Function">decompose-is-hlevel</a> <a id="21578" href="Meta.Reflection.HLevel.html#12808" class="Bound">goal</a>

        <a id="21592" class="Comment">-- Note that if the type here is a metavariable, the tactic is..</a>
        <a id="21665" class="Comment">-- loopy.</a>
        <a id="21683" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="21688" href="Meta.Reflection.HLevel.html#21552" class="Bound">ty</a> <a id="21691" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="21695" class="Symbol">λ</a> <a id="21697" class="Keyword">where</a>
          <a id="21713" class="Symbol">(</a><a id="21714" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="21719" href="Meta.Reflection.HLevel.html#21719" class="Bound">m</a> <a id="21721" class="Symbol">_)</a> <a id="21724" class="Symbol">→</a> <a id="21726" class="Keyword">do</a>
            <a id="21741" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="21752" class="String">&quot;tactic.hlevel&quot;</a> <a id="21768" class="Number">10</a>
              <a id="21785" class="String">&quot;Type under is-hlevel is metavariable, blocking to avoid infinite loop&quot;</a>
            <a id="21869" href="Agda.Builtin.Reflection.html#9468" class="Postulate">blockOnMeta</a> <a id="21881" href="Meta.Reflection.HLevel.html#21719" class="Bound">m</a>
          <a id="21893" class="CatchallClause Symbol">_</a> <a id="21895" class="Symbol">→</a> <a id="21897" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="21902" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>

        <a id="21914" class="Comment">-- Create a meta of type hlevel-decomposition to find any possible hints..</a>
        <a id="21997" href="Meta.Reflection.HLevel.html#21997" class="Bound">solved</a><a id="22003" class="Symbol">@(</a><a id="22005" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="22010" href="Meta.Reflection.HLevel.html#22010" class="Bound">mv</a> <a id="22013" class="Symbol">_)</a> <a id="22016" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="22018" href="Meta.Reflection.Base.html#1768" class="Function">new-meta</a> <a id="22027" class="Symbol">(</a><a id="22028" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="22032" class="Symbol">(</a><a id="22033" class="Keyword">quote</a> <a id="22039" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a><a id="22059" class="Symbol">)</a> <a id="22061" class="Symbol">(</a><a id="22062" href="Meta.Reflection.HLevel.html#21552" class="Bound">ty</a> <a id="22065" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="22068" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22070" class="Symbol">))</a>
          <a id="22083" class="Keyword">where</a> <a id="22089" class="CatchallClause Symbol">_</a> <a id="22091" class="Symbol">→</a> <a id="22093" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="22103" class="Symbol">(</a><a id="22104" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22112" href="Meta.Reflection.HLevel.html#21552" class="Bound">ty</a> <a id="22115" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22117" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22119" class="Symbol">)</a>
        <a id="22129" href="Meta.Reflection.HLevel.html#22129" class="Bound">instances</a> <a id="22139" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="22141" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="22154" href="Meta.Reflection.HLevel.html#22010" class="Bound">mv</a>

        <a id="22166" href="Meta.Reflection.HLevel.html#22166" class="Bound">t</a> <a id="22168" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="22170" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="22178" href="Meta.Reflection.HLevel.html#22129" class="Bound">instances</a>
        <a id="22196" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="22207" class="String">&quot;tactic.hlevel&quot;</a> <a id="22223" class="Number">10</a> <a id="22226" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
          <a id="22238" class="String">&quot;Finding decompositions for\n&quot;</a> <a id="22269" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22281" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22289" href="Meta.Reflection.HLevel.html#21552" class="Bound">ty</a> <a id="22292" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22304" class="String">&quot;\nFound candidates\n &quot;</a> <a id="22328" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22340" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22348" href="Meta.Reflection.HLevel.html#22166" class="Bound">t</a> <a id="22350" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22352" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="22364" class="Comment">-- And try using the hints.</a>
        <a id="22400" href="Meta.Reflection.HLevel.html#19827" class="Function">use-decomp-hints</a> <a id="22417" class="Symbol">(</a><a id="22418" href="Meta.Reflection.HLevel.html#21547" class="Bound">lv</a> <a id="22421" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22423" href="Meta.Reflection.HLevel.html#21552" class="Bound">ty</a><a id="22425" class="Symbol">)</a> <a id="22427" href="Meta.Reflection.HLevel.html#21997" class="Bound">solved</a> <a id="22434" href="Meta.Reflection.HLevel.html#22129" class="Bound">instances</a>

  <a id="22447" class="Comment">-- At the top-level, our goal doesn&#39;t need to have literally the type</a>
  <a id="22519" class="Comment">-- is-hlevel A n. It can be under any number of Πs, both implicit and</a>
  <a id="22591" class="Comment">-- explicit. This means that a goal like (∀ x → is-hlevel T n) can be</a>
  <a id="22663" class="Comment">-- solved using just hlevel!, rather than λ _ → hlevel!. Of course,</a>
  <a id="22733" class="Comment">-- the effect is the same.</a>
  <a id="decompose-is-hlevel-top"></a><a id="22762" href="Meta.Reflection.HLevel.html#22762" class="Function">decompose-is-hlevel-top</a>
    <a id="22790" class="Symbol">:</a> <a id="22792" class="Symbol">∀</a> <a id="22794" class="Symbol">{</a><a id="22795" href="Meta.Reflection.HLevel.html#22795" class="Bound">ℓ</a><a id="22796" class="Symbol">}</a> <a id="22798" class="Symbol">{</a><a id="22799" href="Meta.Reflection.HLevel.html#22799" class="Bound">A</a> <a id="22801" class="Symbol">:</a> <a id="22803" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="22808" href="Meta.Reflection.HLevel.html#22795" class="Bound">ℓ</a><a id="22809" class="Symbol">}</a>
    <a id="22815" class="Symbol">→</a> <a id="22817" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22822" class="Symbol">→</a> <a id="22824" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22827" class="Symbol">(</a><a id="22828" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22833" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22835" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22840" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22842" class="Symbol">(</a><a id="22843" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22846" href="Meta.Reflection.HLevel.html#22799" class="Bound">A</a> <a id="22848" class="Symbol">→</a> <a id="22850" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22853" href="Meta.Reflection.HLevel.html#22799" class="Bound">A</a><a id="22854" class="Symbol">)</a> <a id="22856" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22858" class="Symbol">(</a><a id="22859" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22864" class="Symbol">→</a> <a id="22866" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="22870" class="Symbol">))</a>
  <a id="22875" href="Meta.Reflection.HLevel.html#22762" class="Function">decompose-is-hlevel-top</a> <a id="22899" href="Meta.Reflection.HLevel.html#22899" class="Bound">goal</a> <a id="22904" class="Symbol">=</a>
    <a id="22910" class="Keyword">do</a>
      <a id="22919" href="Meta.Reflection.HLevel.html#22919" class="Bound">ty</a> <a id="22922" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="22924" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="22939" class="Symbol">(</a><a id="22940" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="22946" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22948" href="Meta.Reflection.HLevel.html#5831" class="Function">hlevel-types</a><a id="22960" class="Symbol">)</a> <a id="22962" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
        <a id="22972" class="Symbol">(</a><a id="22973" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="22983" href="Meta.Reflection.HLevel.html#22899" class="Bound">goal</a> <a id="22988" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="22992" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="22998" class="Symbol">)</a> <a id="23000" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="23004" href="Meta.Reflection.Base.html#4396" class="Function">wait-just-a-bit</a>
      <a id="23026" href="Meta.Reflection.HLevel.html#23048" class="Function">go</a> <a id="23029" href="Meta.Reflection.HLevel.html#22919" class="Bound">ty</a>
    <a id="23036" class="Keyword">where</a>
      <a id="23048" href="Meta.Reflection.HLevel.html#23048" class="Function">go</a> <a id="23051" class="Symbol">:</a> <a id="23053" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23058" class="Symbol">→</a> <a id="23060" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23063" class="Symbol">_</a>
      <a id="23071" href="Meta.Reflection.HLevel.html#23048" class="Function">go</a> <a id="23074" class="Symbol">(</a><a id="23075" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="23078" class="Symbol">(</a><a id="23079" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23083" href="Meta.Reflection.HLevel.html#23083" class="Bound">as</a> <a id="23086" href="Meta.Reflection.HLevel.html#23086" class="Bound">at</a><a id="23088" class="Symbol">)</a> <a id="23090" class="Symbol">(</a><a id="23091" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23095" href="Meta.Reflection.HLevel.html#23095" class="Bound">vn</a> <a id="23098" href="Meta.Reflection.HLevel.html#23098" class="Bound">cd</a><a id="23100" class="Symbol">))</a> <a id="23103" class="Symbol">=</a> <a id="23105" class="Keyword">do</a>
        <a id="23116" class="Symbol">(</a><a id="23117" href="Meta.Reflection.HLevel.html#23117" class="Bound">hlevel</a> <a id="23124" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23126" href="Meta.Reflection.HLevel.html#23126" class="Bound">inner</a> <a id="23132" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23134" href="Meta.Reflection.HLevel.html#23134" class="Bound">enter</a> <a id="23140" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23142" href="Meta.Reflection.HLevel.html#23142" class="Bound">leave</a><a id="23147" class="Symbol">)</a> <a id="23149" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="23151" href="Meta.Reflection.HLevel.html#23048" class="Function">go</a> <a id="23154" href="Meta.Reflection.HLevel.html#23098" class="Bound">cd</a>
        <a id="23165" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23170" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="23172" href="Meta.Reflection.HLevel.html#23117" class="Bound">hlevel</a> <a id="23179" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23181" href="Meta.Reflection.HLevel.html#23126" class="Bound">inner</a> <a id="23187" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23189" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="23203" href="Meta.Reflection.HLevel.html#23095" class="Bound">vn</a> <a id="23206" class="Symbol">(</a><a id="23207" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23211" href="Meta.Reflection.HLevel.html#23083" class="Bound">as</a> <a id="23214" href="Meta.Reflection.HLevel.html#23086" class="Bound">at</a><a id="23216" class="Symbol">)</a> <a id="23218" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23220" class="Symbol">λ</a> <a id="23222" href="Meta.Reflection.HLevel.html#23222" class="Bound">t</a> <a id="23224" class="Symbol">→</a> <a id="23226" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="23230" class="Symbol">(</a><a id="23231" href="Meta.Reflection.Base.html#1124" class="Function">arg-vis</a> <a id="23239" href="Meta.Reflection.HLevel.html#23083" class="Bound">as</a><a id="23241" class="Symbol">)</a> <a id="23243" class="Symbol">(</a><a id="23244" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23248" href="Meta.Reflection.HLevel.html#23095" class="Bound">vn</a> <a id="23251" href="Meta.Reflection.HLevel.html#23222" class="Bound">t</a><a id="23252" class="Symbol">)</a>
      <a id="23260" href="Meta.Reflection.HLevel.html#23048" class="CatchallClause Function">go</a><a id="23262" class="CatchallClause"> </a><a id="23263" href="Meta.Reflection.HLevel.html#23263" class="CatchallClause Bound">tm</a> <a id="23266" class="Symbol">=</a> <a id="23268" class="Keyword">do</a>
        <a id="23279" class="Symbol">(</a><a id="23280" href="Meta.Reflection.HLevel.html#23280" class="Bound">hlevel</a> <a id="23287" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23289" href="Meta.Reflection.HLevel.html#23289" class="Bound">inner</a><a id="23294" class="Symbol">)</a> <a id="23296" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="23298" href="Meta.Reflection.HLevel.html#6211" class="Function">decompose-is-hlevel′</a> <a id="23319" href="Meta.Reflection.HLevel.html#23263" class="Bound">tm</a>
        <a id="23330" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23335" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="23337" href="Meta.Reflection.HLevel.html#23280" class="Bound">hlevel</a> <a id="23344" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23346" href="Meta.Reflection.HLevel.html#23289" class="Bound">inner</a> <a id="23352" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23354" class="Symbol">(λ</a> <a id="23357" href="Meta.Reflection.HLevel.html#23357" class="Bound">x</a> <a id="23359" class="Symbol">→</a> <a id="23361" href="Meta.Reflection.HLevel.html#23357" class="Bound">x</a><a id="23362" class="Symbol">)</a> <a id="23364" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23366" class="Symbol">(λ</a> <a id="23369" href="Meta.Reflection.HLevel.html#23369" class="Bound">x</a> <a id="23371" class="Symbol">→</a> <a id="23373" href="Meta.Reflection.HLevel.html#23369" class="Bound">x</a><a id="23374" class="Symbol">)</a>

<a id="23377" class="Comment">-- This is public so it&#39;s usable in tactic attributes. It decomposes the</a>
<a id="23450" class="Comment">-- top-level goal type and enters the search loop.</a>
<a id="hlevel-tactic-worker"></a><a id="23501" href="Meta.Reflection.HLevel.html#23501" class="Function">hlevel-tactic-worker</a> <a id="23522" class="Symbol">:</a> <a id="23524" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23529" class="Symbol">→</a> <a id="23531" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23534" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="23536" href="Meta.Reflection.HLevel.html#23501" class="Function">hlevel-tactic-worker</a> <a id="23557" href="Meta.Reflection.HLevel.html#23557" class="Bound">goal</a> <a id="23562" class="Symbol">=</a> <a id="23564" class="Keyword">do</a>
  <a id="23569" href="Meta.Reflection.HLevel.html#23569" class="Bound">ty</a> <a id="23572" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="23574" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="23589" class="Symbol">(</a><a id="23590" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="23596" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23598" href="Meta.Reflection.HLevel.html#5831" class="Function">hlevel-types</a><a id="23610" class="Symbol">)</a> <a id="23612" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="23614" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="23624" href="Meta.Reflection.HLevel.html#23557" class="Bound">goal</a> <a id="23629" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="23633" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
  <a id="23642" class="Symbol">(</a><a id="23643" href="Meta.Reflection.HLevel.html#23643" class="Bound">lv</a> <a id="23646" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23648" href="Meta.Reflection.HLevel.html#23648" class="Bound">ty</a> <a id="23651" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23653" href="Meta.Reflection.HLevel.html#23653" class="Bound">enter</a> <a id="23659" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23661" href="Meta.Reflection.HLevel.html#23661" class="Bound">leave</a><a id="23666" class="Symbol">)</a> <a id="23668" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="23670" href="Meta.Reflection.HLevel.html#22762" class="Function">decompose-is-hlevel-top</a> <a id="23694" href="Meta.Reflection.HLevel.html#23557" class="Bound">goal</a> <a id="23699" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a>
    <a id="23707" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a>
      <a id="23723" class="Symbol">(</a> <a id="23725" class="String">&quot;hlevel tactic: goal type is not of the form ``is-hlevel A n&#39;&#39;:\n&quot;</a>
      <a id="23798" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23800" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="23808" href="Meta.Reflection.HLevel.html#23569" class="Bound">ty</a>
      <a id="23817" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23819" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="23821" class="Symbol">)</a>

  <a id="23826" class="Comment">-- 10 units of fuel isn&#39;t too many but it&#39;s enough for any realistic</a>
  <a id="23897" class="Comment">-- use-case. Note the scope nonsense: we have to &#39;enter&#39; to get under</a>
  <a id="23969" class="Comment">-- the Πs (extend the scope with their argument types), then &#39;leave&#39;</a>
  <a id="24040" class="Comment">-- (wrap in lambdas) to get back out.</a>
  <a id="24080" href="Meta.Reflection.HLevel.html#24080" class="Bound">solved</a> <a id="24087" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="24089" href="Meta.Reflection.HLevel.html#23653" class="Bound">enter</a> <a id="24095" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="24097" class="Keyword">do</a>
    <a id="24104" href="Meta.Reflection.HLevel.html#24104" class="Bound">goal′</a> <a id="24110" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="24112" href="Meta.Reflection.Base.html#1768" class="Function">new-meta</a> <a id="24121" class="Symbol">(</a><a id="24122" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="24126" class="Symbol">(</a><a id="24127" class="Keyword">quote</a> <a id="24133" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a><a id="24145" class="Symbol">)</a> <a id="24147" class="Symbol">(</a><a id="24148" href="Meta.Reflection.HLevel.html#23643" class="Bound">lv</a> <a id="24151" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="24154" href="Meta.Reflection.HLevel.html#23648" class="Bound">ty</a> <a id="24157" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="24160" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="24162" class="Symbol">))</a>
    <a id="24169" href="Meta.Reflection.HLevel.html#12519" class="Function">search</a> <a id="24176" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="24182" href="Meta.Reflection.HLevel.html#23643" class="Bound">lv</a> <a id="24185" class="Number">10</a> <a id="24188" href="Meta.Reflection.HLevel.html#24104" class="Bound">goal′</a>
    <a id="24198" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="24203" href="Meta.Reflection.HLevel.html#24104" class="Bound">goal′</a>
  <a id="24211" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="24217" href="Meta.Reflection.HLevel.html#23557" class="Bound">goal</a> <a id="24222" class="Symbol">(</a><a id="24223" href="Meta.Reflection.HLevel.html#23661" class="Bound">leave</a> <a id="24229" href="Meta.Reflection.HLevel.html#24080" class="Bound">solved</a><a id="24235" class="Symbol">)</a>

<a id="24238" class="Comment">-- Entry points to the macro</a>
<a id="24267" class="Comment">----------------------------</a>
<a id="24296" class="Keyword">macro</a> <a id="hlevel!"></a><a id="24302" href="Meta.Reflection.HLevel.html#24302" class="Function">hlevel!</a> <a id="24310" class="Symbol">=</a> <a id="24312" href="Meta.Reflection.HLevel.html#23501" class="Function">hlevel-tactic-worker</a>

<a id="24334" class="Comment">-- In addition to using the macro as a.. well, macro, it can be used as</a>
<a id="24406" class="Comment">-- a tactic argument, to replace instance search by the more powerful</a>
<a id="24476" class="Comment">-- decomposition-projection mechanism of the tactic. We provide only</a>
<a id="24545" class="Comment">-- some of the most common helpers:</a>
<a id="el!"></a><a id="24581" href="Meta.Reflection.HLevel.html#24581" class="Function">el!</a> <a id="24585" class="Symbol">:</a> <a id="24587" class="Symbol">∀</a> <a id="24589" class="Symbol">{</a><a id="24590" href="Meta.Reflection.HLevel.html#24590" class="Bound">ℓ</a><a id="24591" class="Symbol">}</a> <a id="24593" class="Symbol">(</a><a id="24594" href="Meta.Reflection.HLevel.html#24594" class="Bound">A</a> <a id="24596" class="Symbol">:</a> <a id="24598" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="24603" href="Meta.Reflection.HLevel.html#24590" class="Bound">ℓ</a><a id="24604" class="Symbol">)</a> <a id="24606" class="Symbol">{</a><a id="24607" href="Meta.Reflection.HLevel.html#24607" class="Bound">n</a><a id="24608" class="Symbol">}</a> <a id="24610" class="Symbol">{@(</a><a id="24613" class="Keyword">tactic</a> <a id="24620" href="Meta.Reflection.HLevel.html#23501" class="Function">hlevel-tactic-worker</a><a id="24640" class="Symbol">)</a> <a id="24642" href="Meta.Reflection.HLevel.html#24642" class="Bound">hl</a> <a id="24645" class="Symbol">:</a> <a id="24647" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="24660" href="Meta.Reflection.HLevel.html#24607" class="Bound">n</a> <a id="24662" href="Meta.Reflection.HLevel.html#24594" class="Bound">A</a><a id="24663" class="Symbol">}</a> <a id="24665" class="Symbol">→</a> <a id="24667" href="Structures.n-Type.html#369" class="Record">n-Type</a> <a id="24674" href="Meta.Reflection.HLevel.html#24590" class="Bound">ℓ</a> <a id="24676" href="Meta.Reflection.HLevel.html#24607" class="Bound">n</a>
<a id="24678" href="Meta.Reflection.HLevel.html#24581" class="Function">el!</a> <a id="24682" href="Meta.Reflection.HLevel.html#24682" class="Bound">A</a> <a id="24684" class="Symbol">{</a><a id="24685" class="Argument">hl</a> <a id="24688" class="Symbol">=</a> <a id="24690" href="Meta.Reflection.HLevel.html#24690" class="Bound">hl</a><a id="24692" class="Symbol">}</a> <a id="24694" class="Symbol">.</a><a id="24695" href="Structures.n-Type.html#449" class="Field">typ</a> <a id="24699" class="Symbol">=</a> <a id="24701" href="Meta.Reflection.HLevel.html#24682" class="Bound">A</a>
<a id="24703" href="Meta.Reflection.HLevel.html#24581" class="Function">el!</a> <a id="24707" href="Meta.Reflection.HLevel.html#24707" class="Bound">A</a> <a id="24709" class="Symbol">{</a><a id="24710" class="Argument">hl</a> <a id="24713" class="Symbol">=</a> <a id="24715" href="Meta.Reflection.HLevel.html#24715" class="Bound">hl</a><a id="24717" class="Symbol">}</a> <a id="24719" class="Symbol">.</a><a id="24720" href="Structures.n-Type.html#468" class="Field">is-tr</a> <a id="24726" class="Symbol">=</a> <a id="24728" href="Meta.Reflection.HLevel.html#24715" class="Bound">hl</a>

<a id="prop-ext!"></a><a id="24732" href="Meta.Reflection.HLevel.html#24732" class="Function">prop-ext!</a>
  <a id="24744" class="Symbol">:</a> <a id="24746" class="Symbol">∀</a> <a id="24748" class="Symbol">{</a><a id="24749" href="Meta.Reflection.HLevel.html#24749" class="Bound">ℓ</a> <a id="24751" href="Meta.Reflection.HLevel.html#24751" class="Bound">ℓ′</a><a id="24753" class="Symbol">}</a> <a id="24755" class="Symbol">{</a><a id="24756" href="Meta.Reflection.HLevel.html#24756" class="Bound">A</a> <a id="24758" class="Symbol">:</a> <a id="24760" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="24765" href="Meta.Reflection.HLevel.html#24749" class="Bound">ℓ</a><a id="24766" class="Symbol">}</a> <a id="24768" class="Symbol">{</a><a id="24769" href="Meta.Reflection.HLevel.html#24769" class="Bound">B</a> <a id="24771" class="Symbol">:</a> <a id="24773" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="24778" href="Meta.Reflection.HLevel.html#24751" class="Bound">ℓ′</a><a id="24780" class="Symbol">}</a>
    <a id="24786" class="Symbol">{@(</a><a id="24789" class="Keyword">tactic</a> <a id="24796" href="Meta.Reflection.HLevel.html#23501" class="Function">hlevel-tactic-worker</a><a id="24816" class="Symbol">)</a> <a id="24818" href="Meta.Reflection.HLevel.html#24818" class="Bound">aprop</a> <a id="24824" class="Symbol">:</a> <a id="24826" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="24839" class="Number">1</a> <a id="24841" href="Meta.Reflection.HLevel.html#24756" class="Bound">A</a><a id="24842" class="Symbol">}</a>
    <a id="24848" class="Symbol">{@(</a><a id="24851" class="Keyword">tactic</a> <a id="24858" href="Meta.Reflection.HLevel.html#23501" class="Function">hlevel-tactic-worker</a><a id="24878" class="Symbol">)</a> <a id="24880" href="Meta.Reflection.HLevel.html#24880" class="Bound">bprop</a> <a id="24886" class="Symbol">:</a> <a id="24888" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="24901" class="Number">1</a> <a id="24903" href="Meta.Reflection.HLevel.html#24769" class="Bound">B</a><a id="24904" class="Symbol">}</a>
  <a id="24908" class="Symbol">→</a> <a id="24910" class="Symbol">(</a><a id="24911" href="Meta.Reflection.HLevel.html#24756" class="Bound">A</a> <a id="24913" class="Symbol">→</a> <a id="24915" href="Meta.Reflection.HLevel.html#24769" class="Bound">B</a><a id="24916" class="Symbol">)</a> <a id="24918" class="Symbol">→</a> <a id="24920" class="Symbol">(</a><a id="24921" href="Meta.Reflection.HLevel.html#24769" class="Bound">B</a> <a id="24923" class="Symbol">→</a> <a id="24925" href="Meta.Reflection.HLevel.html#24756" class="Bound">A</a><a id="24926" class="Symbol">)</a>
  <a id="24930" class="Symbol">→</a> <a id="24932" href="Meta.Reflection.HLevel.html#24756" class="Bound">A</a> <a id="24934" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="24936" href="Meta.Reflection.HLevel.html#24769" class="Bound">B</a>
<a id="24938" href="Meta.Reflection.HLevel.html#24732" class="Function">prop-ext!</a> <a id="24948" class="Symbol">{</a><a id="24949" class="Argument">aprop</a> <a id="24955" class="Symbol">=</a> <a id="24957" href="Meta.Reflection.HLevel.html#24957" class="Bound">aprop</a><a id="24962" class="Symbol">}</a> <a id="24964" class="Symbol">{</a><a id="24965" class="Argument">bprop</a> <a id="24971" class="Symbol">=</a> <a id="24973" href="Meta.Reflection.HLevel.html#24973" class="Bound">bprop</a><a id="24978" class="Symbol">}</a> <a id="24980" class="Symbol">=</a> <a id="24982" href="Foundations.Equiv.Properties.html#2963" class="Function">prop-extₑ</a> <a id="24992" href="Meta.Reflection.HLevel.html#24957" class="Bound">aprop</a> <a id="24998" href="Meta.Reflection.HLevel.html#24973" class="Bound">bprop</a>

<a id="Σ-prop-path!"></a><a id="25005" href="Meta.Reflection.HLevel.html#25005" class="Function">Σ-prop-path!</a>
  <a id="25020" class="Symbol">:</a> <a id="25022" class="Symbol">∀</a> <a id="25024" class="Symbol">{</a><a id="25025" href="Meta.Reflection.HLevel.html#25025" class="Bound">ℓ</a> <a id="25027" href="Meta.Reflection.HLevel.html#25027" class="Bound">ℓ′</a><a id="25029" class="Symbol">}</a> <a id="25031" class="Symbol">{</a><a id="25032" href="Meta.Reflection.HLevel.html#25032" class="Bound">A</a> <a id="25034" class="Symbol">:</a> <a id="25036" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25041" href="Meta.Reflection.HLevel.html#25025" class="Bound">ℓ</a><a id="25042" class="Symbol">}</a> <a id="25044" class="Symbol">{</a><a id="25045" href="Meta.Reflection.HLevel.html#25045" class="Bound">B</a> <a id="25047" class="Symbol">:</a> <a id="25049" href="Meta.Reflection.HLevel.html#25032" class="Bound">A</a> <a id="25051" class="Symbol">→</a> <a id="25053" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25058" href="Meta.Reflection.HLevel.html#25027" class="Bound">ℓ′</a><a id="25060" class="Symbol">}</a>
  <a id="25064" class="Symbol">→</a> <a id="25066" class="Symbol">{@(</a><a id="25069" class="Keyword">tactic</a> <a id="25076" href="Meta.Reflection.HLevel.html#23501" class="Function">hlevel-tactic-worker</a><a id="25096" class="Symbol">)</a> <a id="25098" href="Meta.Reflection.HLevel.html#25098" class="Bound">bxprop</a> <a id="25105" class="Symbol">:</a> <a id="25107" class="Symbol">∀</a> <a id="25109" href="Meta.Reflection.HLevel.html#25109" class="Bound">x</a> <a id="25111" class="Symbol">→</a> <a id="25113" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="25126" class="Number">1</a> <a id="25128" class="Symbol">(</a><a id="25129" href="Meta.Reflection.HLevel.html#25045" class="Bound">B</a> <a id="25131" href="Meta.Reflection.HLevel.html#25109" class="Bound">x</a><a id="25132" class="Symbol">)}</a>
  <a id="25137" class="Symbol">→</a> <a id="25139" class="Symbol">{</a><a id="25140" href="Meta.Reflection.HLevel.html#25140" class="Bound">x</a> <a id="25142" href="Meta.Reflection.HLevel.html#25142" class="Bound">y</a> <a id="25144" class="Symbol">:</a> <a id="25146" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="25148" href="Meta.Reflection.HLevel.html#25032" class="Bound">A</a> <a id="25150" href="Meta.Reflection.HLevel.html#25045" class="Bound">B</a><a id="25151" class="Symbol">}</a>
  <a id="25155" class="Symbol">→</a> <a id="25157" href="Meta.Reflection.HLevel.html#25140" class="Bound">x</a> <a id="25159" class="Symbol">.</a><a id="25160" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="25164" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25166" href="Meta.Reflection.HLevel.html#25142" class="Bound">y</a> <a id="25168" class="Symbol">.</a><a id="25169" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>
  <a id="25175" class="Symbol">→</a> <a id="25177" href="Meta.Reflection.HLevel.html#25140" class="Bound">x</a> <a id="25179" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25181" href="Meta.Reflection.HLevel.html#25142" class="Bound">y</a>
<a id="25183" href="Meta.Reflection.HLevel.html#25005" class="Function">Σ-prop-path!</a> <a id="25196" class="Symbol">{</a><a id="25197" class="Argument">bxprop</a> <a id="25204" class="Symbol">=</a> <a id="25206" href="Meta.Reflection.HLevel.html#25206" class="Bound">bxprop</a><a id="25212" class="Symbol">}</a> <a id="25214" class="Symbol">=</a> <a id="25216" href="Foundations.Sigma.Properties.html#3636" class="Function">Σ-prop-path</a> <a id="25228" href="Meta.Reflection.HLevel.html#25206" class="Bound">bxprop</a>

<a id="prop!"></a><a id="25236" href="Meta.Reflection.HLevel.html#25236" class="Function">prop!</a>
  <a id="25244" class="Symbol">:</a> <a id="25246" class="Symbol">∀</a> <a id="25248" class="Symbol">{</a><a id="25249" href="Meta.Reflection.HLevel.html#25249" class="Bound">ℓ</a><a id="25250" class="Symbol">}</a> <a id="25252" class="Symbol">{</a><a id="25253" href="Meta.Reflection.HLevel.html#25253" class="Bound">A</a> <a id="25255" class="Symbol">:</a> <a id="25257" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="25259" class="Symbol">→</a> <a id="25261" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25266" href="Meta.Reflection.HLevel.html#25249" class="Bound">ℓ</a><a id="25267" class="Symbol">}</a> <a id="25269" class="Symbol">{@(</a><a id="25272" class="Keyword">tactic</a> <a id="25279" href="Meta.Reflection.HLevel.html#23501" class="Function">hlevel-tactic-worker</a><a id="25299" class="Symbol">)</a> <a id="25301" href="Meta.Reflection.HLevel.html#25301" class="Bound">aip</a> <a id="25305" class="Symbol">:</a> <a id="25307" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="25320" class="Number">1</a> <a id="25322" class="Symbol">(</a><a id="25323" href="Meta.Reflection.HLevel.html#25253" class="Bound">A</a> <a id="25325" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25327" class="Symbol">)}</a>
  <a id="25332" class="Symbol">→</a> <a id="25334" class="Symbol">{</a><a id="25335" href="Meta.Reflection.HLevel.html#25335" class="Bound">x</a> <a id="25337" class="Symbol">:</a> <a id="25339" href="Meta.Reflection.HLevel.html#25253" class="Bound">A</a> <a id="25341" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25343" class="Symbol">}</a> <a id="25345" class="Symbol">{</a><a id="25346" href="Meta.Reflection.HLevel.html#25346" class="Bound">y</a> <a id="25348" class="Symbol">:</a> <a id="25350" href="Meta.Reflection.HLevel.html#25253" class="Bound">A</a> <a id="25352" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="25354" class="Symbol">}</a>
  <a id="25358" class="Symbol">→</a> <a id="25360" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="25366" class="Symbol">(λ</a> <a id="25369" href="Meta.Reflection.HLevel.html#25369" class="Bound">i</a> <a id="25371" class="Symbol">→</a> <a id="25373" href="Meta.Reflection.HLevel.html#25253" class="Bound">A</a> <a id="25375" href="Meta.Reflection.HLevel.html#25369" class="Bound">i</a><a id="25376" class="Symbol">)</a> <a id="25378" href="Meta.Reflection.HLevel.html#25335" class="Bound">x</a> <a id="25380" href="Meta.Reflection.HLevel.html#25346" class="Bound">y</a>
<a id="25382" href="Meta.Reflection.HLevel.html#25236" class="Function">prop!</a> <a id="25388" class="Symbol">{</a><a id="25389" class="Argument">A</a> <a id="25391" class="Symbol">=</a> <a id="25393" href="Meta.Reflection.HLevel.html#25393" class="Bound">A</a><a id="25394" class="Symbol">}</a> <a id="25396" class="Symbol">{</a><a id="25397" class="Argument">aip</a> <a id="25401" class="Symbol">=</a> <a id="25403" href="Meta.Reflection.HLevel.html#25403" class="Bound">aip</a><a id="25406" class="Symbol">}</a> <a id="25408" class="Symbol">{</a><a id="25409" href="Meta.Reflection.HLevel.html#25409" class="Bound">x</a><a id="25410" class="Symbol">}</a> <a id="25412" class="Symbol">{</a><a id="25413" href="Meta.Reflection.HLevel.html#25413" class="Bound">y</a><a id="25414" class="Symbol">}</a> <a id="25416" class="Symbol">=</a>
  <a id="25420" href="Foundations.HLevel.Base.html#1139" class="Function">is-prop→PathP</a> <a id="25434" class="Symbol">(λ</a> <a id="25437" href="Meta.Reflection.HLevel.html#25437" class="Bound">i</a> <a id="25439" class="Symbol">→</a> <a id="25441" href="Foundations.Base.html#17080" class="Function">coe0→i</a> <a id="25448" class="Symbol">(λ</a> <a id="25451" href="Meta.Reflection.HLevel.html#25451" class="Bound">j</a> <a id="25453" class="Symbol">→</a> <a id="25455" href="Foundations.Base.html#12784" class="Function">is-prop</a> <a id="25463" class="Symbol">(</a><a id="25464" href="Meta.Reflection.HLevel.html#25393" class="Bound">A</a> <a id="25466" href="Meta.Reflection.HLevel.html#25451" class="Bound">j</a><a id="25467" class="Symbol">))</a> <a id="25470" href="Meta.Reflection.HLevel.html#25437" class="Bound">i</a> <a id="25472" href="Meta.Reflection.HLevel.html#25403" class="Bound">aip</a><a id="25475" class="Symbol">)</a> <a id="25477" href="Meta.Reflection.HLevel.html#25409" class="Bound">x</a> <a id="25479" href="Meta.Reflection.HLevel.html#25413" class="Bound">y</a>

<a id="25482" class="Keyword">open</a> <a id="25487" href="Meta.Reflection.HLevel.html#4069" class="Module">hlevel-projection</a>

<a id="25506" class="Comment">-- Hint database bootstrap</a>
<a id="25533" class="Comment">--------------------------</a>
<a id="25560" class="Comment">-- This instance block contains most of the decompositions we have</a>
<a id="25627" class="Comment">-- defined in the dependencies of this module.</a>

<a id="25675" class="Keyword">instance</a>
  <a id="decomp-lift"></a><a id="25686" href="Meta.Reflection.HLevel.html#25686" class="Function">decomp-lift</a> <a id="25698" class="Symbol">:</a> <a id="25700" class="Symbol">∀</a> <a id="25702" class="Symbol">{</a><a id="25703" href="Meta.Reflection.HLevel.html#25703" class="Bound">ℓ</a> <a id="25705" href="Meta.Reflection.HLevel.html#25705" class="Bound">ℓ′</a><a id="25707" class="Symbol">}</a> <a id="25709" class="Symbol">{</a><a id="25710" href="Meta.Reflection.HLevel.html#25710" class="Bound">T</a> <a id="25712" class="Symbol">:</a> <a id="25714" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25719" href="Meta.Reflection.HLevel.html#25703" class="Bound">ℓ</a><a id="25720" class="Symbol">}</a> <a id="25722" class="Symbol">→</a> <a id="25724" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="25745" class="Symbol">(</a><a id="25746" href="Foundations.Prim.Type.html#590" class="Record">Lift</a> <a id="25751" href="Meta.Reflection.HLevel.html#25705" class="Bound">ℓ′</a> <a id="25754" href="Meta.Reflection.HLevel.html#25710" class="Bound">T</a><a id="25755" class="Symbol">)</a>
  <a id="25759" href="Meta.Reflection.HLevel.html#25686" class="Function">decomp-lift</a> <a id="25771" class="Symbol">=</a> <a id="25773" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="25780" class="Symbol">(</a><a id="25781" class="Keyword">quote</a> <a id="25787" href="Foundations.HLevel.Retracts.html#5051" class="Function">Lift-is-of-hlevel</a><a id="25804" class="Symbol">)</a> <a id="25806" class="Symbol">(</a><a id="25807" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="25814" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="25816" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="25824" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="25826" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="25828" class="Symbol">)</a>

  <a id="25833" class="Comment">-- -- Non-dependent Π and Σ for readability first:</a>

  <a id="decomp-fun"></a><a id="25887" href="Meta.Reflection.HLevel.html#25887" class="Function">decomp-fun</a> <a id="25898" class="Symbol">:</a> <a id="25900" class="Symbol">∀</a> <a id="25902" class="Symbol">{</a><a id="25903" href="Meta.Reflection.HLevel.html#25903" class="Bound">ℓ</a> <a id="25905" href="Meta.Reflection.HLevel.html#25905" class="Bound">ℓ′</a><a id="25907" class="Symbol">}</a> <a id="25909" class="Symbol">{</a><a id="25910" href="Meta.Reflection.HLevel.html#25910" class="Bound">A</a> <a id="25912" class="Symbol">:</a> <a id="25914" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25919" href="Meta.Reflection.HLevel.html#25903" class="Bound">ℓ</a><a id="25920" class="Symbol">}</a> <a id="25922" class="Symbol">{</a><a id="25923" href="Meta.Reflection.HLevel.html#25923" class="Bound">B</a> <a id="25925" class="Symbol">:</a> <a id="25927" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25932" href="Meta.Reflection.HLevel.html#25905" class="Bound">ℓ′</a><a id="25934" class="Symbol">}</a> <a id="25936" class="Symbol">→</a> <a id="25938" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="25959" class="Symbol">(</a><a id="25960" href="Meta.Reflection.HLevel.html#25910" class="Bound">A</a> <a id="25962" class="Symbol">→</a> <a id="25964" href="Meta.Reflection.HLevel.html#25923" class="Bound">B</a><a id="25965" class="Symbol">)</a>
  <a id="25969" href="Meta.Reflection.HLevel.html#25887" class="Function">decomp-fun</a> <a id="25980" class="Symbol">=</a> <a id="25982" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="25989" class="Symbol">(</a><a id="25990" class="Keyword">quote</a> <a id="25996" href="Foundations.HLevel.Retracts.html#4002" class="Function">fun-is-of-hlevel</a><a id="26012" class="Symbol">)</a> <a id="26014" class="Symbol">(</a><a id="26015" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="26022" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26024" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="26032" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26034" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26036" class="Symbol">)</a>

  <a id="decomp-prod"></a><a id="26041" href="Meta.Reflection.HLevel.html#26041" class="Function">decomp-prod</a> <a id="26053" class="Symbol">:</a> <a id="26055" class="Symbol">∀</a> <a id="26057" class="Symbol">{</a><a id="26058" href="Meta.Reflection.HLevel.html#26058" class="Bound">ℓ</a> <a id="26060" href="Meta.Reflection.HLevel.html#26060" class="Bound">ℓ′</a><a id="26062" class="Symbol">}</a> <a id="26064" class="Symbol">{</a><a id="26065" href="Meta.Reflection.HLevel.html#26065" class="Bound">A</a> <a id="26067" class="Symbol">:</a> <a id="26069" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26074" href="Meta.Reflection.HLevel.html#26058" class="Bound">ℓ</a><a id="26075" class="Symbol">}</a> <a id="26077" class="Symbol">{</a><a id="26078" href="Meta.Reflection.HLevel.html#26078" class="Bound">B</a> <a id="26080" class="Symbol">:</a> <a id="26082" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26087" href="Meta.Reflection.HLevel.html#26060" class="Bound">ℓ′</a><a id="26089" class="Symbol">}</a> <a id="26091" class="Symbol">→</a> <a id="26093" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="26114" class="Symbol">(</a><a id="26115" href="Meta.Reflection.HLevel.html#26065" class="Bound">A</a> <a id="26117" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="26119" href="Meta.Reflection.HLevel.html#26078" class="Bound">B</a><a id="26120" class="Symbol">)</a>
  <a id="26124" href="Meta.Reflection.HLevel.html#26041" class="Function">decomp-prod</a> <a id="26136" class="Symbol">=</a> <a id="26138" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="26145" class="Symbol">(</a><a id="26146" class="Keyword">quote</a> <a id="26152" href="Foundations.HLevel.Retracts.html#4836" class="Function">×-is-of-hlevel</a><a id="26166" class="Symbol">)</a> <a id="26168" class="Symbol">(</a><a id="26169" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="26176" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26178" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="26186" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26188" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="26196" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26198" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26200" class="Symbol">)</a>

  <a id="26205" class="Comment">-- Dependent type formers:</a>
  <a id="decomp-pi³"></a><a id="26234" href="Meta.Reflection.HLevel.html#26234" class="Function">decomp-pi³</a>
    <a id="26249" class="Symbol">:</a> <a id="26251" class="Symbol">∀</a> <a id="26253" class="Symbol">{</a><a id="26254" href="Meta.Reflection.HLevel.html#26254" class="Bound">ℓa</a> <a id="26257" href="Meta.Reflection.HLevel.html#26257" class="Bound">ℓb</a> <a id="26260" href="Meta.Reflection.HLevel.html#26260" class="Bound">ℓc</a> <a id="26263" href="Meta.Reflection.HLevel.html#26263" class="Bound">ℓd</a><a id="26265" class="Symbol">}</a> <a id="26267" class="Symbol">{</a><a id="26268" href="Meta.Reflection.HLevel.html#26268" class="Bound">A</a> <a id="26270" class="Symbol">:</a> <a id="26272" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26277" href="Meta.Reflection.HLevel.html#26254" class="Bound">ℓa</a><a id="26279" class="Symbol">}</a> <a id="26281" class="Symbol">{</a><a id="26282" href="Meta.Reflection.HLevel.html#26282" class="Bound">B</a> <a id="26284" class="Symbol">:</a> <a id="26286" href="Meta.Reflection.HLevel.html#26268" class="Bound">A</a> <a id="26288" class="Symbol">→</a> <a id="26290" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26295" href="Meta.Reflection.HLevel.html#26257" class="Bound">ℓb</a><a id="26297" class="Symbol">}</a> <a id="26299" class="Symbol">{</a><a id="26300" href="Meta.Reflection.HLevel.html#26300" class="Bound">C</a> <a id="26302" class="Symbol">:</a> <a id="26304" class="Symbol">∀</a> <a id="26306" href="Meta.Reflection.HLevel.html#26306" class="Bound">x</a> <a id="26308" class="Symbol">(</a><a id="26309" href="Meta.Reflection.HLevel.html#26309" class="Bound">y</a> <a id="26311" class="Symbol">:</a> <a id="26313" href="Meta.Reflection.HLevel.html#26282" class="Bound">B</a> <a id="26315" href="Meta.Reflection.HLevel.html#26306" class="Bound">x</a><a id="26316" class="Symbol">)</a> <a id="26318" class="Symbol">→</a> <a id="26320" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26325" href="Meta.Reflection.HLevel.html#26260" class="Bound">ℓc</a><a id="26327" class="Symbol">}</a>
    <a id="26333" class="Symbol">→</a> <a id="26335" class="Symbol">{</a><a id="26336" href="Meta.Reflection.HLevel.html#26336" class="Bound">D</a> <a id="26338" class="Symbol">:</a> <a id="26340" class="Symbol">∀</a> <a id="26342" href="Meta.Reflection.HLevel.html#26342" class="Bound">x</a> <a id="26344" href="Meta.Reflection.HLevel.html#26344" class="Bound">y</a> <a id="26346" class="Symbol">(</a><a id="26347" href="Meta.Reflection.HLevel.html#26347" class="Bound">z</a> <a id="26349" class="Symbol">:</a> <a id="26351" href="Meta.Reflection.HLevel.html#26300" class="Bound">C</a> <a id="26353" href="Meta.Reflection.HLevel.html#26342" class="Bound">x</a> <a id="26355" href="Meta.Reflection.HLevel.html#26344" class="Bound">y</a><a id="26356" class="Symbol">)</a> <a id="26358" class="Symbol">→</a> <a id="26360" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26365" href="Meta.Reflection.HLevel.html#26263" class="Bound">ℓd</a><a id="26367" class="Symbol">}</a>
    <a id="26373" class="Symbol">→</a> <a id="26375" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="26396" class="Symbol">(∀</a> <a id="26399" href="Meta.Reflection.HLevel.html#26399" class="Bound">a</a> <a id="26401" href="Meta.Reflection.HLevel.html#26401" class="Bound">b</a> <a id="26403" href="Meta.Reflection.HLevel.html#26403" class="Bound">c</a> <a id="26405" class="Symbol">→</a> <a id="26407" href="Meta.Reflection.HLevel.html#26336" class="Bound">D</a> <a id="26409" href="Meta.Reflection.HLevel.html#26399" class="Bound">a</a> <a id="26411" href="Meta.Reflection.HLevel.html#26401" class="Bound">b</a> <a id="26413" href="Meta.Reflection.HLevel.html#26403" class="Bound">c</a><a id="26414" class="Symbol">)</a>
  <a id="26418" href="Meta.Reflection.HLevel.html#26234" class="Function">decomp-pi³</a> <a id="26429" class="Symbol">=</a> <a id="26431" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="26438" class="Symbol">(</a><a id="26439" class="Keyword">quote</a> <a id="26445" href="Foundations.HLevel.Retracts.html#3717" class="Function">Π₃-is-of-hlevel</a><a id="26460" class="Symbol">)</a> <a id="26462" class="Symbol">(</a><a id="26463" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="26470" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26472" href="Meta.Reflection.HLevel.html#3053" class="InductiveConstructor">`search-under</a> <a id="26486" class="Number">3</a> <a id="26488" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26490" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26492" class="Symbol">)</a>

  <a id="decomp-pi²"></a><a id="26497" href="Meta.Reflection.HLevel.html#26497" class="Function">decomp-pi²</a>
    <a id="26512" class="Symbol">:</a> <a id="26514" class="Symbol">∀</a> <a id="26516" class="Symbol">{</a><a id="26517" href="Meta.Reflection.HLevel.html#26517" class="Bound">ℓa</a> <a id="26520" href="Meta.Reflection.HLevel.html#26520" class="Bound">ℓb</a> <a id="26523" href="Meta.Reflection.HLevel.html#26523" class="Bound">ℓc</a><a id="26525" class="Symbol">}</a> <a id="26527" class="Symbol">{</a><a id="26528" href="Meta.Reflection.HLevel.html#26528" class="Bound">A</a> <a id="26530" class="Symbol">:</a> <a id="26532" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26537" href="Meta.Reflection.HLevel.html#26517" class="Bound">ℓa</a><a id="26539" class="Symbol">}</a> <a id="26541" class="Symbol">{</a><a id="26542" href="Meta.Reflection.HLevel.html#26542" class="Bound">B</a> <a id="26544" class="Symbol">:</a> <a id="26546" href="Meta.Reflection.HLevel.html#26528" class="Bound">A</a> <a id="26548" class="Symbol">→</a> <a id="26550" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26555" href="Meta.Reflection.HLevel.html#26520" class="Bound">ℓb</a><a id="26557" class="Symbol">}</a> <a id="26559" class="Symbol">{</a><a id="26560" href="Meta.Reflection.HLevel.html#26560" class="Bound">C</a> <a id="26562" class="Symbol">:</a> <a id="26564" class="Symbol">∀</a> <a id="26566" href="Meta.Reflection.HLevel.html#26566" class="Bound">x</a> <a id="26568" class="Symbol">(</a><a id="26569" href="Meta.Reflection.HLevel.html#26569" class="Bound">y</a> <a id="26571" class="Symbol">:</a> <a id="26573" href="Meta.Reflection.HLevel.html#26542" class="Bound">B</a> <a id="26575" href="Meta.Reflection.HLevel.html#26566" class="Bound">x</a><a id="26576" class="Symbol">)</a> <a id="26578" class="Symbol">→</a> <a id="26580" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26585" href="Meta.Reflection.HLevel.html#26523" class="Bound">ℓc</a><a id="26587" class="Symbol">}</a>
    <a id="26593" class="Symbol">→</a> <a id="26595" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="26616" class="Symbol">(∀</a> <a id="26619" href="Meta.Reflection.HLevel.html#26619" class="Bound">a</a> <a id="26621" href="Meta.Reflection.HLevel.html#26621" class="Bound">b</a> <a id="26623" class="Symbol">→</a> <a id="26625" href="Meta.Reflection.HLevel.html#26560" class="Bound">C</a> <a id="26627" href="Meta.Reflection.HLevel.html#26619" class="Bound">a</a> <a id="26629" href="Meta.Reflection.HLevel.html#26621" class="Bound">b</a><a id="26630" class="Symbol">)</a>
  <a id="26634" href="Meta.Reflection.HLevel.html#26497" class="Function">decomp-pi²</a> <a id="26645" class="Symbol">=</a> <a id="26647" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="26654" class="Symbol">(</a><a id="26655" class="Keyword">quote</a> <a id="26661" href="Foundations.HLevel.Retracts.html#3481" class="Function">Π₂-is-of-hlevel</a><a id="26676" class="Symbol">)</a> <a id="26678" class="Symbol">(</a><a id="26679" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="26686" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26688" href="Meta.Reflection.HLevel.html#3053" class="InductiveConstructor">`search-under</a> <a id="26702" class="Number">2</a> <a id="26704" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26706" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26708" class="Symbol">)</a>

  <a id="decomp-pi"></a><a id="26713" href="Meta.Reflection.HLevel.html#26713" class="Function">decomp-pi</a> <a id="26723" class="Symbol">:</a> <a id="26725" class="Symbol">∀</a> <a id="26727" class="Symbol">{</a><a id="26728" href="Meta.Reflection.HLevel.html#26728" class="Bound">ℓ</a> <a id="26730" href="Meta.Reflection.HLevel.html#26730" class="Bound">ℓ′</a><a id="26732" class="Symbol">}</a> <a id="26734" class="Symbol">{</a><a id="26735" href="Meta.Reflection.HLevel.html#26735" class="Bound">A</a> <a id="26737" class="Symbol">:</a> <a id="26739" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26744" href="Meta.Reflection.HLevel.html#26728" class="Bound">ℓ</a><a id="26745" class="Symbol">}</a> <a id="26747" class="Symbol">{</a><a id="26748" href="Meta.Reflection.HLevel.html#26748" class="Bound">B</a> <a id="26750" class="Symbol">:</a> <a id="26752" href="Meta.Reflection.HLevel.html#26735" class="Bound">A</a> <a id="26754" class="Symbol">→</a> <a id="26756" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26761" href="Meta.Reflection.HLevel.html#26730" class="Bound">ℓ′</a><a id="26763" class="Symbol">}</a> <a id="26765" class="Symbol">→</a> <a id="26767" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="26788" class="Symbol">(∀</a> <a id="26791" href="Meta.Reflection.HLevel.html#26791" class="Bound">a</a> <a id="26793" class="Symbol">→</a> <a id="26795" href="Meta.Reflection.HLevel.html#26748" class="Bound">B</a> <a id="26797" href="Meta.Reflection.HLevel.html#26791" class="Bound">a</a><a id="26798" class="Symbol">)</a>
  <a id="26802" href="Meta.Reflection.HLevel.html#26713" class="Function">decomp-pi</a> <a id="26812" class="Symbol">=</a> <a id="26814" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="26821" class="Symbol">(</a><a id="26822" class="Keyword">quote</a> <a id="26828" href="Foundations.HLevel.Retracts.html#2744" class="Function">Π-is-of-hlevel</a><a id="26842" class="Symbol">)</a> <a id="26844" class="Symbol">(</a><a id="26845" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="26852" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26854" href="Meta.Reflection.HLevel.html#3053" class="InductiveConstructor">`search-under</a> <a id="26868" class="Number">1</a> <a id="26870" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26872" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26874" class="Symbol">)</a>

  <a id="decomp-impl-pi"></a><a id="26879" href="Meta.Reflection.HLevel.html#26879" class="Function">decomp-impl-pi</a> <a id="26894" class="Symbol">:</a> <a id="26896" class="Symbol">∀</a> <a id="26898" class="Symbol">{</a><a id="26899" href="Meta.Reflection.HLevel.html#26899" class="Bound">ℓ</a> <a id="26901" href="Meta.Reflection.HLevel.html#26901" class="Bound">ℓ′</a><a id="26903" class="Symbol">}</a> <a id="26905" class="Symbol">{</a><a id="26906" href="Meta.Reflection.HLevel.html#26906" class="Bound">A</a> <a id="26908" class="Symbol">:</a> <a id="26910" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26915" href="Meta.Reflection.HLevel.html#26899" class="Bound">ℓ</a><a id="26916" class="Symbol">}</a> <a id="26918" class="Symbol">{</a><a id="26919" href="Meta.Reflection.HLevel.html#26919" class="Bound">B</a> <a id="26921" class="Symbol">:</a> <a id="26923" href="Meta.Reflection.HLevel.html#26906" class="Bound">A</a> <a id="26925" class="Symbol">→</a> <a id="26927" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26932" href="Meta.Reflection.HLevel.html#26901" class="Bound">ℓ′</a><a id="26934" class="Symbol">}</a> <a id="26936" class="Symbol">→</a> <a id="26938" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="26959" class="Symbol">(∀</a> <a id="26962" class="Symbol">{</a><a id="26963" href="Meta.Reflection.HLevel.html#26963" class="Bound">a</a><a id="26964" class="Symbol">}</a> <a id="26966" class="Symbol">→</a> <a id="26968" href="Meta.Reflection.HLevel.html#26919" class="Bound">B</a> <a id="26970" href="Meta.Reflection.HLevel.html#26963" class="Bound">a</a><a id="26971" class="Symbol">)</a>
  <a id="26975" href="Meta.Reflection.HLevel.html#26879" class="Function">decomp-impl-pi</a> <a id="26990" class="Symbol">=</a> <a id="26992" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="26999" class="Symbol">(</a><a id="27000" class="Keyword">quote</a> <a id="27006" href="Foundations.HLevel.Retracts.html#3178" class="Function">Π-is-of-hlevel-implicit</a><a id="27029" class="Symbol">)</a> <a id="27031" class="Symbol">(</a><a id="27032" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="27039" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27041" href="Meta.Reflection.HLevel.html#3053" class="InductiveConstructor">`search-under</a> <a id="27055" class="Number">1</a> <a id="27057" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27059" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27061" class="Symbol">)</a>

  <a id="decomp-sigma"></a><a id="27066" href="Meta.Reflection.HLevel.html#27066" class="Function">decomp-sigma</a> <a id="27079" class="Symbol">:</a> <a id="27081" class="Symbol">∀</a> <a id="27083" class="Symbol">{</a><a id="27084" href="Meta.Reflection.HLevel.html#27084" class="Bound">ℓ</a> <a id="27086" href="Meta.Reflection.HLevel.html#27086" class="Bound">ℓ′</a><a id="27088" class="Symbol">}</a> <a id="27090" class="Symbol">{</a><a id="27091" href="Meta.Reflection.HLevel.html#27091" class="Bound">A</a> <a id="27093" class="Symbol">:</a> <a id="27095" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27100" href="Meta.Reflection.HLevel.html#27084" class="Bound">ℓ</a><a id="27101" class="Symbol">}</a> <a id="27103" class="Symbol">{</a><a id="27104" href="Meta.Reflection.HLevel.html#27104" class="Bound">B</a> <a id="27106" class="Symbol">:</a> <a id="27108" href="Meta.Reflection.HLevel.html#27091" class="Bound">A</a> <a id="27110" class="Symbol">→</a> <a id="27112" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27117" href="Meta.Reflection.HLevel.html#27086" class="Bound">ℓ′</a><a id="27119" class="Symbol">}</a> <a id="27121" class="Symbol">→</a> <a id="27123" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="27144" class="Symbol">(</a><a id="27145" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="27147" href="Meta.Reflection.HLevel.html#27091" class="Bound">A</a> <a id="27149" href="Meta.Reflection.HLevel.html#27104" class="Bound">B</a><a id="27150" class="Symbol">)</a>
  <a id="27154" href="Meta.Reflection.HLevel.html#27066" class="Function">decomp-sigma</a> <a id="27167" class="Symbol">=</a> <a id="27169" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="27176" class="Symbol">(</a><a id="27177" class="Keyword">quote</a> <a id="27183" href="Foundations.HLevel.Retracts.html#4153" class="Function">Σ-is-of-hlevel</a><a id="27197" class="Symbol">)</a> <a id="27199" class="Symbol">(</a><a id="27200" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="27207" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27209" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="27217" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27219" href="Meta.Reflection.HLevel.html#3053" class="InductiveConstructor">`search-under</a> <a id="27233" class="Number">1</a> <a id="27235" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27237" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27239" class="Symbol">)</a>

  <a id="27244" class="Comment">-- Path decomposition rules we have in scope. Note the use of</a>
  <a id="27308" class="Comment">-- nondeterminism: the following three instances both compete for</a>
  <a id="27376" class="Comment">-- solving the same goals --- but generally only one will be</a>
  <a id="27439" class="Comment">-- applicable. That way we don&#39;t have to juggle h-levels quite as</a>
  <a id="27507" class="Comment">-- much.</a>
  <a id="decomp-path′"></a><a id="27518" href="Meta.Reflection.HLevel.html#27518" class="Function">decomp-path′</a> <a id="27531" class="Symbol">:</a> <a id="27533" class="Symbol">∀</a> <a id="27535" class="Symbol">{</a><a id="27536" href="Meta.Reflection.HLevel.html#27536" class="Bound">ℓ</a><a id="27537" class="Symbol">}</a> <a id="27539" class="Symbol">{</a><a id="27540" href="Meta.Reflection.HLevel.html#27540" class="Bound">A</a> <a id="27542" class="Symbol">:</a> <a id="27544" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27549" href="Meta.Reflection.HLevel.html#27536" class="Bound">ℓ</a><a id="27550" class="Symbol">}</a> <a id="27552" class="Symbol">{</a><a id="27553" href="Meta.Reflection.HLevel.html#27553" class="Bound">a</a> <a id="27555" href="Meta.Reflection.HLevel.html#27555" class="Bound">b</a> <a id="27557" class="Symbol">:</a> <a id="27559" href="Meta.Reflection.HLevel.html#27540" class="Bound">A</a><a id="27560" class="Symbol">}</a> <a id="27562" class="Symbol">→</a> <a id="27564" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="27585" class="Symbol">(</a><a id="27586" href="Meta.Reflection.HLevel.html#27553" class="Bound">a</a> <a id="27588" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27590" href="Meta.Reflection.HLevel.html#27555" class="Bound">b</a><a id="27591" class="Symbol">)</a>
  <a id="27595" href="Meta.Reflection.HLevel.html#27518" class="Function">decomp-path′</a> <a id="27608" class="Symbol">=</a> <a id="27610" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="27617" class="Symbol">(</a><a id="27618" class="Keyword">quote</a> <a id="27624" href="Foundations.HLevel.Base.html#3234" class="Function">Path-is-of-hlevel′</a><a id="27642" class="Symbol">)</a> <a id="27644" class="Symbol">(</a><a id="27645" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="27652" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27654" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="27662" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27664" href="Meta.Reflection.HLevel.html#3256" class="InductiveConstructor">`meta</a> <a id="27670" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27672" href="Meta.Reflection.HLevel.html#3256" class="InductiveConstructor">`meta</a> <a id="27678" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27680" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27682" class="Symbol">)</a>

  <a id="decomp-path"></a><a id="27687" href="Meta.Reflection.HLevel.html#27687" class="Function">decomp-path</a> <a id="27699" class="Symbol">:</a> <a id="27701" class="Symbol">∀</a> <a id="27703" class="Symbol">{</a><a id="27704" href="Meta.Reflection.HLevel.html#27704" class="Bound">ℓ</a><a id="27705" class="Symbol">}</a> <a id="27707" class="Symbol">{</a><a id="27708" href="Meta.Reflection.HLevel.html#27708" class="Bound">A</a> <a id="27710" class="Symbol">:</a> <a id="27712" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27717" href="Meta.Reflection.HLevel.html#27704" class="Bound">ℓ</a><a id="27718" class="Symbol">}</a> <a id="27720" class="Symbol">{</a><a id="27721" href="Meta.Reflection.HLevel.html#27721" class="Bound">a</a> <a id="27723" href="Meta.Reflection.HLevel.html#27723" class="Bound">b</a> <a id="27725" class="Symbol">:</a> <a id="27727" href="Meta.Reflection.HLevel.html#27708" class="Bound">A</a><a id="27728" class="Symbol">}</a> <a id="27730" class="Symbol">→</a> <a id="27732" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="27753" class="Symbol">(</a><a id="27754" href="Meta.Reflection.HLevel.html#27721" class="Bound">a</a> <a id="27756" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27758" href="Meta.Reflection.HLevel.html#27723" class="Bound">b</a><a id="27759" class="Symbol">)</a>
  <a id="27763" href="Meta.Reflection.HLevel.html#27687" class="Function">decomp-path</a> <a id="27775" class="Symbol">=</a> <a id="27777" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="27784" class="Symbol">(</a><a id="27785" class="Keyword">quote</a> <a id="27791" href="Foundations.HLevel.Base.html#2656" class="Function">Path-is-of-hlevel</a><a id="27808" class="Symbol">)</a> <a id="27810" class="Symbol">(</a><a id="27811" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="27818" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27820" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="27828" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27830" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27832" class="Symbol">)</a>

  <a id="decomp-univalence"></a><a id="27837" href="Meta.Reflection.HLevel.html#27837" class="Function">decomp-univalence</a> <a id="27855" class="Symbol">:</a> <a id="27857" class="Symbol">∀</a> <a id="27859" class="Symbol">{</a><a id="27860" href="Meta.Reflection.HLevel.html#27860" class="Bound">ℓ</a><a id="27861" class="Symbol">}</a> <a id="27863" class="Symbol">{</a><a id="27864" href="Meta.Reflection.HLevel.html#27864" class="Bound">A</a> <a id="27866" href="Meta.Reflection.HLevel.html#27866" class="Bound">B</a> <a id="27868" class="Symbol">:</a> <a id="27870" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27875" href="Meta.Reflection.HLevel.html#27860" class="Bound">ℓ</a><a id="27876" class="Symbol">}</a> <a id="27878" class="Symbol">→</a> <a id="27880" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="27901" class="Symbol">(</a><a id="27902" href="Meta.Reflection.HLevel.html#27864" class="Bound">A</a> <a id="27904" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27906" href="Meta.Reflection.HLevel.html#27866" class="Bound">B</a><a id="27907" class="Symbol">)</a>
  <a id="27911" href="Meta.Reflection.HLevel.html#27837" class="Function">decomp-univalence</a> <a id="27929" class="Symbol">=</a> <a id="27931" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="27938" class="Symbol">(</a><a id="27939" class="Keyword">quote</a> <a id="27945" href="Structures.n-Type.html#1377" class="Function">＝-is-of-hlevel</a><a id="27959" class="Symbol">)</a> <a id="27961" class="Symbol">(</a><a id="27962" href="Meta.Reflection.HLevel.html#3556" class="InductiveConstructor">`level</a> <a id="27969" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27971" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="27979" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27981" href="Meta.Reflection.HLevel.html#3522" class="InductiveConstructor">`search</a> <a id="27989" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27991" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="27994" class="Symbol">)</a>

  <a id="27999" class="Comment">-- List isn&#39;t really a type on the same footing as all the others, but</a>
  <a id="28072" class="Comment">-- we&#39;re here, so we might as well, right?</a>
  <a id="28117" class="Comment">-- TODO</a>
  <a id="28127" class="Comment">-- decomp-list : ∀ {ℓ} {A : Type ℓ} → hlevel-decomposition (List A)</a>
  <a id="28197" class="Comment">-- decomp-list = decomp (quote ListPath.List-is-of-hlevel) (`level-minus 2 ∷ `search ∷ [])</a>

  <a id="28291" class="Comment">-- This one really ought to work with instance selection only, but</a>
  <a id="28360" class="Comment">-- Agda has trouble with the (1 + k + n) level in H-Level-n-Type. The</a>
  <a id="28432" class="Comment">-- decomposition here is a bit more flexible.</a>
  <a id="decomp-ntype"></a><a id="28480" href="Meta.Reflection.HLevel.html#28480" class="Function">decomp-ntype</a> <a id="28493" class="Symbol">:</a> <a id="28495" class="Symbol">∀</a> <a id="28497" class="Symbol">{</a><a id="28498" href="Meta.Reflection.HLevel.html#28498" class="Bound">ℓ</a><a id="28499" class="Symbol">}</a> <a id="28501" class="Symbol">{</a><a id="28502" href="Meta.Reflection.HLevel.html#28502" class="Bound">n</a><a id="28503" class="Symbol">}</a> <a id="28505" class="Symbol">→</a> <a id="28507" href="Meta.Reflection.HLevel.html#3697" class="Datatype">hlevel-decomposition</a> <a id="28528" class="Symbol">(</a><a id="28529" href="Structures.n-Type.html#369" class="Record">n-Type</a> <a id="28536" href="Meta.Reflection.HLevel.html#28498" class="Bound">ℓ</a> <a id="28538" href="Meta.Reflection.HLevel.html#28502" class="Bound">n</a><a id="28539" class="Symbol">)</a>
  <a id="28543" href="Meta.Reflection.HLevel.html#28480" class="Function">decomp-ntype</a> <a id="28556" class="Symbol">=</a> <a id="28558" href="Meta.Reflection.HLevel.html#3750" class="InductiveConstructor">decomp</a> <a id="28565" class="Symbol">(</a><a id="28566" class="Keyword">quote</a> <a id="28572" href="Structures.n-Type.html#2577" class="Function">n-Type-is-of-hlevel</a><a id="28591" class="Symbol">)</a> <a id="28593" class="Symbol">(</a><a id="28594" href="Meta.Reflection.HLevel.html#2853" class="InductiveConstructor">`level-minus</a> <a id="28607" class="Number">1</a> <a id="28609" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28611" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28613" class="Symbol">)</a>

  <a id="hlevel-proj-n-type"></a><a id="28618" href="Meta.Reflection.HLevel.html#28618" class="Function">hlevel-proj-n-type</a> <a id="28637" class="Symbol">:</a> <a id="28639" href="Meta.Reflection.HLevel.html#4069" class="Record">hlevel-projection</a> <a id="28657" class="Symbol">(</a><a id="28658" class="Keyword">quote</a> <a id="28664" href="Structures.n-Type.html#449" class="Field">n-Type.typ</a><a id="28674" class="Symbol">)</a>
  <a id="28678" href="Meta.Reflection.HLevel.html#28618" class="Function">hlevel-proj-n-type</a> <a id="28697" class="Symbol">.</a><a id="28698" href="Meta.Reflection.HLevel.html#4126" class="Field">has-level</a> <a id="28708" class="Symbol">=</a> <a id="28710" class="Keyword">quote</a> <a id="28716" href="Structures.n-Type.html#468" class="Field">n-Type.is-tr</a>
  <a id="28731" href="Meta.Reflection.HLevel.html#28618" class="Function">hlevel-proj-n-type</a> <a id="28750" class="Symbol">.</a><a id="28751" href="Meta.Reflection.HLevel.html#4313" class="Field">get-level</a> <a id="28761" href="Meta.Reflection.HLevel.html#28761" class="Bound">ty</a> <a id="28764" class="Symbol">=</a> <a id="28766" class="Keyword">do</a>
    <a id="28773" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="28777" class="Symbol">(</a><a id="28778" class="Keyword">quote</a> <a id="28784" href="Structures.n-Type.html#369" class="Record">n-Type</a><a id="28790" class="Symbol">)</a> <a id="28792" class="Symbol">(</a><a id="28793" href="Meta.Reflection.HLevel.html#28793" class="Bound">ell</a> <a id="28797" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="28800" href="Meta.Reflection.HLevel.html#28800" class="Bound">lv′t</a> <a id="28805" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="28808" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28810" class="Symbol">)</a> <a id="28812" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="28814" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="28821" href="Meta.Reflection.HLevel.html#28761" class="Bound">ty</a>
      <a id="28830" class="Keyword">where</a> <a id="28836" class="CatchallClause Symbol">_</a> <a id="28838" class="Symbol">→</a> <a id="28840" href="Meta.Reflection.HLevel.html#5462" class="Function">backtrack</a> <a id="28850" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="28852" class="String">&quot;Type of thing isn&#39;t n-Type, it is &quot;</a> <a id="28889" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28891" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="28899" href="Meta.Reflection.HLevel.html#28761" class="Bound">ty</a> <a id="28902" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28904" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="28911" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="28921" href="Meta.Reflection.HLevel.html#28800" class="Bound">lv′t</a>
  <a id="28928" href="Meta.Reflection.HLevel.html#28618" class="Function">hlevel-proj-n-type</a> <a id="28947" class="Symbol">.</a><a id="28948" href="Meta.Reflection.HLevel.html#4466" class="Field">get-argument</a> <a id="28961" class="Symbol">(_</a> <a id="28964" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28966" class="Symbol">_</a> <a id="28968" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28970" href="Meta.Reflection.HLevel.html#28970" class="Bound">it</a> <a id="28973" href="Meta.Reflection.Base.html#2291" class="InductiveConstructor Operator">v∷</a> <a id="28976" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28978" class="Symbol">)</a> <a id="28980" class="Symbol">=</a> <a id="28982" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="28987" href="Meta.Reflection.HLevel.html#28970" class="Bound">it</a>
  <a id="28992" href="Meta.Reflection.HLevel.html#28618" class="CatchallClause Function">hlevel-proj-n-type</a><a id="29010" class="CatchallClause"> </a><a id="29011" class="CatchallClause Symbol">.</a><a id="29012" href="Meta.Reflection.HLevel.html#4466" class="CatchallClause Field">get-argument</a><a id="29024" class="CatchallClause"> </a><a id="29025" class="CatchallClause Symbol">_</a> <a id="29027" class="Symbol">=</a> <a id="29029" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="29039" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="29043" class="Keyword">private</a>
  <a id="29053" class="Keyword">module</a> <a id="29060" href="Meta.Reflection.HLevel.html#29060" class="Module">_</a> <a id="29062" class="Symbol">{</a><a id="29063" href="Meta.Reflection.HLevel.html#29063" class="Bound">ℓ</a><a id="29064" class="Symbol">}</a> <a id="29066" class="Symbol">{</a><a id="29067" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29069" class="Symbol">:</a> <a id="29071" href="Structures.n-Type.html#369" class="Record">n-Type</a> <a id="29078" href="Meta.Reflection.HLevel.html#29063" class="Bound">ℓ</a> <a id="29080" class="Number">2</a><a id="29081" class="Symbol">}</a> <a id="29083" class="Symbol">{</a><a id="29084" href="Meta.Reflection.HLevel.html#29084" class="Bound">B</a> <a id="29086" class="Symbol">:</a> <a id="29088" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29090" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29092" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29094" class="Symbol">→</a> <a id="29096" href="Structures.n-Type.html#369" class="Record">n-Type</a> <a id="29103" href="Meta.Reflection.HLevel.html#29063" class="Bound">ℓ</a> <a id="29105" class="Number">3</a><a id="29106" class="Symbol">}</a> <a id="29108" class="Keyword">where</a>
    <a id="29118" href="Meta.Reflection.HLevel.html#29118" class="Function">some-def</a> <a id="29127" class="Symbol">=</a> <a id="29129" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29131" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29133" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29139" href="Meta.Reflection.HLevel.html#29139" class="Function">_</a> <a id="29141" class="Symbol">:</a> <a id="29143" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29156" class="Number">2</a> <a id="29158" class="Symbol">(</a><a id="29159" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29161" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29163" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29165" class="Symbol">→</a> <a id="29167" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29169" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29171" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29173" class="Symbol">→</a> <a id="29175" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29177" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29179" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29181" class="Symbol">→</a> <a id="29183" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29185" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29187" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29188" class="Symbol">)</a>
    <a id="29194" class="Symbol">_</a> <a id="29196" class="Symbol">=</a> <a id="29198" href="Meta.Reflection.HLevel.html#24302" class="Macro">hlevel!</a>

    <a id="29211" href="Meta.Reflection.HLevel.html#29211" class="Function">_</a> <a id="29213" class="Symbol">:</a> <a id="29215" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29228" class="Number">3</a> <a id="29230" class="Symbol">(</a><a id="29231" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="29233" href="Meta.Reflection.HLevel.html#29118" class="Function">some-def</a> <a id="29242" class="Symbol">λ</a> <a id="29244" href="Meta.Reflection.HLevel.html#29244" class="Bound">x</a> <a id="29246" class="Symbol">→</a> <a id="29248" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29250" href="Meta.Reflection.HLevel.html#29084" class="Bound">B</a> <a id="29252" href="Meta.Reflection.HLevel.html#29244" class="Bound">x</a> <a id="29254" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29255" class="Symbol">)</a>
    <a id="29261" class="Symbol">_</a> <a id="29263" class="Symbol">=</a> <a id="29265" href="Meta.Reflection.HLevel.html#24302" class="Macro">hlevel!</a>

    <a id="29278" href="Meta.Reflection.HLevel.html#29278" class="Function">_</a> <a id="29280" class="Symbol">:</a> <a id="29282" class="Symbol">∀</a> <a id="29284" href="Meta.Reflection.HLevel.html#29284" class="Bound">a</a> <a id="29286" class="Symbol">→</a> <a id="29288" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29301" class="Number">5</a> <a id="29303" class="Symbol">(</a><a id="29304" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29306" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29308" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29310" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29312" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29314" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29316" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29318" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29320" class="Symbol">(</a><a id="29321" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29323" class="Symbol">→</a> <a id="29325" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29327" href="Meta.Reflection.HLevel.html#29084" class="Bound">B</a> <a id="29329" href="Meta.Reflection.HLevel.html#29284" class="Bound">a</a> <a id="29331" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29332" class="Symbol">))</a>
    <a id="29339" class="Symbol">_</a> <a id="29341" class="Symbol">=</a> <a id="29343" href="Meta.Reflection.HLevel.html#24302" class="Macro">hlevel!</a>

    <a id="29356" href="Meta.Reflection.HLevel.html#29356" class="Function">_</a> <a id="29358" class="Symbol">:</a> <a id="29360" class="Symbol">∀</a> <a id="29362" href="Meta.Reflection.HLevel.html#29362" class="Bound">a</a> <a id="29364" class="Symbol">→</a> <a id="29366" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29379" class="Number">3</a> <a id="29381" class="Symbol">(</a><a id="29382" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29384" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29386" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29388" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29390" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29392" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29394" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29396" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29398" class="Symbol">(</a><a id="29399" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29401" class="Symbol">→</a> <a id="29403" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29405" href="Meta.Reflection.HLevel.html#29084" class="Bound">B</a> <a id="29407" href="Meta.Reflection.HLevel.html#29362" class="Bound">a</a> <a id="29409" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29410" class="Symbol">))</a>
    <a id="29417" class="Symbol">_</a> <a id="29419" class="Symbol">=</a> <a id="29421" href="Meta.Reflection.HLevel.html#24302" class="Macro">hlevel!</a>

    <a id="29434" href="Meta.Reflection.HLevel.html#29434" class="Function">_</a> <a id="29436" class="Symbol">:</a> <a id="29438" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29451" class="Number">2</a> <a id="29453" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29455" href="Meta.Reflection.HLevel.html#29067" class="Bound">A</a> <a id="29457" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29463" class="Symbol">_</a> <a id="29465" class="Symbol">=</a> <a id="29467" href="Meta.Reflection.HLevel.html#24302" class="Macro">hlevel!</a>

    <a id="29480" class="Comment">-- FIXME this is urgent</a>
    <a id="29508" class="Comment">-- _ : ∀ n → is-of-hlevel (suc n) (n-Type ℓ n)</a>
    <a id="29559" class="Comment">-- _ = hlevel!</a>

    <a id="29579" href="Meta.Reflection.HLevel.html#29579" class="Function">_</a> <a id="29581" class="Symbol">:</a> <a id="29583" class="Symbol">∀</a> <a id="29585" href="Meta.Reflection.HLevel.html#29585" class="Bound">n</a> <a id="29587" class="Symbol">(</a><a id="29588" href="Meta.Reflection.HLevel.html#29588" class="Bound">x</a> <a id="29590" class="Symbol">:</a> <a id="29592" href="Structures.n-Type.html#369" class="Record">n-Type</a> <a id="29599" href="Meta.Reflection.HLevel.html#29063" class="Bound">ℓ</a> <a id="29601" href="Meta.Reflection.HLevel.html#29585" class="Bound">n</a><a id="29602" class="Symbol">)</a> <a id="29604" class="Symbol">→</a> <a id="29606" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29619" class="Symbol">(</a><a id="29620" class="Number">2</a> <a id="29622" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="29624" href="Meta.Reflection.HLevel.html#29585" class="Bound">n</a><a id="29625" class="Symbol">)</a> <a id="29627" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29629" href="Meta.Reflection.HLevel.html#29588" class="Bound">x</a> <a id="29631" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29637" class="Symbol">_</a> <a id="29639" class="Symbol">=</a> <a id="29641" class="Symbol">λ</a> <a id="29643" href="Meta.Reflection.HLevel.html#29643" class="Bound">n</a> <a id="29645" href="Meta.Reflection.HLevel.html#29645" class="Bound">x</a> <a id="29647" class="Symbol">→</a> <a id="29649" href="Meta.Reflection.HLevel.html#24302" class="Macro">hlevel!</a>
</pre></body></html>