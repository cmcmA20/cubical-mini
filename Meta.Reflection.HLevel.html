<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Reflection.HLevel</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Comment">-- -vtactic.hlevel:20 -vtc.def:10</a>
<a id="58" class="Keyword">module</a> <a id="65" href="Meta.Reflection.HLevel.html" class="Module">Meta.Reflection.HLevel</a> <a id="88" class="Keyword">where</a>

<a id="95" class="Keyword">open</a> <a id="100" class="Keyword">import</a> <a id="107" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="124" class="Keyword">open</a> <a id="129" class="Keyword">import</a> <a id="136" href="Foundations.Equiv.html" class="Module">Foundations.Equiv</a>
<a id="154" class="Keyword">open</a> <a id="159" class="Keyword">import</a> <a id="166" href="Foundations.HLevel.html" class="Module">Foundations.HLevel</a>
<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Foundations.Pi.html" class="Module">Foundations.Pi</a>
<a id="212" class="Keyword">open</a> <a id="217" class="Keyword">import</a> <a id="224" href="Foundations.Sigma.html" class="Module">Foundations.Sigma</a>

<a id="243" class="Keyword">open</a> <a id="248" class="Keyword">import</a> <a id="255" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="270" class="Keyword">open</a> <a id="275" class="Keyword">import</a> <a id="282" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="297" class="Keyword">open</a> <a id="302" class="Keyword">import</a> <a id="309" href="Data.List.Operations.html" class="Module">Data.List.Operations</a>
<a id="330" class="Keyword">open</a> <a id="335" class="Keyword">import</a> <a id="342" href="Data.List.Instances.html" class="Module">Data.List.Instances</a>
<a id="362" class="Keyword">open</a> <a id="367" class="Keyword">import</a> <a id="374" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="390" class="Keyword">open</a> <a id="395" class="Keyword">import</a> <a id="402" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="416" class="Keyword">open</a> <a id="421" class="Keyword">import</a> <a id="428" href="Data.Nat.Instances.html" class="Module">Data.Nat.Instances</a>
<a id="447" class="Keyword">open</a> <a id="452" class="Keyword">import</a> <a id="459" href="Data.String.Instances.html" class="Module">Data.String.Instances</a>

<a id="482" class="Keyword">open</a> <a id="487" class="Keyword">import</a> <a id="494" href="Structures.n-Type.html" class="Module">Structures.n-Type</a>

<a id="513" class="Keyword">open</a> <a id="518" class="Keyword">import</a> <a id="525" href="Meta.Foldable.html" class="Module">Meta.Foldable</a>
<a id="539" class="Keyword">open</a> <a id="544" class="Keyword">import</a> <a id="551" href="Meta.HLevel.html" class="Module">Meta.HLevel</a>          <a id="572" class="Keyword">public</a>
<a id="579" class="Keyword">open</a> <a id="584" class="Keyword">import</a> <a id="591" href="Meta.Reflection.Base.html" class="Module">Meta.Reflection.Base</a>

<a id="613" class="Comment">{-
Tactic for generating readable h-level proofs automatically. Contains an
essential reimplementation of the instance search mechanism, with
support for arbitrary level offsets (`level-minus) and searching under
binders (`search-under). Ambiguity is explicitly supported: the first
goal for which we can complete a proof tree is the one we go with.

The tactic works in a naÏve way, trying h-level lemmas until one
succeeds. There are three ways of making progress: Using a *projection
hint*, using a *decomposition hint*, or by falling back to instance
selection. The instance selection fallback is self-explanatory.

Projection hints handle the situation is-hlevel (X .p) n, where X
inhabits a record that contains evidence of its hlevel. If there is a
projection hint with `underlying-type == p`, then we use `has-level
(get-argument (X .p))` as the solution. Being a base case, projection
hints also handle raising h-levels: If `get-level (X .p) &lt; n`, we solve
by raising `has-level ...` the appropriate amount.

Decomposition hints are slightly more interesting. Decomposition hints
apply to a type, say P, and instruct the tactic on how to build an
application of type (is-hlevel P n). The way this application is built
is customizable.

Finding rules
-------------

Rules are found using instance search, specifically for the
&#39;hlevel-decomposition&#39; and &#39;hlevel-projection&#39; types. The
hlevel-projection type is flat, so the runtime of
projection-decomposition is *linear in the number of possible
projections*.

The hlevel-decomposition type is more interesting, since it is indexed
by the type that it can decompose. That way, we can use Agda&#39;s own
instance selection mechanism to narrow down to relevant decompositions.

Nondeterminism
--------------

In case more than one projection and/or decomposition hint is possible,
they will all be tried in order. This allows the tactic to generate
sensible-looking code, by trying simpler decompositions first. As an
example, the non-dependent lemmas for → and × will be tried before those
for Π and Σ, just like a human would.
-}</a>

<a id="2698" class="Comment">-- | Specifies how an argument should be filled in during elaboration of</a>
<a id="2771" class="Comment">-- an h-level lemma.</a>
<a id="2792" class="Keyword">data</a> <a id="Arg-spec"></a><a id="2797" href="Meta.Reflection.HLevel.html#2797" class="Datatype">Arg-spec</a> <a id="2806" class="Symbol">:</a> <a id="2808" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="2813" class="Keyword">where</a>
  <a id="Arg-spec.`level-minus"></a><a id="2821" href="Meta.Reflection.HLevel.html#2821" class="InductiveConstructor">`level-minus</a>  <a id="2835" class="Symbol">:</a> <a id="2837" class="Symbol">(</a><a id="2838" href="Meta.Reflection.HLevel.html#2838" class="Bound">n</a> <a id="2840" class="Symbol">:</a> <a id="2842" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2843" class="Symbol">)</a> <a id="2845" class="Symbol">→</a> <a id="2847" href="Meta.Reflection.HLevel.html#2797" class="Datatype">Arg-spec</a>
  <a id="2858" class="Comment">-- ^ Insert the level we&#39;re solving for minus the given offset (note</a>
  <a id="2929" class="Comment">-- that this is the wonky subtraction operation, &quot;monus&quot;) at this</a>
  <a id="2997" class="Comment">-- argument position</a>

  <a id="Arg-spec.`search-under"></a><a id="3021" href="Meta.Reflection.HLevel.html#3021" class="InductiveConstructor">`search-under</a> <a id="3035" class="Symbol">:</a> <a id="3037" class="Symbol">(</a><a id="3038" href="Meta.Reflection.HLevel.html#3038" class="Bound">n</a> <a id="3040" class="Symbol">:</a> <a id="3042" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3043" class="Symbol">)</a> <a id="3045" class="Symbol">→</a> <a id="3047" href="Meta.Reflection.HLevel.html#2797" class="Datatype">Arg-spec</a>
  <a id="3058" class="Comment">-- ^ Recursively search for an h-level witness, under @n@ visible</a>
  <a id="3126" class="Comment">-- lambdas. This is suitable for lemmas of type</a>
  <a id="3176" class="Comment">-- (∀ x y z → is-hlevel ...) → is-hlevel ...</a>

  <a id="Arg-spec.`meta"></a><a id="3224" href="Meta.Reflection.HLevel.html#3224" class="InductiveConstructor">`meta</a>         <a id="3238" class="Symbol">:</a> <a id="3240" href="Meta.Reflection.HLevel.html#2797" class="Datatype">Arg-spec</a>
  <a id="3251" class="Comment">-- ^ Insert a meta at this argument position. No search will be</a>
  <a id="3317" class="Comment">-- performed for this meta, so it must be solved from the context in</a>
  <a id="3388" class="Comment">-- which the lemma is used.</a>

<a id="3417" class="Comment">-- Common patterns: Keep the level, search in the current scope.</a>
<a id="3482" class="Keyword">pattern</a> <a id="`search"></a><a id="3490" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="3498" class="Symbol">=</a> <a id="3500" href="Meta.Reflection.HLevel.html#3021" class="InductiveConstructor">`search-under</a> <a id="3514" class="Number">0</a>
<a id="3516" class="Keyword">pattern</a> <a id="`level"></a><a id="3524" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="3531" class="Symbol">=</a> <a id="3533" href="Meta.Reflection.HLevel.html#2821" class="InductiveConstructor">`level-minus</a> <a id="3546" class="Number">0</a>

<a id="3549" class="Comment">-- | A specification for how to decompose the type @T@ into</a>
<a id="3609" class="Comment">-- sub-components, to establish an h-level result.</a>
<a id="3660" class="Keyword">data</a> <a id="hlevel-decomposition"></a><a id="3665" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="3686" class="Symbol">{</a><a id="3687" href="Meta.Reflection.HLevel.html#3687" class="Bound">ℓ</a><a id="3688" class="Symbol">}</a> <a id="3690" class="Symbol">(</a><a id="3691" href="Meta.Reflection.HLevel.html#3691" class="Bound">T</a> <a id="3693" class="Symbol">:</a> <a id="3695" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="3700" href="Meta.Reflection.HLevel.html#3687" class="Bound">ℓ</a><a id="3701" class="Symbol">)</a> <a id="3703" class="Symbol">:</a> <a id="3705" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="3710" class="Keyword">where</a>
  <a id="hlevel-decomposition.decomp"></a><a id="3718" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a>
    <a id="3729" class="Symbol">:</a> <a id="3731" class="Symbol">(</a><a id="3732" href="Meta.Reflection.HLevel.html#3732" class="Bound">h-level-lemma</a> <a id="3746" class="Symbol">:</a> <a id="3748" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="3752" class="Symbol">)</a> <a id="3754" class="Symbol">(</a><a id="3755" href="Meta.Reflection.HLevel.html#3755" class="Bound">arguments</a> <a id="3765" class="Symbol">:</a> <a id="3767" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3772" href="Meta.Reflection.HLevel.html#2797" class="Datatype">Arg-spec</a><a id="3780" class="Symbol">)</a>
    <a id="3786" class="Symbol">→</a> <a id="3788" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="3809" href="Meta.Reflection.HLevel.html#3691" class="Bound">T</a>
  <a id="3813" class="Comment">-- To prove that T has a given h-level, we can invoke the</a>
  <a id="3873" class="Comment">-- @h-level-lemma@ with the specified @arguments@.</a>

<a id="3925" class="Comment">-- | How to decompose an application of a record selector into something</a>
<a id="3998" class="Comment">-- which might have an h-level.</a>
<a id="4030" class="Keyword">record</a> <a id="hlevel-projection"></a><a id="4037" href="Meta.Reflection.HLevel.html#4037" class="Record">hlevel-projection</a> <a id="4055" class="Symbol">(</a><a id="4056" href="Meta.Reflection.HLevel.html#4056" class="Bound">proj</a> <a id="4061" class="Symbol">:</a> <a id="4063" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="4067" class="Symbol">)</a> <a id="4069" class="Symbol">:</a> <a id="4071" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="4076" class="Keyword">where</a>
  <a id="4084" class="Keyword">field</a>
    <a id="hlevel-projection.has-level"></a><a id="4094" href="Meta.Reflection.HLevel.html#4094" class="Field">has-level</a> <a id="4104" class="Symbol">:</a> <a id="4106" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
    <a id="4115" class="Comment">-- ^ The name of the h-level lemma. It must be sufficient to apply</a>
    <a id="4186" class="Comment">-- this name to the argument (see get-argument below); arg specs are</a>
    <a id="4259" class="Comment">-- not supported.</a>
    <a id="hlevel-projection.get-level"></a><a id="4281" href="Meta.Reflection.HLevel.html#4281" class="Field">get-level</a> <a id="4291" class="Symbol">:</a> <a id="4293" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="4298" class="Symbol">→</a> <a id="4300" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4303" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4312" class="Comment">-- ^ Given an application of underlying-type, what h-level does this</a>
    <a id="4385" class="Comment">-- type have? Necessary for computing lifts.</a>
    <a id="hlevel-projection.get-argument"></a><a id="4434" href="Meta.Reflection.HLevel.html#4434" class="Field">get-argument</a> <a id="4447" class="Symbol">:</a> <a id="4449" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4454" class="Symbol">(</a><a id="4455" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4459" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="4463" class="Symbol">)</a> <a id="4465" class="Symbol">→</a> <a id="4467" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4470" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4479" class="Comment">-- ^ Extract the argument out from under the application.</a>
<a id="4537" class="Comment">{-
Using projections
-----------------

Projection decomposition happens as follows; suppose we have some
neutral

  n = def (quote X) as

in order, every &#39;hlevel-projection&#39; instance definition will be tried;
Let us call a generic instance I. If I.underlying-type == X, then we&#39;ll
use this instance, otherwise, we fail (i.e. backtrack and try another
projection).

To use this instance, the get-level and get-argument functions are
involved; get-argument must take &#39;as&#39; and return some representative
sub-expression e. get-level will receive e&#39;s inferred type and must
return the h-level of the type n. Finally, we return

  I.has-level (get-argument e),

possibly wrapped in (k - get-level (get-argument e)) applications of
is-hlevel-suc.
-}</a>

<a id="5282" class="Keyword">open</a> <a id="5287" href="Meta.Reflection.HLevel.html#4037" class="Module">hlevel-projection</a>
<a id="5305" class="Keyword">private</a>
  <a id="5315" class="Comment">-- Throw an empty type error to try another alternative, stating the</a>
  <a id="5386" class="Comment">-- purpose of backtracking for debugging:</a>
  <a id="backtrack"></a><a id="5430" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="5440" class="Symbol">:</a> <a id="5442" class="Symbol">∀</a> <a id="5444" class="Symbol">{</a><a id="5445" href="Meta.Reflection.HLevel.html#5445" class="Bound">ℓ</a><a id="5446" class="Symbol">}</a> <a id="5448" class="Symbol">{</a><a id="5449" href="Meta.Reflection.HLevel.html#5449" class="Bound">A</a> <a id="5451" class="Symbol">:</a> <a id="5453" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="5458" href="Meta.Reflection.HLevel.html#5445" class="Bound">ℓ</a><a id="5459" class="Symbol">}</a> <a id="5461" class="Symbol">→</a> <a id="5463" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5468" href="Agda.Builtin.Reflection.html#7893" class="Datatype">ErrorPart</a> <a id="5478" class="Symbol">→</a> <a id="5480" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="5483" href="Meta.Reflection.HLevel.html#5449" class="Bound">A</a>
  <a id="5487" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="5497" href="Meta.Reflection.HLevel.html#5497" class="Bound">note</a> <a id="5502" class="Symbol">=</a> <a id="5504" class="Keyword">do</a>
    <a id="5511" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="5522" class="String">&quot;tactic.hlevel&quot;</a> <a id="5538" class="Number">10</a> <a id="5541" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="5543" class="String">&quot;Backtracking search... &quot;</a> <a id="5569" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5571" href="Meta.Reflection.HLevel.html#5497" class="Bound">note</a>
    <a id="5580" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="5590" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="5592" class="String">&quot;Search hit a dead-end: &quot;</a> <a id="5618" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5620" href="Meta.Reflection.HLevel.html#5497" class="Bound">note</a>

  <a id="5628" class="Comment">-- A list of names which we should not reduce while trying to invert</a>
  <a id="5699" class="Comment">-- an application of is-hlevel/is-prop/is-set into an &#39;underlying</a>
  <a id="5767" class="Comment">-- type&#39; and level arguments.</a>
  <a id="hlevel-types"></a><a id="5799" href="Meta.Reflection.HLevel.html#5799" class="Function">hlevel-types</a> <a id="5812" class="Symbol">:</a> <a id="5814" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5819" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
  <a id="5826" href="Meta.Reflection.HLevel.html#5799" class="Function">hlevel-types</a> <a id="5839" class="Symbol">=</a> <a id="5841" class="Keyword">quote</a> <a id="5847" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="5860" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5862" class="Keyword">quote</a> <a id="5868" href="Foundations.Base.html#12784" class="Function">is-prop</a> <a id="5876" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5878" class="Keyword">quote</a> <a id="5884" href="Foundations.Base.html#12853" class="Function">is-set</a> <a id="5891" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5893" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

  <a id="5899" class="Keyword">pattern</a> <a id="nat-lit"></a><a id="5907" href="Meta.Reflection.HLevel.html#5907" class="InductiveConstructor">nat-lit</a> <a id="5915" href="Meta.Reflection.HLevel.html#5972" class="Bound">n</a> <a id="5917" class="Symbol">=</a>
    <a id="5923" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="5927" class="Symbol">(</a><a id="5928" class="Keyword">quote</a> <a id="5934" href="Agda.Builtin.FromNat.html#281" class="Field">Number.fromNat</a><a id="5948" class="Symbol">)</a> <a id="5950" class="Symbol">(_</a> <a id="5953" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5955" class="Symbol">_</a> <a id="5957" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5959" class="Symbol">_</a> <a id="5961" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5963" class="InductiveConstructor">lit</a> <a id="5967" class="Symbol">(</a><a id="5968" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="5972" href="Meta.Reflection.HLevel.html#5972" class="Bound">n</a><a id="5973" class="Symbol">)</a> <a id="5975" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="5978" class="Symbol">_)</a>

  <a id="5984" class="Comment">-- Decompose an application of is-hlevel and/or one of the other</a>
  <a id="6051" class="Comment">-- &#39;hlevel-types&#39; into its constituent parts. Invariant:</a>
  <a id="6110" class="Comment">--</a>
  <a id="6115" class="Comment">--    decompose-is-hlevel′ t = (n , a) ⊢ t = is-of-hlevel n a</a>
  <a id="decompose-is-hlevel′"></a><a id="6179" href="Meta.Reflection.HLevel.html#6179" class="Function">decompose-is-hlevel′</a> <a id="6200" class="Symbol">:</a> <a id="6202" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6207" class="Symbol">→</a> <a id="6209" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6212" class="Symbol">(</a><a id="6213" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6218" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6220" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6224" class="Symbol">)</a>

  <a id="6229" class="Comment">-- Infer the type of the given term, and decompose it according to</a>
  <a id="6298" class="Comment">-- decompose-is-hlevel′.</a>
  <a id="decompose-is-hlevel"></a><a id="6325" href="Meta.Reflection.HLevel.html#6325" class="Function">decompose-is-hlevel</a> <a id="6345" class="Symbol">:</a> <a id="6347" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6352" class="Symbol">→</a> <a id="6354" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6357" class="Symbol">(</a><a id="6358" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6363" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6365" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6369" class="Symbol">)</a>
  <a id="6373" href="Meta.Reflection.HLevel.html#6325" class="Function">decompose-is-hlevel</a> <a id="6393" href="Meta.Reflection.HLevel.html#6393" class="Bound">goal</a> <a id="6398" class="Symbol">=</a> <a id="6400" class="Keyword">do</a>
    <a id="6407" href="Meta.Reflection.HLevel.html#6407" class="Bound">ty</a> <a id="6410" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6412" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="6427" class="Symbol">(</a><a id="6428" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="6434" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6436" href="Meta.Reflection.HLevel.html#5799" class="Function">hlevel-types</a><a id="6448" class="Symbol">)</a> <a id="6450" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="6452" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="6462" href="Meta.Reflection.HLevel.html#6393" class="Bound">goal</a> <a id="6467" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="6471" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
    <a id="6482" href="Meta.Reflection.HLevel.html#6179" class="Function">decompose-is-hlevel′</a> <a id="6503" href="Meta.Reflection.HLevel.html#6407" class="Bound">ty</a>

  <a id="6509" href="Meta.Reflection.HLevel.html#6179" class="Function">decompose-is-hlevel′</a> <a id="6530" href="Meta.Reflection.HLevel.html#6530" class="Bound">ty</a> <a id="6533" class="Symbol">=</a> <a id="6535" class="Keyword">do</a>
    <a id="6542" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6546" class="Symbol">(</a><a id="6547" class="Keyword">quote</a> <a id="6553" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a><a id="6565" class="Symbol">)</a> <a id="6567" class="Symbol">(_</a> <a id="6570" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6572" href="Meta.Reflection.HLevel.html#6572" class="Bound">lv</a> <a id="6575" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="6578" href="Meta.Reflection.HLevel.html#6578" class="Bound">ty</a> <a id="6581" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="6584" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6586" class="Symbol">)</a> <a id="6588" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6590" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6595" href="Meta.Reflection.HLevel.html#6530" class="Bound">ty</a>
      <a id="6604" class="Keyword">where</a>
        <a id="6618" class="Comment">-- Handle the ones with special names:</a>
        <a id="6665" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6669" class="Symbol">(</a><a id="6670" class="Keyword">quote</a> <a id="6676" href="Foundations.Base.html#12853" class="Function">is-set</a><a id="6682" class="Symbol">)</a> <a id="6684" class="Symbol">(_</a> <a id="6687" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6689" href="Meta.Reflection.HLevel.html#6689" class="Bound">ty</a> <a id="6692" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="6695" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6697" class="Symbol">)</a> <a id="6699" class="Symbol">→</a> <a id="6701" class="Keyword">do</a>
          <a id="6714" href="Meta.Reflection.HLevel.html#6714" class="Bound">ty</a> <a id="6717" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6719" href="Meta.Reflection.Base.html#4433" class="Function">wait-just-a-bit</a> <a id="6735" href="Meta.Reflection.HLevel.html#6689" class="Bound">ty</a>
          <a id="6748" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6753" class="Symbol">(</a><a id="6754" class="Keyword">quoteTerm</a> <a id="6764" class="Number">2</a> <a id="6766" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6768" href="Meta.Reflection.HLevel.html#6714" class="Bound">ty</a><a id="6770" class="Symbol">)</a>

        <a id="6781" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6785" class="Symbol">(</a><a id="6786" class="Keyword">quote</a> <a id="6792" href="Foundations.Base.html#12784" class="Function">is-prop</a><a id="6799" class="Symbol">)</a> <a id="6801" class="Symbol">(_</a> <a id="6804" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6806" href="Meta.Reflection.HLevel.html#6806" class="Bound">ty</a> <a id="6809" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="6812" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6814" class="Symbol">)</a> <a id="6816" class="Symbol">→</a> <a id="6818" class="Keyword">do</a>
          <a id="6831" href="Meta.Reflection.HLevel.html#6831" class="Bound">ty</a> <a id="6834" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6836" href="Meta.Reflection.Base.html#4433" class="Function">wait-just-a-bit</a> <a id="6852" href="Meta.Reflection.HLevel.html#6806" class="Bound">ty</a>
          <a id="6865" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6870" class="Symbol">(</a><a id="6871" class="Keyword">quoteTerm</a> <a id="6881" class="Number">1</a> <a id="6883" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6885" href="Meta.Reflection.HLevel.html#6831" class="Bound">ty</a><a id="6887" class="Symbol">)</a>

        <a id="6898" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6902" class="Symbol">(</a><a id="6903" class="Keyword">quote</a> <a id="6909" href="Foundations.Base.html#12640" class="Function">is-contr</a><a id="6917" class="Symbol">)</a> <a id="6919" class="Symbol">(_</a> <a id="6922" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6924" href="Meta.Reflection.HLevel.html#6924" class="Bound">ty</a> <a id="6927" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="6930" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6932" class="Symbol">)</a> <a id="6934" class="Symbol">→</a> <a id="6936" class="Keyword">do</a>
          <a id="6949" href="Meta.Reflection.HLevel.html#6949" class="Bound">ty</a> <a id="6952" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="6954" href="Meta.Reflection.Base.html#4433" class="Function">wait-just-a-bit</a> <a id="6970" href="Meta.Reflection.HLevel.html#6924" class="Bound">ty</a>
          <a id="6983" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6988" class="Symbol">(</a><a id="6989" class="Keyword">quoteTerm</a> <a id="6999" class="Number">0</a> <a id="7001" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7003" href="Meta.Reflection.HLevel.html#6949" class="Bound">ty</a><a id="7005" class="Symbol">)</a>

        <a id="7016" class="CatchallClause Symbol">_</a> <a id="7018" class="Symbol">→</a> <a id="7020" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="7030" class="String">&quot;Goal type isn&#39;t is-hlevel&quot;</a>

    <a id="7063" class="Comment">-- To support having bare hlevel! in the source file, we need to</a>
    <a id="7132" class="Comment">-- block decomposition on having a rigid-ish type at the</a>
    <a id="7193" class="Comment">-- top-level. Otherwise the first hint that matches will get</a>
    <a id="7258" class="Comment">-- matched endlessly until we run out of fuel!</a>
    <a id="7309" href="Meta.Reflection.HLevel.html#7309" class="Bound">ty</a> <a id="7312" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="7314" href="Meta.Reflection.Base.html#4433" class="Function">wait-just-a-bit</a> <a id="7330" href="Meta.Reflection.HLevel.html#6578" class="Bound">ty</a>
    <a id="7337" href="Meta.Reflection.HLevel.html#7337" class="Bound">lv</a> <a id="7340" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="7342" href="Meta.Reflection.Base.html#4433" class="Function">wait-just-a-bit</a> <a id="7358" href="Meta.Reflection.HLevel.html#6572" class="Bound">lv</a>
    <a id="7365" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7370" class="Symbol">(</a><a id="7371" href="Meta.Reflection.HLevel.html#7337" class="Bound">lv</a> <a id="7374" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7376" href="Meta.Reflection.HLevel.html#7309" class="Bound">ty</a><a id="7378" class="Symbol">)</a>

<a id="7381" class="Comment">{-
Lifting n-Types
---------------

The n-types are the leaves of the hlevel solving process, so they&#39;re
pretty much our only opportunity to adjust levels in a big way. Suppose
you have

  T = def (quote X) as

with
  get-level (get-argument T) = n
  w : is-of-hlevel n T

but what you want is a witness of is-of-hlevel (k + n) T, where k is some
numeral? Well, the solution is obvious: we can compute k - n and lift
T&#39;s witness (k - n) levels. Right?

No: we&#39;re dealing with potential open naturals, so we have to be careful
about performing ‘symbolic’ subtractions. The way we do this is with,
essentially, a loop: If w doesn&#39;t work, then try

  is-hlevel-suc n w : is-hlevel (suc n) T

until you reach a sucᵏ n = k + n. Actually, slightly more efficient, we
keep around a counter k′ for the number of tries, and transfer successors
from the wanted level (k + n) until is-of-hlevel-+ n (sucᵏ′ n) w works.
-}</a>
  <a id="lift-sol"></a><a id="8293" href="Meta.Reflection.HLevel.html#8293" class="Function">lift-sol</a> <a id="8302" class="Symbol">:</a> <a id="8304" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8309" class="Symbol">→</a> <a id="8311" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8316" class="Symbol">→</a> <a id="8318" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8320" class="Symbol">→</a> <a id="8322" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8329" href="Meta.Reflection.HLevel.html#8293" class="Function">lift-sol</a> <a id="8338" href="Meta.Reflection.HLevel.html#8338" class="Bound">tm</a> <a id="8341" class="Symbol">_</a> <a id="8343" class="Number">0</a> <a id="8345" class="Symbol">=</a> <a id="8347" href="Meta.Reflection.HLevel.html#8338" class="Bound">tm</a>
  <a id="8352" href="Meta.Reflection.HLevel.html#8293" class="CatchallClause Function">lift-sol</a><a id="8360" class="CatchallClause"> </a><a id="8361" href="Meta.Reflection.HLevel.html#8361" class="CatchallClause Bound">tm</a><a id="8363" class="CatchallClause"> </a><a id="8364" href="Meta.Reflection.HLevel.html#8364" class="CatchallClause Bound">l1</a><a id="8366" class="CatchallClause"> </a><a id="8367" href="Meta.Reflection.HLevel.html#8367" class="CatchallClause Bound">l</a> <a id="8369" class="Symbol">=</a> <a id="8371" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="8375" class="Symbol">(</a><a id="8376" class="Keyword">quote</a> <a id="8382" href="Foundations.HLevel.Base.html#2758" class="Function">is-of-hlevel-+</a><a id="8396" class="Symbol">)</a> <a id="8398" class="Symbol">(</a><a id="8399" href="Meta.Reflection.HLevel.html#8364" class="Bound">l1</a> <a id="8402" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="8405" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8409" class="Symbol">(</a><a id="8410" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8414" href="Meta.Reflection.HLevel.html#8367" class="Bound">l</a><a id="8415" class="Symbol">)</a> <a id="8417" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="8420" href="Meta.Reflection.HLevel.html#8361" class="Bound">tm</a> <a id="8423" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="8426" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8428" class="Symbol">)</a>

  <a id="pred-term"></a><a id="8433" href="Meta.Reflection.HLevel.html#8433" class="Function">pred-term</a> <a id="8443" class="Symbol">:</a> <a id="8445" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8450" class="Symbol">→</a> <a id="8452" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="8458" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8465" href="Meta.Reflection.HLevel.html#8433" class="Function">pred-term</a> <a id="8475" class="Symbol">(</a><a id="8476" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="8480" class="Symbol">(</a><a id="8481" class="Keyword">quote</a> <a id="8487" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="8490" class="Symbol">)</a> <a id="8492" class="Symbol">(</a><a id="8493" href="Meta.Reflection.HLevel.html#8493" class="Bound">x</a> <a id="8495" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="8498" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8500" class="Symbol">))</a> <a id="8503" class="Symbol">=</a> <a id="8505" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8510" href="Meta.Reflection.HLevel.html#8493" class="Bound">x</a>
  <a id="8514" href="Meta.Reflection.HLevel.html#8433" class="Function">pred-term</a> <a id="8524" class="Symbol">(</a><a id="8525" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8529" class="Symbol">(</a><a id="8530" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8534" href="Meta.Reflection.HLevel.html#8534" class="Bound">n</a><a id="8535" class="Symbol">))</a> <a id="8538" class="Keyword">with</a> <a id="8543" href="Meta.Reflection.HLevel.html#8534" class="Bound">n</a>
  <a id="8547" class="Symbol">...</a> <a id="8551" class="Symbol">|</a> <a id="8553" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8557" href="Meta.Reflection.HLevel.html#8557" class="Bound">k</a> <a id="8559" class="Symbol">=</a> <a id="8561" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8566" class="Symbol">(</a><a id="8567" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8571" class="Symbol">(</a><a id="8572" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8576" href="Meta.Reflection.HLevel.html#8557" class="Bound">k</a><a id="8577" class="Symbol">))</a>
  <a id="8582" class="CatchallClause Symbol">...</a><a id="8585" class="CatchallClause"> </a><a id="8586" class="CatchallClause Symbol">|</a><a id="8587" class="CatchallClause"> </a><a id="8588" class="CatchallClause Symbol">_</a> <a id="8590" class="Symbol">=</a> <a id="8592" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
  <a id="8602" href="Meta.Reflection.HLevel.html#8433" class="CatchallClause Function">pred-term</a><a id="8611" class="CatchallClause"> </a><a id="8612" class="CatchallClause Symbol">_</a> <a id="8614" class="Symbol">=</a> <a id="8616" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="lifting-loop"></a><a id="8627" href="Meta.Reflection.HLevel.html#8627" class="Function">lifting-loop</a> <a id="8640" class="Symbol">:</a> <a id="8642" class="Symbol">(</a><a id="8643" href="Meta.Reflection.HLevel.html#8643" class="Bound">fuel</a> <a id="8648" class="Symbol">:</a> <a id="8650" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="8651" class="Symbol">)</a> <a id="8653" class="Symbol">→</a> <a id="8655" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8657" class="Symbol">→</a> <a id="8659" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8664" class="Symbol">→</a> <a id="8666" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8671" class="Symbol">→</a> <a id="8673" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8678" class="Symbol">→</a> <a id="8680" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8685" class="Symbol">→</a> <a id="8687" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="8690" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="8694" href="Meta.Reflection.HLevel.html#8627" class="Function">lifting-loop</a> <a id="8707" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="8712" class="Symbol">_</a> <a id="8714" class="Symbol">_</a> <a id="8716" class="Symbol">_</a> <a id="8718" class="Symbol">_</a> <a id="8720" class="Symbol">_</a> <a id="8722" class="Symbol">=</a> <a id="8724" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="8734" class="String">&quot;Lifting loop ran out of fuel&quot;</a>
  <a id="8767" href="Meta.Reflection.HLevel.html#8627" class="Function">lifting-loop</a> <a id="8780" class="Symbol">(</a><a id="8781" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8785" href="Meta.Reflection.HLevel.html#8785" class="Bound">fuel</a><a id="8789" class="Symbol">)</a> <a id="8791" href="Meta.Reflection.HLevel.html#8791" class="Bound">it</a> <a id="8794" href="Meta.Reflection.HLevel.html#8794" class="Bound">solution</a> <a id="8803" href="Meta.Reflection.HLevel.html#8803" class="Bound">goal</a> <a id="8808" href="Meta.Reflection.HLevel.html#8808" class="Bound">l1</a> <a id="8811" href="Meta.Reflection.HLevel.html#8811" class="Bound">l2</a> <a id="8814" class="Symbol">=</a>
    <a id="8820" href="Meta.Reflection.HLevel.html#9035" class="Function">let&#39;s-hope</a> <a id="8831" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="8835" class="Keyword">do</a>
      <a id="8844" class="Symbol">(</a><a id="8845" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8850" href="Meta.Reflection.HLevel.html#8850" class="Bound">l2′</a><a id="8853" class="Symbol">)</a> <a id="8855" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="8857" href="Meta.Reflection.HLevel.html#8433" class="Function">pred-term</a> <a id="8867" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="8871" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="8881" href="Meta.Reflection.HLevel.html#8811" class="Bound">l2</a> <a id="8884" class="Keyword">where</a>
        <a id="8898" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="8906" class="Symbol">→</a> <a id="8908" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="8918" class="String">&quot;Lifting loop reached its end with no success&quot;</a>
      <a id="8971" href="Meta.Reflection.HLevel.html#8627" class="Function">lifting-loop</a> <a id="8984" href="Meta.Reflection.HLevel.html#8785" class="Bound">fuel</a> <a id="8989" class="Symbol">(</a><a id="8990" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8994" href="Meta.Reflection.HLevel.html#8791" class="Bound">it</a><a id="8996" class="Symbol">)</a> <a id="8998" href="Meta.Reflection.HLevel.html#8794" class="Bound">solution</a> <a id="9007" href="Meta.Reflection.HLevel.html#8803" class="Bound">goal</a> <a id="9012" href="Meta.Reflection.HLevel.html#8808" class="Bound">l1</a> <a id="9015" href="Meta.Reflection.HLevel.html#8850" class="Bound">l2′</a>
    <a id="9023" class="Keyword">where</a>
      <a id="9035" href="Meta.Reflection.HLevel.html#9035" class="Function">let&#39;s-hope</a> <a id="9046" class="Symbol">:</a> <a id="9048" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9051" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="9059" href="Meta.Reflection.HLevel.html#9035" class="Function">let&#39;s-hope</a> <a id="9070" class="Symbol">=</a> <a id="9072" class="Keyword">do</a>
        <a id="9083" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9094" class="String">&quot;tactic.hlevel&quot;</a> <a id="9110" class="Number">30</a> <a id="9113" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="9115" class="String">&quot;Lifting loop: Trying &quot;</a> <a id="9139" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9141" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9149" class="Symbol">(</a><a id="9150" href="Meta.Reflection.HLevel.html#8293" class="Function">lift-sol</a> <a id="9159" href="Meta.Reflection.HLevel.html#8794" class="Bound">solution</a> <a id="9168" href="Meta.Reflection.HLevel.html#8808" class="Bound">l1</a> <a id="9171" href="Meta.Reflection.HLevel.html#8791" class="Bound">it</a><a id="9173" class="Symbol">)</a> <a id="9175" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9177" class="String">&quot; for level &quot;</a> <a id="9191" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9193" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9201" href="Meta.Reflection.HLevel.html#8811" class="Bound">l2</a> <a id="9204" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9206" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="9217" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="9223" href="Meta.Reflection.HLevel.html#8803" class="Bound">goal</a> <a id="9228" class="Symbol">(</a><a id="9229" href="Meta.Reflection.HLevel.html#8293" class="Function">lift-sol</a> <a id="9238" href="Meta.Reflection.HLevel.html#8794" class="Bound">solution</a> <a id="9247" href="Meta.Reflection.HLevel.html#8808" class="Bound">l1</a> <a id="9250" href="Meta.Reflection.HLevel.html#8791" class="Bound">it</a><a id="9252" class="Symbol">)</a>
    <a id="9258" class="Comment">-- con (quote suc) (</a>

  <a id="9282" class="Comment">-- Projection decomposition.</a>
  <a id="treat-as-n-type"></a><a id="9313" href="Meta.Reflection.HLevel.html#9313" class="Function">treat-as-n-type</a> <a id="9329" class="Symbol">:</a> <a id="9331" class="Symbol">∀</a> <a id="9333" class="Symbol">{</a><a id="9334" href="Meta.Reflection.HLevel.html#9334" class="Bound">n</a><a id="9335" class="Symbol">}</a> <a id="9337" class="Symbol">→</a> <a id="9339" href="Meta.Reflection.HLevel.html#4037" class="Record">hlevel-projection</a> <a id="9357" href="Meta.Reflection.HLevel.html#9334" class="Bound">n</a> <a id="9359" class="Symbol">→</a> <a id="9361" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="9366" class="Symbol">→</a> <a id="9368" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9371" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="9375" href="Meta.Reflection.HLevel.html#9313" class="Function">treat-as-n-type</a> <a id="9391" href="Meta.Reflection.HLevel.html#9391" class="Bound">projection</a> <a id="9402" href="Meta.Reflection.HLevel.html#9402" class="Bound">goal</a> <a id="9407" class="Symbol">=</a> <a id="9409" class="Keyword">do</a>
    <a id="9416" class="Comment">-- First we must be looking at a goal which is of the type is-hlevel</a>
    <a id="9489" class="Comment">-- A n. We&#39;ll need both n and A.</a>
    <a id="9526" class="Symbol">(</a><a id="9527" href="Meta.Reflection.HLevel.html#9527" class="Bound">wanted-level</a> <a id="9540" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9542" href="Meta.Reflection.HLevel.html#9542" class="Bound">ty</a><a id="9544" class="Symbol">)</a> <a id="9546" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="9548" href="Meta.Reflection.HLevel.html#6325" class="Function">decompose-is-hlevel</a> <a id="9568" href="Meta.Reflection.HLevel.html#9402" class="Bound">goal</a>
    <a id="9577" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9588" class="String">&quot;tactic.hlevel&quot;</a> <a id="9604" class="Number">10</a> <a id="9607" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
      <a id="9615" class="String">&quot;Attempting to treat as &quot;</a> <a id="9641" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9643" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9651" href="Meta.Reflection.HLevel.html#9527" class="Bound">wanted-level</a> <a id="9664" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9666" class="String">&quot;-Type: &quot;</a> <a id="9676" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9678" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9686" href="Meta.Reflection.HLevel.html#9542" class="Bound">ty</a> <a id="9689" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9691" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="9698" href="Meta.Reflection.HLevel.html#9698" class="Bound">ty</a> <a id="9701" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="9703" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="9710" href="Meta.Reflection.HLevel.html#9542" class="Bound">ty</a>

    <a id="9718" class="Comment">-- Reduce the type to whnf and check whether the outermost term</a>
    <a id="9786" class="Comment">-- constructor is an application of the projection we&#39;re looking</a>
    <a id="9855" class="Comment">-- for.</a>
    <a id="9867" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="9871" href="Meta.Reflection.HLevel.html#9871" class="Bound">namen</a> <a id="9877" href="Meta.Reflection.HLevel.html#9877" class="Bound">args</a> <a id="9882" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="9884" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="9893" href="Meta.Reflection.HLevel.html#9698" class="Bound">ty</a>
      <a id="9902" class="Keyword">where</a> <a id="9908" href="Meta.Reflection.HLevel.html#9908" class="CatchallClause Bound">what</a> <a id="9913" class="Symbol">→</a> <a id="9915" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="9925" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="9927" class="String">&quot;Thing isn&#39;t an application, it is &quot;</a> <a id="9964" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9966" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9974" href="Meta.Reflection.HLevel.html#9908" class="Bound">what</a> <a id="9979" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9981" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="9989" href="Meta.Reflection.HLevel.html#9989" class="Bound">it</a> <a id="9992" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="9994" href="Meta.Reflection.HLevel.html#9391" class="Bound">projection</a> <a id="10005" class="Symbol">.</a><a id="10006" href="Meta.Reflection.HLevel.html#4434" class="Field">get-argument</a> <a id="10019" href="Meta.Reflection.HLevel.html#9877" class="Bound">args</a>

    <a id="10029" class="Comment">-- And compute the level of the projected thing, in addition to a</a>
    <a id="10099" class="Comment">-- numeral form of the wanted level.</a>
    <a id="10140" href="Meta.Reflection.HLevel.html#10140" class="Bound">actual-level</a> <a id="10153" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10155" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="10165" href="Meta.Reflection.HLevel.html#9989" class="Bound">it</a> <a id="10168" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="10172" href="Meta.Reflection.HLevel.html#9391" class="Bound">projection</a> <a id="10183" class="Symbol">.</a><a id="10184" href="Meta.Reflection.HLevel.html#4281" class="Field">get-level</a>

    <a id="10199" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="10210" class="String">&quot;tactic.hlevel&quot;</a> <a id="10226" class="Number">10</a> <a id="10229" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
      <a id="10237" class="String">&quot;... but it&#39;s actually a(n) &quot;</a> <a id="10267" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10269" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10277" href="Meta.Reflection.HLevel.html#10140" class="Bound">actual-level</a> <a id="10290" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10292" class="String">&quot;-Type&quot;</a> <a id="10300" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10302" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10310" href="Meta.Reflection.HLevel.html#10310" class="Bound">lv</a> <a id="10313" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10315" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10325" href="Meta.Reflection.HLevel.html#9527" class="Bound">wanted-level</a>
    <a id="10342" href="Meta.Reflection.HLevel.html#10342" class="Bound">lv′</a> <a id="10346" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10348" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10358" href="Meta.Reflection.HLevel.html#10140" class="Bound">actual-level</a>
    <a id="10375" href="Meta.Reflection.HLevel.html#8627" class="Function">lifting-loop</a> <a id="10388" class="Number">10000</a> <a id="10394" class="Number">0</a> <a id="10396" class="Symbol">(</a><a id="10397" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10401" class="Symbol">(</a><a id="10402" href="Meta.Reflection.HLevel.html#9391" class="Bound">projection</a> <a id="10413" class="Symbol">.</a><a id="10414" href="Meta.Reflection.HLevel.html#4094" class="Field">has-level</a><a id="10423" class="Symbol">)</a> <a id="10425" class="Symbol">(</a><a id="10426" href="Meta.Reflection.HLevel.html#9989" class="Bound">it</a> <a id="10429" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="10432" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10434" class="Symbol">))</a> <a id="10437" href="Meta.Reflection.HLevel.html#9402" class="Bound">goal</a> <a id="10442" href="Meta.Reflection.HLevel.html#10342" class="Bound">lv′</a> <a id="10446" href="Meta.Reflection.HLevel.html#10310" class="Bound">lv</a>

    <a id="10454" href="Agda.Builtin.Reflection.html#9521" class="Postulate">commitTC</a>

  <a id="10466" class="Comment">-- Fall back to Agda&#39;s instance search mechanism. This isn&#39;t as</a>
  <a id="10532" class="Comment">-- straightforward as just using the &#39;hlevel&#39; function for a couple of</a>
  <a id="10605" class="Comment">-- reasons.</a>
  <a id="use-instance-search"></a><a id="10619" href="Meta.Reflection.HLevel.html#10619" class="Function">use-instance-search</a> <a id="10639" class="Symbol">:</a> <a id="10641" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="10646" class="Symbol">→</a> <a id="10648" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="10653" class="Symbol">→</a> <a id="10655" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="10658" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="10662" href="Meta.Reflection.HLevel.html#10619" class="Function">use-instance-search</a> <a id="10682" href="Meta.Reflection.HLevel.html#10682" class="Bound">has-alts</a> <a id="10691" href="Meta.Reflection.HLevel.html#10691" class="Bound">goal</a> <a id="10696" class="Symbol">=</a> <a id="10698" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="10713" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="10715" class="Keyword">do</a>
    <a id="10722" class="Symbol">(</a><a id="10723" href="Meta.Reflection.HLevel.html#10723" class="Bound">lv</a> <a id="10726" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10728" href="Meta.Reflection.HLevel.html#10728" class="Bound">ty</a><a id="10730" class="Symbol">)</a> <a id="10732" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10734" href="Meta.Reflection.HLevel.html#6325" class="Function">decompose-is-hlevel</a> <a id="10754" href="Meta.Reflection.HLevel.html#10691" class="Bound">goal</a>
    <a id="10763" href="Meta.Reflection.HLevel.html#10763" class="Bound">solved</a><a id="10769" class="Symbol">@(</a><a id="10771" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="10776" href="Meta.Reflection.HLevel.html#10776" class="Bound">mv</a> <a id="10779" class="Symbol">_)</a> <a id="10782" href="Meta.Bind.html#183" class="Field Operator">←</a>
      <a id="10790" href="Meta.Reflection.Base.html#1805" class="Function">new-meta</a> <a id="10799" class="Symbol">(</a><a id="10800" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10804" class="Symbol">(</a><a id="10805" class="Keyword">quote</a> <a id="10811" href="Meta.HLevel.html#174" class="Record">H-Level</a><a id="10818" class="Symbol">)</a> <a id="10820" class="Symbol">(</a><a id="10821" href="Meta.Reflection.HLevel.html#10723" class="Bound">lv</a> <a id="10824" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="10827" href="Meta.Reflection.HLevel.html#10728" class="Bound">ty</a> <a id="10830" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="10833" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10835" class="Symbol">))</a> <a id="10838" class="Keyword">where</a> <a id="10844" class="CatchallClause Symbol">_</a> <a id="10846" class="Symbol">→</a> <a id="10848" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="10858" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="10865" href="Meta.Reflection.HLevel.html#10865" class="Bound">instances</a> <a id="10875" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10877" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="10890" href="Meta.Reflection.HLevel.html#10776" class="Bound">mv</a>

    <a id="10898" href="Meta.Reflection.HLevel.html#10898" class="Bound">t</a> <a id="10900" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="10902" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="10910" href="Meta.Reflection.HLevel.html#10865" class="Bound">instances</a>
    <a id="10924" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="10935" class="String">&quot;tactic.hlevel&quot;</a> <a id="10951" class="Number">10</a> <a id="10954" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
      <a id="10962" class="String">&quot;Using instance search for\n&quot;</a> <a id="10992" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10994" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11002" href="Meta.Reflection.HLevel.html#10728" class="Bound">ty</a> <a id="11005" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
      <a id="11013" class="String">&quot;\nFound candidates\n &quot;</a> <a id="11037" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11039" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11047" href="Meta.Reflection.HLevel.html#10898" class="Bound">t</a> <a id="11049" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11051" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="11059" class="Comment">-- We actually want to manage the instance searching ourselves,</a>
    <a id="11127" class="Comment">-- sorta, to avoid getting into situations where the macro has</a>
    <a id="11194" class="Comment">-- committed to instance search but Agda will disagree with it.</a>
    <a id="11262" class="Keyword">let</a>
      <a id="11272" href="Meta.Reflection.HLevel.html#11272" class="Bound">go</a> <a id="11275" class="Symbol">:</a> <a id="11277" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="11282" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="11287" class="Symbol">→</a> <a id="11289" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="11292" class="Symbol">(</a><a id="11293" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="11295" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="11297" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="11301" class="Symbol">)</a>
      <a id="11309" href="Meta.Reflection.HLevel.html#11272" class="Bound">go</a> <a id="11312" class="Symbol">=</a> <a id="11314" class="Symbol">λ</a> <a id="11316" class="Keyword">where</a>
        <a id="11330" class="Comment">-- If there is *exactly* one instance candidate for this goal,</a>
        <a id="11401" class="Comment">-- then we can go ahead and solve it. That&#39;s because having</a>
        <a id="11469" class="Comment">-- exactly one instance means Agda will solve using that</a>
        <a id="11534" class="Comment">-- instance!</a>
        <a id="11555" class="Symbol">(</a><a id="11556" href="Meta.Reflection.HLevel.html#11556" class="Bound">x</a> <a id="11558" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11560" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11562" class="Symbol">)</a> <a id="11564" class="Symbol">→</a> <a id="11566" class="Keyword">do</a>
          <a id="11579" class="Comment">-- Note that, since getInstances works by creating a new meta,</a>
          <a id="11652" class="Comment">-- we have to commit to the instance ourselves.</a>
          <a id="11710" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11716" href="Meta.Reflection.HLevel.html#10763" class="Bound">solved</a> <a id="11723" href="Meta.Reflection.HLevel.html#11556" class="Bound">x</a>
          <a id="11735" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="11750" class="Symbol">(</a><a id="11751" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="11757" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11759" class="Keyword">quote</a> <a id="11765" href="Meta.HLevel.html#314" class="Function">hlevel</a> <a id="11772" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11774" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11776" class="Symbol">)</a> <a id="11778" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="11780" href="Agda.Builtin.Reflection.html#10063" class="Postulate">withReconstructed</a> <a id="11798" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="11803" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
            <a id="11817" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11823" href="Meta.Reflection.HLevel.html#10691" class="Bound">goal</a> <a id="11828" class="Symbol">(</a><a id="11829" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="11833" class="Symbol">(</a><a id="11834" class="Keyword">quote</a> <a id="11840" href="Meta.HLevel.html#314" class="Function">hlevel</a><a id="11846" class="Symbol">)</a> <a id="11848" class="Symbol">(</a><a id="11849" href="Meta.Reflection.HLevel.html#10723" class="Bound">lv</a> <a id="11852" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="11855" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11857" class="Symbol">))</a>
          <a id="11870" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="11875" class="Symbol">(</a><a id="11876" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="11879" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11881" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="11885" class="Symbol">)</a>

        <a id="11896" class="Comment">-- If there are any more alternatives to be tried after this</a>
        <a id="11965" class="Comment">-- one, then we fail (backtrack). Otherwise, we discard the TC</a>
        <a id="12036" class="Comment">-- state but indicate success: this will cause the meta to be</a>
        <a id="12106" class="Comment">-- solved with an interaction point (if using</a>
        <a id="12160" class="Comment">-- elaborate-and-give).</a>
        <a id="12192" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="12195" class="Symbol">→</a> <a id="12197" href="Data.Bool.Base.html#492" class="Function Operator">if</a> <a id="12200" href="Meta.Reflection.HLevel.html#10682" class="Bound">has-alts</a>
          <a id="12219" href="Data.Bool.Base.html#492" class="Function Operator">then</a> <a id="12224" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="12234" class="String">&quot;No possible instances, but have other decompositions to try&quot;</a>
          <a id="12306" href="Data.Bool.Base.html#492" class="Function Operator">else</a> <a id="12311" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="12316" class="Symbol">(</a><a id="12317" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12320" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12322" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="12327" class="Symbol">)</a>

        <a id="12338" class="CatchallClause Symbol">_</a> <a id="12340" class="Symbol">→</a> <a id="12342" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="12352" class="String">&quot;Too many possible instances; will not use instance search for this goal&quot;</a>
    <a id="12430" href="Meta.Reflection.HLevel.html#11272" class="Bound">go</a> <a id="12433" href="Meta.Reflection.HLevel.html#10865" class="Bound">instances</a>

  <a id="12446" class="Comment">-- Entry point for calling the tactic.</a>
  <a id="search"></a><a id="12487" href="Meta.Reflection.HLevel.html#12487" class="Function">search</a> <a id="12494" class="Symbol">:</a> <a id="12496" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="12501" class="Symbol">→</a> <a id="12503" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12508" class="Symbol">→</a> <a id="12510" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="12512" class="Symbol">→</a> <a id="12514" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12519" class="Symbol">→</a> <a id="12521" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="12524" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="12528" class="Comment">-- Give up if we&#39;re out of fuel:</a>
  <a id="12563" href="Meta.Reflection.HLevel.html#12487" class="Function">search</a> <a id="12570" href="Meta.Reflection.HLevel.html#12570" class="Bound">has-alts</a> <a id="12579" class="Symbol">_</a>     <a id="12585" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="12593" href="Meta.Reflection.HLevel.html#12593" class="Bound">goal</a> <a id="12598" class="Symbol">=</a> <a id="12600" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="12606" href="Meta.Reflection.HLevel.html#12593" class="Bound">goal</a> <a id="12611" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>

  <a id="12622" class="Comment">-- Actual main loop: try using the hints database, try treating the</a>
  <a id="12692" class="Comment">-- goal as an n-type, fall back to instance search.</a>
  <a id="12746" href="Meta.Reflection.HLevel.html#12487" class="Function">search</a> <a id="12753" href="Meta.Reflection.HLevel.html#12753" class="Bound">has-alts</a> <a id="12762" href="Meta.Reflection.HLevel.html#12762" class="Bound">level</a> <a id="12768" class="Symbol">(</a><a id="12769" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12773" href="Meta.Reflection.HLevel.html#12773" class="Bound">n</a><a id="12774" class="Symbol">)</a> <a id="12776" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a> <a id="12781" class="Symbol">=</a>
    <a id="12787" href="Meta.Reflection.HLevel.html#13105" class="Function">use-projections</a>
      <a id="12809" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="12813" href="Meta.Reflection.HLevel.html#21451" class="Function">use-hints</a>
      <a id="12829" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="12833" href="Meta.Reflection.HLevel.html#10619" class="Function">use-instance-search</a> <a id="12853" href="Meta.Reflection.HLevel.html#12753" class="Bound">has-alts</a> <a id="12862" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a>
      <a id="12873" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="12877" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="12887" class="String">&quot;Search failed!!&quot;</a>
    <a id="12909" class="Keyword">where</a>
      <a id="12921" class="Keyword">open</a> <a id="12926" href="Meta.Reflection.HLevel.html#4037" class="Module">hlevel-projection</a>

      <a id="12951" class="Comment">-- Nondeterministically use a projection for establishing the</a>
      <a id="13019" class="Comment">-- result. This follows the approach described in [Using</a>
      <a id="13082" class="Comment">-- projections].</a>
      <a id="13105" href="Meta.Reflection.HLevel.html#13105" class="Function">use-projections</a> <a id="13121" class="Symbol">:</a> <a id="13123" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="13126" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="13134" href="Meta.Reflection.HLevel.html#13105" class="Function">use-projections</a> <a id="13150" class="Symbol">=</a> <a id="13152" class="Keyword">do</a>
        <a id="13163" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13167" href="Meta.Reflection.HLevel.html#13167" class="Bound">qn</a> <a id="13170" class="Symbol">_</a> <a id="13172" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13174" class="Symbol">(</a><a id="13175" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="13179" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="13183" href="Meta.Reflection.HLevel.html#6325" class="Function">decompose-is-hlevel</a> <a id="13203" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a><a id="13207" class="Symbol">)</a> <a id="13209" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="13213" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
          <a id="13230" class="Keyword">where</a> <a id="13236" class="CatchallClause Symbol">_</a> <a id="13238" class="Symbol">→</a> <a id="13240" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="13250" class="String">&quot;Term is not headed by a definition; ignoring projections.&quot;</a>

        <a id="13319" href="Meta.Reflection.HLevel.html#13319" class="Bound">goalt</a> <a id="13325" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13327" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="13337" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a>
        <a id="13350" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="13361" class="String">&quot;tactic.hlevel&quot;</a> <a id="13377" class="Number">20</a> <a id="13380" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
          <a id="13392" class="String">&quot;Will attempt to use projections for goal\n  &quot;</a> <a id="13439" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13441" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13449" href="Meta.Reflection.HLevel.html#13319" class="Bound">goalt</a> <a id="13455" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13457" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="13469" class="Symbol">(</a><a id="13470" href="Meta.Reflection.HLevel.html#13470" class="Bound">solved</a> <a id="13477" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13479" href="Meta.Reflection.HLevel.html#13479" class="Bound">instances</a><a id="13488" class="Symbol">)</a> <a id="13490" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13492" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="13507" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="13509" class="Keyword">do</a>
          <a id="13522" href="Meta.Reflection.HLevel.html#13522" class="Bound">solved</a><a id="13528" class="Symbol">@(</a><a id="13530" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="13535" href="Meta.Reflection.HLevel.html#13535" class="Bound">mv</a> <a id="13538" class="Symbol">_)</a> <a id="13541" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13543" href="Meta.Reflection.Base.html#1805" class="Function">new-meta</a> <a id="13552" class="Symbol">(</a><a id="13553" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13557" class="Symbol">(</a><a id="13558" class="Keyword">quote</a> <a id="13564" href="Meta.Reflection.HLevel.html#4037" class="Record">hlevel-projection</a><a id="13581" class="Symbol">)</a> <a id="13583" class="Symbol">(</a><a id="13584" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="13588" class="Symbol">(</a><a id="13589" href="Agda.Builtin.Reflection.html#4283" class="InductiveConstructor">name</a> <a id="13594" href="Meta.Reflection.HLevel.html#13167" class="Bound">qn</a><a id="13596" class="Symbol">)</a> <a id="13598" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="13601" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13603" class="Symbol">))</a>
            <a id="13618" class="Keyword">where</a> <a id="13624" class="CatchallClause Symbol">_</a> <a id="13626" class="Symbol">→</a> <a id="13628" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="13638" class="Symbol">(</a><a id="13639" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13647" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a> <a id="13652" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13654" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13656" class="Symbol">)</a>

          <a id="13669" class="Comment">-- If there are some hints, then great, otherwise we discard</a>
          <a id="13740" class="Comment">-- the TC state.</a>
          <a id="13767" class="Symbol">(</a><a id="13768" href="Meta.Reflection.HLevel.html#13768" class="Bound">x</a> <a id="13770" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13772" href="Meta.Reflection.HLevel.html#13772" class="Bound">xs</a><a id="13774" class="Symbol">)</a> <a id="13776" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13778" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="13791" href="Meta.Reflection.HLevel.html#13535" class="Bound">mv</a>
            <a id="13806" class="Keyword">where</a> <a id="13812" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="13815" class="Symbol">→</a> <a id="13817" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="13822" class="Symbol">((</a><a id="13824" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="13832" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13834" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13836" class="Symbol">)</a> <a id="13838" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13840" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="13845" class="Symbol">)</a>

          <a id="13858" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="13863" class="Symbol">((</a><a id="13865" href="Meta.Reflection.HLevel.html#13522" class="Bound">solved</a> <a id="13872" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13874" href="Meta.Reflection.HLevel.html#13768" class="Bound">x</a> <a id="13876" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13878" href="Meta.Reflection.HLevel.html#13772" class="Bound">xs</a><a id="13880" class="Symbol">)</a> <a id="13882" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13884" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="13888" class="Symbol">)</a>

        <a id="13899" href="Meta.Foldable.html#505" class="Function">nondet</a> <a id="13906" class="Symbol">(</a><a id="13907" href="Meta.Idiom.html#121" class="InductiveConstructor">eff</a> <a id="13911" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="13915" class="Symbol">)</a> <a id="13917" href="Meta.Reflection.HLevel.html#13479" class="Bound">instances</a> <a id="13927" class="Symbol">λ</a> <a id="13929" href="Meta.Reflection.HLevel.html#13929" class="Bound">a</a> <a id="13931" class="Symbol">→</a> <a id="13933" class="Keyword">do</a>
          <a id="13946" href="Meta.Reflection.HLevel.html#13946" class="Bound">projection</a> <a id="13957" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="13959" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="13969" class="Symbol">{</a><a id="13970" class="Argument">A</a> <a id="13972" class="Symbol">=</a> <a id="13974" href="Meta.Reflection.HLevel.html#4037" class="Record">hlevel-projection</a> <a id="13992" href="Meta.Reflection.HLevel.html#13167" class="Bound">qn</a><a id="13994" class="Symbol">}</a> <a id="13996" href="Meta.Reflection.HLevel.html#13929" class="Bound">a</a>
          <a id="14008" href="Meta.Reflection.HLevel.html#14008" class="Bound">ty</a> <a id="14011" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="14013" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="14028" class="Symbol">(</a><a id="14029" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="14035" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14037" href="Meta.Reflection.HLevel.html#5799" class="Function">hlevel-types</a><a id="14049" class="Symbol">)</a> <a id="14051" class="Symbol">(</a><a id="14052" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="14062" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a> <a id="14067" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="14071" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="14077" class="Symbol">)</a>
          <a id="14089" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="14100" class="String">&quot;tactic.hlevel&quot;</a> <a id="14116" class="Number">20</a> <a id="14119" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
            <a id="14133" class="String">&quot;Outer type: &quot;</a> <a id="14148" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14150" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="14158" href="Meta.Reflection.HLevel.html#14008" class="Bound">ty</a> <a id="14161" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14163" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="14176" href="Meta.Reflection.HLevel.html#9313" class="Function">treat-as-n-type</a> <a id="14192" href="Meta.Reflection.HLevel.html#13946" class="Bound">projection</a> <a id="14203" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a> <a id="14208" href="Meta.Bind.html#289" class="Function Operator">&gt;&gt;</a> <a id="14211" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="14217" href="Meta.Reflection.HLevel.html#13470" class="Bound">solved</a> <a id="14224" href="Meta.Reflection.HLevel.html#13929" class="Bound">a</a>

      <a id="14233" class="Comment">-- Get rid of any invisible binders that lead the term.</a>
      <a id="14295" href="Meta.Reflection.HLevel.html#14295" class="Function">remove-invisible</a> <a id="14312" class="Symbol">:</a> <a id="14314" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14319" class="Symbol">→</a> <a id="14321" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14326" class="Symbol">→</a> <a id="14328" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="14331" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14342" href="Meta.Reflection.HLevel.html#14295" class="Function">remove-invisible</a>
        <a id="14367" class="Symbol">(</a><a id="14368" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14372" class="Symbol">_</a> <a id="14374" class="Symbol">(</a><a id="14375" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14379" class="Symbol">_</a> <a id="14381" href="Meta.Reflection.HLevel.html#14381" class="Bound">t</a><a id="14382" class="Symbol">))</a>
        <a id="14393" class="Symbol">(</a><a id="14394" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="14397" class="Symbol">(</a><a id="14398" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="14402" class="Symbol">(</a><a id="14403" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="14412" href="Meta.Reflection.HLevel.html#14412" class="Bound">invisible</a> <a id="14422" class="Symbol">_)</a> <a id="14425" class="Symbol">_)</a> <a id="14428" class="Symbol">(</a><a id="14429" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14433" class="Symbol">_</a> <a id="14435" href="Meta.Reflection.HLevel.html#14435" class="Bound">ret</a><a id="14438" class="Symbol">))</a>
        <a id="14449" class="Symbol">=</a> <a id="14451" href="Meta.Reflection.HLevel.html#14295" class="Function">remove-invisible</a> <a id="14468" href="Meta.Reflection.HLevel.html#14381" class="Bound">t</a> <a id="14470" href="Meta.Reflection.HLevel.html#14435" class="Bound">ret</a>
      <a id="14480" href="Meta.Reflection.HLevel.html#14295" class="CatchallClause Function">remove-invisible</a><a id="14496" class="CatchallClause"> </a><a id="14497" href="Meta.Reflection.HLevel.html#14497" class="CatchallClause Bound">inner</a><a id="14502" class="CatchallClause"> </a><a id="14503" class="CatchallClause Symbol">_</a> <a id="14505" class="Symbol">=</a> <a id="14507" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="14512" href="Meta.Reflection.HLevel.html#14497" class="Bound">inner</a>

      <a id="14525" class="Comment">-- Search using decompositions involves manipulating the scope,</a>
      <a id="14595" class="Comment">-- which is why it&#39;s spread over so many functions, and even then,</a>
      <a id="14668" class="Comment">-- some are too big.</a>

      <a id="14696" class="Comment">-- Wrap the given term in a series of visible lambdas.</a>
      <a id="14757" href="Meta.Reflection.HLevel.html#14757" class="Function">wrap-lams</a> <a id="14767" class="Symbol">:</a> <a id="14769" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="14771" class="Symbol">→</a> <a id="14773" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14778" class="Symbol">→</a> <a id="14780" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14791" href="Meta.Reflection.HLevel.html#14757" class="Function">wrap-lams</a> <a id="14801" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="14806" href="Meta.Reflection.HLevel.html#14806" class="Bound">r</a> <a id="14808" class="Symbol">=</a> <a id="14810" href="Meta.Reflection.HLevel.html#14806" class="Bound">r</a>
      <a id="14818" href="Meta.Reflection.HLevel.html#14757" class="Function">wrap-lams</a> <a id="14828" class="Symbol">(</a><a id="14829" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="14833" href="Meta.Reflection.HLevel.html#14833" class="Bound">x</a><a id="14834" class="Symbol">)</a> <a id="14836" href="Meta.Reflection.HLevel.html#14836" class="Bound">r</a> <a id="14838" class="Symbol">=</a> <a id="14840" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14844" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="14852" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="14854" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14858" class="String">&quot;a&quot;</a> <a id="14862" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="14864" href="Meta.Reflection.HLevel.html#14757" class="Function">wrap-lams</a> <a id="14874" href="Meta.Reflection.HLevel.html#14833" class="Bound">x</a> <a id="14876" href="Meta.Reflection.HLevel.html#14836" class="Bound">r</a>

      <a id="14885" class="Comment">-- Compute a continuation which extends the context by n visible</a>
      <a id="14956" class="Comment">-- variables, all typed &#39;unknown&#39;.</a>
      <a id="14997" href="Meta.Reflection.HLevel.html#14997" class="Function">extend-n</a> <a id="15006" class="Symbol">:</a> <a id="15008" class="Symbol">∀</a> <a id="15010" class="Symbol">{</a><a id="15011" href="Meta.Reflection.HLevel.html#15011" class="Bound">ℓ</a><a id="15012" class="Symbol">}</a> <a id="15014" class="Symbol">→</a> <a id="15016" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="15018" class="Symbol">→</a> <a id="15020" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15023" class="Symbol">((</a><a id="15025" href="Meta.Reflection.HLevel.html#15025" class="Bound">A</a> <a id="15027" class="Symbol">:</a> <a id="15029" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="15034" href="Meta.Reflection.HLevel.html#15011" class="Bound">ℓ</a><a id="15035" class="Symbol">)</a> <a id="15037" class="Symbol">→</a> <a id="15039" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15042" href="Meta.Reflection.HLevel.html#15025" class="Bound">A</a> <a id="15044" class="Symbol">→</a> <a id="15046" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15049" href="Meta.Reflection.HLevel.html#15025" class="Bound">A</a><a id="15050" class="Symbol">)</a>
      <a id="15058" href="Meta.Reflection.HLevel.html#14997" class="Function">extend-n</a> <a id="15067" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="15072" class="Symbol">=</a> <a id="15074" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15079" class="Symbol">λ</a> <a id="15081" href="Meta.Reflection.HLevel.html#15081" class="Bound">_</a> <a id="15083" href="Meta.Reflection.HLevel.html#15083" class="Bound">x</a> <a id="15085" class="Symbol">→</a> <a id="15087" href="Meta.Reflection.HLevel.html#15083" class="Bound">x</a>
      <a id="15095" href="Meta.Reflection.HLevel.html#14997" class="Function">extend-n</a> <a id="15104" class="Symbol">(</a><a id="15105" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="15109" href="Meta.Reflection.HLevel.html#15109" class="Bound">n</a><a id="15110" class="Symbol">)</a> <a id="15112" class="Symbol">=</a> <a id="15114" class="Keyword">do</a>
        <a id="15125" href="Meta.Reflection.HLevel.html#15125" class="Bound">rest</a> <a id="15130" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="15132" href="Meta.Reflection.HLevel.html#14997" class="Function">extend-n</a> <a id="15141" href="Meta.Reflection.HLevel.html#15109" class="Bound">n</a>
        <a id="15151" href="Foundations.Prim.Type.html#599" class="InductiveConstructor">lift</a> <a id="15156" href="Meta.Reflection.HLevel.html#15156" class="Bound">mv</a> <a id="15159" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="15161" href="Meta.Reflection.HLevel.html#15125" class="Bound">rest</a> <a id="15166" class="Symbol">(</a><a id="15167" href="Foundations.Prim.Type.html#538" class="Record">Lift</a> <a id="15172" class="Symbol">_</a> <a id="15174" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15178" class="Symbol">)</a> <a id="15180" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="15182" href="Foundations.Prim.Type.html#599" class="InductiveConstructor">lift</a> <a id="15187" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="15191" href="Meta.Reflection.Base.html#1805" class="Function">new-meta</a> <a id="15200" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="15216" class="Keyword">let</a> <a id="15220" href="Meta.Reflection.HLevel.html#15220" class="Bound">domain</a> <a id="15227" class="Symbol">=</a> <a id="15229" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="15233" class="Symbol">(</a><a id="15234" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="15243" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="15251" class="Symbol">(</a><a id="15252" href="Agda.Builtin.Reflection.html#3463" class="InductiveConstructor">modality</a> <a id="15261" href="Agda.Builtin.Reflection.html#3019" class="InductiveConstructor">relevant</a> <a id="15270" href="Agda.Builtin.Reflection.html#3241" class="InductiveConstructor">quantity-ω</a><a id="15280" class="Symbol">))</a> <a id="15283" href="Meta.Reflection.HLevel.html#15156" class="Bound">mv</a>
        <a id="15294" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15299" class="Symbol">λ</a> <a id="15301" href="Meta.Reflection.HLevel.html#15301" class="Bound">a</a> <a id="15303" href="Meta.Reflection.HLevel.html#15303" class="Bound">k</a> <a id="15305" class="Symbol">→</a> <a id="15307" href="Meta.Reflection.HLevel.html#15125" class="Bound">rest</a> <a id="15312" href="Meta.Reflection.HLevel.html#15301" class="Bound">a</a> <a id="15314" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="15316" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="15330" class="String">&quot;a&quot;</a> <a id="15334" href="Meta.Reflection.HLevel.html#15220" class="Bound">domain</a> <a id="15341" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="15343" href="Meta.Reflection.HLevel.html#15303" class="Bound">k</a>

      <a id="15352" class="Comment">-- Given a list of argument specs, actually unify the goal with</a>
      <a id="15422" class="Comment">-- the solution of decomposition, and call a continuation to</a>
      <a id="15489" class="Comment">-- perform any outstanding searches.</a>
      <a id="15532" href="Meta.Reflection.HLevel.html#15532" class="Function">gen-args</a>
        <a id="15549" class="Symbol">:</a> <a id="15551" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>              <a id="15569" class="Comment">-- ^ Are there any alternatives after this one?</a>
        <a id="15625" class="Symbol">→</a> <a id="15627" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>              <a id="15645" class="Comment">-- ^ What level are we searching for?</a>

        <a id="15692" class="Symbol">→</a> <a id="15694" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>              <a id="15712" class="Comment">-- ^ Name of the lemma,</a>
        <a id="15744" class="Symbol">→</a> <a id="15746" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15751" href="Meta.Reflection.HLevel.html#2797" class="Datatype">Arg-spec</a>     <a id="15764" class="Comment">-- ^ and the arguments we should invent.</a>

        <a id="15814" class="Symbol">→</a> <a id="15816" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15821" class="Symbol">(</a><a id="15822" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="15826" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15830" class="Symbol">)</a>
        <a id="15840" class="Comment">-- ^ Accumulator: computed arguments (criminally, in reverse</a>
        <a id="15909" class="Comment">-- order)</a>
        <a id="15927" class="Symbol">→</a> <a id="15929" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15932" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
          <a id="15944" class="Comment">-- ^ Accumulator/continuation: what do we need to do after</a>
          <a id="16013" class="Comment">-- unifying the goal with the lemma?. This is both</a>
          <a id="16074" class="Comment">-- continuation (it can be used to run something after the</a>
          <a id="16143" class="Comment">-- arguments are built) and accumulator (searching recursively</a>
          <a id="16216" class="Comment">-- is done last).</a>
        <a id="16242" class="Symbol">→</a> <a id="16244" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="16247" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>              <a id="16262" class="Comment">-- ^ Returns nada</a>
      <a id="16286" href="Meta.Reflection.HLevel.html#15532" class="Function">gen-args</a> <a id="16295" href="Meta.Reflection.HLevel.html#16295" class="Bound">has-alts</a> <a id="16304" href="Meta.Reflection.HLevel.html#16304" class="Bound">level</a> <a id="16310" href="Meta.Reflection.HLevel.html#16310" class="Bound">defn</a> <a id="16315" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="16318" href="Meta.Reflection.HLevel.html#16318" class="Bound">accum</a> <a id="16324" href="Meta.Reflection.HLevel.html#16324" class="Bound">cont</a> <a id="16329" class="Symbol">=</a> <a id="16331" class="Keyword">do</a>
        <a id="16342" class="Comment">-- If we have no arguments to generate, then we can go ahead and</a>
        <a id="16415" class="Comment">-- use the accumulator as-is.</a>
        <a id="16453" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="16459" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a> <a id="16464" class="Symbol">(</a><a id="16465" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16469" href="Meta.Reflection.HLevel.html#16310" class="Bound">defn</a> <a id="16474" class="Symbol">(</a><a id="16475" href="Data.List.Base.html#846" class="Function">reverse</a> <a id="16483" href="Meta.Reflection.HLevel.html#16318" class="Bound">accum</a><a id="16488" class="Symbol">))</a>
        <a id="16499" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="16510" class="String">&quot;tactic.hlevel&quot;</a> <a id="16526" class="Number">10</a> <a id="16529" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
          <a id="16541" class="String">&quot;Committed to solution: &quot;</a> <a id="16567" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16569" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="16577" class="Symbol">(</a><a id="16578" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16582" href="Meta.Reflection.HLevel.html#16310" class="Bound">defn</a> <a id="16587" class="Symbol">(</a><a id="16588" href="Data.List.Base.html#846" class="Function">reverse</a> <a id="16596" href="Meta.Reflection.HLevel.html#16318" class="Bound">accum</a><a id="16601" class="Symbol">))</a> <a id="16604" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16606" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="16617" href="Meta.Reflection.HLevel.html#16324" class="Bound">cont</a>

      <a id="16629" href="Meta.Reflection.HLevel.html#15532" class="Function">gen-args</a> <a id="16638" href="Meta.Reflection.HLevel.html#16638" class="Bound">has-alts</a> <a id="16647" href="Meta.Reflection.HLevel.html#16647" class="Bound">level</a> <a id="16653" href="Meta.Reflection.HLevel.html#16653" class="Bound">defn</a> <a id="16658" class="Symbol">(</a><a id="16659" href="Meta.Reflection.HLevel.html#16659" class="Bound">x</a> <a id="16661" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16663" href="Meta.Reflection.HLevel.html#16663" class="Bound">args</a><a id="16667" class="Symbol">)</a> <a id="16669" href="Meta.Reflection.HLevel.html#16669" class="Bound">accum</a> <a id="16675" href="Meta.Reflection.HLevel.html#16675" class="Bound">cont</a> <a id="16680" class="Keyword">with</a> <a id="16685" href="Meta.Reflection.HLevel.html#16659" class="Bound">x</a>
      <a id="16693" class="Comment">-- If we got asked for the level without an adjustment (i.e. monus</a>
      <a id="16766" class="Comment">-- by zero), then we may as well not bother *trying* to adjust it.</a>
      <a id="16839" class="Comment">-- Saves a bit of computation.</a>
      <a id="16876" class="Symbol">...</a> <a id="16880" class="Symbol">|</a> <a id="16882" href="Meta.Reflection.HLevel.html#2821" class="InductiveConstructor">`level-minus</a> <a id="16895" class="Number">0</a> <a id="16897" class="Symbol">=</a> <a id="16899" href="Meta.Reflection.HLevel.html#15532" class="Function">gen-args</a> <a id="16908" class="Bound">has-alts</a> <a id="16917" class="Bound">level</a> <a id="16923" class="Bound">defn</a> <a id="16928" class="Bound">args</a> <a id="16933" class="Symbol">(</a><a id="16934" class="Bound">level</a> <a id="16940" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="16943" class="Bound">accum</a><a id="16948" class="Symbol">)</a> <a id="16950" class="Bound">cont</a>
      <a id="16961" class="Comment">-- If we have to insert the level minus some offset, then we need</a>
      <a id="17033" class="Comment">-- to do the computation:</a>
      <a id="17065" class="Symbol">...</a> <a id="17069" class="Symbol">|</a> <a id="17071" href="Meta.Reflection.HLevel.html#2821" class="InductiveConstructor">`level-minus</a> <a id="17084" href="Meta.Reflection.HLevel.html#17084" class="Bound">n</a><a id="17085" class="Symbol">@(</a><a id="17087" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17091" class="Symbol">_)</a> <a id="17094" class="Symbol">=</a>
        <a id="17104" class="Keyword">do</a>
          <a id="17117" href="Meta.Reflection.HLevel.html#17117" class="Bound">level</a> <a id="17123" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="17125" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="17135" class="Bound">level</a>
          <a id="17151" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="17162" class="String">&quot;tactic.hlevel&quot;</a> <a id="17178" class="Number">10</a> <a id="17181" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
            <a id="17195" class="String">&quot;Hint demands offset, performing symbolic monus, subtracting from\n  &quot;</a> <a id="17266" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17268" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="17276" href="Meta.Reflection.HLevel.html#17117" class="Bound">level</a> <a id="17282" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17284" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="17297" href="Meta.Reflection.HLevel.html#17297" class="Bound">level′′</a> <a id="17305" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="17307" href="Meta.Reflection.HLevel.html#17892" class="Function">monus</a> <a id="17313" href="Meta.Reflection.HLevel.html#17117" class="Bound">level</a> <a id="17319" href="Meta.Reflection.HLevel.html#17084" class="Bound">n</a>
          <a id="17331" class="Comment">-- Reduce otherwise we get Number.fromNat as the term</a>
          <a id="17395" href="Meta.Reflection.HLevel.html#15532" class="Function">gen-args</a> <a id="17404" class="Bound">has-alts</a> <a id="17413" href="Meta.Reflection.HLevel.html#17117" class="Bound">level</a> <a id="17419" class="Bound">defn</a> <a id="17424" class="Bound">args</a> <a id="17429" class="Symbol">(</a><a id="17430" href="Meta.Reflection.HLevel.html#17297" class="Bound">level′′</a> <a id="17438" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="17441" class="Bound">accum</a><a id="17446" class="Symbol">)</a> <a id="17448" class="Bound">cont</a>
        <a id="17461" class="Keyword">where</a>
          <a id="17477" class="Comment">-- A &#39;symbolic&#39; monus function. If we&#39;re looking at an actual</a>
          <a id="17549" class="Comment">-- number, then we can just do the computation in TC, but</a>
          <a id="17617" class="Comment">-- otherwise we have to reimplement the builtin subtraction,</a>
          <a id="17688" class="Comment">-- where the minuend is a *term* rather than a number. In</a>
          <a id="17756" class="Comment">-- addition to being a bad operation (monus, grr), it&#39;s</a>
          <a id="17822" class="Comment">-- *partial*. We can end up backtracking while subtracting.</a>
          <a id="17892" href="Meta.Reflection.HLevel.html#17892" class="Function">monus</a> <a id="17898" class="Symbol">:</a> <a id="17900" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="17905" class="Symbol">→</a> <a id="17907" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="17909" class="Symbol">→</a> <a id="17911" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="17914" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
          <a id="17929" href="Meta.Reflection.HLevel.html#17892" class="Function">monus</a> <a id="17935" class="Symbol">(</a><a id="17936" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="17940" class="Symbol">(</a><a id="17941" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="17945" href="Meta.Reflection.HLevel.html#17945" class="Bound">n</a><a id="17946" class="Symbol">))</a> <a id="17949" href="Meta.Reflection.HLevel.html#17949" class="Bound">k</a> <a id="17951" class="Symbol">=</a> <a id="17953" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="17958" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="17960" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="17964" class="Symbol">(</a><a id="17965" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="17969" class="Symbol">(</a><a id="17970" href="Meta.Reflection.HLevel.html#17945" class="Bound">n</a> <a id="17972" href="Agda.Builtin.Nat.html#426" class="Primitive Operator">-</a> <a id="17974" href="Meta.Reflection.HLevel.html#17949" class="Bound">k</a><a id="17975" class="Symbol">))</a>
          <a id="17988" href="Meta.Reflection.HLevel.html#17892" class="CatchallClause Function">monus</a><a id="17993" class="CatchallClause"> </a><a id="17994" href="Meta.Reflection.HLevel.html#17994" class="CatchallClause Bound">tm</a><a id="17996" class="CatchallClause"> </a><a id="17997" href="Agda.Builtin.Nat.html#221" class="CatchallClause InductiveConstructor">zero</a> <a id="18002" class="Symbol">=</a> <a id="18004" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18009" href="Meta.Reflection.HLevel.html#17994" class="Bound">tm</a>
          <a id="18022" href="Meta.Reflection.HLevel.html#17892" class="Function">monus</a> <a id="18028" href="Meta.Reflection.HLevel.html#18028" class="Bound">thezero</a><a id="18035" class="Symbol">@(</a><a id="18037" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18041" class="Symbol">(</a><a id="18042" class="Keyword">quote</a> <a id="18048" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="18052" class="Symbol">)</a> <a id="18054" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18056" class="Symbol">)</a> <a id="18058" class="Symbol">(</a><a id="18059" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18063" href="Meta.Reflection.HLevel.html#18063" class="Bound">it</a><a id="18065" class="Symbol">)</a> <a id="18067" class="Symbol">=</a> <a id="18069" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18074" href="Meta.Reflection.HLevel.html#18028" class="Bound">thezero</a>
          <a id="18092" href="Meta.Reflection.HLevel.html#17892" class="Function">monus</a> <a id="18098" class="Symbol">(</a><a id="18099" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18103" class="Symbol">(</a><a id="18104" class="Keyword">quote</a> <a id="18110" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="18113" class="Symbol">)</a> <a id="18115" class="Symbol">(</a><a id="18116" href="Meta.Reflection.HLevel.html#18116" class="Bound">x</a> <a id="18118" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="18121" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18123" class="Symbol">))</a> <a id="18126" class="Symbol">(</a><a id="18127" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18131" href="Meta.Reflection.HLevel.html#18131" class="Bound">it</a><a id="18133" class="Symbol">)</a> <a id="18135" class="Symbol">=</a> <a id="18137" class="Keyword">do</a>
            <a id="18152" href="Meta.Reflection.HLevel.html#18152" class="Bound">x</a> <a id="18154" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="18156" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="18163" href="Meta.Reflection.HLevel.html#18116" class="Bound">x</a>
            <a id="18177" href="Meta.Reflection.HLevel.html#17892" class="Function">monus</a> <a id="18183" href="Meta.Reflection.HLevel.html#18152" class="Bound">x</a> <a id="18185" href="Meta.Reflection.HLevel.html#18131" class="Bound">it</a>
          <a id="18198" href="Meta.Reflection.HLevel.html#17892" class="CatchallClause Function">monus</a><a id="18203" class="CatchallClause"> </a><a id="18204" href="Meta.Reflection.HLevel.html#18204" class="CatchallClause Bound">tm</a><a id="18206" class="CatchallClause"> </a><a id="18207" class="CatchallClause Symbol">(</a><a id="18208" href="Agda.Builtin.Nat.html#234" class="CatchallClause InductiveConstructor">suc</a><a id="18211" class="CatchallClause"> </a><a id="18212" href="Meta.Reflection.HLevel.html#18212" class="CatchallClause Bound">it</a><a id="18214" class="CatchallClause Symbol">)</a> <a id="18216" class="Symbol">=</a> <a id="18218" class="Keyword">do</a>
            <a id="18233" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="18244" class="String">&quot;tactic.hlevel&quot;</a> <a id="18260" class="Number">10</a> <a id="18263" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="18265" class="String">&quot;Dunno how to take 1 from &quot;</a> <a id="18293" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18295" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="18303" href="Meta.Reflection.HLevel.html#18204" class="Bound">tm</a> <a id="18306" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18308" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
            <a id="18323" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="18333" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="18343" class="Comment">-- Insert a metavariable, to be solved by Agda. It&#39;d be sad if the</a>
      <a id="18416" class="Comment">-- macro handled everything!</a>
      <a id="18451" class="Symbol">...</a> <a id="18455" class="Symbol">|</a> <a id="18457" href="Meta.Reflection.HLevel.html#3224" class="InductiveConstructor">`meta</a> <a id="18463" class="Symbol">=</a> <a id="18465" href="Meta.Reflection.HLevel.html#15532" class="Function">gen-args</a> <a id="18474" class="Bound">has-alts</a> <a id="18483" class="Bound">level</a> <a id="18489" class="Bound">defn</a> <a id="18494" class="Bound">args</a> <a id="18499" class="Symbol">(</a><a id="18500" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="18508" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="18511" class="Bound">accum</a><a id="18516" class="Symbol">)</a> <a id="18518" class="Bound">cont</a>

      <a id="18530" class="Symbol">...</a> <a id="18534" class="Symbol">|</a> <a id="18536" href="Meta.Reflection.HLevel.html#3021" class="InductiveConstructor">`search-under</a> <a id="18550" href="Meta.Reflection.HLevel.html#18550" class="Bound">under</a> <a id="18556" class="Symbol">=</a> <a id="18558" class="Keyword">do</a>
        <a id="18569" class="Comment">-- To search under some variables, we work in a scope extended</a>
        <a id="18640" class="Comment">-- by &#39;under&#39;-many variables. The metavariable lives in that</a>
        <a id="18709" class="Comment">-- scope, so we have to quantify over the variables we</a>
        <a id="18772" class="Comment">-- introduced to use it outside, i.e., in the actual (outer)</a>
        <a id="18841" class="Comment">-- search problem.</a>
        <a id="18868" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="18879" class="String">&quot;tactic.hlevel&quot;</a> <a id="18895" class="Number">10</a> <a id="18898" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="18900" class="String">&quot;Going under &quot;</a> <a id="18915" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18917" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="18925" class="Symbol">(</a><a id="18926" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="18930" class="Symbol">(</a><a id="18931" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18935" href="Meta.Reflection.HLevel.html#18550" class="Bound">under</a><a id="18940" class="Symbol">))</a> <a id="18943" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18945" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="18956" href="Meta.Reflection.HLevel.html#18956" class="Bound">gounder</a> <a id="18964" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="18966" href="Meta.Reflection.HLevel.html#14997" class="Function">extend-n</a> <a id="18975" href="Meta.Reflection.HLevel.html#18550" class="Bound">under</a>
        <a id="18989" href="Meta.Reflection.HLevel.html#18989" class="Bound">mv</a> <a id="18992" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="18994" href="Meta.Reflection.HLevel.html#18956" class="Bound">gounder</a> <a id="19002" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19007" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19009" class="Keyword">do</a>
          <a id="19022" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19033" class="String">&quot;tactic.hlevel&quot;</a> <a id="19049" class="Number">10</a> <a id="19052" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19054" class="String">&quot;In extended context&quot;</a>
          <a id="19086" href="Meta.Reflection.Base.html#1805" class="Function">new-meta</a> <a id="19095" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="19111" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19122" class="String">&quot;tactic.hlevel&quot;</a> <a id="19138" class="Number">10</a> <a id="19141" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19143" class="String">&quot;Metavariable: &quot;</a> <a id="19160" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19162" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="19170" class="Symbol">(</a><a id="19171" href="Meta.Reflection.HLevel.html#14757" class="Function">wrap-lams</a> <a id="19181" href="Meta.Reflection.HLevel.html#18550" class="Bound">under</a> <a id="19187" href="Meta.Reflection.HLevel.html#18989" class="Bound">mv</a><a id="19189" class="Symbol">)</a> <a id="19191" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19193" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="19204" class="Comment">-- After we&#39;ve put the mv wrapped under some lambdas in the</a>
        <a id="19272" class="Comment">-- argument list,</a>
        <a id="19298" href="Meta.Reflection.HLevel.html#15532" class="Function">gen-args</a> <a id="19307" class="Bound">has-alts</a> <a id="19316" class="Bound">level</a> <a id="19322" class="Bound">defn</a> <a id="19327" class="Bound">args</a> <a id="19332" class="Symbol">(</a><a id="19333" href="Meta.Reflection.HLevel.html#14757" class="Function">wrap-lams</a> <a id="19343" href="Meta.Reflection.HLevel.html#18550" class="Bound">under</a> <a id="19349" href="Meta.Reflection.HLevel.html#18989" class="Bound">mv</a> <a id="19352" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="19355" class="Bound">accum</a><a id="19360" class="Symbol">)</a> <a id="19362" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19364" class="Keyword">do</a>
          <a id="19377" class="Comment">-- On our way back up, we do any more searching that needed to</a>
          <a id="19450" class="Comment">-- get done, and..</a>
          <a id="19479" class="Bound">cont</a>
          <a id="19494" class="Comment">-- go back under the new scope to recursively search for</a>
          <a id="19561" class="Comment">-- levels.</a>
          <a id="19582" href="Meta.Reflection.HLevel.html#18956" class="Bound">gounder</a> <a id="19590" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="19592" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="19594" href="Meta.Reflection.HLevel.html#12487" class="Function">search</a> <a id="19601" class="Bound">has-alts</a> <a id="19610" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="19618" href="Meta.Reflection.HLevel.html#12773" class="Bound">n</a> <a id="19620" href="Meta.Reflection.HLevel.html#18989" class="Bound">mv</a>

      <a id="19630" class="Comment">-- Try all the candidate hints in order. This is a version of</a>
      <a id="19698" class="Comment">-- &#39;nondet&#39; which additionally threads whether we&#39;re looking at</a>
      <a id="19768" class="Comment">-- last alternative.</a>
      <a id="19795" href="Meta.Reflection.HLevel.html#19795" class="Function">use-decomp-hints</a> <a id="19812" class="Symbol">:</a> <a id="19814" class="Symbol">(</a><a id="19815" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19820" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="19822" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="19826" class="Symbol">)</a> <a id="19828" class="Symbol">→</a> <a id="19830" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19835" class="Symbol">→</a> <a id="19837" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="19842" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19847" class="Symbol">→</a> <a id="19849" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="19852" class="Symbol">(</a><a id="19853" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="19855" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="19857" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="19861" class="Symbol">)</a>
      <a id="19869" href="Meta.Reflection.HLevel.html#19795" class="Function">use-decomp-hints</a> <a id="19886" class="Symbol">(</a><a id="19887" href="Meta.Reflection.HLevel.html#19887" class="Bound">lv</a> <a id="19890" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="19892" href="Meta.Reflection.HLevel.html#19892" class="Bound">goal-ty</a><a id="19899" class="Symbol">)</a> <a id="19901" href="Meta.Reflection.HLevel.html#19901" class="Bound">solved</a> <a id="19908" class="Symbol">(</a><a id="19909" href="Meta.Reflection.HLevel.html#19909" class="Bound">c1</a> <a id="19912" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19914" href="Meta.Reflection.HLevel.html#19914" class="Bound">cs</a><a id="19916" class="Symbol">)</a> <a id="19918" class="Symbol">=</a> <a id="19920" class="Keyword">do</a>
        <a id="19931" href="Meta.Reflection.HLevel.html#19931" class="Bound">ty</a> <a id="19934" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="19936" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="19946" href="Meta.Reflection.HLevel.html#19909" class="Bound">c1</a>
        <a id="19957" href="Meta.Reflection.HLevel.html#19957" class="Bound">c1′</a> <a id="19961" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="19963" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="19970" href="Meta.Reflection.HLevel.html#19909" class="Bound">c1</a>
        <a id="19981" class="Symbol">(</a><a id="19982" href="Meta.Reflection.HLevel.html#14295" class="Function">remove-invisible</a> <a id="19999" href="Meta.Reflection.HLevel.html#19957" class="Bound">c1′</a> <a id="20003" href="Meta.Reflection.HLevel.html#19931" class="Bound">ty</a> <a id="20006" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="20010" class="Symbol">λ</a> <a id="20012" class="Keyword">where</a>

          <a id="20029" class="Comment">-- If we have an actual decomp constructor, then we can try</a>
          <a id="20099" class="Comment">-- using its argument specification to construct a little</a>
          <a id="20167" class="Comment">-- h-level lemma</a>
          <a id="20194" class="Symbol">(</a><a id="20195" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="20199" class="Symbol">(</a><a id="20200" class="Keyword">quote</a> <a id="20206" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a><a id="20212" class="Symbol">)</a> <a id="20214" class="Symbol">(_</a> <a id="20217" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20219" class="Symbol">_</a> <a id="20221" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20223" href="Meta.Reflection.HLevel.html#20223" class="Bound">nm</a> <a id="20226" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="20229" href="Meta.Reflection.HLevel.html#20229" class="Bound">argspec</a> <a id="20237" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="20240" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20242" class="Symbol">))</a> <a id="20245" class="Symbol">→</a> <a id="20247" class="Keyword">do</a>
            <a id="20262" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="20273" class="String">&quot;tactic.hlevel&quot;</a> <a id="20289" class="Number">10</a> <a id="20292" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
              <a id="20308" class="String">&quot;Using &quot;</a> <a id="20317" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20319" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20327" href="Meta.Reflection.HLevel.html#20223" class="Bound">nm</a> <a id="20330" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20332" class="String">&quot; decomposition for:\n  &quot;</a>
              <a id="20372" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20374" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20382" class="Symbol">(</a><a id="20383" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="20387" class="Symbol">(</a><a id="20388" class="Keyword">quote</a> <a id="20394" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a><a id="20406" class="Symbol">)</a> <a id="20408" class="Symbol">(</a><a id="20409" href="Meta.Reflection.HLevel.html#19887" class="Bound">lv</a> <a id="20412" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="20415" href="Meta.Reflection.HLevel.html#19892" class="Bound">goal-ty</a> <a id="20423" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="20426" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20428" class="Symbol">))</a> <a id="20431" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20433" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

            <a id="20449" href="Meta.Reflection.HLevel.html#20449" class="Bound">nm′</a> <a id="20453" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="20455" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20465" href="Meta.Reflection.HLevel.html#20223" class="Bound">nm</a>
            <a id="20480" href="Meta.Reflection.HLevel.html#20480" class="Bound">argsp</a> <a id="20486" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="20488" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20498" href="Meta.Reflection.HLevel.html#20229" class="Bound">argspec</a>
            <a id="20518" class="Comment">-- Generate the argument spine, and discard the instance</a>
            <a id="20587" class="Comment">-- search meta.</a>
            <a id="20615" href="Meta.Reflection.HLevel.html#15532" class="Function">gen-args</a> <a id="20624" class="Symbol">(</a><a id="20625" href="Data.Bool.Base.html#169" class="Function">not</a> <a id="20629" class="Symbol">(</a><a id="20630" href="Data.List.Operations.html#439" class="Function">length</a> <a id="20637" href="Meta.Reflection.HLevel.html#19914" class="Bound">cs</a> <a id="20640" href="Agda.Builtin.Nat.html#631" class="Primitive Operator">==</a> <a id="20643" class="Number">0</a><a id="20644" class="Symbol">))</a> <a id="20647" href="Meta.Reflection.HLevel.html#19887" class="Bound">lv</a> <a id="20650" href="Meta.Reflection.HLevel.html#20449" class="Bound">nm′</a> <a id="20654" href="Meta.Reflection.HLevel.html#20480" class="Bound">argsp</a> <a id="20660" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="20663" class="Symbol">(</a><a id="20664" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="20673" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="20675" class="Symbol">)</a>
            <a id="20689" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="20695" href="Meta.Reflection.HLevel.html#19901" class="Bound">solved</a> <a id="20702" href="Meta.Reflection.HLevel.html#19909" class="Bound">c1</a>

            <a id="20718" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="20723" class="Symbol">(</a><a id="20724" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="20727" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="20729" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="20733" class="Symbol">)</a>

          <a id="20746" class="Comment">-- It&#39;s possible that this particular hint was a bust, i.e.</a>
          <a id="20816" class="Comment">-- because someone wasn&#39;t being careful with what</a>
          <a id="20876" class="Comment">-- hlevel-decomposition instances they&#39;ve defined. That&#39;s no</a>
          <a id="20947" class="Comment">-- matter: we can just ignore it.</a>
          <a id="20991" class="CatchallClause Symbol">_</a> <a id="20993" class="Symbol">→</a> <a id="20995" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="21005" class="String">&quot;Non-canonical hint&quot;</a><a id="21025" class="Symbol">)</a>
          <a id="21037" class="Comment">-- If we didn&#39;t manage to get the hint to work, for any</a>
          <a id="21103" class="Comment">-- reason, try again with the rest of the hints.</a>
          <a id="21162" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a> <a id="21166" href="Meta.Reflection.HLevel.html#19795" class="Function">use-decomp-hints</a> <a id="21183" class="Symbol">(</a><a id="21184" href="Meta.Reflection.HLevel.html#19887" class="Bound">lv</a> <a id="21187" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21189" href="Meta.Reflection.HLevel.html#19892" class="Bound">goal-ty</a><a id="21196" class="Symbol">)</a> <a id="21198" href="Meta.Reflection.HLevel.html#19901" class="Bound">solved</a> <a id="21205" href="Meta.Reflection.HLevel.html#19914" class="Bound">cs</a>

      <a id="21215" href="Meta.Reflection.HLevel.html#19795" class="Function">use-decomp-hints</a> <a id="21232" class="Symbol">(_</a> <a id="21235" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21237" href="Meta.Reflection.HLevel.html#21237" class="Bound">goal-ty</a><a id="21244" class="Symbol">)</a> <a id="21246" class="Symbol">_</a> <a id="21248" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="21251" class="Symbol">=</a>
        <a id="21261" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="21271" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="21273" class="String">&quot;Ran out of decomposition hints for &quot;</a> <a id="21311" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21313" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="21321" href="Meta.Reflection.HLevel.html#21237" class="Bound">goal-ty</a> <a id="21329" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21331" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="21341" class="Comment">-- Using the hints involving querying Agda for potential</a>
      <a id="21404" class="Comment">-- instances, then trying each in order.</a>
      <a id="21451" href="Meta.Reflection.HLevel.html#21451" class="Function">use-hints</a> <a id="21461" class="Symbol">:</a> <a id="21463" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="21466" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="21474" href="Meta.Reflection.HLevel.html#21451" class="Function">use-hints</a> <a id="21484" class="Symbol">=</a> <a id="21486" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="21501" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="21503" class="Keyword">do</a>
        <a id="21514" class="Symbol">(</a><a id="21515" href="Meta.Reflection.HLevel.html#21515" class="Bound">lv</a> <a id="21518" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21520" href="Meta.Reflection.HLevel.html#21520" class="Bound">ty</a><a id="21522" class="Symbol">)</a> <a id="21524" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="21526" href="Meta.Reflection.HLevel.html#6325" class="Function">decompose-is-hlevel</a> <a id="21546" href="Meta.Reflection.HLevel.html#12776" class="Bound">goal</a>

        <a id="21560" class="Comment">-- Note that if the type here is a metavariable, the tactic is..</a>
        <a id="21633" class="Comment">-- loopy.</a>
        <a id="21651" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="21656" href="Meta.Reflection.HLevel.html#21520" class="Bound">ty</a> <a id="21659" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="21663" class="Symbol">λ</a> <a id="21665" class="Keyword">where</a>
          <a id="21681" class="Symbol">(</a><a id="21682" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="21687" href="Meta.Reflection.HLevel.html#21687" class="Bound">m</a> <a id="21689" class="Symbol">_)</a> <a id="21692" class="Symbol">→</a> <a id="21694" class="Keyword">do</a>
            <a id="21709" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="21720" class="String">&quot;tactic.hlevel&quot;</a> <a id="21736" class="Number">10</a>
              <a id="21753" class="String">&quot;Type under is-hlevel is metavariable, blocking to avoid infinite loop&quot;</a>
            <a id="21837" href="Agda.Builtin.Reflection.html#9468" class="Postulate">blockOnMeta</a> <a id="21849" href="Meta.Reflection.HLevel.html#21687" class="Bound">m</a>
          <a id="21861" class="CatchallClause Symbol">_</a> <a id="21863" class="Symbol">→</a> <a id="21865" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="21870" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>

        <a id="21882" class="Comment">-- Create a meta of type hlevel-decomposition to find any possible hints..</a>
        <a id="21965" href="Meta.Reflection.HLevel.html#21965" class="Bound">solved</a><a id="21971" class="Symbol">@(</a><a id="21973" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="21978" href="Meta.Reflection.HLevel.html#21978" class="Bound">mv</a> <a id="21981" class="Symbol">_)</a> <a id="21984" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="21986" href="Meta.Reflection.Base.html#1805" class="Function">new-meta</a> <a id="21995" class="Symbol">(</a><a id="21996" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="22000" class="Symbol">(</a><a id="22001" class="Keyword">quote</a> <a id="22007" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a><a id="22027" class="Symbol">)</a> <a id="22029" class="Symbol">(</a><a id="22030" href="Meta.Reflection.HLevel.html#21520" class="Bound">ty</a> <a id="22033" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="22036" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22038" class="Symbol">))</a>
          <a id="22051" class="Keyword">where</a> <a id="22057" class="CatchallClause Symbol">_</a> <a id="22059" class="Symbol">→</a> <a id="22061" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="22071" class="Symbol">(</a><a id="22072" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22080" href="Meta.Reflection.HLevel.html#21520" class="Bound">ty</a> <a id="22083" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22085" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22087" class="Symbol">)</a>
        <a id="22097" href="Meta.Reflection.HLevel.html#22097" class="Bound">instances</a> <a id="22107" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="22109" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="22122" href="Meta.Reflection.HLevel.html#21978" class="Bound">mv</a>

        <a id="22134" href="Meta.Reflection.HLevel.html#22134" class="Bound">t</a> <a id="22136" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="22138" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="22146" href="Meta.Reflection.HLevel.html#22097" class="Bound">instances</a>
        <a id="22164" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="22175" class="String">&quot;tactic.hlevel&quot;</a> <a id="22191" class="Number">10</a> <a id="22194" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
          <a id="22206" class="String">&quot;Finding decompositions for\n&quot;</a> <a id="22237" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22249" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22257" href="Meta.Reflection.HLevel.html#21520" class="Bound">ty</a> <a id="22260" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22272" class="String">&quot;\nFound candidates\n &quot;</a> <a id="22296" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22308" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22316" href="Meta.Reflection.HLevel.html#22134" class="Bound">t</a> <a id="22318" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22320" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="22332" class="Comment">-- And try using the hints.</a>
        <a id="22368" href="Meta.Reflection.HLevel.html#19795" class="Function">use-decomp-hints</a> <a id="22385" class="Symbol">(</a><a id="22386" href="Meta.Reflection.HLevel.html#21515" class="Bound">lv</a> <a id="22389" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22391" href="Meta.Reflection.HLevel.html#21520" class="Bound">ty</a><a id="22393" class="Symbol">)</a> <a id="22395" href="Meta.Reflection.HLevel.html#21965" class="Bound">solved</a> <a id="22402" href="Meta.Reflection.HLevel.html#22097" class="Bound">instances</a>

  <a id="22415" class="Comment">-- At the top-level, our goal doesn&#39;t need to have literally the type</a>
  <a id="22487" class="Comment">-- is-hlevel A n. It can be under any number of Πs, both implicit and</a>
  <a id="22559" class="Comment">-- explicit. This means that a goal like (∀ x → is-hlevel T n) can be</a>
  <a id="22631" class="Comment">-- solved using just hlevel!, rather than λ _ → hlevel!. Of course,</a>
  <a id="22701" class="Comment">-- the effect is the same.</a>
  <a id="decompose-is-hlevel-top"></a><a id="22730" href="Meta.Reflection.HLevel.html#22730" class="Function">decompose-is-hlevel-top</a>
    <a id="22758" class="Symbol">:</a> <a id="22760" class="Symbol">∀</a> <a id="22762" class="Symbol">{</a><a id="22763" href="Meta.Reflection.HLevel.html#22763" class="Bound">ℓ</a><a id="22764" class="Symbol">}</a> <a id="22766" class="Symbol">{</a><a id="22767" href="Meta.Reflection.HLevel.html#22767" class="Bound">A</a> <a id="22769" class="Symbol">:</a> <a id="22771" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="22776" href="Meta.Reflection.HLevel.html#22763" class="Bound">ℓ</a><a id="22777" class="Symbol">}</a>
    <a id="22783" class="Symbol">→</a> <a id="22785" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22790" class="Symbol">→</a> <a id="22792" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22795" class="Symbol">(</a><a id="22796" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22801" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22803" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22808" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22810" class="Symbol">(</a><a id="22811" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22814" href="Meta.Reflection.HLevel.html#22767" class="Bound">A</a> <a id="22816" class="Symbol">→</a> <a id="22818" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22821" href="Meta.Reflection.HLevel.html#22767" class="Bound">A</a><a id="22822" class="Symbol">)</a> <a id="22824" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22826" class="Symbol">(</a><a id="22827" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22832" class="Symbol">→</a> <a id="22834" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="22838" class="Symbol">))</a>
  <a id="22843" href="Meta.Reflection.HLevel.html#22730" class="Function">decompose-is-hlevel-top</a> <a id="22867" href="Meta.Reflection.HLevel.html#22867" class="Bound">goal</a> <a id="22872" class="Symbol">=</a>
    <a id="22878" class="Keyword">do</a>
      <a id="22887" href="Meta.Reflection.HLevel.html#22887" class="Bound">ty</a> <a id="22890" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="22892" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="22907" class="Symbol">(</a><a id="22908" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="22914" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22916" href="Meta.Reflection.HLevel.html#5799" class="Function">hlevel-types</a><a id="22928" class="Symbol">)</a> <a id="22930" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a>
        <a id="22940" class="Symbol">(</a><a id="22941" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="22951" href="Meta.Reflection.HLevel.html#22867" class="Bound">goal</a> <a id="22956" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="22960" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="22966" class="Symbol">)</a> <a id="22968" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="22972" href="Meta.Reflection.Base.html#4433" class="Function">wait-just-a-bit</a>
      <a id="22994" href="Meta.Reflection.HLevel.html#23016" class="Function">go</a> <a id="22997" href="Meta.Reflection.HLevel.html#22887" class="Bound">ty</a>
    <a id="23004" class="Keyword">where</a>
      <a id="23016" href="Meta.Reflection.HLevel.html#23016" class="Function">go</a> <a id="23019" class="Symbol">:</a> <a id="23021" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23026" class="Symbol">→</a> <a id="23028" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23031" class="Symbol">_</a>
      <a id="23039" href="Meta.Reflection.HLevel.html#23016" class="Function">go</a> <a id="23042" class="Symbol">(</a><a id="23043" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="23046" class="Symbol">(</a><a id="23047" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23051" href="Meta.Reflection.HLevel.html#23051" class="Bound">as</a> <a id="23054" href="Meta.Reflection.HLevel.html#23054" class="Bound">at</a><a id="23056" class="Symbol">)</a> <a id="23058" class="Symbol">(</a><a id="23059" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23063" href="Meta.Reflection.HLevel.html#23063" class="Bound">vn</a> <a id="23066" href="Meta.Reflection.HLevel.html#23066" class="Bound">cd</a><a id="23068" class="Symbol">))</a> <a id="23071" class="Symbol">=</a> <a id="23073" class="Keyword">do</a>
        <a id="23084" class="Symbol">(</a><a id="23085" href="Meta.Reflection.HLevel.html#23085" class="Bound">hlevel</a> <a id="23092" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23094" href="Meta.Reflection.HLevel.html#23094" class="Bound">inner</a> <a id="23100" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23102" href="Meta.Reflection.HLevel.html#23102" class="Bound">enter</a> <a id="23108" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23110" href="Meta.Reflection.HLevel.html#23110" class="Bound">leave</a><a id="23115" class="Symbol">)</a> <a id="23117" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="23119" href="Meta.Reflection.HLevel.html#23016" class="Function">go</a> <a id="23122" href="Meta.Reflection.HLevel.html#23066" class="Bound">cd</a>
        <a id="23133" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23138" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="23140" href="Meta.Reflection.HLevel.html#23085" class="Bound">hlevel</a> <a id="23147" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23149" href="Meta.Reflection.HLevel.html#23094" class="Bound">inner</a> <a id="23155" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23157" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="23171" href="Meta.Reflection.HLevel.html#23063" class="Bound">vn</a> <a id="23174" class="Symbol">(</a><a id="23175" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23179" href="Meta.Reflection.HLevel.html#23051" class="Bound">as</a> <a id="23182" href="Meta.Reflection.HLevel.html#23054" class="Bound">at</a><a id="23184" class="Symbol">)</a> <a id="23186" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23188" class="Symbol">λ</a> <a id="23190" href="Meta.Reflection.HLevel.html#23190" class="Bound">t</a> <a id="23192" class="Symbol">→</a> <a id="23194" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="23198" class="Symbol">(</a><a id="23199" href="Meta.Reflection.Base.html#1161" class="Function">arg-vis</a> <a id="23207" href="Meta.Reflection.HLevel.html#23051" class="Bound">as</a><a id="23209" class="Symbol">)</a> <a id="23211" class="Symbol">(</a><a id="23212" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23216" href="Meta.Reflection.HLevel.html#23063" class="Bound">vn</a> <a id="23219" href="Meta.Reflection.HLevel.html#23190" class="Bound">t</a><a id="23220" class="Symbol">)</a>
      <a id="23228" href="Meta.Reflection.HLevel.html#23016" class="CatchallClause Function">go</a><a id="23230" class="CatchallClause"> </a><a id="23231" href="Meta.Reflection.HLevel.html#23231" class="CatchallClause Bound">tm</a> <a id="23234" class="Symbol">=</a> <a id="23236" class="Keyword">do</a>
        <a id="23247" class="Symbol">(</a><a id="23248" href="Meta.Reflection.HLevel.html#23248" class="Bound">hlevel</a> <a id="23255" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23257" href="Meta.Reflection.HLevel.html#23257" class="Bound">inner</a><a id="23262" class="Symbol">)</a> <a id="23264" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="23266" href="Meta.Reflection.HLevel.html#6179" class="Function">decompose-is-hlevel′</a> <a id="23287" href="Meta.Reflection.HLevel.html#23231" class="Bound">tm</a>
        <a id="23298" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23303" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="23305" href="Meta.Reflection.HLevel.html#23248" class="Bound">hlevel</a> <a id="23312" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23314" href="Meta.Reflection.HLevel.html#23257" class="Bound">inner</a> <a id="23320" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23322" class="Symbol">(λ</a> <a id="23325" href="Meta.Reflection.HLevel.html#23325" class="Bound">x</a> <a id="23327" class="Symbol">→</a> <a id="23329" href="Meta.Reflection.HLevel.html#23325" class="Bound">x</a><a id="23330" class="Symbol">)</a> <a id="23332" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23334" class="Symbol">(λ</a> <a id="23337" href="Meta.Reflection.HLevel.html#23337" class="Bound">x</a> <a id="23339" class="Symbol">→</a> <a id="23341" href="Meta.Reflection.HLevel.html#23337" class="Bound">x</a><a id="23342" class="Symbol">)</a>

<a id="23345" class="Comment">-- This is public so it&#39;s usable in tactic attributes. It decomposes the</a>
<a id="23418" class="Comment">-- top-level goal type and enters the search loop.</a>
<a id="hlevel-tactic-worker"></a><a id="23469" href="Meta.Reflection.HLevel.html#23469" class="Function">hlevel-tactic-worker</a> <a id="23490" class="Symbol">:</a> <a id="23492" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23497" class="Symbol">→</a> <a id="23499" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23502" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="23504" href="Meta.Reflection.HLevel.html#23469" class="Function">hlevel-tactic-worker</a> <a id="23525" href="Meta.Reflection.HLevel.html#23525" class="Bound">goal</a> <a id="23530" class="Symbol">=</a> <a id="23532" class="Keyword">do</a>
  <a id="23537" href="Meta.Reflection.HLevel.html#23537" class="Bound">ty</a> <a id="23540" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="23542" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="23557" class="Symbol">(</a><a id="23558" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="23564" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23566" href="Meta.Reflection.HLevel.html#5799" class="Function">hlevel-types</a><a id="23578" class="Symbol">)</a> <a id="23580" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="23582" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="23592" href="Meta.Reflection.HLevel.html#23525" class="Bound">goal</a> <a id="23597" href="Meta.Bind.html#183" class="Field Operator">&gt;&gt;=</a> <a id="23601" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
  <a id="23610" class="Symbol">(</a><a id="23611" href="Meta.Reflection.HLevel.html#23611" class="Bound">lv</a> <a id="23614" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23616" href="Meta.Reflection.HLevel.html#23616" class="Bound">ty</a> <a id="23619" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23621" href="Meta.Reflection.HLevel.html#23621" class="Bound">enter</a> <a id="23627" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23629" href="Meta.Reflection.HLevel.html#23629" class="Bound">leave</a><a id="23634" class="Symbol">)</a> <a id="23636" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="23638" href="Meta.Reflection.HLevel.html#22730" class="Function">decompose-is-hlevel-top</a> <a id="23662" href="Meta.Reflection.HLevel.html#23525" class="Bound">goal</a> <a id="23667" href="Meta.Alt.html#307" class="Field Operator">&lt;|&gt;</a>
    <a id="23675" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a>
      <a id="23691" class="Symbol">(</a> <a id="23693" class="String">&quot;hlevel tactic: goal type is not of the form ``is-hlevel A n&#39;&#39;:\n&quot;</a>
      <a id="23766" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23768" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="23776" href="Meta.Reflection.HLevel.html#23537" class="Bound">ty</a>
      <a id="23785" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23787" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="23789" class="Symbol">)</a>

  <a id="23794" class="Comment">-- 10 units of fuel isn&#39;t too many but it&#39;s enough for any realistic</a>
  <a id="23865" class="Comment">-- use-case. Note the scope nonsense: we have to &#39;enter&#39; to get under</a>
  <a id="23937" class="Comment">-- the Πs (extend the scope with their argument types), then &#39;leave&#39;</a>
  <a id="24008" class="Comment">-- (wrap in lambdas) to get back out.</a>
  <a id="24048" href="Meta.Reflection.HLevel.html#24048" class="Bound">solved</a> <a id="24055" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="24057" href="Meta.Reflection.HLevel.html#23621" class="Bound">enter</a> <a id="24063" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="24065" class="Keyword">do</a>
    <a id="24072" href="Meta.Reflection.HLevel.html#24072" class="Bound">goal′</a> <a id="24078" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="24080" href="Meta.Reflection.Base.html#1805" class="Function">new-meta</a> <a id="24089" class="Symbol">(</a><a id="24090" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="24094" class="Symbol">(</a><a id="24095" class="Keyword">quote</a> <a id="24101" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a><a id="24113" class="Symbol">)</a> <a id="24115" class="Symbol">(</a><a id="24116" href="Meta.Reflection.HLevel.html#23611" class="Bound">lv</a> <a id="24119" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="24122" href="Meta.Reflection.HLevel.html#23616" class="Bound">ty</a> <a id="24125" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="24128" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="24130" class="Symbol">))</a>
    <a id="24137" href="Meta.Reflection.HLevel.html#12487" class="Function">search</a> <a id="24144" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="24150" href="Meta.Reflection.HLevel.html#23611" class="Bound">lv</a> <a id="24153" class="Number">10</a> <a id="24156" href="Meta.Reflection.HLevel.html#24072" class="Bound">goal′</a>
    <a id="24166" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="24171" href="Meta.Reflection.HLevel.html#24072" class="Bound">goal′</a>
  <a id="24179" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="24185" href="Meta.Reflection.HLevel.html#23525" class="Bound">goal</a> <a id="24190" class="Symbol">(</a><a id="24191" href="Meta.Reflection.HLevel.html#23629" class="Bound">leave</a> <a id="24197" href="Meta.Reflection.HLevel.html#24048" class="Bound">solved</a><a id="24203" class="Symbol">)</a>

<a id="24206" class="Comment">-- Entry points to the macro</a>
<a id="24235" class="Comment">----------------------------</a>
<a id="24264" class="Keyword">macro</a> <a id="hlevel!"></a><a id="24270" href="Meta.Reflection.HLevel.html#24270" class="Function">hlevel!</a> <a id="24278" class="Symbol">=</a> <a id="24280" href="Meta.Reflection.HLevel.html#23469" class="Function">hlevel-tactic-worker</a>

<a id="24302" class="Comment">-- In addition to using the macro as a.. well, macro, it can be used as</a>
<a id="24374" class="Comment">-- a tactic argument, to replace instance search by the more powerful</a>
<a id="24444" class="Comment">-- decomposition-projection mechanism of the tactic. We provide only</a>
<a id="24513" class="Comment">-- some of the most common helpers:</a>
<a id="el!"></a><a id="24549" href="Meta.Reflection.HLevel.html#24549" class="Function">el!</a> <a id="24553" class="Symbol">:</a> <a id="24555" class="Symbol">∀</a> <a id="24557" class="Symbol">{</a><a id="24558" href="Meta.Reflection.HLevel.html#24558" class="Bound">ℓ</a><a id="24559" class="Symbol">}</a> <a id="24561" class="Symbol">(</a><a id="24562" href="Meta.Reflection.HLevel.html#24562" class="Bound">A</a> <a id="24564" class="Symbol">:</a> <a id="24566" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="24571" href="Meta.Reflection.HLevel.html#24558" class="Bound">ℓ</a><a id="24572" class="Symbol">)</a> <a id="24574" class="Symbol">{</a><a id="24575" href="Meta.Reflection.HLevel.html#24575" class="Bound">n</a><a id="24576" class="Symbol">}</a> <a id="24578" class="Symbol">{@(</a><a id="24581" class="Keyword">tactic</a> <a id="24588" href="Meta.Reflection.HLevel.html#23469" class="Function">hlevel-tactic-worker</a><a id="24608" class="Symbol">)</a> <a id="24610" href="Meta.Reflection.HLevel.html#24610" class="Bound">hl</a> <a id="24613" class="Symbol">:</a> <a id="24615" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="24628" href="Meta.Reflection.HLevel.html#24575" class="Bound">n</a> <a id="24630" href="Meta.Reflection.HLevel.html#24562" class="Bound">A</a><a id="24631" class="Symbol">}</a> <a id="24633" class="Symbol">→</a> <a id="24635" href="Structures.n-Type.html#284" class="Record">n-Type</a> <a id="24642" href="Meta.Reflection.HLevel.html#24558" class="Bound">ℓ</a> <a id="24644" href="Meta.Reflection.HLevel.html#24575" class="Bound">n</a>
<a id="24646" href="Meta.Reflection.HLevel.html#24549" class="Function">el!</a> <a id="24650" href="Meta.Reflection.HLevel.html#24650" class="Bound">A</a> <a id="24652" class="Symbol">{</a><a id="24653" class="Argument">hl</a> <a id="24656" class="Symbol">=</a> <a id="24658" href="Meta.Reflection.HLevel.html#24658" class="Bound">hl</a><a id="24660" class="Symbol">}</a> <a id="24662" class="Symbol">.</a><a id="24663" href="Structures.n-Type.html#364" class="Field">typ</a> <a id="24667" class="Symbol">=</a> <a id="24669" href="Meta.Reflection.HLevel.html#24650" class="Bound">A</a>
<a id="24671" href="Meta.Reflection.HLevel.html#24549" class="Function">el!</a> <a id="24675" href="Meta.Reflection.HLevel.html#24675" class="Bound">A</a> <a id="24677" class="Symbol">{</a><a id="24678" class="Argument">hl</a> <a id="24681" class="Symbol">=</a> <a id="24683" href="Meta.Reflection.HLevel.html#24683" class="Bound">hl</a><a id="24685" class="Symbol">}</a> <a id="24687" class="Symbol">.</a><a id="24688" href="Structures.n-Type.html#383" class="Field">is-tr</a> <a id="24694" class="Symbol">=</a> <a id="24696" href="Meta.Reflection.HLevel.html#24683" class="Bound">hl</a>

<a id="prop-ext!"></a><a id="24700" href="Meta.Reflection.HLevel.html#24700" class="Function">prop-ext!</a>
  <a id="24712" class="Symbol">:</a> <a id="24714" class="Symbol">∀</a> <a id="24716" class="Symbol">{</a><a id="24717" href="Meta.Reflection.HLevel.html#24717" class="Bound">ℓ</a> <a id="24719" href="Meta.Reflection.HLevel.html#24719" class="Bound">ℓ′</a><a id="24721" class="Symbol">}</a> <a id="24723" class="Symbol">{</a><a id="24724" href="Meta.Reflection.HLevel.html#24724" class="Bound">A</a> <a id="24726" class="Symbol">:</a> <a id="24728" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="24733" href="Meta.Reflection.HLevel.html#24717" class="Bound">ℓ</a><a id="24734" class="Symbol">}</a> <a id="24736" class="Symbol">{</a><a id="24737" href="Meta.Reflection.HLevel.html#24737" class="Bound">B</a> <a id="24739" class="Symbol">:</a> <a id="24741" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="24746" href="Meta.Reflection.HLevel.html#24719" class="Bound">ℓ′</a><a id="24748" class="Symbol">}</a>
    <a id="24754" class="Symbol">{@(</a><a id="24757" class="Keyword">tactic</a> <a id="24764" href="Meta.Reflection.HLevel.html#23469" class="Function">hlevel-tactic-worker</a><a id="24784" class="Symbol">)</a> <a id="24786" href="Meta.Reflection.HLevel.html#24786" class="Bound">aprop</a> <a id="24792" class="Symbol">:</a> <a id="24794" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="24807" class="Number">1</a> <a id="24809" href="Meta.Reflection.HLevel.html#24724" class="Bound">A</a><a id="24810" class="Symbol">}</a>
    <a id="24816" class="Symbol">{@(</a><a id="24819" class="Keyword">tactic</a> <a id="24826" href="Meta.Reflection.HLevel.html#23469" class="Function">hlevel-tactic-worker</a><a id="24846" class="Symbol">)</a> <a id="24848" href="Meta.Reflection.HLevel.html#24848" class="Bound">bprop</a> <a id="24854" class="Symbol">:</a> <a id="24856" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="24869" class="Number">1</a> <a id="24871" href="Meta.Reflection.HLevel.html#24737" class="Bound">B</a><a id="24872" class="Symbol">}</a>
  <a id="24876" class="Symbol">→</a> <a id="24878" class="Symbol">(</a><a id="24879" href="Meta.Reflection.HLevel.html#24724" class="Bound">A</a> <a id="24881" class="Symbol">→</a> <a id="24883" href="Meta.Reflection.HLevel.html#24737" class="Bound">B</a><a id="24884" class="Symbol">)</a> <a id="24886" class="Symbol">→</a> <a id="24888" class="Symbol">(</a><a id="24889" href="Meta.Reflection.HLevel.html#24737" class="Bound">B</a> <a id="24891" class="Symbol">→</a> <a id="24893" href="Meta.Reflection.HLevel.html#24724" class="Bound">A</a><a id="24894" class="Symbol">)</a>
  <a id="24898" class="Symbol">→</a> <a id="24900" href="Meta.Reflection.HLevel.html#24724" class="Bound">A</a> <a id="24902" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="24904" href="Meta.Reflection.HLevel.html#24737" class="Bound">B</a>
<a id="24906" href="Meta.Reflection.HLevel.html#24700" class="Function">prop-ext!</a> <a id="24916" class="Symbol">{</a><a id="24917" class="Argument">aprop</a> <a id="24923" class="Symbol">=</a> <a id="24925" href="Meta.Reflection.HLevel.html#24925" class="Bound">aprop</a><a id="24930" class="Symbol">}</a> <a id="24932" class="Symbol">{</a><a id="24933" class="Argument">bprop</a> <a id="24939" class="Symbol">=</a> <a id="24941" href="Meta.Reflection.HLevel.html#24941" class="Bound">bprop</a><a id="24946" class="Symbol">}</a> <a id="24948" class="Symbol">=</a> <a id="24950" href="Foundations.Equiv.Properties.html#2518" class="Function">prop-extₑ</a> <a id="24960" href="Meta.Reflection.HLevel.html#24925" class="Bound">aprop</a> <a id="24966" href="Meta.Reflection.HLevel.html#24941" class="Bound">bprop</a>

<a id="Σ-prop-path!"></a><a id="24973" href="Meta.Reflection.HLevel.html#24973" class="Function">Σ-prop-path!</a>
  <a id="24988" class="Symbol">:</a> <a id="24990" class="Symbol">∀</a> <a id="24992" class="Symbol">{</a><a id="24993" href="Meta.Reflection.HLevel.html#24993" class="Bound">ℓ</a> <a id="24995" href="Meta.Reflection.HLevel.html#24995" class="Bound">ℓ′</a><a id="24997" class="Symbol">}</a> <a id="24999" class="Symbol">{</a><a id="25000" href="Meta.Reflection.HLevel.html#25000" class="Bound">A</a> <a id="25002" class="Symbol">:</a> <a id="25004" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25009" href="Meta.Reflection.HLevel.html#24993" class="Bound">ℓ</a><a id="25010" class="Symbol">}</a> <a id="25012" class="Symbol">{</a><a id="25013" href="Meta.Reflection.HLevel.html#25013" class="Bound">B</a> <a id="25015" class="Symbol">:</a> <a id="25017" href="Meta.Reflection.HLevel.html#25000" class="Bound">A</a> <a id="25019" class="Symbol">→</a> <a id="25021" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25026" href="Meta.Reflection.HLevel.html#24995" class="Bound">ℓ′</a><a id="25028" class="Symbol">}</a>
  <a id="25032" class="Symbol">→</a> <a id="25034" class="Symbol">{@(</a><a id="25037" class="Keyword">tactic</a> <a id="25044" href="Meta.Reflection.HLevel.html#23469" class="Function">hlevel-tactic-worker</a><a id="25064" class="Symbol">)</a> <a id="25066" href="Meta.Reflection.HLevel.html#25066" class="Bound">bxprop</a> <a id="25073" class="Symbol">:</a> <a id="25075" class="Symbol">∀</a> <a id="25077" href="Meta.Reflection.HLevel.html#25077" class="Bound">x</a> <a id="25079" class="Symbol">→</a> <a id="25081" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="25094" class="Number">1</a> <a id="25096" class="Symbol">(</a><a id="25097" href="Meta.Reflection.HLevel.html#25013" class="Bound">B</a> <a id="25099" href="Meta.Reflection.HLevel.html#25077" class="Bound">x</a><a id="25100" class="Symbol">)}</a>
  <a id="25105" class="Symbol">→</a> <a id="25107" class="Symbol">{</a><a id="25108" href="Meta.Reflection.HLevel.html#25108" class="Bound">x</a> <a id="25110" href="Meta.Reflection.HLevel.html#25110" class="Bound">y</a> <a id="25112" class="Symbol">:</a> <a id="25114" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="25116" href="Meta.Reflection.HLevel.html#25000" class="Bound">A</a> <a id="25118" href="Meta.Reflection.HLevel.html#25013" class="Bound">B</a><a id="25119" class="Symbol">}</a>
  <a id="25123" class="Symbol">→</a> <a id="25125" href="Meta.Reflection.HLevel.html#25108" class="Bound">x</a> <a id="25127" class="Symbol">.</a><a id="25128" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="25132" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25134" href="Meta.Reflection.HLevel.html#25110" class="Bound">y</a> <a id="25136" class="Symbol">.</a><a id="25137" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>
  <a id="25143" class="Symbol">→</a> <a id="25145" href="Meta.Reflection.HLevel.html#25108" class="Bound">x</a> <a id="25147" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25149" href="Meta.Reflection.HLevel.html#25110" class="Bound">y</a>
<a id="25151" href="Meta.Reflection.HLevel.html#24973" class="Function">Σ-prop-path!</a> <a id="25164" class="Symbol">{</a><a id="25165" class="Argument">bxprop</a> <a id="25172" class="Symbol">=</a> <a id="25174" href="Meta.Reflection.HLevel.html#25174" class="Bound">bxprop</a><a id="25180" class="Symbol">}</a> <a id="25182" class="Symbol">=</a> <a id="25184" href="Foundations.Sigma.Properties.html#3636" class="Function">Σ-prop-path</a> <a id="25196" href="Meta.Reflection.HLevel.html#25174" class="Bound">bxprop</a>

<a id="prop!"></a><a id="25204" href="Meta.Reflection.HLevel.html#25204" class="Function">prop!</a>
  <a id="25212" class="Symbol">:</a> <a id="25214" class="Symbol">∀</a> <a id="25216" class="Symbol">{</a><a id="25217" href="Meta.Reflection.HLevel.html#25217" class="Bound">ℓ</a><a id="25218" class="Symbol">}</a> <a id="25220" class="Symbol">{</a><a id="25221" href="Meta.Reflection.HLevel.html#25221" class="Bound">A</a> <a id="25223" class="Symbol">:</a> <a id="25225" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="25227" class="Symbol">→</a> <a id="25229" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25234" href="Meta.Reflection.HLevel.html#25217" class="Bound">ℓ</a><a id="25235" class="Symbol">}</a> <a id="25237" class="Symbol">{@(</a><a id="25240" class="Keyword">tactic</a> <a id="25247" href="Meta.Reflection.HLevel.html#23469" class="Function">hlevel-tactic-worker</a><a id="25267" class="Symbol">)</a> <a id="25269" href="Meta.Reflection.HLevel.html#25269" class="Bound">aip</a> <a id="25273" class="Symbol">:</a> <a id="25275" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="25288" class="Number">1</a> <a id="25290" class="Symbol">(</a><a id="25291" href="Meta.Reflection.HLevel.html#25221" class="Bound">A</a> <a id="25293" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25295" class="Symbol">)}</a>
  <a id="25300" class="Symbol">→</a> <a id="25302" class="Symbol">{</a><a id="25303" href="Meta.Reflection.HLevel.html#25303" class="Bound">x</a> <a id="25305" class="Symbol">:</a> <a id="25307" href="Meta.Reflection.HLevel.html#25221" class="Bound">A</a> <a id="25309" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25311" class="Symbol">}</a> <a id="25313" class="Symbol">{</a><a id="25314" href="Meta.Reflection.HLevel.html#25314" class="Bound">y</a> <a id="25316" class="Symbol">:</a> <a id="25318" href="Meta.Reflection.HLevel.html#25221" class="Bound">A</a> <a id="25320" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="25322" class="Symbol">}</a>
  <a id="25326" class="Symbol">→</a> <a id="25328" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="25334" class="Symbol">(λ</a> <a id="25337" href="Meta.Reflection.HLevel.html#25337" class="Bound">i</a> <a id="25339" class="Symbol">→</a> <a id="25341" href="Meta.Reflection.HLevel.html#25221" class="Bound">A</a> <a id="25343" href="Meta.Reflection.HLevel.html#25337" class="Bound">i</a><a id="25344" class="Symbol">)</a> <a id="25346" href="Meta.Reflection.HLevel.html#25303" class="Bound">x</a> <a id="25348" href="Meta.Reflection.HLevel.html#25314" class="Bound">y</a>
<a id="25350" href="Meta.Reflection.HLevel.html#25204" class="Function">prop!</a> <a id="25356" class="Symbol">{</a><a id="25357" class="Argument">A</a> <a id="25359" class="Symbol">=</a> <a id="25361" href="Meta.Reflection.HLevel.html#25361" class="Bound">A</a><a id="25362" class="Symbol">}</a> <a id="25364" class="Symbol">{</a><a id="25365" class="Argument">aip</a> <a id="25369" class="Symbol">=</a> <a id="25371" href="Meta.Reflection.HLevel.html#25371" class="Bound">aip</a><a id="25374" class="Symbol">}</a> <a id="25376" class="Symbol">{</a><a id="25377" href="Meta.Reflection.HLevel.html#25377" class="Bound">x</a><a id="25378" class="Symbol">}</a> <a id="25380" class="Symbol">{</a><a id="25381" href="Meta.Reflection.HLevel.html#25381" class="Bound">y</a><a id="25382" class="Symbol">}</a> <a id="25384" class="Symbol">=</a>
  <a id="25388" href="Foundations.HLevel.Base.html#1139" class="Function">is-prop→PathP</a> <a id="25402" class="Symbol">(λ</a> <a id="25405" href="Meta.Reflection.HLevel.html#25405" class="Bound">i</a> <a id="25407" class="Symbol">→</a> <a id="25409" href="Foundations.Base.html#17139" class="Function">coe0→i</a> <a id="25416" class="Symbol">(λ</a> <a id="25419" href="Meta.Reflection.HLevel.html#25419" class="Bound">j</a> <a id="25421" class="Symbol">→</a> <a id="25423" href="Foundations.Base.html#12784" class="Function">is-prop</a> <a id="25431" class="Symbol">(</a><a id="25432" href="Meta.Reflection.HLevel.html#25361" class="Bound">A</a> <a id="25434" href="Meta.Reflection.HLevel.html#25419" class="Bound">j</a><a id="25435" class="Symbol">))</a> <a id="25438" href="Meta.Reflection.HLevel.html#25405" class="Bound">i</a> <a id="25440" href="Meta.Reflection.HLevel.html#25371" class="Bound">aip</a><a id="25443" class="Symbol">)</a> <a id="25445" href="Meta.Reflection.HLevel.html#25377" class="Bound">x</a> <a id="25447" href="Meta.Reflection.HLevel.html#25381" class="Bound">y</a>

<a id="25450" class="Keyword">open</a> <a id="25455" href="Meta.Reflection.HLevel.html#4037" class="Module">hlevel-projection</a>

<a id="25474" class="Comment">-- Hint database bootstrap</a>
<a id="25501" class="Comment">--------------------------</a>
<a id="25528" class="Comment">-- This instance block contains most of the decompositions we have</a>
<a id="25595" class="Comment">-- defined in the dependencies of this module.</a>

<a id="25643" class="Keyword">instance</a>
  <a id="decomp-lift"></a><a id="25654" href="Meta.Reflection.HLevel.html#25654" class="Function">decomp-lift</a> <a id="25666" class="Symbol">:</a> <a id="25668" class="Symbol">∀</a> <a id="25670" class="Symbol">{</a><a id="25671" href="Meta.Reflection.HLevel.html#25671" class="Bound">ℓ</a> <a id="25673" href="Meta.Reflection.HLevel.html#25673" class="Bound">ℓ′</a><a id="25675" class="Symbol">}</a> <a id="25677" class="Symbol">{</a><a id="25678" href="Meta.Reflection.HLevel.html#25678" class="Bound">T</a> <a id="25680" class="Symbol">:</a> <a id="25682" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25687" href="Meta.Reflection.HLevel.html#25671" class="Bound">ℓ</a><a id="25688" class="Symbol">}</a> <a id="25690" class="Symbol">→</a> <a id="25692" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="25713" class="Symbol">(</a><a id="25714" href="Foundations.Prim.Type.html#538" class="Record">Lift</a> <a id="25719" href="Meta.Reflection.HLevel.html#25673" class="Bound">ℓ′</a> <a id="25722" href="Meta.Reflection.HLevel.html#25678" class="Bound">T</a><a id="25723" class="Symbol">)</a>
  <a id="25727" href="Meta.Reflection.HLevel.html#25654" class="Function">decomp-lift</a> <a id="25739" class="Symbol">=</a> <a id="25741" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="25748" class="Symbol">(</a><a id="25749" class="Keyword">quote</a> <a id="25755" href="Foundations.HLevel.Retracts.html#5051" class="Function">Lift-is-of-hlevel</a><a id="25772" class="Symbol">)</a> <a id="25774" class="Symbol">(</a><a id="25775" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="25782" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="25784" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="25792" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="25794" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="25796" class="Symbol">)</a>

  <a id="25801" class="Comment">-- -- Non-dependent Π and Σ for readability first:</a>

  <a id="decomp-fun"></a><a id="25855" href="Meta.Reflection.HLevel.html#25855" class="Function">decomp-fun</a> <a id="25866" class="Symbol">:</a> <a id="25868" class="Symbol">∀</a> <a id="25870" class="Symbol">{</a><a id="25871" href="Meta.Reflection.HLevel.html#25871" class="Bound">ℓ</a> <a id="25873" href="Meta.Reflection.HLevel.html#25873" class="Bound">ℓ′</a><a id="25875" class="Symbol">}</a> <a id="25877" class="Symbol">{</a><a id="25878" href="Meta.Reflection.HLevel.html#25878" class="Bound">A</a> <a id="25880" class="Symbol">:</a> <a id="25882" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25887" href="Meta.Reflection.HLevel.html#25871" class="Bound">ℓ</a><a id="25888" class="Symbol">}</a> <a id="25890" class="Symbol">{</a><a id="25891" href="Meta.Reflection.HLevel.html#25891" class="Bound">B</a> <a id="25893" class="Symbol">:</a> <a id="25895" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="25900" href="Meta.Reflection.HLevel.html#25873" class="Bound">ℓ′</a><a id="25902" class="Symbol">}</a> <a id="25904" class="Symbol">→</a> <a id="25906" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="25927" class="Symbol">(</a><a id="25928" href="Meta.Reflection.HLevel.html#25878" class="Bound">A</a> <a id="25930" class="Symbol">→</a> <a id="25932" href="Meta.Reflection.HLevel.html#25891" class="Bound">B</a><a id="25933" class="Symbol">)</a>
  <a id="25937" href="Meta.Reflection.HLevel.html#25855" class="Function">decomp-fun</a> <a id="25948" class="Symbol">=</a> <a id="25950" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="25957" class="Symbol">(</a><a id="25958" class="Keyword">quote</a> <a id="25964" href="Foundations.HLevel.Retracts.html#4002" class="Function">fun-is-of-hlevel</a><a id="25980" class="Symbol">)</a> <a id="25982" class="Symbol">(</a><a id="25983" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="25990" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="25992" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="26000" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26002" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26004" class="Symbol">)</a>

  <a id="decomp-prod"></a><a id="26009" href="Meta.Reflection.HLevel.html#26009" class="Function">decomp-prod</a> <a id="26021" class="Symbol">:</a> <a id="26023" class="Symbol">∀</a> <a id="26025" class="Symbol">{</a><a id="26026" href="Meta.Reflection.HLevel.html#26026" class="Bound">ℓ</a> <a id="26028" href="Meta.Reflection.HLevel.html#26028" class="Bound">ℓ′</a><a id="26030" class="Symbol">}</a> <a id="26032" class="Symbol">{</a><a id="26033" href="Meta.Reflection.HLevel.html#26033" class="Bound">A</a> <a id="26035" class="Symbol">:</a> <a id="26037" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26042" href="Meta.Reflection.HLevel.html#26026" class="Bound">ℓ</a><a id="26043" class="Symbol">}</a> <a id="26045" class="Symbol">{</a><a id="26046" href="Meta.Reflection.HLevel.html#26046" class="Bound">B</a> <a id="26048" class="Symbol">:</a> <a id="26050" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26055" href="Meta.Reflection.HLevel.html#26028" class="Bound">ℓ′</a><a id="26057" class="Symbol">}</a> <a id="26059" class="Symbol">→</a> <a id="26061" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="26082" class="Symbol">(</a><a id="26083" href="Meta.Reflection.HLevel.html#26033" class="Bound">A</a> <a id="26085" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="26087" href="Meta.Reflection.HLevel.html#26046" class="Bound">B</a><a id="26088" class="Symbol">)</a>
  <a id="26092" href="Meta.Reflection.HLevel.html#26009" class="Function">decomp-prod</a> <a id="26104" class="Symbol">=</a> <a id="26106" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="26113" class="Symbol">(</a><a id="26114" class="Keyword">quote</a> <a id="26120" href="Foundations.HLevel.Retracts.html#4836" class="Function">×-is-of-hlevel</a><a id="26134" class="Symbol">)</a> <a id="26136" class="Symbol">(</a><a id="26137" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="26144" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26146" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="26154" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26156" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="26164" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26166" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26168" class="Symbol">)</a>

  <a id="26173" class="Comment">-- Dependent type formers:</a>
  <a id="decomp-pi³"></a><a id="26202" href="Meta.Reflection.HLevel.html#26202" class="Function">decomp-pi³</a>
    <a id="26217" class="Symbol">:</a> <a id="26219" class="Symbol">∀</a> <a id="26221" class="Symbol">{</a><a id="26222" href="Meta.Reflection.HLevel.html#26222" class="Bound">ℓa</a> <a id="26225" href="Meta.Reflection.HLevel.html#26225" class="Bound">ℓb</a> <a id="26228" href="Meta.Reflection.HLevel.html#26228" class="Bound">ℓc</a> <a id="26231" href="Meta.Reflection.HLevel.html#26231" class="Bound">ℓd</a><a id="26233" class="Symbol">}</a> <a id="26235" class="Symbol">{</a><a id="26236" href="Meta.Reflection.HLevel.html#26236" class="Bound">A</a> <a id="26238" class="Symbol">:</a> <a id="26240" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26245" href="Meta.Reflection.HLevel.html#26222" class="Bound">ℓa</a><a id="26247" class="Symbol">}</a> <a id="26249" class="Symbol">{</a><a id="26250" href="Meta.Reflection.HLevel.html#26250" class="Bound">B</a> <a id="26252" class="Symbol">:</a> <a id="26254" href="Meta.Reflection.HLevel.html#26236" class="Bound">A</a> <a id="26256" class="Symbol">→</a> <a id="26258" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26263" href="Meta.Reflection.HLevel.html#26225" class="Bound">ℓb</a><a id="26265" class="Symbol">}</a> <a id="26267" class="Symbol">{</a><a id="26268" href="Meta.Reflection.HLevel.html#26268" class="Bound">C</a> <a id="26270" class="Symbol">:</a> <a id="26272" class="Symbol">∀</a> <a id="26274" href="Meta.Reflection.HLevel.html#26274" class="Bound">x</a> <a id="26276" class="Symbol">(</a><a id="26277" href="Meta.Reflection.HLevel.html#26277" class="Bound">y</a> <a id="26279" class="Symbol">:</a> <a id="26281" href="Meta.Reflection.HLevel.html#26250" class="Bound">B</a> <a id="26283" href="Meta.Reflection.HLevel.html#26274" class="Bound">x</a><a id="26284" class="Symbol">)</a> <a id="26286" class="Symbol">→</a> <a id="26288" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26293" href="Meta.Reflection.HLevel.html#26228" class="Bound">ℓc</a><a id="26295" class="Symbol">}</a>
    <a id="26301" class="Symbol">→</a> <a id="26303" class="Symbol">{</a><a id="26304" href="Meta.Reflection.HLevel.html#26304" class="Bound">D</a> <a id="26306" class="Symbol">:</a> <a id="26308" class="Symbol">∀</a> <a id="26310" href="Meta.Reflection.HLevel.html#26310" class="Bound">x</a> <a id="26312" href="Meta.Reflection.HLevel.html#26312" class="Bound">y</a> <a id="26314" class="Symbol">(</a><a id="26315" href="Meta.Reflection.HLevel.html#26315" class="Bound">z</a> <a id="26317" class="Symbol">:</a> <a id="26319" href="Meta.Reflection.HLevel.html#26268" class="Bound">C</a> <a id="26321" href="Meta.Reflection.HLevel.html#26310" class="Bound">x</a> <a id="26323" href="Meta.Reflection.HLevel.html#26312" class="Bound">y</a><a id="26324" class="Symbol">)</a> <a id="26326" class="Symbol">→</a> <a id="26328" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26333" href="Meta.Reflection.HLevel.html#26231" class="Bound">ℓd</a><a id="26335" class="Symbol">}</a>
    <a id="26341" class="Symbol">→</a> <a id="26343" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="26364" class="Symbol">(∀</a> <a id="26367" href="Meta.Reflection.HLevel.html#26367" class="Bound">a</a> <a id="26369" href="Meta.Reflection.HLevel.html#26369" class="Bound">b</a> <a id="26371" href="Meta.Reflection.HLevel.html#26371" class="Bound">c</a> <a id="26373" class="Symbol">→</a> <a id="26375" href="Meta.Reflection.HLevel.html#26304" class="Bound">D</a> <a id="26377" href="Meta.Reflection.HLevel.html#26367" class="Bound">a</a> <a id="26379" href="Meta.Reflection.HLevel.html#26369" class="Bound">b</a> <a id="26381" href="Meta.Reflection.HLevel.html#26371" class="Bound">c</a><a id="26382" class="Symbol">)</a>
  <a id="26386" href="Meta.Reflection.HLevel.html#26202" class="Function">decomp-pi³</a> <a id="26397" class="Symbol">=</a> <a id="26399" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="26406" class="Symbol">(</a><a id="26407" class="Keyword">quote</a> <a id="26413" href="Foundations.HLevel.Retracts.html#3717" class="Function">Π₃-is-of-hlevel</a><a id="26428" class="Symbol">)</a> <a id="26430" class="Symbol">(</a><a id="26431" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="26438" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26440" href="Meta.Reflection.HLevel.html#3021" class="InductiveConstructor">`search-under</a> <a id="26454" class="Number">3</a> <a id="26456" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26458" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26460" class="Symbol">)</a>

  <a id="decomp-pi²"></a><a id="26465" href="Meta.Reflection.HLevel.html#26465" class="Function">decomp-pi²</a>
    <a id="26480" class="Symbol">:</a> <a id="26482" class="Symbol">∀</a> <a id="26484" class="Symbol">{</a><a id="26485" href="Meta.Reflection.HLevel.html#26485" class="Bound">ℓa</a> <a id="26488" href="Meta.Reflection.HLevel.html#26488" class="Bound">ℓb</a> <a id="26491" href="Meta.Reflection.HLevel.html#26491" class="Bound">ℓc</a><a id="26493" class="Symbol">}</a> <a id="26495" class="Symbol">{</a><a id="26496" href="Meta.Reflection.HLevel.html#26496" class="Bound">A</a> <a id="26498" class="Symbol">:</a> <a id="26500" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26505" href="Meta.Reflection.HLevel.html#26485" class="Bound">ℓa</a><a id="26507" class="Symbol">}</a> <a id="26509" class="Symbol">{</a><a id="26510" href="Meta.Reflection.HLevel.html#26510" class="Bound">B</a> <a id="26512" class="Symbol">:</a> <a id="26514" href="Meta.Reflection.HLevel.html#26496" class="Bound">A</a> <a id="26516" class="Symbol">→</a> <a id="26518" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26523" href="Meta.Reflection.HLevel.html#26488" class="Bound">ℓb</a><a id="26525" class="Symbol">}</a> <a id="26527" class="Symbol">{</a><a id="26528" href="Meta.Reflection.HLevel.html#26528" class="Bound">C</a> <a id="26530" class="Symbol">:</a> <a id="26532" class="Symbol">∀</a> <a id="26534" href="Meta.Reflection.HLevel.html#26534" class="Bound">x</a> <a id="26536" class="Symbol">(</a><a id="26537" href="Meta.Reflection.HLevel.html#26537" class="Bound">y</a> <a id="26539" class="Symbol">:</a> <a id="26541" href="Meta.Reflection.HLevel.html#26510" class="Bound">B</a> <a id="26543" href="Meta.Reflection.HLevel.html#26534" class="Bound">x</a><a id="26544" class="Symbol">)</a> <a id="26546" class="Symbol">→</a> <a id="26548" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26553" href="Meta.Reflection.HLevel.html#26491" class="Bound">ℓc</a><a id="26555" class="Symbol">}</a>
    <a id="26561" class="Symbol">→</a> <a id="26563" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="26584" class="Symbol">(∀</a> <a id="26587" href="Meta.Reflection.HLevel.html#26587" class="Bound">a</a> <a id="26589" href="Meta.Reflection.HLevel.html#26589" class="Bound">b</a> <a id="26591" class="Symbol">→</a> <a id="26593" href="Meta.Reflection.HLevel.html#26528" class="Bound">C</a> <a id="26595" href="Meta.Reflection.HLevel.html#26587" class="Bound">a</a> <a id="26597" href="Meta.Reflection.HLevel.html#26589" class="Bound">b</a><a id="26598" class="Symbol">)</a>
  <a id="26602" href="Meta.Reflection.HLevel.html#26465" class="Function">decomp-pi²</a> <a id="26613" class="Symbol">=</a> <a id="26615" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="26622" class="Symbol">(</a><a id="26623" class="Keyword">quote</a> <a id="26629" href="Foundations.HLevel.Retracts.html#3481" class="Function">Π₂-is-of-hlevel</a><a id="26644" class="Symbol">)</a> <a id="26646" class="Symbol">(</a><a id="26647" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="26654" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26656" href="Meta.Reflection.HLevel.html#3021" class="InductiveConstructor">`search-under</a> <a id="26670" class="Number">2</a> <a id="26672" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26674" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26676" class="Symbol">)</a>

  <a id="decomp-pi"></a><a id="26681" href="Meta.Reflection.HLevel.html#26681" class="Function">decomp-pi</a> <a id="26691" class="Symbol">:</a> <a id="26693" class="Symbol">∀</a> <a id="26695" class="Symbol">{</a><a id="26696" href="Meta.Reflection.HLevel.html#26696" class="Bound">ℓ</a> <a id="26698" href="Meta.Reflection.HLevel.html#26698" class="Bound">ℓ′</a><a id="26700" class="Symbol">}</a> <a id="26702" class="Symbol">{</a><a id="26703" href="Meta.Reflection.HLevel.html#26703" class="Bound">A</a> <a id="26705" class="Symbol">:</a> <a id="26707" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26712" href="Meta.Reflection.HLevel.html#26696" class="Bound">ℓ</a><a id="26713" class="Symbol">}</a> <a id="26715" class="Symbol">{</a><a id="26716" href="Meta.Reflection.HLevel.html#26716" class="Bound">B</a> <a id="26718" class="Symbol">:</a> <a id="26720" href="Meta.Reflection.HLevel.html#26703" class="Bound">A</a> <a id="26722" class="Symbol">→</a> <a id="26724" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26729" href="Meta.Reflection.HLevel.html#26698" class="Bound">ℓ′</a><a id="26731" class="Symbol">}</a> <a id="26733" class="Symbol">→</a> <a id="26735" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="26756" class="Symbol">(∀</a> <a id="26759" href="Meta.Reflection.HLevel.html#26759" class="Bound">a</a> <a id="26761" class="Symbol">→</a> <a id="26763" href="Meta.Reflection.HLevel.html#26716" class="Bound">B</a> <a id="26765" href="Meta.Reflection.HLevel.html#26759" class="Bound">a</a><a id="26766" class="Symbol">)</a>
  <a id="26770" href="Meta.Reflection.HLevel.html#26681" class="Function">decomp-pi</a> <a id="26780" class="Symbol">=</a> <a id="26782" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="26789" class="Symbol">(</a><a id="26790" class="Keyword">quote</a> <a id="26796" href="Foundations.HLevel.Retracts.html#2744" class="Function">Π-is-of-hlevel</a><a id="26810" class="Symbol">)</a> <a id="26812" class="Symbol">(</a><a id="26813" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="26820" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26822" href="Meta.Reflection.HLevel.html#3021" class="InductiveConstructor">`search-under</a> <a id="26836" class="Number">1</a> <a id="26838" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26840" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26842" class="Symbol">)</a>

  <a id="decomp-impl-pi"></a><a id="26847" href="Meta.Reflection.HLevel.html#26847" class="Function">decomp-impl-pi</a> <a id="26862" class="Symbol">:</a> <a id="26864" class="Symbol">∀</a> <a id="26866" class="Symbol">{</a><a id="26867" href="Meta.Reflection.HLevel.html#26867" class="Bound">ℓ</a> <a id="26869" href="Meta.Reflection.HLevel.html#26869" class="Bound">ℓ′</a><a id="26871" class="Symbol">}</a> <a id="26873" class="Symbol">{</a><a id="26874" href="Meta.Reflection.HLevel.html#26874" class="Bound">A</a> <a id="26876" class="Symbol">:</a> <a id="26878" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26883" href="Meta.Reflection.HLevel.html#26867" class="Bound">ℓ</a><a id="26884" class="Symbol">}</a> <a id="26886" class="Symbol">{</a><a id="26887" href="Meta.Reflection.HLevel.html#26887" class="Bound">B</a> <a id="26889" class="Symbol">:</a> <a id="26891" href="Meta.Reflection.HLevel.html#26874" class="Bound">A</a> <a id="26893" class="Symbol">→</a> <a id="26895" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="26900" href="Meta.Reflection.HLevel.html#26869" class="Bound">ℓ′</a><a id="26902" class="Symbol">}</a> <a id="26904" class="Symbol">→</a> <a id="26906" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="26927" class="Symbol">(∀</a> <a id="26930" class="Symbol">{</a><a id="26931" href="Meta.Reflection.HLevel.html#26931" class="Bound">a</a><a id="26932" class="Symbol">}</a> <a id="26934" class="Symbol">→</a> <a id="26936" href="Meta.Reflection.HLevel.html#26887" class="Bound">B</a> <a id="26938" href="Meta.Reflection.HLevel.html#26931" class="Bound">a</a><a id="26939" class="Symbol">)</a>
  <a id="26943" href="Meta.Reflection.HLevel.html#26847" class="Function">decomp-impl-pi</a> <a id="26958" class="Symbol">=</a> <a id="26960" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="26967" class="Symbol">(</a><a id="26968" class="Keyword">quote</a> <a id="26974" href="Foundations.HLevel.Retracts.html#3178" class="Function">Π-is-of-hlevel-implicit</a><a id="26997" class="Symbol">)</a> <a id="26999" class="Symbol">(</a><a id="27000" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="27007" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27009" href="Meta.Reflection.HLevel.html#3021" class="InductiveConstructor">`search-under</a> <a id="27023" class="Number">1</a> <a id="27025" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27027" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27029" class="Symbol">)</a>

  <a id="decomp-sigma"></a><a id="27034" href="Meta.Reflection.HLevel.html#27034" class="Function">decomp-sigma</a> <a id="27047" class="Symbol">:</a> <a id="27049" class="Symbol">∀</a> <a id="27051" class="Symbol">{</a><a id="27052" href="Meta.Reflection.HLevel.html#27052" class="Bound">ℓ</a> <a id="27054" href="Meta.Reflection.HLevel.html#27054" class="Bound">ℓ′</a><a id="27056" class="Symbol">}</a> <a id="27058" class="Symbol">{</a><a id="27059" href="Meta.Reflection.HLevel.html#27059" class="Bound">A</a> <a id="27061" class="Symbol">:</a> <a id="27063" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27068" href="Meta.Reflection.HLevel.html#27052" class="Bound">ℓ</a><a id="27069" class="Symbol">}</a> <a id="27071" class="Symbol">{</a><a id="27072" href="Meta.Reflection.HLevel.html#27072" class="Bound">B</a> <a id="27074" class="Symbol">:</a> <a id="27076" href="Meta.Reflection.HLevel.html#27059" class="Bound">A</a> <a id="27078" class="Symbol">→</a> <a id="27080" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27085" href="Meta.Reflection.HLevel.html#27054" class="Bound">ℓ′</a><a id="27087" class="Symbol">}</a> <a id="27089" class="Symbol">→</a> <a id="27091" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="27112" class="Symbol">(</a><a id="27113" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="27115" href="Meta.Reflection.HLevel.html#27059" class="Bound">A</a> <a id="27117" href="Meta.Reflection.HLevel.html#27072" class="Bound">B</a><a id="27118" class="Symbol">)</a>
  <a id="27122" href="Meta.Reflection.HLevel.html#27034" class="Function">decomp-sigma</a> <a id="27135" class="Symbol">=</a> <a id="27137" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="27144" class="Symbol">(</a><a id="27145" class="Keyword">quote</a> <a id="27151" href="Foundations.HLevel.Retracts.html#4153" class="Function">Σ-is-of-hlevel</a><a id="27165" class="Symbol">)</a> <a id="27167" class="Symbol">(</a><a id="27168" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="27175" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27177" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="27185" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27187" href="Meta.Reflection.HLevel.html#3021" class="InductiveConstructor">`search-under</a> <a id="27201" class="Number">1</a> <a id="27203" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27205" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27207" class="Symbol">)</a>

  <a id="27212" class="Comment">-- Path decomposition rules we have in scope. Note the use of</a>
  <a id="27276" class="Comment">-- nondeterminism: the following three instances both compete for</a>
  <a id="27344" class="Comment">-- solving the same goals --- but generally only one will be</a>
  <a id="27407" class="Comment">-- applicable. That way we don&#39;t have to juggle h-levels quite as</a>
  <a id="27475" class="Comment">-- much.</a>
  <a id="decomp-path′"></a><a id="27486" href="Meta.Reflection.HLevel.html#27486" class="Function">decomp-path′</a> <a id="27499" class="Symbol">:</a> <a id="27501" class="Symbol">∀</a> <a id="27503" class="Symbol">{</a><a id="27504" href="Meta.Reflection.HLevel.html#27504" class="Bound">ℓ</a><a id="27505" class="Symbol">}</a> <a id="27507" class="Symbol">{</a><a id="27508" href="Meta.Reflection.HLevel.html#27508" class="Bound">A</a> <a id="27510" class="Symbol">:</a> <a id="27512" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27517" href="Meta.Reflection.HLevel.html#27504" class="Bound">ℓ</a><a id="27518" class="Symbol">}</a> <a id="27520" class="Symbol">{</a><a id="27521" href="Meta.Reflection.HLevel.html#27521" class="Bound">a</a> <a id="27523" href="Meta.Reflection.HLevel.html#27523" class="Bound">b</a> <a id="27525" class="Symbol">:</a> <a id="27527" href="Meta.Reflection.HLevel.html#27508" class="Bound">A</a><a id="27528" class="Symbol">}</a> <a id="27530" class="Symbol">→</a> <a id="27532" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="27553" class="Symbol">(</a><a id="27554" href="Meta.Reflection.HLevel.html#27521" class="Bound">a</a> <a id="27556" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27558" href="Meta.Reflection.HLevel.html#27523" class="Bound">b</a><a id="27559" class="Symbol">)</a>
  <a id="27563" href="Meta.Reflection.HLevel.html#27486" class="Function">decomp-path′</a> <a id="27576" class="Symbol">=</a> <a id="27578" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="27585" class="Symbol">(</a><a id="27586" class="Keyword">quote</a> <a id="27592" href="Foundations.HLevel.Base.html#3739" class="Function">Path-is-of-hlevel′</a><a id="27610" class="Symbol">)</a> <a id="27612" class="Symbol">(</a><a id="27613" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="27620" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27622" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="27630" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27632" href="Meta.Reflection.HLevel.html#3224" class="InductiveConstructor">`meta</a> <a id="27638" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27640" href="Meta.Reflection.HLevel.html#3224" class="InductiveConstructor">`meta</a> <a id="27646" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27648" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27650" class="Symbol">)</a>

  <a id="decomp-path"></a><a id="27655" href="Meta.Reflection.HLevel.html#27655" class="Function">decomp-path</a> <a id="27667" class="Symbol">:</a> <a id="27669" class="Symbol">∀</a> <a id="27671" class="Symbol">{</a><a id="27672" href="Meta.Reflection.HLevel.html#27672" class="Bound">ℓ</a><a id="27673" class="Symbol">}</a> <a id="27675" class="Symbol">{</a><a id="27676" href="Meta.Reflection.HLevel.html#27676" class="Bound">A</a> <a id="27678" class="Symbol">:</a> <a id="27680" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27685" href="Meta.Reflection.HLevel.html#27672" class="Bound">ℓ</a><a id="27686" class="Symbol">}</a> <a id="27688" class="Symbol">{</a><a id="27689" href="Meta.Reflection.HLevel.html#27689" class="Bound">a</a> <a id="27691" href="Meta.Reflection.HLevel.html#27691" class="Bound">b</a> <a id="27693" class="Symbol">:</a> <a id="27695" href="Meta.Reflection.HLevel.html#27676" class="Bound">A</a><a id="27696" class="Symbol">}</a> <a id="27698" class="Symbol">→</a> <a id="27700" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="27721" class="Symbol">(</a><a id="27722" href="Meta.Reflection.HLevel.html#27689" class="Bound">a</a> <a id="27724" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27726" href="Meta.Reflection.HLevel.html#27691" class="Bound">b</a><a id="27727" class="Symbol">)</a>
  <a id="27731" href="Meta.Reflection.HLevel.html#27655" class="Function">decomp-path</a> <a id="27743" class="Symbol">=</a> <a id="27745" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="27752" class="Symbol">(</a><a id="27753" class="Keyword">quote</a> <a id="27759" href="Foundations.HLevel.Base.html#3161" class="Function">Path-is-of-hlevel</a><a id="27776" class="Symbol">)</a> <a id="27778" class="Symbol">(</a><a id="27779" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="27786" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27788" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="27796" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27798" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27800" class="Symbol">)</a>

  <a id="decomp-univalence"></a><a id="27805" href="Meta.Reflection.HLevel.html#27805" class="Function">decomp-univalence</a> <a id="27823" class="Symbol">:</a> <a id="27825" class="Symbol">∀</a> <a id="27827" class="Symbol">{</a><a id="27828" href="Meta.Reflection.HLevel.html#27828" class="Bound">ℓ</a><a id="27829" class="Symbol">}</a> <a id="27831" class="Symbol">{</a><a id="27832" href="Meta.Reflection.HLevel.html#27832" class="Bound">A</a> <a id="27834" href="Meta.Reflection.HLevel.html#27834" class="Bound">B</a> <a id="27836" class="Symbol">:</a> <a id="27838" href="Foundations.Prim.Type.html#228" class="Primitive">Type</a> <a id="27843" href="Meta.Reflection.HLevel.html#27828" class="Bound">ℓ</a><a id="27844" class="Symbol">}</a> <a id="27846" class="Symbol">→</a> <a id="27848" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="27869" class="Symbol">(</a><a id="27870" href="Meta.Reflection.HLevel.html#27832" class="Bound">A</a> <a id="27872" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27874" href="Meta.Reflection.HLevel.html#27834" class="Bound">B</a><a id="27875" class="Symbol">)</a>
  <a id="27879" href="Meta.Reflection.HLevel.html#27805" class="Function">decomp-univalence</a> <a id="27897" class="Symbol">=</a> <a id="27899" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="27906" class="Symbol">(</a><a id="27907" class="Keyword">quote</a> <a id="27913" href="Structures.n-Type.html#1292" class="Function">＝-is-of-hlevel</a><a id="27927" class="Symbol">)</a> <a id="27929" class="Symbol">(</a><a id="27930" href="Meta.Reflection.HLevel.html#3524" class="InductiveConstructor">`level</a> <a id="27937" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27939" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="27947" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27949" href="Meta.Reflection.HLevel.html#3490" class="InductiveConstructor">`search</a> <a id="27957" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27959" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="27962" class="Symbol">)</a>

  <a id="27967" class="Comment">-- List isn&#39;t really a type on the same footing as all the others, but</a>
  <a id="28040" class="Comment">-- we&#39;re here, so we might as well, right?</a>
  <a id="28085" class="Comment">-- TODO</a>
  <a id="28095" class="Comment">-- decomp-list : ∀ {ℓ} {A : Type ℓ} → hlevel-decomposition (List A)</a>
  <a id="28165" class="Comment">-- decomp-list = decomp (quote ListPath.List-is-of-hlevel) (`level-minus 2 ∷ `search ∷ [])</a>

  <a id="28259" class="Comment">-- This one really ought to work with instance selection only, but</a>
  <a id="28328" class="Comment">-- Agda has trouble with the (1 + k + n) level in H-Level-n-Type. The</a>
  <a id="28400" class="Comment">-- decomposition here is a bit more flexible.</a>
  <a id="decomp-ntype"></a><a id="28448" href="Meta.Reflection.HLevel.html#28448" class="Function">decomp-ntype</a> <a id="28461" class="Symbol">:</a> <a id="28463" class="Symbol">∀</a> <a id="28465" class="Symbol">{</a><a id="28466" href="Meta.Reflection.HLevel.html#28466" class="Bound">ℓ</a><a id="28467" class="Symbol">}</a> <a id="28469" class="Symbol">{</a><a id="28470" href="Meta.Reflection.HLevel.html#28470" class="Bound">n</a><a id="28471" class="Symbol">}</a> <a id="28473" class="Symbol">→</a> <a id="28475" href="Meta.Reflection.HLevel.html#3665" class="Datatype">hlevel-decomposition</a> <a id="28496" class="Symbol">(</a><a id="28497" href="Structures.n-Type.html#284" class="Record">n-Type</a> <a id="28504" href="Meta.Reflection.HLevel.html#28466" class="Bound">ℓ</a> <a id="28506" href="Meta.Reflection.HLevel.html#28470" class="Bound">n</a><a id="28507" class="Symbol">)</a>
  <a id="28511" href="Meta.Reflection.HLevel.html#28448" class="Function">decomp-ntype</a> <a id="28524" class="Symbol">=</a> <a id="28526" href="Meta.Reflection.HLevel.html#3718" class="InductiveConstructor">decomp</a> <a id="28533" class="Symbol">(</a><a id="28534" class="Keyword">quote</a> <a id="28540" href="Structures.n-Type.html#2492" class="Function">n-Type-is-of-hlevel</a><a id="28559" class="Symbol">)</a> <a id="28561" class="Symbol">(</a><a id="28562" href="Meta.Reflection.HLevel.html#2821" class="InductiveConstructor">`level-minus</a> <a id="28575" class="Number">1</a> <a id="28577" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28579" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28581" class="Symbol">)</a>

  <a id="hlevel-proj-n-type"></a><a id="28586" href="Meta.Reflection.HLevel.html#28586" class="Function">hlevel-proj-n-type</a> <a id="28605" class="Symbol">:</a> <a id="28607" href="Meta.Reflection.HLevel.html#4037" class="Record">hlevel-projection</a> <a id="28625" class="Symbol">(</a><a id="28626" class="Keyword">quote</a> <a id="28632" href="Structures.n-Type.html#364" class="Field">n-Type.typ</a><a id="28642" class="Symbol">)</a>
  <a id="28646" href="Meta.Reflection.HLevel.html#28586" class="Function">hlevel-proj-n-type</a> <a id="28665" class="Symbol">.</a><a id="28666" href="Meta.Reflection.HLevel.html#4094" class="Field">has-level</a> <a id="28676" class="Symbol">=</a> <a id="28678" class="Keyword">quote</a> <a id="28684" href="Structures.n-Type.html#383" class="Field">n-Type.is-tr</a>
  <a id="28699" href="Meta.Reflection.HLevel.html#28586" class="Function">hlevel-proj-n-type</a> <a id="28718" class="Symbol">.</a><a id="28719" href="Meta.Reflection.HLevel.html#4281" class="Field">get-level</a> <a id="28729" href="Meta.Reflection.HLevel.html#28729" class="Bound">ty</a> <a id="28732" class="Symbol">=</a> <a id="28734" class="Keyword">do</a>
    <a id="28741" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="28745" class="Symbol">(</a><a id="28746" class="Keyword">quote</a> <a id="28752" href="Structures.n-Type.html#284" class="Record">n-Type</a><a id="28758" class="Symbol">)</a> <a id="28760" class="Symbol">(</a><a id="28761" href="Meta.Reflection.HLevel.html#28761" class="Bound">ell</a> <a id="28765" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="28768" href="Meta.Reflection.HLevel.html#28768" class="Bound">lv′t</a> <a id="28773" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="28776" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28778" class="Symbol">)</a> <a id="28780" href="Meta.Bind.html#183" class="Field Operator">←</a> <a id="28782" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="28789" href="Meta.Reflection.HLevel.html#28729" class="Bound">ty</a>
      <a id="28798" class="Keyword">where</a> <a id="28804" class="CatchallClause Symbol">_</a> <a id="28806" class="Symbol">→</a> <a id="28808" href="Meta.Reflection.HLevel.html#5430" class="Function">backtrack</a> <a id="28818" href="Foundations.Pi.Base.html#810" class="Function Operator">$</a> <a id="28820" class="String">&quot;Type of thing isn&#39;t n-Type, it is &quot;</a> <a id="28857" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28859" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="28867" href="Meta.Reflection.HLevel.html#28729" class="Bound">ty</a> <a id="28870" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28872" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="28879" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="28889" href="Meta.Reflection.HLevel.html#28768" class="Bound">lv′t</a>
  <a id="28896" href="Meta.Reflection.HLevel.html#28586" class="Function">hlevel-proj-n-type</a> <a id="28915" class="Symbol">.</a><a id="28916" href="Meta.Reflection.HLevel.html#4434" class="Field">get-argument</a> <a id="28929" class="Symbol">(_</a> <a id="28932" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28934" class="Symbol">_</a> <a id="28936" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28938" href="Meta.Reflection.HLevel.html#28938" class="Bound">it</a> <a id="28941" href="Meta.Reflection.Base.html#2328" class="InductiveConstructor Operator">v∷</a> <a id="28944" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28946" class="Symbol">)</a> <a id="28948" class="Symbol">=</a> <a id="28950" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="28955" href="Meta.Reflection.HLevel.html#28938" class="Bound">it</a>
  <a id="28960" href="Meta.Reflection.HLevel.html#28586" class="CatchallClause Function">hlevel-proj-n-type</a><a id="28978" class="CatchallClause"> </a><a id="28979" class="CatchallClause Symbol">.</a><a id="28980" href="Meta.Reflection.HLevel.html#4434" class="CatchallClause Field">get-argument</a><a id="28992" class="CatchallClause"> </a><a id="28993" class="CatchallClause Symbol">_</a> <a id="28995" class="Symbol">=</a> <a id="28997" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="29007" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>


<a id="29012" class="Comment">-- Usage</a>
<a id="29021" class="Keyword">private</a>
  <a id="29031" class="Keyword">module</a> <a id="29038" href="Meta.Reflection.HLevel.html#29038" class="Module">_</a> <a id="29040" class="Symbol">{</a><a id="29041" href="Meta.Reflection.HLevel.html#29041" class="Bound">ℓ</a><a id="29042" class="Symbol">}</a> <a id="29044" class="Symbol">{</a><a id="29045" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29047" class="Symbol">:</a> <a id="29049" href="Structures.n-Type.html#284" class="Record">n-Type</a> <a id="29056" href="Meta.Reflection.HLevel.html#29041" class="Bound">ℓ</a> <a id="29058" class="Number">2</a><a id="29059" class="Symbol">}</a> <a id="29061" class="Symbol">{</a><a id="29062" href="Meta.Reflection.HLevel.html#29062" class="Bound">B</a> <a id="29064" class="Symbol">:</a> <a id="29066" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29068" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29070" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29072" class="Symbol">→</a> <a id="29074" href="Structures.n-Type.html#284" class="Record">n-Type</a> <a id="29081" href="Meta.Reflection.HLevel.html#29041" class="Bound">ℓ</a> <a id="29083" class="Number">3</a><a id="29084" class="Symbol">}</a> <a id="29086" class="Keyword">where</a>
    <a id="29096" href="Meta.Reflection.HLevel.html#29096" class="Function">some-def</a> <a id="29105" class="Symbol">=</a> <a id="29107" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29109" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29111" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29117" href="Meta.Reflection.HLevel.html#29117" class="Function">_</a> <a id="29119" class="Symbol">:</a> <a id="29121" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29134" class="Number">2</a> <a id="29136" class="Symbol">(</a><a id="29137" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29139" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29141" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29143" class="Symbol">→</a> <a id="29145" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29147" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29149" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29151" class="Symbol">→</a> <a id="29153" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29155" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29157" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29159" class="Symbol">→</a> <a id="29161" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29163" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29165" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29166" class="Symbol">)</a>
    <a id="29172" class="Symbol">_</a> <a id="29174" class="Symbol">=</a> <a id="29176" href="Meta.Reflection.HLevel.html#24270" class="Macro">hlevel!</a>

    <a id="29189" href="Meta.Reflection.HLevel.html#29189" class="Function">_</a> <a id="29191" class="Symbol">:</a> <a id="29193" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29206" class="Number">3</a> <a id="29208" class="Symbol">(</a><a id="29209" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="29211" href="Meta.Reflection.HLevel.html#29096" class="Function">some-def</a> <a id="29220" class="Symbol">λ</a> <a id="29222" href="Meta.Reflection.HLevel.html#29222" class="Bound">x</a> <a id="29224" class="Symbol">→</a> <a id="29226" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29228" href="Meta.Reflection.HLevel.html#29062" class="Bound">B</a> <a id="29230" href="Meta.Reflection.HLevel.html#29222" class="Bound">x</a> <a id="29232" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29233" class="Symbol">)</a>
    <a id="29239" class="Symbol">_</a> <a id="29241" class="Symbol">=</a> <a id="29243" href="Meta.Reflection.HLevel.html#24270" class="Macro">hlevel!</a>

    <a id="29256" href="Meta.Reflection.HLevel.html#29256" class="Function">_</a> <a id="29258" class="Symbol">:</a> <a id="29260" class="Symbol">∀</a> <a id="29262" href="Meta.Reflection.HLevel.html#29262" class="Bound">a</a> <a id="29264" class="Symbol">→</a> <a id="29266" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29279" class="Number">5</a> <a id="29281" class="Symbol">(</a><a id="29282" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29284" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29286" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29288" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29290" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29292" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29294" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29296" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29298" class="Symbol">(</a><a id="29299" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29301" class="Symbol">→</a> <a id="29303" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29305" href="Meta.Reflection.HLevel.html#29062" class="Bound">B</a> <a id="29307" href="Meta.Reflection.HLevel.html#29262" class="Bound">a</a> <a id="29309" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29310" class="Symbol">))</a>
    <a id="29317" class="Symbol">_</a> <a id="29319" class="Symbol">=</a> <a id="29321" href="Meta.Reflection.HLevel.html#24270" class="Macro">hlevel!</a>

    <a id="29334" href="Meta.Reflection.HLevel.html#29334" class="Function">_</a> <a id="29336" class="Symbol">:</a> <a id="29338" class="Symbol">∀</a> <a id="29340" href="Meta.Reflection.HLevel.html#29340" class="Bound">a</a> <a id="29342" class="Symbol">→</a> <a id="29344" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29357" class="Number">3</a> <a id="29359" class="Symbol">(</a><a id="29360" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29362" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29364" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29366" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29368" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29370" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29372" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29374" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29376" class="Symbol">(</a><a id="29377" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29379" class="Symbol">→</a> <a id="29381" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29383" href="Meta.Reflection.HLevel.html#29062" class="Bound">B</a> <a id="29385" href="Meta.Reflection.HLevel.html#29340" class="Bound">a</a> <a id="29387" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29388" class="Symbol">))</a>
    <a id="29395" class="Symbol">_</a> <a id="29397" class="Symbol">=</a> <a id="29399" href="Meta.Reflection.HLevel.html#24270" class="Macro">hlevel!</a>

    <a id="29412" href="Meta.Reflection.HLevel.html#29412" class="Function">_</a> <a id="29414" class="Symbol">:</a> <a id="29416" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29429" class="Number">2</a> <a id="29431" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29433" href="Meta.Reflection.HLevel.html#29045" class="Bound">A</a> <a id="29435" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29441" class="Symbol">_</a> <a id="29443" class="Symbol">=</a> <a id="29445" href="Meta.Reflection.HLevel.html#24270" class="Macro">hlevel!</a>

    <a id="29458" class="Comment">-- this one uses `H-Level-nType` instance which is compile-time only</a>
    <a id="29531" class="Symbol">@</a><a id="29532" class="Number">0</a> <a id="29534" href="Meta.Reflection.HLevel.html#29534" class="Function">_</a> <a id="29536" class="Symbol">:</a> <a id="29538" class="Symbol">∀</a> <a id="29540" href="Meta.Reflection.HLevel.html#29540" class="Bound">n</a> <a id="29542" class="Symbol">→</a> <a id="29544" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29557" class="Symbol">(</a><a id="29558" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="29562" href="Meta.Reflection.HLevel.html#29540" class="Bound">n</a><a id="29563" class="Symbol">)</a> <a id="29565" class="Symbol">(</a><a id="29566" href="Structures.n-Type.html#284" class="Record">n-Type</a> <a id="29573" href="Meta.Reflection.HLevel.html#29041" class="Bound">ℓ</a> <a id="29575" href="Meta.Reflection.HLevel.html#29540" class="Bound">n</a><a id="29576" class="Symbol">)</a>
    <a id="29582" class="Symbol">_</a> <a id="29584" class="Symbol">=</a> <a id="29586" href="Meta.Reflection.HLevel.html#24270" class="Macro">hlevel!</a>

    <a id="29599" href="Meta.Reflection.HLevel.html#29599" class="Function">_</a> <a id="29601" class="Symbol">:</a> <a id="29603" class="Symbol">∀</a> <a id="29605" href="Meta.Reflection.HLevel.html#29605" class="Bound">n</a> <a id="29607" class="Symbol">(</a><a id="29608" href="Meta.Reflection.HLevel.html#29608" class="Bound">x</a> <a id="29610" class="Symbol">:</a> <a id="29612" href="Structures.n-Type.html#284" class="Record">n-Type</a> <a id="29619" href="Meta.Reflection.HLevel.html#29041" class="Bound">ℓ</a> <a id="29621" href="Meta.Reflection.HLevel.html#29605" class="Bound">n</a><a id="29622" class="Symbol">)</a> <a id="29624" class="Symbol">→</a> <a id="29626" href="Foundations.HLevel.Base.html#350" class="Function">is-of-hlevel</a> <a id="29639" class="Symbol">(</a><a id="29640" class="Number">2</a> <a id="29642" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="29644" href="Meta.Reflection.HLevel.html#29605" class="Bound">n</a><a id="29645" class="Symbol">)</a> <a id="29647" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29649" href="Meta.Reflection.HLevel.html#29608" class="Bound">x</a> <a id="29651" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29657" class="Symbol">_</a> <a id="29659" class="Symbol">=</a> <a id="29661" class="Symbol">λ</a> <a id="29663" href="Meta.Reflection.HLevel.html#29663" class="Bound">n</a> <a id="29665" href="Meta.Reflection.HLevel.html#29665" class="Bound">x</a> <a id="29667" class="Symbol">→</a> <a id="29669" href="Meta.Reflection.HLevel.html#24270" class="Macro">hlevel!</a>
</pre></body></html>