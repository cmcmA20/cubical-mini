<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Reflection.RecordEquiv</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

  Reflection-based tools for converting between iterated record types, particularly between
  record types and iterated Σ-types.

  The main functions are `declareRecordIsoΣ` and `declareRecordIsoΣ`. See end of file for
  example usage.

-}</a>
<a id="246" class="Symbol">{-#</a> <a id="250" class="Keyword">OPTIONS</a> <a id="258" class="Pragma">--no-exact-split</a> <a id="275" class="Pragma">--safe</a> <a id="282" class="Symbol">#-}</a>
<a id="286" class="Keyword">module</a> <a id="293" href="Cubical.Reflection.RecordEquiv.html" class="Module">Cubical.Reflection.RecordEquiv</a> <a id="324" class="Keyword">where</a>

<a id="331" class="Keyword">open</a> <a id="336" class="Keyword">import</a> <a id="343" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a>
<a id="371" class="Keyword">open</a> <a id="376" class="Keyword">import</a> <a id="383" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a>
<a id="415" class="Keyword">open</a> <a id="420" class="Keyword">import</a> <a id="427" href="Cubical.Foundations.Equiv.html" class="Module">Cubical.Foundations.Equiv</a>

<a id="454" class="Keyword">open</a> <a id="459" class="Keyword">import</a> <a id="466" href="Cubical.Data.List.Base.html" class="Module">Cubical.Data.List.Base</a> <a id="489" class="Symbol">as</a> <a id="492" class="Module">List</a>
<a id="497" class="Keyword">open</a> <a id="502" class="Keyword">import</a> <a id="509" href="Cubical.Data.Nat.Base.html" class="Module">Cubical.Data.Nat.Base</a>
<a id="531" class="Keyword">open</a> <a id="536" class="Keyword">import</a> <a id="543" href="Cubical.Data.Maybe.html" class="Module">Cubical.Data.Maybe</a> <a id="562" class="Symbol">as</a> <a id="565" class="Module">Maybe</a>
<a id="571" class="Keyword">open</a> <a id="576" class="Keyword">import</a> <a id="583" href="Cubical.Data.Sigma.Base.html" class="Module">Cubical.Data.Sigma.Base</a>
<a id="607" class="Keyword">open</a> <a id="612" class="Keyword">import</a> <a id="619" href="Cubical.Data.String.Base.html" class="Module">Cubical.Data.String.Base</a>

<a id="645" class="Keyword">import</a> <a id="652" href="Agda.Builtin.Reflection.html" class="Module">Agda.Builtin.Reflection</a> <a id="676" class="Symbol">as</a> <a id="679" class="Module">R</a>
<a id="681" class="Keyword">open</a> <a id="686" class="Keyword">import</a> <a id="693" href="Cubical.Reflection.Base.html" class="Module">Cubical.Reflection.Base</a>

<a id="718" class="Comment">-- Intended to represent a (possibly nested) field of a record type. For example, the list</a>
<a id="809" class="Comment">-- &quot;snd&quot; ∷ fst&quot; ∷ []` would represent the field `.fst .snd`.</a>
<a id="Projections"></a><a id="870" href="Cubical.Reflection.RecordEquiv.html#870" class="Function">Projections</a> <a id="882" class="Symbol">=</a> <a id="884" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="889" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a>

<a id="897" class="Comment">-- Intended to represent a bijection between two record types by an association list</a>
<a id="982" class="Comment">-- between (possibly nested) fields of the one and the other. The `Maybe`s are included to</a>
<a id="1073" class="Comment">-- allow dropping fields of Unit (or other definitionally unique) type.</a>
<a id="1145" class="Comment">--</a>
<a id="1148" class="Comment">-- For example, the correspondence</a>
<a id="1183" class="Comment">--</a>
<a id="1186" class="Comment">--   .fst .fst ↔ .snd</a>
<a id="1208" class="Comment">--   .fst .snd ↔ .fst</a>
<a id="1230" class="Comment">--   .snd ↔ ∅</a>
<a id="1244" class="Comment">--</a>
<a id="1247" class="Comment">-- between (A × B) × Unit and B × A would be represented by the list</a>
<a id="1316" class="Comment">--</a>
<a id="1319" class="Comment">--   [ (just [&quot;fst&quot;; &quot;fst&quot;] , just [&quot;snd&quot;])</a>
<a id="1363" class="Comment">--   ; (just [&quot;snd&quot;; &quot;fst&quot;] , just [&quot;fst&quot;])</a>
<a id="1407" class="Comment">--   ; (just [&quot;snd&quot;] , nothing)</a>
<a id="1439" class="Comment">--   ]</a>
<a id="RecordAssoc"></a><a id="1446" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a> <a id="1458" class="Symbol">=</a> <a id="1460" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="1465" class="Symbol">(</a><a id="1466" href="Cubical.Data.Maybe.Base.html#180" class="Datatype">Maybe</a> <a id="1472" href="Cubical.Reflection.RecordEquiv.html#870" class="Function">Projections</a> <a id="1484" href="Cubical.Data.Sigma.Base.html#456" class="Function Operator">×</a> <a id="1486" href="Cubical.Data.Maybe.Base.html#180" class="Datatype">Maybe</a> <a id="1492" href="Cubical.Reflection.RecordEquiv.html#870" class="Function">Projections</a><a id="1503" class="Symbol">)</a>

<a id="1506" class="Comment">-- Describes a correspondence between a non-nested record and an iterated Σ-type; more</a>
<a id="1593" class="Comment">-- convenient to work with than RecordAssoc in this special case, which is the most common</a>
<a id="1684" class="Comment">-- one. For example,</a>
<a id="1705" class="Comment">--</a>
<a id="1708" class="Comment">--   leaf &quot;a&quot; , (leaf &quot;b&quot; , leaf &quot;c&quot;)</a>
<a id="1746" class="Comment">--</a>
<a id="1749" class="Comment">-- describes the following RecordAssoc:</a>
<a id="1789" class="Comment">--</a>
<a id="1792" class="Comment">--   .fst ↔ .a</a>
<a id="1807" class="Comment">--   .snd .fst ↔ .b</a>
<a id="1827" class="Comment">--   .snd .snd ↔ .c</a>
<a id="1847" class="Comment">--</a>
<a id="1850" class="Comment">-- The `unit` constructor is the correspondence between Unit (&quot;nullary Σ&quot;) and the empty</a>
<a id="1939" class="Comment">-- record.</a>
<a id="1950" class="Keyword">data</a> <a id="ΣFormat"></a><a id="1955" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="1963" class="Symbol">:</a> <a id="1965" href="Agda.Primitive.html#337" class="Primitive">Type</a> <a id="1970" class="Keyword">where</a>
  <a id="ΣFormat.leaf"></a><a id="1978" href="Cubical.Reflection.RecordEquiv.html#1978" class="InductiveConstructor">leaf</a> <a id="1983" class="Symbol">:</a> <a id="1985" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="1992" class="Symbol">→</a> <a id="1994" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a>
  <a id="ΣFormat._,_"></a><a id="2004" href="Cubical.Reflection.RecordEquiv.html#2004" class="InductiveConstructor Operator">_,_</a> <a id="2008" class="Symbol">:</a> <a id="2010" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="2018" class="Symbol">→</a> <a id="2020" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="2028" class="Symbol">→</a> <a id="2030" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a>
  <a id="ΣFormat.unit"></a><a id="2040" href="Cubical.Reflection.RecordEquiv.html#2040" class="InductiveConstructor">unit</a> <a id="2045" class="Symbol">:</a> <a id="2047" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a>

<a id="2056" class="Keyword">infixr</a> <a id="2063" class="Number">4</a> <a id="2065" href="Cubical.Reflection.RecordEquiv.html#2004" class="InductiveConstructor Operator">_,_</a>

<a id="2070" class="Comment">-- Inverse of a correspondence between record types</a>
<a id="flipRecordAssoc"></a><a id="2122" href="Cubical.Reflection.RecordEquiv.html#2122" class="Function">flipRecordAssoc</a> <a id="2138" class="Symbol">:</a> <a id="2140" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a> <a id="2152" class="Symbol">→</a> <a id="2154" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a>
<a id="2166" href="Cubical.Reflection.RecordEquiv.html#2122" class="Function">flipRecordAssoc</a> <a id="2182" class="Symbol">=</a> <a id="2184" href="Cubical.Data.List.Base.html#610" class="Function">List.map</a> <a id="2193" class="Symbol">λ</a> <a id="2195" class="Symbol">{</a><a id="2196" href="Cubical.Reflection.RecordEquiv.html#2196" class="Bound">p</a> <a id="2198" class="Symbol">.</a><a id="2199" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="2203" class="Symbol">→</a> <a id="2205" href="Cubical.Reflection.RecordEquiv.html#2196" class="Bound">p</a> <a id="2207" class="Symbol">.</a><a id="2208" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a><a id="2211" class="Symbol">;</a> <a id="2213" href="Cubical.Reflection.RecordEquiv.html#2213" class="Bound">p</a> <a id="2215" class="Symbol">.</a><a id="2216" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="2220" class="Symbol">→</a> <a id="2222" href="Cubical.Reflection.RecordEquiv.html#2213" class="Bound">p</a> <a id="2224" class="Symbol">.</a><a id="2225" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a><a id="2228" class="Symbol">}</a>

<a id="2231" class="Comment">-- The identity correspondence on the domain of a given correspondence</a>
<a id="fstIdRecordAssoc"></a><a id="2302" href="Cubical.Reflection.RecordEquiv.html#2302" class="Function">fstIdRecordAssoc</a> <a id="2319" class="Symbol">:</a> <a id="2321" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a> <a id="2333" class="Symbol">→</a> <a id="2335" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a>
<a id="2347" href="Cubical.Reflection.RecordEquiv.html#2302" class="Function">fstIdRecordAssoc</a> <a id="2364" class="Symbol">=</a> <a id="2366" href="Cubical.Data.List.Base.html#610" class="Function">List.map</a> <a id="2375" class="Symbol">λ</a> <a id="2377" class="Symbol">{</a><a id="2378" href="Cubical.Reflection.RecordEquiv.html#2378" class="Bound">p</a> <a id="2380" class="Symbol">.</a><a id="2381" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="2385" class="Symbol">→</a> <a id="2387" href="Cubical.Reflection.RecordEquiv.html#2378" class="Bound">p</a> <a id="2389" class="Symbol">.</a><a id="2390" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a><a id="2393" class="Symbol">;</a> <a id="2395" href="Cubical.Reflection.RecordEquiv.html#2395" class="Bound">p</a> <a id="2397" class="Symbol">.</a><a id="2398" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="2402" class="Symbol">→</a> <a id="2404" href="Cubical.Reflection.RecordEquiv.html#2395" class="Bound">p</a> <a id="2406" class="Symbol">.</a><a id="2407" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a><a id="2410" class="Symbol">}</a>

<a id="2413" class="Comment">-- Constructs a ΣFormat from a list of fields meant to represent a right-associated Σ-type</a>
<a id="List→ΣFormat"></a><a id="2504" href="Cubical.Reflection.RecordEquiv.html#2504" class="Function">List→ΣFormat</a> <a id="2517" class="Symbol">:</a> <a id="2519" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2524" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="2531" class="Symbol">→</a> <a id="2533" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a>
<a id="2541" href="Cubical.Reflection.RecordEquiv.html#2504" class="Function">List→ΣFormat</a> <a id="2554" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2557" class="Symbol">=</a> <a id="2559" href="Cubical.Reflection.RecordEquiv.html#2040" class="InductiveConstructor">unit</a>
<a id="2564" href="Cubical.Reflection.RecordEquiv.html#2504" class="Function">List→ΣFormat</a> <a id="2577" class="Symbol">(</a><a id="2578" href="Cubical.Reflection.RecordEquiv.html#2578" class="Bound">x</a> <a id="2580" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2582" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2584" class="Symbol">)</a> <a id="2586" class="Symbol">=</a> <a id="2588" href="Cubical.Reflection.RecordEquiv.html#1978" class="InductiveConstructor">leaf</a> <a id="2593" href="Cubical.Reflection.RecordEquiv.html#2578" class="Bound">x</a>
<a id="2595" href="Cubical.Reflection.RecordEquiv.html#2504" class="Function">List→ΣFormat</a> <a id="2608" class="Symbol">(</a><a id="2609" href="Cubical.Reflection.RecordEquiv.html#2609" class="Bound">x</a> <a id="2611" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2613" href="Cubical.Reflection.RecordEquiv.html#2613" class="Bound">y</a> <a id="2615" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2617" href="Cubical.Reflection.RecordEquiv.html#2617" class="Bound">xs</a><a id="2619" class="Symbol">)</a> <a id="2621" class="Symbol">=</a> <a id="2623" href="Cubical.Reflection.RecordEquiv.html#1978" class="InductiveConstructor">leaf</a> <a id="2628" href="Cubical.Reflection.RecordEquiv.html#2609" class="Bound">x</a> <a id="2630" href="Cubical.Reflection.RecordEquiv.html#2004" class="InductiveConstructor Operator">,</a> <a id="2632" href="Cubical.Reflection.RecordEquiv.html#2504" class="Function">List→ΣFormat</a> <a id="2645" class="Symbol">(</a><a id="2646" href="Cubical.Reflection.RecordEquiv.html#2613" class="Bound">y</a> <a id="2648" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2650" href="Cubical.Reflection.RecordEquiv.html#2617" class="Bound">xs</a><a id="2652" class="Symbol">)</a>

<a id="2655" class="Comment">-- Converts a ΣFormat to an association list as described above.</a>
<a id="2720" class="Comment">-- The domain of the RecordAssoc is the record type, the codomain is the Σ-type.</a>
<a id="ΣFormat→RecordAssoc"></a><a id="2801" href="Cubical.Reflection.RecordEquiv.html#2801" class="Function">ΣFormat→RecordAssoc</a> <a id="2821" class="Symbol">:</a> <a id="2823" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="2831" class="Symbol">→</a> <a id="2833" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a>
<a id="2845" href="Cubical.Reflection.RecordEquiv.html#2801" class="Function">ΣFormat→RecordAssoc</a> <a id="2865" class="Symbol">=</a> <a id="2867" href="Cubical.Reflection.RecordEquiv.html#2883" class="Function">go</a> <a id="2870" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="2875" class="Keyword">where</a>
  <a id="2883" href="Cubical.Reflection.RecordEquiv.html#2883" class="Function">go</a> <a id="2886" class="Symbol">:</a> <a id="2888" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2893" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="2900" class="Symbol">→</a> <a id="2902" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="2910" class="Symbol">→</a> <a id="2912" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a>
  <a id="2926" href="Cubical.Reflection.RecordEquiv.html#2883" class="Function">go</a> <a id="2929" href="Cubical.Reflection.RecordEquiv.html#2929" class="Bound">prefix</a> <a id="2936" href="Cubical.Reflection.RecordEquiv.html#2040" class="InductiveConstructor">unit</a> <a id="2941" class="Symbol">=</a> <a id="2943" href="Cubical.Data.List.Base.html#363" class="Function Operator">[</a> <a id="2945" href="Cubical.Data.Maybe.Base.html#216" class="InductiveConstructor">nothing</a> <a id="2953" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2955" href="Cubical.Data.Maybe.Base.html#236" class="InductiveConstructor">just</a> <a id="2960" href="Cubical.Reflection.RecordEquiv.html#2929" class="Bound">prefix</a> <a id="2967" href="Cubical.Data.List.Base.html#363" class="Function Operator">]</a>
  <a id="2971" href="Cubical.Reflection.RecordEquiv.html#2883" class="Function">go</a> <a id="2974" href="Cubical.Reflection.RecordEquiv.html#2974" class="Bound">prefix</a> <a id="2981" class="Symbol">(</a><a id="2982" href="Cubical.Reflection.RecordEquiv.html#1978" class="InductiveConstructor">leaf</a> <a id="2987" href="Cubical.Reflection.RecordEquiv.html#2987" class="Bound">fieldName</a><a id="2996" class="Symbol">)</a> <a id="2998" class="Symbol">=</a> <a id="3000" href="Cubical.Data.List.Base.html#363" class="Function Operator">[</a> <a id="3002" href="Cubical.Data.Maybe.Base.html#236" class="InductiveConstructor">just</a> <a id="3007" href="Cubical.Data.List.Base.html#363" class="Function Operator">[</a> <a id="3009" href="Cubical.Reflection.RecordEquiv.html#2987" class="Bound">fieldName</a> <a id="3019" href="Cubical.Data.List.Base.html#363" class="Function Operator">]</a> <a id="3021" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3023" href="Cubical.Data.Maybe.Base.html#236" class="InductiveConstructor">just</a> <a id="3028" href="Cubical.Reflection.RecordEquiv.html#2974" class="Bound">prefix</a> <a id="3035" href="Cubical.Data.List.Base.html#363" class="Function Operator">]</a>
  <a id="3039" href="Cubical.Reflection.RecordEquiv.html#2883" class="Function">go</a> <a id="3042" href="Cubical.Reflection.RecordEquiv.html#3042" class="Bound">prefix</a> <a id="3049" class="Symbol">(</a><a id="3050" href="Cubical.Reflection.RecordEquiv.html#3050" class="Bound">sig₁</a> <a id="3055" href="Cubical.Reflection.RecordEquiv.html#2004" class="InductiveConstructor Operator">,</a> <a id="3057" href="Cubical.Reflection.RecordEquiv.html#3057" class="Bound">sig₂</a><a id="3061" class="Symbol">)</a> <a id="3063" class="Symbol">=</a>
    <a id="3069" href="Cubical.Reflection.RecordEquiv.html#2883" class="Function">go</a> <a id="3072" class="Symbol">(</a><a id="3073" class="Keyword">quote</a> <a id="3079" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="3083" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3085" href="Cubical.Reflection.RecordEquiv.html#3042" class="Bound">prefix</a><a id="3091" class="Symbol">)</a> <a id="3093" href="Cubical.Reflection.RecordEquiv.html#3050" class="Bound">sig₁</a> <a id="3098" href="Cubical.Data.List.Base.html#400" class="Function Operator">++</a> <a id="3101" href="Cubical.Reflection.RecordEquiv.html#2883" class="Function">go</a> <a id="3104" class="Symbol">(</a><a id="3105" class="Keyword">quote</a> <a id="3111" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="3115" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3117" href="Cubical.Reflection.RecordEquiv.html#3042" class="Bound">prefix</a><a id="3123" class="Symbol">)</a> <a id="3125" href="Cubical.Reflection.RecordEquiv.html#3057" class="Bound">sig₂</a>

<a id="3131" class="Comment">-- Define a reflected type with the shape of the Σ-type described by a ΣFormat.</a>
<a id="3211" class="Comment">-- The type arguments to the Σ are filled in with unsolved metavariables.</a>
<a id="ΣFormat→Ty"></a><a id="3285" href="Cubical.Reflection.RecordEquiv.html#3285" class="Function">ΣFormat→Ty</a> <a id="3296" class="Symbol">:</a> <a id="3298" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="3306" class="Symbol">→</a> <a id="3308" href="Agda.Builtin.Reflection.html#4758" class="Function">R.Type</a>
<a id="3315" href="Cubical.Reflection.RecordEquiv.html#3285" class="Function">ΣFormat→Ty</a> <a id="3326" href="Cubical.Reflection.RecordEquiv.html#2040" class="InductiveConstructor">unit</a> <a id="3331" class="Symbol">=</a> <a id="3333" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">R.def</a> <a id="3339" class="Symbol">(</a><a id="3340" class="Keyword">quote</a> <a id="3346" href="Cubical.Data.Unit.Base.html#171" class="Record">Unit</a><a id="3350" class="Symbol">)</a> <a id="3352" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
<a id="3355" href="Cubical.Reflection.RecordEquiv.html#3285" class="Function">ΣFormat→Ty</a> <a id="3366" class="Symbol">(</a><a id="3367" href="Cubical.Reflection.RecordEquiv.html#1978" class="InductiveConstructor">leaf</a> <a id="3372" class="Symbol">_)</a> <a id="3375" class="Symbol">=</a> <a id="3377" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">R.unknown</a>
<a id="3387" href="Cubical.Reflection.RecordEquiv.html#3285" class="Function">ΣFormat→Ty</a> <a id="3398" class="Symbol">(</a><a id="3399" href="Cubical.Reflection.RecordEquiv.html#3399" class="Bound">sig₁</a> <a id="3404" href="Cubical.Reflection.RecordEquiv.html#2004" class="InductiveConstructor Operator">,</a> <a id="3406" href="Cubical.Reflection.RecordEquiv.html#3406" class="Bound">sig₂</a><a id="3410" class="Symbol">)</a> <a id="3412" class="Symbol">=</a>
  <a id="3416" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">R.def</a> <a id="3422" class="Symbol">(</a><a id="3423" class="Keyword">quote</a> <a id="3429" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a><a id="3430" class="Symbol">)</a> <a id="3432" class="Symbol">(</a><a id="3433" href="Cubical.Reflection.RecordEquiv.html#3285" class="Function">ΣFormat→Ty</a> <a id="3444" href="Cubical.Reflection.RecordEquiv.html#3399" class="Bound">sig₁</a> <a id="3449" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="3452" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">R.lam</a> <a id="3458" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">R.visible</a> <a id="3468" class="Symbol">(</a><a id="3469" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">R.abs</a> <a id="3475" class="String">&quot;_&quot;</a> <a id="3479" class="Symbol">(</a><a id="3480" href="Cubical.Reflection.RecordEquiv.html#3285" class="Function">ΣFormat→Ty</a> <a id="3491" href="Cubical.Reflection.RecordEquiv.html#3406" class="Bound">sig₂</a><a id="3495" class="Symbol">))</a> <a id="3498" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="3501" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3503" class="Symbol">)</a>

<a id="3506" class="Comment">-- Given the name of a record type and a ΣFormat describing an isomorphism between this</a>
<a id="3594" class="Comment">-- type and a Σ-type, constructs a reflected type of isomorphisms between the record and</a>
<a id="3683" class="Comment">-- Σ-type. If the record type takes parameters or indices, then the result is a similarly</a>
<a id="3773" class="Comment">-- parameterized family of isomorphisms. All parameters to the isomorphism are made</a>
<a id="3857" class="Comment">-- implicit.</a>
<a id="recordName→isoTy"></a><a id="3870" href="Cubical.Reflection.RecordEquiv.html#3870" class="Function">recordName→isoTy</a> <a id="3887" class="Symbol">:</a> <a id="3889" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="3896" class="Symbol">→</a> <a id="3898" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="3906" class="Symbol">→</a> <a id="3908" href="Agda.Builtin.Reflection.html#8296" class="Postulate">R.TC</a> <a id="3913" href="Agda.Builtin.Reflection.html#4687" class="Datatype">R.Term</a>
<a id="3920" href="Cubical.Reflection.RecordEquiv.html#3870" class="Function">recordName→isoTy</a> <a id="3937" href="Cubical.Reflection.RecordEquiv.html#3937" class="Bound">name</a> <a id="3942" href="Cubical.Reflection.RecordEquiv.html#3942" class="Bound">σ</a> <a id="3944" class="Symbol">=</a>
  <a id="3948" href="Agda.Builtin.Reflection.html#8572" class="Postulate">R.inferType</a> <a id="3960" class="Symbol">(</a><a id="3961" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">R.def</a> <a id="3967" href="Cubical.Reflection.RecordEquiv.html#3937" class="Bound">name</a> <a id="3972" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3974" class="Symbol">)</a> <a id="3976" href="Cubical.Reflection.Base.html#302" class="Function Operator">&gt;&gt;=</a> <a id="3980" href="Agda.Builtin.Reflection.html#8651" class="Postulate">R.normalise</a> <a id="3992" href="Cubical.Reflection.Base.html#302" class="Function Operator">&gt;&gt;=</a> <a id="3996" href="Cubical.Reflection.RecordEquiv.html#4085" class="Function">go</a> <a id="3999" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="4004" class="Keyword">where</a>
  <a id="4012" href="Cubical.Reflection.RecordEquiv.html#4012" class="Function">σTy</a> <a id="4016" class="Symbol">=</a> <a id="4018" href="Cubical.Reflection.RecordEquiv.html#3285" class="Function">ΣFormat→Ty</a> <a id="4029" href="Cubical.Reflection.RecordEquiv.html#3942" class="Bound">σ</a>

  <a id="4034" class="Comment">-- Recurses on the type of the named record type</a>
  <a id="4085" href="Cubical.Reflection.RecordEquiv.html#4085" class="Function">go</a> <a id="4088" class="Symbol">:</a> <a id="4090" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4095" href="Agda.Builtin.Reflection.html#3615" class="Datatype">R.ArgInfo</a> <a id="4105" class="Symbol">→</a> <a id="4107" href="Agda.Builtin.Reflection.html#4758" class="Function">R.Type</a> <a id="4114" class="Symbol">→</a> <a id="4116" href="Agda.Builtin.Reflection.html#8296" class="Postulate">R.TC</a> <a id="4121" href="Agda.Builtin.Reflection.html#4687" class="Datatype">R.Term</a>
  <a id="4130" href="Cubical.Reflection.RecordEquiv.html#4085" class="Function">go</a> <a id="4133" href="Cubical.Reflection.RecordEquiv.html#4133" class="Bound">acc</a> <a id="4137" class="Symbol">(</a><a id="4138" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">R.pi</a> <a id="4143" class="Symbol">(</a><a id="4144" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">R.arg</a> <a id="4150" href="Cubical.Reflection.RecordEquiv.html#4150" class="Bound">i</a> <a id="4152" href="Cubical.Reflection.RecordEquiv.html#4152" class="Bound">argTy</a><a id="4157" class="Symbol">)</a> <a id="4159" class="Symbol">(</a><a id="4160" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">R.abs</a> <a id="4166" href="Cubical.Reflection.RecordEquiv.html#4166" class="Bound">s</a> <a id="4168" href="Cubical.Reflection.RecordEquiv.html#4168" class="Bound">ty</a><a id="4170" class="Symbol">))</a> <a id="4173" class="Symbol">=</a>
    <a id="4179" class="Comment">-- If the record takes a parameter, the returned isomorphism is likewise parameterized</a>
    <a id="4270" href="Cubical.Reflection.Base.html#459" class="Function">liftTC</a> <a id="4277" class="Symbol">(λ</a> <a id="4280" href="Cubical.Reflection.RecordEquiv.html#4280" class="Bound">t</a> <a id="4282" class="Symbol">→</a> <a id="4284" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">R.pi</a> <a id="4289" class="Symbol">(</a><a id="4290" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">R.arg</a> <a id="4296" href="Cubical.Reflection.RecordEquiv.html#4351" class="Function">i&#39;</a> <a id="4299" href="Cubical.Reflection.RecordEquiv.html#4152" class="Bound">argTy</a><a id="4304" class="Symbol">)</a> <a id="4306" class="Symbol">(</a><a id="4307" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">R.abs</a> <a id="4313" href="Cubical.Reflection.RecordEquiv.html#4166" class="Bound">s</a> <a id="4315" href="Cubical.Reflection.RecordEquiv.html#4280" class="Bound">t</a><a id="4316" class="Symbol">))</a> <a id="4319" class="Symbol">(</a><a id="4320" href="Cubical.Reflection.RecordEquiv.html#4085" class="Function">go</a> <a id="4323" class="Symbol">(</a><a id="4324" href="Cubical.Reflection.RecordEquiv.html#4150" class="Bound">i</a> <a id="4326" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4328" href="Cubical.Reflection.RecordEquiv.html#4133" class="Bound">acc</a><a id="4331" class="Symbol">)</a> <a id="4333" href="Cubical.Reflection.RecordEquiv.html#4168" class="Bound">ty</a><a id="4335" class="Symbol">)</a>
    <a id="4341" class="Keyword">where</a>
    <a id="4351" href="Cubical.Reflection.RecordEquiv.html#4351" class="Function">i&#39;</a> <a id="4354" class="Symbol">=</a> <a id="4356" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">R.arg-info</a> <a id="4367" href="Agda.Builtin.Reflection.html#2770" class="InductiveConstructor">R.hidden</a> <a id="4376" class="Symbol">(</a><a id="4377" href="Agda.Builtin.Reflection.html#3463" class="InductiveConstructor">R.modality</a> <a id="4388" href="Agda.Builtin.Reflection.html#3019" class="InductiveConstructor">R.relevant</a> <a id="4399" href="Agda.Builtin.Reflection.html#3241" class="InductiveConstructor">R.quantity-ω</a><a id="4411" class="Symbol">)</a>
  <a id="4415" href="Cubical.Reflection.RecordEquiv.html#4085" class="Function">go</a> <a id="4418" href="Cubical.Reflection.RecordEquiv.html#4418" class="Bound">acc</a> <a id="4422" class="Symbol">(</a><a id="4423" href="Agda.Builtin.Reflection.html#5171" class="InductiveConstructor">R.agda-sort</a> <a id="4435" class="Symbol">_)</a> <a id="4438" class="Symbol">=</a>
    <a id="4444" class="Comment">-- Main case, constructs isomorphism type</a>
    <a id="4490" href="Agda.Builtin.Reflection.html#8339" class="Postulate">R.returnTC</a> <a id="4501" class="Symbol">(</a><a id="4502" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">R.def</a> <a id="4508" class="Symbol">(</a><a id="4509" class="Keyword">quote</a> <a id="4515" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a><a id="4518" class="Symbol">)</a> <a id="4520" class="Symbol">(</a><a id="4521" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">R.def</a> <a id="4527" href="Cubical.Reflection.RecordEquiv.html#3937" class="Bound">name</a> <a id="4532" class="Symbol">(</a><a id="4533" href="Cubical.Reflection.RecordEquiv.html#4581" class="Function">makeArgs</a> <a id="4542" class="Number">0</a> <a id="4544" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4547" href="Cubical.Reflection.RecordEquiv.html#4418" class="Bound">acc</a><a id="4550" class="Symbol">)</a> <a id="4552" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="4555" href="Cubical.Reflection.RecordEquiv.html#4012" class="Function">σTy</a> <a id="4559" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="4562" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4564" class="Symbol">))</a>
    <a id="4571" class="Keyword">where</a>
    <a id="4581" href="Cubical.Reflection.RecordEquiv.html#4581" class="Function">makeArgs</a> <a id="4590" class="Symbol">:</a> <a id="4592" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4594" class="Symbol">→</a> <a id="4596" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4601" class="Symbol">(</a><a id="4602" href="Agda.Builtin.Reflection.html#3696" class="Datatype">R.Arg</a> <a id="4608" href="Agda.Builtin.Reflection.html#4687" class="Datatype">R.Term</a><a id="4614" class="Symbol">)</a> <a id="4616" class="Symbol">→</a> <a id="4618" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4623" href="Agda.Builtin.Reflection.html#3615" class="Datatype">R.ArgInfo</a> <a id="4633" class="Symbol">→</a> <a id="4635" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4640" class="Symbol">(</a><a id="4641" href="Agda.Builtin.Reflection.html#3696" class="Datatype">R.Arg</a> <a id="4647" href="Agda.Builtin.Reflection.html#4687" class="Datatype">R.Term</a><a id="4653" class="Symbol">)</a>
    <a id="4659" href="Cubical.Reflection.RecordEquiv.html#4581" class="Function">makeArgs</a> <a id="4668" href="Cubical.Reflection.RecordEquiv.html#4668" class="Bound">n</a> <a id="4670" href="Cubical.Reflection.RecordEquiv.html#4670" class="Bound">acc</a> <a id="4674" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4677" class="Symbol">=</a> <a id="4679" href="Cubical.Reflection.RecordEquiv.html#4670" class="Bound">acc</a>
    <a id="4687" href="Cubical.Reflection.RecordEquiv.html#4581" class="Function">makeArgs</a> <a id="4696" href="Cubical.Reflection.RecordEquiv.html#4696" class="Bound">n</a> <a id="4698" href="Cubical.Reflection.RecordEquiv.html#4698" class="Bound">acc</a> <a id="4702" class="Symbol">(</a><a id="4703" href="Cubical.Reflection.RecordEquiv.html#4703" class="Bound">i</a> <a id="4705" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4707" href="Cubical.Reflection.RecordEquiv.html#4707" class="Bound">infos</a><a id="4712" class="Symbol">)</a> <a id="4714" class="Symbol">=</a> <a id="4716" href="Cubical.Reflection.RecordEquiv.html#4581" class="Function">makeArgs</a> <a id="4725" class="Symbol">(</a><a id="4726" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4730" href="Cubical.Reflection.RecordEquiv.html#4696" class="Bound">n</a><a id="4731" class="Symbol">)</a> <a id="4733" class="Symbol">(</a><a id="4734" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">R.arg</a> <a id="4740" href="Cubical.Reflection.RecordEquiv.html#4703" class="Bound">i</a> <a id="4742" class="Symbol">(</a><a id="4743" href="Cubical.Reflection.Base.html#577" class="Function">v</a> <a id="4745" href="Cubical.Reflection.RecordEquiv.html#4696" class="Bound">n</a><a id="4746" class="Symbol">)</a> <a id="4748" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4750" href="Cubical.Reflection.RecordEquiv.html#4698" class="Bound">acc</a><a id="4753" class="Symbol">)</a> <a id="4755" href="Cubical.Reflection.RecordEquiv.html#4707" class="Bound">infos</a>
  <a id="4763" href="Cubical.Reflection.RecordEquiv.html#4085" class="CatchallClause Function">go</a><a id="4765" class="CatchallClause"> </a><a id="4766" class="CatchallClause Symbol">_</a><a id="4767" class="CatchallClause"> </a><a id="4768" class="CatchallClause Symbol">_</a> <a id="4770" class="Symbol">=</a> <a id="4772" href="Agda.Builtin.Reflection.html#8509" class="Postulate">R.typeError</a> <a id="4784" class="Symbol">(</a><a id="4785" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">R.strErr</a> <a id="4794" class="String">&quot;Not a record type name: &quot;</a> <a id="4821" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4823" href="Agda.Builtin.Reflection.html#8009" class="InductiveConstructor">R.nameErr</a> <a id="4833" href="Cubical.Reflection.RecordEquiv.html#3937" class="Bound">name</a> <a id="4838" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4840" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4842" class="Symbol">)</a>

<a id="4845" class="Comment">-- Given an association list `al` defining a correspondence between record types (say R</a>
<a id="4933" class="Comment">-- and S) and a `term` belonging to R, produces clauses defining an element of S, with</a>
<a id="5020" class="Comment">-- each field of S instantiated with a field of `term` according to `al`.  For example,</a>
<a id="5108" class="Comment">-- the correspondence</a>
<a id="5130" class="Comment">--</a>
<a id="5133" class="Comment">--   .fst ↔ .a</a>
<a id="5148" class="Comment">--   .snd .fst ↔ .b</a>
<a id="5168" class="Comment">--   .snd .snd ↔ ∅</a>
<a id="5187" class="Comment">--   ∅ ↔ .c</a>
<a id="5199" class="Comment">--</a>
<a id="5202" class="Comment">-- would produce the clauses</a>
<a id="5231" class="Comment">--</a>
<a id="5234" class="Comment">-- ... .a = term .fst</a>
<a id="5256" class="Comment">-- ... .b = term .snd</a>
<a id="5278" class="Comment">-- ... .c = _</a>
<a id="5292" class="Comment">--</a>
<a id="5295" class="Comment">-- Here the type of .c should have a definitionally unique element, so</a>
<a id="5366" class="Comment">-- we can safely fill it with an unsolved metavariable.</a>
<a id="convertClauses"></a><a id="5422" href="Cubical.Reflection.RecordEquiv.html#5422" class="Function">convertClauses</a> <a id="5437" class="Symbol">:</a> <a id="5439" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a> <a id="5451" class="Symbol">→</a> <a id="5453" href="Agda.Builtin.Reflection.html#4687" class="Datatype">R.Term</a> <a id="5460" class="Symbol">→</a> <a id="5462" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5467" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a>
<a id="5476" href="Cubical.Reflection.RecordEquiv.html#5422" class="Function">convertClauses</a> <a id="5491" href="Cubical.Reflection.RecordEquiv.html#5491" class="Bound">al</a> <a id="5494" href="Cubical.Reflection.RecordEquiv.html#5494" class="Bound">term</a> <a id="5499" class="Symbol">=</a> <a id="5501" href="Cubical.Reflection.RecordEquiv.html#6220" class="Function">fixIfEmpty</a> <a id="5512" class="Symbol">(</a><a id="5513" href="Cubical.Data.List.Base.html#901" class="Function">List.filterMap</a> <a id="5528" href="Cubical.Reflection.RecordEquiv.html#5553" class="Function">makeClause</a> <a id="5539" href="Cubical.Reflection.RecordEquiv.html#5491" class="Bound">al</a><a id="5541" class="Symbol">)</a>
  <a id="5545" class="Keyword">where</a>
  <a id="5553" href="Cubical.Reflection.RecordEquiv.html#5553" class="Function">makeClause</a> <a id="5564" class="Symbol">:</a> <a id="5566" href="Cubical.Data.Maybe.Base.html#180" class="Datatype">Maybe</a> <a id="5572" href="Cubical.Reflection.RecordEquiv.html#870" class="Function">Projections</a> <a id="5584" href="Cubical.Data.Sigma.Base.html#456" class="Function Operator">×</a> <a id="5586" href="Cubical.Data.Maybe.Base.html#180" class="Datatype">Maybe</a> <a id="5592" href="Cubical.Reflection.RecordEquiv.html#870" class="Function">Projections</a> <a id="5604" class="Symbol">→</a> <a id="5606" href="Cubical.Data.Maybe.Base.html#180" class="Datatype">Maybe</a> <a id="5612" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a>
  <a id="5623" href="Cubical.Reflection.RecordEquiv.html#5553" class="Function">makeClause</a> <a id="5634" class="Symbol">(</a><a id="5635" href="Cubical.Reflection.RecordEquiv.html#5635" class="Bound">projl</a> <a id="5641" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5643" href="Cubical.Data.Maybe.Base.html#236" class="InductiveConstructor">just</a> <a id="5648" href="Cubical.Reflection.RecordEquiv.html#5648" class="Bound">projr</a><a id="5653" class="Symbol">)</a> <a id="5655" class="Symbol">=</a>
    <a id="5661" href="Cubical.Data.Maybe.Base.html#236" class="InductiveConstructor">just</a> <a id="5666" class="Symbol">(</a><a id="5667" href="Agda.Builtin.Reflection.html#5800" class="InductiveConstructor">R.clause</a> <a id="5676" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5679" class="Symbol">(</a><a id="5680" href="Cubical.Reflection.RecordEquiv.html#5744" class="Function">goPat</a> <a id="5686" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5689" href="Cubical.Reflection.RecordEquiv.html#5648" class="Bound">projr</a><a id="5694" class="Symbol">)</a> <a id="5696" class="Symbol">(</a><a id="5697" href="Cubical.Data.Maybe.Base.html#456" class="Function">Maybe.rec</a> <a id="5707" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">R.unknown</a> <a id="5717" href="Cubical.Reflection.RecordEquiv.html#5906" class="Function">goTm</a> <a id="5722" href="Cubical.Reflection.RecordEquiv.html#5635" class="Bound">projl</a><a id="5727" class="Symbol">))</a>
    <a id="5734" class="Keyword">where</a>
    <a id="5744" href="Cubical.Reflection.RecordEquiv.html#5744" class="Function">goPat</a> <a id="5750" class="Symbol">:</a> <a id="5752" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5757" class="Symbol">(</a><a id="5758" href="Agda.Builtin.Reflection.html#3696" class="Datatype">R.Arg</a> <a id="5764" href="Agda.Builtin.Reflection.html#4725" class="Datatype">R.Pattern</a><a id="5773" class="Symbol">)</a> <a id="5775" class="Symbol">→</a> <a id="5777" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5782" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="5789" class="Symbol">→</a> <a id="5791" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5796" class="Symbol">(</a><a id="5797" href="Agda.Builtin.Reflection.html#3696" class="Datatype">R.Arg</a> <a id="5803" href="Agda.Builtin.Reflection.html#4725" class="Datatype">R.Pattern</a><a id="5812" class="Symbol">)</a>
    <a id="5818" href="Cubical.Reflection.RecordEquiv.html#5744" class="Function">goPat</a> <a id="5824" href="Cubical.Reflection.RecordEquiv.html#5824" class="Bound">acc</a> <a id="5828" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5831" class="Symbol">=</a> <a id="5833" href="Cubical.Reflection.RecordEquiv.html#5824" class="Bound">acc</a>
    <a id="5841" href="Cubical.Reflection.RecordEquiv.html#5744" class="Function">goPat</a> <a id="5847" href="Cubical.Reflection.RecordEquiv.html#5847" class="Bound">acc</a> <a id="5851" class="Symbol">(</a><a id="5852" href="Cubical.Reflection.RecordEquiv.html#5852" class="Bound">π</a> <a id="5854" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5856" href="Cubical.Reflection.RecordEquiv.html#5856" class="Bound">projs</a><a id="5861" class="Symbol">)</a> <a id="5863" class="Symbol">=</a> <a id="5865" href="Cubical.Reflection.RecordEquiv.html#5744" class="Function">goPat</a> <a id="5871" class="Symbol">(</a><a id="5872" href="Cubical.Reflection.Base.html#618" class="InductiveConstructor">varg</a> <a id="5877" class="Symbol">(</a><a id="5878" href="Agda.Builtin.Reflection.html#5671" class="InductiveConstructor">R.proj</a> <a id="5885" href="Cubical.Reflection.RecordEquiv.html#5852" class="Bound">π</a><a id="5886" class="Symbol">)</a> <a id="5888" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5890" href="Cubical.Reflection.RecordEquiv.html#5847" class="Bound">acc</a><a id="5893" class="Symbol">)</a> <a id="5895" href="Cubical.Reflection.RecordEquiv.html#5856" class="Bound">projs</a>

    <a id="5906" href="Cubical.Reflection.RecordEquiv.html#5906" class="Function">goTm</a> <a id="5911" class="Symbol">:</a> <a id="5913" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5918" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="5925" class="Symbol">→</a> <a id="5927" href="Agda.Builtin.Reflection.html#4687" class="Datatype">R.Term</a>
    <a id="5938" href="Cubical.Reflection.RecordEquiv.html#5906" class="Function">goTm</a> <a id="5943" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5946" class="Symbol">=</a> <a id="5948" href="Cubical.Reflection.RecordEquiv.html#5494" class="Bound">term</a>
    <a id="5957" href="Cubical.Reflection.RecordEquiv.html#5906" class="Function">goTm</a> <a id="5962" class="Symbol">(</a><a id="5963" href="Cubical.Reflection.RecordEquiv.html#5963" class="Bound">π</a> <a id="5965" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5967" href="Cubical.Reflection.RecordEquiv.html#5967" class="Bound">projs</a><a id="5972" class="Symbol">)</a> <a id="5974" class="Symbol">=</a> <a id="5976" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">R.def</a> <a id="5982" href="Cubical.Reflection.RecordEquiv.html#5963" class="Bound">π</a> <a id="5984" href="Cubical.Data.List.Base.html#363" class="Function Operator">[</a> <a id="5986" href="Cubical.Reflection.Base.html#618" class="InductiveConstructor">varg</a> <a id="5991" class="Symbol">(</a><a id="5992" href="Cubical.Reflection.RecordEquiv.html#5906" class="Function">goTm</a> <a id="5997" href="Cubical.Reflection.RecordEquiv.html#5967" class="Bound">projs</a><a id="6002" class="Symbol">)</a> <a id="6004" href="Cubical.Data.List.Base.html#363" class="Function Operator">]</a>
  <a id="6008" href="Cubical.Reflection.RecordEquiv.html#5553" class="Function">makeClause</a> <a id="6019" class="Symbol">(_</a> <a id="6022" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6024" href="Cubical.Data.Maybe.Base.html#216" class="InductiveConstructor">nothing</a><a id="6031" class="Symbol">)</a> <a id="6033" class="Symbol">=</a> <a id="6035" href="Cubical.Data.Maybe.Base.html#216" class="InductiveConstructor">nothing</a>

  <a id="6046" class="Comment">-- If there end up being zero clauses, then S should be a type with a definitionally</a>
  <a id="6133" class="Comment">-- unique element, so we return a single clause defined by an unsolved metavariable.</a>
  <a id="6220" href="Cubical.Reflection.RecordEquiv.html#6220" class="Function">fixIfEmpty</a> <a id="6231" class="Symbol">:</a> <a id="6233" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6238" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a> <a id="6247" class="Symbol">→</a> <a id="6249" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6254" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a>
  <a id="6265" href="Cubical.Reflection.RecordEquiv.html#6220" class="Function">fixIfEmpty</a> <a id="6276" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="6279" class="Symbol">=</a> <a id="6281" href="Cubical.Data.List.Base.html#363" class="Function Operator">[</a> <a id="6283" href="Agda.Builtin.Reflection.html#5800" class="InductiveConstructor">R.clause</a> <a id="6292" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="6295" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="6298" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">R.unknown</a> <a id="6308" href="Cubical.Data.List.Base.html#363" class="Function Operator">]</a>
  <a id="6312" href="Cubical.Reflection.RecordEquiv.html#6220" class="Function">fixIfEmpty</a> <a id="6323" class="Symbol">(</a><a id="6324" href="Cubical.Reflection.RecordEquiv.html#6324" class="Bound">c</a> <a id="6326" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6328" href="Cubical.Reflection.RecordEquiv.html#6328" class="Bound">cs</a><a id="6330" class="Symbol">)</a> <a id="6332" class="Symbol">=</a> <a id="6334" href="Cubical.Reflection.RecordEquiv.html#6324" class="Bound">c</a> <a id="6336" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6338" href="Cubical.Reflection.RecordEquiv.html#6328" class="Bound">cs</a>

<a id="6342" class="Comment">-- Apply functions to the telescope and pattern parts of a clause</a>
<a id="mapClause"></a><a id="6408" href="Cubical.Reflection.RecordEquiv.html#6408" class="Function">mapClause</a> <a id="6418" class="Symbol">:</a>
  <a id="6422" class="Symbol">(</a><a id="6423" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6428" class="Symbol">(</a><a id="6429" href="Agda.Builtin.String.html#335" class="Postulate">String</a> <a id="6436" href="Cubical.Data.Sigma.Base.html#456" class="Function Operator">×</a> <a id="6438" href="Agda.Builtin.Reflection.html#3696" class="Datatype">R.Arg</a> <a id="6444" href="Agda.Builtin.Reflection.html#4758" class="Function">R.Type</a><a id="6450" class="Symbol">)</a> <a id="6452" class="Symbol">→</a> <a id="6454" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6459" class="Symbol">(</a><a id="6460" href="Agda.Builtin.String.html#335" class="Postulate">String</a> <a id="6467" href="Cubical.Data.Sigma.Base.html#456" class="Function Operator">×</a> <a id="6469" href="Agda.Builtin.Reflection.html#3696" class="Datatype">R.Arg</a> <a id="6475" href="Agda.Builtin.Reflection.html#4758" class="Function">R.Type</a><a id="6481" class="Symbol">))</a>
  <a id="6486" class="Symbol">→</a> <a id="6488" class="Symbol">(</a><a id="6489" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6494" class="Symbol">(</a><a id="6495" href="Agda.Builtin.Reflection.html#3696" class="Datatype">R.Arg</a> <a id="6501" href="Agda.Builtin.Reflection.html#4725" class="Datatype">R.Pattern</a><a id="6510" class="Symbol">)</a> <a id="6512" class="Symbol">→</a> <a id="6514" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6519" class="Symbol">(</a><a id="6520" href="Agda.Builtin.Reflection.html#3696" class="Datatype">R.Arg</a> <a id="6526" href="Agda.Builtin.Reflection.html#4725" class="Datatype">R.Pattern</a><a id="6535" class="Symbol">))</a>
  <a id="6540" class="Symbol">→</a> <a id="6542" class="Symbol">(</a><a id="6543" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a> <a id="6552" class="Symbol">→</a> <a id="6554" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a><a id="6562" class="Symbol">)</a>
<a id="6564" href="Cubical.Reflection.RecordEquiv.html#6408" class="Function">mapClause</a> <a id="6574" href="Cubical.Reflection.RecordEquiv.html#6574" class="Bound">f</a> <a id="6576" href="Cubical.Reflection.RecordEquiv.html#6576" class="Bound">g</a> <a id="6578" class="Symbol">(</a><a id="6579" href="Agda.Builtin.Reflection.html#5800" class="InductiveConstructor">R.clause</a> <a id="6588" href="Cubical.Reflection.RecordEquiv.html#6588" class="Bound">tel</a> <a id="6592" href="Cubical.Reflection.RecordEquiv.html#6592" class="Bound">ps</a> <a id="6595" href="Cubical.Reflection.RecordEquiv.html#6595" class="Bound">t</a><a id="6596" class="Symbol">)</a> <a id="6598" class="Symbol">=</a> <a id="6600" href="Agda.Builtin.Reflection.html#5800" class="InductiveConstructor">R.clause</a> <a id="6609" class="Symbol">(</a><a id="6610" href="Cubical.Reflection.RecordEquiv.html#6574" class="Bound">f</a> <a id="6612" href="Cubical.Reflection.RecordEquiv.html#6588" class="Bound">tel</a><a id="6615" class="Symbol">)</a> <a id="6617" class="Symbol">(</a><a id="6618" href="Cubical.Reflection.RecordEquiv.html#6576" class="Bound">g</a> <a id="6620" href="Cubical.Reflection.RecordEquiv.html#6592" class="Bound">ps</a><a id="6622" class="Symbol">)</a> <a id="6624" href="Cubical.Reflection.RecordEquiv.html#6595" class="Bound">t</a>
<a id="6626" href="Cubical.Reflection.RecordEquiv.html#6408" class="Function">mapClause</a> <a id="6636" href="Cubical.Reflection.RecordEquiv.html#6636" class="Bound">f</a> <a id="6638" href="Cubical.Reflection.RecordEquiv.html#6638" class="Bound">g</a> <a id="6640" class="Symbol">(</a><a id="6641" href="Agda.Builtin.Reflection.html#5882" class="InductiveConstructor">R.absurd-clause</a> <a id="6657" href="Cubical.Reflection.RecordEquiv.html#6657" class="Bound">tel</a> <a id="6661" href="Cubical.Reflection.RecordEquiv.html#6661" class="Bound">ps</a><a id="6663" class="Symbol">)</a> <a id="6665" class="Symbol">=</a> <a id="6667" href="Agda.Builtin.Reflection.html#5882" class="InductiveConstructor">R.absurd-clause</a> <a id="6683" class="Symbol">(</a><a id="6684" href="Cubical.Reflection.RecordEquiv.html#6636" class="Bound">f</a> <a id="6686" href="Cubical.Reflection.RecordEquiv.html#6657" class="Bound">tel</a><a id="6689" class="Symbol">)</a> <a id="6691" class="Symbol">(</a><a id="6692" href="Cubical.Reflection.RecordEquiv.html#6638" class="Bound">g</a> <a id="6694" href="Cubical.Reflection.RecordEquiv.html#6661" class="Bound">ps</a><a id="6696" class="Symbol">)</a>

<a id="6699" class="Comment">-- Given a ΣFormat `σ` relating a record type R and Σ-type S, returns</a>
<a id="6769" class="Comment">-- a list of clauses defining an isomorphism between R and S.</a>
<a id="recordIsoΣClauses"></a><a id="6831" href="Cubical.Reflection.RecordEquiv.html#6831" class="Function">recordIsoΣClauses</a> <a id="6849" class="Symbol">:</a> <a id="6851" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="6859" class="Symbol">→</a> <a id="6861" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6866" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a>
<a id="6875" href="Cubical.Reflection.RecordEquiv.html#6831" class="Function">recordIsoΣClauses</a> <a id="6893" href="Cubical.Reflection.RecordEquiv.html#6893" class="Bound">σ</a> <a id="6895" class="Symbol">=</a>
  <a id="6899" href="Cubical.Reflection.RecordEquiv.html#7367" class="Function">funClauses</a> <a id="6910" class="Symbol">(</a><a id="6911" class="Keyword">quote</a> <a id="6917" href="Cubical.Foundations.Isomorphism.html#885" class="Field">Iso.fun</a><a id="6924" class="Symbol">)</a> <a id="6926" href="Cubical.Reflection.RecordEquiv.html#7120" class="Function">R↔Σ</a> <a id="6930" href="Cubical.Data.List.Base.html#400" class="Function Operator">++</a>
  <a id="6935" href="Cubical.Reflection.RecordEquiv.html#7367" class="Function">funClauses</a> <a id="6946" class="Symbol">(</a><a id="6947" class="Keyword">quote</a> <a id="6953" href="Cubical.Foundations.Isomorphism.html#901" class="Field">Iso.inv</a><a id="6960" class="Symbol">)</a> <a id="6962" href="Cubical.Reflection.RecordEquiv.html#7150" class="Function">Σ↔R</a> <a id="6966" href="Cubical.Data.List.Base.html#400" class="Function Operator">++</a>
  <a id="6971" class="Comment">-- Clauses for the forward and backward inverse conditions</a>
  <a id="7032" href="Cubical.Reflection.RecordEquiv.html#7931" class="Function">pathClauses</a> <a id="7044" class="Symbol">(</a><a id="7045" class="Keyword">quote</a> <a id="7051" href="Cubical.Foundations.Isomorphism.html#917" class="Field">Iso.rightInv</a><a id="7063" class="Symbol">)</a> <a id="7065" href="Cubical.Reflection.RecordEquiv.html#7150" class="Function">Σ↔R</a> <a id="7069" href="Cubical.Data.List.Base.html#400" class="Function Operator">++</a>
  <a id="7074" href="Cubical.Reflection.RecordEquiv.html#7931" class="Function">pathClauses</a> <a id="7086" class="Symbol">(</a><a id="7087" class="Keyword">quote</a> <a id="7093" href="Cubical.Foundations.Isomorphism.html#948" class="Field">Iso.leftInv</a><a id="7104" class="Symbol">)</a> <a id="7106" href="Cubical.Reflection.RecordEquiv.html#7120" class="Function">R↔Σ</a>
  <a id="7112" class="Keyword">where</a>
  <a id="7120" href="Cubical.Reflection.RecordEquiv.html#7120" class="Function">R↔Σ</a> <a id="7124" class="Symbol">=</a> <a id="7126" href="Cubical.Reflection.RecordEquiv.html#2801" class="Function">ΣFormat→RecordAssoc</a> <a id="7146" href="Cubical.Reflection.RecordEquiv.html#6893" class="Bound">σ</a>
  <a id="7150" href="Cubical.Reflection.RecordEquiv.html#7150" class="Function">Σ↔R</a> <a id="7154" class="Symbol">=</a> <a id="7156" href="Cubical.Reflection.RecordEquiv.html#2122" class="Function">flipRecordAssoc</a> <a id="7172" href="Cubical.Reflection.RecordEquiv.html#7120" class="Function">R↔Σ</a>

  <a id="7179" class="Comment">-- Given an association list `al` for a correspondence R ↔ S, produces the list of</a>
  <a id="7264" class="Comment">-- clauses defining a function from R to S.</a>
  <a id="7310" class="Comment">-- The `prefix` will be either `Iso.fun` or `Iso.inv`.</a>
  <a id="7367" href="Cubical.Reflection.RecordEquiv.html#7367" class="Function">funClauses</a> <a id="7378" class="Symbol">:</a> <a id="7380" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="7387" class="Symbol">→</a> <a id="7389" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a> <a id="7401" class="Symbol">→</a> <a id="7403" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="7408" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a>
  <a id="7419" href="Cubical.Reflection.RecordEquiv.html#7367" class="Function">funClauses</a> <a id="7430" href="Cubical.Reflection.RecordEquiv.html#7430" class="Bound">prefix</a> <a id="7437" href="Cubical.Reflection.RecordEquiv.html#7437" class="Bound">al</a> <a id="7440" class="Symbol">=</a>
    <a id="7446" href="Cubical.Data.List.Base.html#610" class="Function">List.map</a>
      <a id="7461" class="Comment">-- Introduce a new variable of the input type</a>
      <a id="7513" class="Symbol">(</a><a id="7514" href="Cubical.Reflection.RecordEquiv.html#6408" class="Function">mapClause</a>
        <a id="7532" class="Symbol">((</a><a id="7534" class="String">&quot;_&quot;</a> <a id="7538" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7540" href="Cubical.Reflection.Base.html#618" class="InductiveConstructor">varg</a> <a id="7545" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">R.unknown</a><a id="7554" class="Symbol">)</a> <a id="7556" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷_</a><a id="7558" class="Symbol">)</a>
        <a id="7568" class="Symbol">(λ</a> <a id="7571" href="Cubical.Reflection.RecordEquiv.html#7571" class="Bound">ps</a> <a id="7574" class="Symbol">→</a> <a id="7576" href="Agda.Builtin.Reflection.html#5671" class="InductiveConstructor">R.proj</a> <a id="7583" href="Cubical.Reflection.RecordEquiv.html#7430" class="Bound">prefix</a> <a id="7590" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="7593" href="Agda.Builtin.Reflection.html#5601" class="InductiveConstructor">R.var</a> <a id="7599" class="Number">0</a> <a id="7601" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="7604" href="Cubical.Reflection.RecordEquiv.html#7571" class="Bound">ps</a><a id="7606" class="Symbol">))</a>
      <a id="7615" class="Comment">-- Each clause is a projection applied to the input variable</a>
      <a id="7682" class="Symbol">(</a><a id="7683" href="Cubical.Reflection.RecordEquiv.html#5422" class="Function">convertClauses</a> <a id="7698" href="Cubical.Reflection.RecordEquiv.html#7437" class="Bound">al</a> <a id="7701" class="Symbol">(</a><a id="7702" href="Cubical.Reflection.Base.html#577" class="Function">v</a> <a id="7704" class="Number">0</a><a id="7705" class="Symbol">))</a>

  <a id="7711" class="Comment">-- Given an association list `al` for a correspondence R ↔ S, produces the list of</a>
  <a id="7796" class="Comment">-- clauses defining the inverse path for the round-trip R → S → R.</a>
  <a id="7865" class="Comment">-- The `prefix` will be either `Iso.rightInv` or `Iso.leftInv`.</a>
  <a id="7931" href="Cubical.Reflection.RecordEquiv.html#7931" class="Function">pathClauses</a> <a id="7943" class="Symbol">:</a> <a id="7945" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="7952" class="Symbol">→</a> <a id="7954" href="Cubical.Reflection.RecordEquiv.html#1446" class="Function">RecordAssoc</a> <a id="7966" class="Symbol">→</a> <a id="7968" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="7973" href="Agda.Builtin.Reflection.html#4744" class="Datatype">R.Clause</a>
  <a id="7984" href="Cubical.Reflection.RecordEquiv.html#7931" class="Function">pathClauses</a> <a id="7996" href="Cubical.Reflection.RecordEquiv.html#7996" class="Bound">prefix</a> <a id="8003" href="Cubical.Reflection.RecordEquiv.html#8003" class="Bound">al</a> <a id="8006" class="Symbol">=</a>
    <a id="8012" href="Cubical.Data.List.Base.html#610" class="Function">List.map</a>
      <a id="8027" class="Comment">-- Introduce a variable of the input type and an interval variable</a>
      <a id="8100" class="Symbol">(</a><a id="8101" href="Cubical.Reflection.RecordEquiv.html#6408" class="Function">mapClause</a>
        <a id="8119" class="Symbol">(λ</a> <a id="8122" href="Cubical.Reflection.RecordEquiv.html#8122" class="Bound">vs</a> <a id="8125" class="Symbol">→</a> <a id="8127" class="Symbol">(</a><a id="8128" class="String">&quot;_&quot;</a> <a id="8132" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8134" href="Cubical.Reflection.Base.html#618" class="InductiveConstructor">varg</a> <a id="8139" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">R.unknown</a><a id="8148" class="Symbol">)</a> <a id="8150" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="8152" class="Symbol">(</a><a id="8153" class="String">&quot;_&quot;</a> <a id="8157" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8159" href="Cubical.Reflection.Base.html#618" class="InductiveConstructor">varg</a> <a id="8164" class="Symbol">(</a><a id="8165" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">R.def</a> <a id="8171" class="Symbol">(</a><a id="8172" class="Keyword">quote</a> <a id="8178" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="8179" class="Symbol">)</a> <a id="8181" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8183" class="Symbol">))</a> <a id="8186" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="8188" href="Cubical.Reflection.RecordEquiv.html#8122" class="Bound">vs</a><a id="8190" class="Symbol">)</a>
        <a id="8200" class="Symbol">(λ</a> <a id="8203" href="Cubical.Reflection.RecordEquiv.html#8203" class="Bound">ps</a> <a id="8206" class="Symbol">→</a> <a id="8208" href="Agda.Builtin.Reflection.html#5671" class="InductiveConstructor">R.proj</a> <a id="8215" href="Cubical.Reflection.RecordEquiv.html#7996" class="Bound">prefix</a> <a id="8222" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="8225" href="Agda.Builtin.Reflection.html#5601" class="InductiveConstructor">R.var</a> <a id="8231" class="Number">1</a> <a id="8233" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="8236" href="Agda.Builtin.Reflection.html#5601" class="InductiveConstructor">R.var</a> <a id="8242" class="Number">0</a> <a id="8244" href="Cubical.Reflection.Base.html#784" class="InductiveConstructor Operator">v∷</a> <a id="8247" href="Cubical.Reflection.RecordEquiv.html#8203" class="Bound">ps</a><a id="8249" class="Symbol">))</a>
      <a id="8258" class="Comment">-- The inverse condition at each clause holds by reflexivity</a>
      <a id="8325" class="Symbol">(</a><a id="8326" href="Cubical.Reflection.RecordEquiv.html#5422" class="Function">convertClauses</a> <a id="8341" class="Symbol">(</a><a id="8342" href="Cubical.Reflection.RecordEquiv.html#2302" class="Function">fstIdRecordAssoc</a> <a id="8359" href="Cubical.Reflection.RecordEquiv.html#8003" class="Bound">al</a><a id="8361" class="Symbol">)</a> <a id="8363" class="Symbol">(</a><a id="8364" href="Cubical.Reflection.Base.html#577" class="Function">v</a> <a id="8366" class="Number">1</a><a id="8367" class="Symbol">))</a>

<a id="8371" class="Comment">------------------------------------------------------------------------------------------</a>
<a id="8462" class="Comment">-- Main functions</a>
<a id="8480" class="Comment">------------------------------------------------------------------------------------------</a>

<a id="8572" class="Comment">-- Given a ΣFormat describing a correspondence between a record and nested Σ-type,</a>
<a id="8655" class="Comment">-- constructs an isomorphism between them as a term.</a>
<a id="8708" class="Comment">--</a>
<a id="8711" class="Comment">-- Because this term is a large pattern-matching lambda, it is better to use the</a>
<a id="8792" class="Comment">-- declare* functions below, which declare a named function.</a>
<a id="recordIsoΣTerm"></a><a id="8853" href="Cubical.Reflection.RecordEquiv.html#8853" class="Function">recordIsoΣTerm</a> <a id="8868" class="Symbol">:</a> <a id="8870" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="8878" class="Symbol">→</a> <a id="8880" href="Agda.Builtin.Reflection.html#4687" class="Datatype">R.Term</a>
<a id="8887" href="Cubical.Reflection.RecordEquiv.html#8853" class="Function">recordIsoΣTerm</a> <a id="8902" href="Cubical.Reflection.RecordEquiv.html#8902" class="Bound">σ</a> <a id="8904" class="Symbol">=</a> <a id="8906" href="Agda.Builtin.Reflection.html#5055" class="InductiveConstructor">R.pat-lam</a> <a id="8916" class="Symbol">(</a><a id="8917" href="Cubical.Reflection.RecordEquiv.html#6831" class="Function">recordIsoΣClauses</a> <a id="8935" href="Cubical.Reflection.RecordEquiv.html#8902" class="Bound">σ</a><a id="8936" class="Symbol">)</a> <a id="8938" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="8942" class="Comment">-- Given a name `idName`, a ΣFormat `σ` describing a correspondence between a record and</a>
<a id="9031" class="Comment">-- nested Σ-type, and the name `recordName` of the record type, declares a function with</a>
<a id="9120" class="Comment">-- name `idName` defining an isomorphism between the two types (with implicit parameters</a>
<a id="9209" class="Comment">-- corresponding to the parameters and indices of the record type).</a>
<a id="declareRecordIsoΣ&#39;"></a><a id="9277" href="Cubical.Reflection.RecordEquiv.html#9277" class="Function">declareRecordIsoΣ&#39;</a> <a id="9296" class="Symbol">:</a> <a id="9298" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="9305" class="Symbol">→</a> <a id="9307" href="Cubical.Reflection.RecordEquiv.html#1955" class="Datatype">ΣFormat</a> <a id="9315" class="Symbol">→</a> <a id="9317" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="9324" class="Symbol">→</a> <a id="9326" href="Agda.Builtin.Reflection.html#8296" class="Postulate">R.TC</a> <a id="9331" href="Cubical.Data.Unit.Base.html#171" class="Record">Unit</a>
<a id="9336" href="Cubical.Reflection.RecordEquiv.html#9277" class="Function">declareRecordIsoΣ&#39;</a> <a id="9355" href="Cubical.Reflection.RecordEquiv.html#9355" class="Bound">idName</a> <a id="9362" href="Cubical.Reflection.RecordEquiv.html#9362" class="Bound">σ</a> <a id="9364" href="Cubical.Reflection.RecordEquiv.html#9364" class="Bound">recordName</a> <a id="9375" class="Symbol">=</a>
  <a id="9379" href="Cubical.Reflection.RecordEquiv.html#3870" class="Function">recordName→isoTy</a> <a id="9396" href="Cubical.Reflection.RecordEquiv.html#9364" class="Bound">recordName</a> <a id="9407" href="Cubical.Reflection.RecordEquiv.html#9362" class="Bound">σ</a> <a id="9409" href="Cubical.Reflection.Base.html#302" class="Function Operator">&gt;&gt;=</a> <a id="9413" class="Symbol">λ</a> <a id="9415" href="Cubical.Reflection.RecordEquiv.html#9415" class="Bound">isoTy</a> <a id="9421" class="Symbol">→</a>
  <a id="9425" href="Agda.Builtin.Reflection.html#9147" class="Postulate">R.declareDef</a> <a id="9438" class="Symbol">(</a><a id="9439" href="Cubical.Reflection.Base.html#618" class="InductiveConstructor">varg</a> <a id="9444" href="Cubical.Reflection.RecordEquiv.html#9355" class="Bound">idName</a><a id="9450" class="Symbol">)</a> <a id="9452" href="Cubical.Reflection.RecordEquiv.html#9415" class="Bound">isoTy</a> <a id="9458" href="Cubical.Reflection.Base.html#338" class="Function Operator">&gt;&gt;</a>
  <a id="9463" href="Agda.Builtin.Reflection.html#9343" class="Postulate">R.defineFun</a> <a id="9475" href="Cubical.Reflection.RecordEquiv.html#9355" class="Bound">idName</a> <a id="9482" class="Symbol">(</a><a id="9483" href="Cubical.Reflection.RecordEquiv.html#6831" class="Function">recordIsoΣClauses</a> <a id="9501" href="Cubical.Reflection.RecordEquiv.html#9362" class="Bound">σ</a><a id="9502" class="Symbol">)</a>

<a id="9505" class="Comment">-- Given a name `idName` and the name `recordName` of a record type, declares a function</a>
<a id="9594" class="Comment">-- with name `idName` defining an isomorphism from the record type to the right-associated</a>
<a id="9685" class="Comment">-- Σ-type corresponding to its list of fields (with implicit parameters corresponding to</a>
<a id="9774" class="Comment">-- the parameters and indices of the record type).</a>
<a id="declareRecordIsoΣ"></a><a id="9825" href="Cubical.Reflection.RecordEquiv.html#9825" class="Function">declareRecordIsoΣ</a> <a id="9843" class="Symbol">:</a> <a id="9845" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="9852" class="Symbol">→</a> <a id="9854" href="Agda.Builtin.Reflection.html#488" class="Postulate">R.Name</a> <a id="9861" class="Symbol">→</a> <a id="9863" href="Agda.Builtin.Reflection.html#8296" class="Postulate">R.TC</a> <a id="9868" href="Cubical.Data.Unit.Base.html#171" class="Record">Unit</a>
<a id="9873" href="Cubical.Reflection.RecordEquiv.html#9825" class="Function">declareRecordIsoΣ</a> <a id="9891" href="Cubical.Reflection.RecordEquiv.html#9891" class="Bound">idName</a> <a id="9898" href="Cubical.Reflection.RecordEquiv.html#9898" class="Bound">recordName</a> <a id="9909" class="Symbol">=</a>
  <a id="9913" href="Agda.Builtin.Reflection.html#9426" class="Postulate">R.getDefinition</a> <a id="9929" href="Cubical.Reflection.RecordEquiv.html#9898" class="Bound">recordName</a> <a id="9940" href="Cubical.Reflection.Base.html#302" class="Function Operator">&gt;&gt;=</a> <a id="9944" class="Symbol">λ</a> <a id="9946" class="Keyword">where</a>
  <a id="9954" class="Symbol">(</a><a id="9955" href="Agda.Builtin.Reflection.html#7311" class="InductiveConstructor">R.record-type</a> <a id="9969" class="Symbol">_</a> <a id="9971" href="Cubical.Reflection.RecordEquiv.html#9971" class="Bound">fs</a><a id="9973" class="Symbol">)</a> <a id="9975" class="Symbol">→</a>
    <a id="9981" class="Keyword">let</a> <a id="9985" href="Cubical.Reflection.RecordEquiv.html#9985" class="Bound">σ</a> <a id="9987" class="Symbol">=</a> <a id="9989" href="Cubical.Reflection.RecordEquiv.html#2504" class="Function">List→ΣFormat</a> <a id="10002" class="Symbol">(</a><a id="10003" href="Cubical.Data.List.Base.html#610" class="Function">List.map</a> <a id="10012" class="Symbol">(λ</a> <a id="10015" class="Symbol">{(</a><a id="10017" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">R.arg</a> <a id="10023" class="Symbol">_</a> <a id="10025" href="Cubical.Reflection.RecordEquiv.html#10025" class="Bound">n</a><a id="10026" class="Symbol">)</a> <a id="10028" class="Symbol">→</a> <a id="10030" href="Cubical.Reflection.RecordEquiv.html#10025" class="Bound">n</a><a id="10031" class="Symbol">})</a> <a id="10034" href="Cubical.Reflection.RecordEquiv.html#9971" class="Bound">fs</a><a id="10036" class="Symbol">)</a> <a id="10038" class="Keyword">in</a>
    <a id="10045" href="Cubical.Reflection.RecordEquiv.html#9277" class="Function">declareRecordIsoΣ&#39;</a> <a id="10064" href="Cubical.Reflection.RecordEquiv.html#9891" class="Bound">idName</a> <a id="10071" href="Cubical.Reflection.RecordEquiv.html#9985" class="Bound">σ</a> <a id="10073" href="Cubical.Reflection.RecordEquiv.html#9898" class="Bound">recordName</a>
  <a id="10086" class="CatchallClause Symbol">_</a> <a id="10088" class="Symbol">→</a>
    <a id="10094" href="Agda.Builtin.Reflection.html#8509" class="Postulate">R.typeError</a> <a id="10106" class="Symbol">(</a><a id="10107" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">R.strErr</a> <a id="10116" class="String">&quot;Not a record type name:&quot;</a> <a id="10142" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10144" href="Agda.Builtin.Reflection.html#8009" class="InductiveConstructor">R.nameErr</a> <a id="10154" href="Cubical.Reflection.RecordEquiv.html#9898" class="Bound">recordName</a> <a id="10165" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10167" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10169" class="Symbol">)</a>


<a id="10173" class="Comment">------------------------------------------------------------------------------------------</a>
<a id="10264" class="Comment">-- Examples</a>
<a id="10276" class="Comment">------------------------------------------------------------------------------------------</a>

<a id="10368" class="Keyword">private</a>
  <a id="10378" class="Keyword">module</a> <a id="Example"></a><a id="10385" href="Cubical.Reflection.RecordEquiv.html#10385" class="Module">Example</a> <a id="10393" class="Keyword">where</a>
    <a id="10403" class="Keyword">variable</a>
      <a id="10418" href="Cubical.Reflection.RecordEquiv.html#10418" class="Generalizable">ℓ</a> <a id="10420" href="Cubical.Reflection.RecordEquiv.html#10420" class="Generalizable">ℓ&#39;</a> <a id="10423" class="Symbol">:</a> <a id="10425" href="Agda.Primitive.html#644" class="Postulate">Level</a>
      <a id="10437" href="Cubical.Reflection.RecordEquiv.html#10437" class="Generalizable">A</a> <a id="10439" class="Symbol">:</a> <a id="10441" href="Agda.Primitive.html#337" class="Primitive">Type</a> <a id="10446" href="Cubical.Reflection.RecordEquiv.html#10418" class="Generalizable">ℓ</a>
      <a id="10454" href="Cubical.Reflection.RecordEquiv.html#10454" class="Generalizable">B</a> <a id="10456" class="Symbol">:</a> <a id="10458" href="Cubical.Reflection.RecordEquiv.html#10437" class="Generalizable">A</a> <a id="10460" class="Symbol">→</a> <a id="10462" href="Agda.Primitive.html#337" class="Primitive">Type</a> <a id="10467" href="Cubical.Reflection.RecordEquiv.html#10420" class="Generalizable">ℓ&#39;</a>

    <a id="10475" class="Keyword">record</a> <a id="Example.Example0"></a><a id="10482" href="Cubical.Reflection.RecordEquiv.html#10482" class="Record">Example0</a> <a id="10491" class="Symbol">{</a><a id="10492" href="Cubical.Reflection.RecordEquiv.html#10492" class="Bound">A</a> <a id="10494" class="Symbol">:</a> <a id="10496" href="Agda.Primitive.html#337" class="Primitive">Type</a> <a id="10501" href="Cubical.Reflection.RecordEquiv.html#10418" class="Generalizable">ℓ</a><a id="10502" class="Symbol">}</a> <a id="10504" class="Symbol">(</a><a id="10505" href="Cubical.Reflection.RecordEquiv.html#10505" class="Bound">B</a> <a id="10507" class="Symbol">:</a> <a id="10509" href="Cubical.Reflection.RecordEquiv.html#10492" class="Bound">A</a> <a id="10511" class="Symbol">→</a> <a id="10513" href="Agda.Primitive.html#337" class="Primitive">Type</a> <a id="10518" href="Cubical.Reflection.RecordEquiv.html#10420" class="Generalizable">ℓ&#39;</a><a id="10520" class="Symbol">)</a> <a id="10522" class="Symbol">:</a> <a id="10524" href="Agda.Primitive.html#337" class="Primitive">Type</a> <a id="10529" class="Symbol">(</a><a id="10530" href="Agda.Primitive.html#863" class="Primitive">ℓ-max</a> <a id="10536" href="Cubical.Reflection.RecordEquiv.html#10501" class="Bound">ℓ</a> <a id="10538" href="Cubical.Reflection.RecordEquiv.html#10518" class="Bound">ℓ&#39;</a><a id="10540" class="Symbol">)</a> <a id="10542" class="Keyword">where</a>
      <a id="10554" class="Keyword">no-eta-equality</a> <a id="10570" class="Comment">-- works with or without eta equality</a>
      <a id="10614" class="Keyword">field</a>
        <a id="Example.Example0.cool"></a><a id="10628" href="Cubical.Reflection.RecordEquiv.html#10628" class="Field">cool</a> <a id="10633" class="Symbol">:</a> <a id="10635" href="Cubical.Reflection.RecordEquiv.html#10492" class="Bound">A</a>
        <a id="Example.Example0.fun"></a><a id="10645" href="Cubical.Reflection.RecordEquiv.html#10645" class="Field">fun</a> <a id="10649" class="Symbol">:</a> <a id="10651" href="Cubical.Reflection.RecordEquiv.html#10492" class="Bound">A</a>
        <a id="Example.Example0.wow"></a><a id="10661" href="Cubical.Reflection.RecordEquiv.html#10661" class="Field">wow</a> <a id="10665" class="Symbol">:</a> <a id="10667" href="Cubical.Reflection.RecordEquiv.html#10505" class="Bound">B</a> <a id="10669" href="Cubical.Reflection.RecordEquiv.html#10628" class="Field">cool</a>

    <a id="10679" class="Comment">-- Declares a function `Example0IsoΣ` that gives an isomorphism between the record type and a</a>
    <a id="10777" class="Comment">-- right-associated nested Σ-type (with the parameters to Example0 as implict arguments).</a>
    <a id="10871" class="Keyword">unquoteDecl</a> <a id="Example.Example0IsoΣ"></a><a id="10883" href="Cubical.Reflection.RecordEquiv.html#10883" class="Function">Example0IsoΣ</a> <a id="10896" class="Symbol">=</a> <a id="10898" href="Cubical.Reflection.RecordEquiv.html#9825" class="Function">declareRecordIsoΣ</a> <a id="10916" href="Cubical.Reflection.RecordEquiv.html#10883" class="Function">Example0IsoΣ</a> <a id="10929" class="Symbol">(</a><a id="10930" class="Keyword">quote</a> <a id="10936" href="Cubical.Reflection.RecordEquiv.html#10482" class="Record">Example0</a><a id="10944" class="Symbol">)</a>

    <a id="10951" class="Comment">-- `Example0IsoΣ` has the type we expect</a>
    <a id="Example.test0"></a><a id="10996" href="Cubical.Reflection.RecordEquiv.html#10996" class="Function">test0</a> <a id="11002" class="Symbol">:</a> <a id="11004" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="11008" class="Symbol">(</a><a id="11009" href="Cubical.Reflection.RecordEquiv.html#10482" class="Record">Example0</a> <a id="11018" href="Cubical.Reflection.RecordEquiv.html#10454" class="Generalizable">B</a><a id="11019" class="Symbol">)</a> <a id="11021" class="Symbol">(</a><a id="11022" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="11025" href="Cubical.Reflection.RecordEquiv.html#11025" class="Bound">a</a> <a id="11027" href="Cubical.Core.Primitives.html#6268" class="Function">꞉</a> <a id="11029" href="Cubical.Reflection.RecordEquiv.html#10437" class="Generalizable">A</a> <a id="11031" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="11033" class="Symbol">(</a><a id="11034" href="Cubical.Core.Primitives.html#6268" class="Function">Σ[</a> <a id="11037" href="Cubical.Reflection.RecordEquiv.html#11037" class="Symbol">_</a> <a id="11039" href="Cubical.Core.Primitives.html#6268" class="Function">꞉</a> <a id="11041" href="Cubical.Reflection.RecordEquiv.html#10437" class="Generalizable">A</a> <a id="11043" href="Cubical.Core.Primitives.html#6268" class="Function">]</a> <a id="11045" href="Cubical.Reflection.RecordEquiv.html#10454" class="Generalizable">B</a> <a id="11047" href="Cubical.Reflection.RecordEquiv.html#11025" class="Bound">a</a><a id="11048" class="Symbol">))</a>
    <a id="11055" href="Cubical.Reflection.RecordEquiv.html#10996" class="Function">test0</a> <a id="11061" class="Symbol">=</a> <a id="11063" href="Cubical.Reflection.RecordEquiv.html#10883" class="Function">Example0IsoΣ</a>

    <a id="11081" class="Comment">-- A record with no fields is isomorphic to Unit</a>

    <a id="11135" class="Keyword">record</a> <a id="Example.Example1"></a><a id="11142" href="Cubical.Reflection.RecordEquiv.html#11142" class="Record">Example1</a> <a id="11151" class="Symbol">:</a> <a id="11153" href="Agda.Primitive.html#337" class="Primitive">Type</a> <a id="11158" class="Keyword">where</a>

    <a id="11169" class="Keyword">unquoteDecl</a> <a id="Example.Example1IsoΣ"></a><a id="11181" href="Cubical.Reflection.RecordEquiv.html#11181" class="Function">Example1IsoΣ</a> <a id="11194" class="Symbol">=</a> <a id="11196" href="Cubical.Reflection.RecordEquiv.html#9825" class="Function">declareRecordIsoΣ</a> <a id="11214" href="Cubical.Reflection.RecordEquiv.html#11181" class="Function">Example1IsoΣ</a> <a id="11227" class="Symbol">(</a><a id="11228" class="Keyword">quote</a> <a id="11234" href="Cubical.Reflection.RecordEquiv.html#11142" class="Record">Example1</a><a id="11242" class="Symbol">)</a>

    <a id="Example.test1"></a><a id="11249" href="Cubical.Reflection.RecordEquiv.html#11249" class="Function">test1</a> <a id="11255" class="Symbol">:</a> <a id="11257" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="11261" href="Cubical.Reflection.RecordEquiv.html#11142" class="Record">Example1</a> <a id="11270" href="Cubical.Data.Unit.Base.html#171" class="Record">Unit</a>
    <a id="11279" href="Cubical.Reflection.RecordEquiv.html#11249" class="Function">test1</a> <a id="11285" class="Symbol">=</a> <a id="11287" href="Cubical.Reflection.RecordEquiv.html#11181" class="Function">Example1IsoΣ</a>
</pre></body></html>