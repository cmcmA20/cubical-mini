<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Copattern</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">-- Reed Mullanix 2024</a>
<a id="23" class="Symbol">{-#</a> <a id="27" class="Keyword">OPTIONS</a> <a id="35" class="Pragma">--safe</a> <a id="42" class="Pragma">--no-exact-split</a> <a id="59" class="Symbol">#-}</a>
<a id="63" class="Keyword">module</a> <a id="70" href="Meta.Copattern.html" class="Module">Meta.Copattern</a> <a id="85" class="Keyword">where</a>

<a id="92" class="Keyword">open</a> <a id="97" class="Keyword">import</a> <a id="104" href="Meta.Prelude.html" class="Module">Meta.Prelude</a>
<a id="117" class="Keyword">open</a> <a id="122" class="Keyword">import</a> <a id="129" href="Meta.Reflection.html" class="Module">Meta.Reflection</a>

<a id="146" class="Keyword">open</a> <a id="151" class="Keyword">import</a> <a id="158" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="173" class="Keyword">open</a> <a id="178" class="Keyword">import</a> <a id="185" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="200" class="Keyword">open</a> <a id="205" class="Keyword">import</a> <a id="212" href="Data.List.Operations.html" class="Module">Data.List.Operations</a>
<a id="233" class="Keyword">open</a> <a id="238" class="Keyword">import</a> <a id="245" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="277" class="Keyword">open</a> <a id="282" class="Keyword">import</a> <a id="289" href="Data.List.Instances.Traversable.html" class="Module">Data.List.Instances.Traversable</a>
<a id="321" class="Keyword">open</a> <a id="326" class="Keyword">import</a> <a id="333" href="Data.Reflection.Argument.html" class="Module">Data.Reflection.Argument</a>
<a id="358" class="Keyword">open</a> <a id="363" class="Keyword">import</a> <a id="370" href="Data.Reflection.Error.html" class="Module">Data.Reflection.Error</a>
<a id="392" class="Keyword">open</a> <a id="397" class="Keyword">import</a> <a id="404" href="Data.Reflection.Instances.FromString.html" class="Module">Data.Reflection.Instances.FromString</a>
<a id="441" class="Keyword">open</a> <a id="446" class="Keyword">import</a> <a id="453" href="Data.Reflection.Name.html" class="Module">Data.Reflection.Name</a>
<a id="474" class="Keyword">open</a> <a id="479" class="Keyword">import</a> <a id="486" href="Data.Reflection.Term.html" class="Module">Data.Reflection.Term</a>
<a id="507" class="Keyword">open</a> <a id="512" class="Keyword">import</a> <a id="519" href="Data.String.Base.html" class="Module">Data.String.Base</a>
<a id="536" class="Keyword">open</a> <a id="541" class="Keyword">import</a> <a id="548" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>

<a id="564" class="Comment">--------------------------------------------------------------------------------</a>
<a id="645" class="Comment">-- Macros for manipulating copattern definitions.</a>

<a id="696" class="Comment">-- Make a top-level copattern binding for an existing record.</a>
<a id="make-copattern"></a><a id="758" href="Meta.Copattern.html#758" class="Function">make-copattern</a> <a id="773" class="Symbol">:</a> <a id="775" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="780" class="Symbol">→</a> <a id="782" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="787" class="Symbol">→</a> <a id="789" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="794" class="Symbol">→</a> <a id="796" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="801" class="Symbol">→</a> <a id="803" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="806" href="Foundations.Notation.Logic.html#4130" class="Field">⊤</a>
<a id="808" href="Meta.Copattern.html#758" class="Function">make-copattern</a> <a id="823" href="Meta.Copattern.html#823" class="Bound">declare?</a> <a id="832" href="Meta.Copattern.html#832" class="Bound">def-name</a> <a id="841" href="Meta.Copattern.html#841" class="Bound">tm</a> <a id="844" href="Meta.Copattern.html#844" class="Bound">tp</a> <a id="847" class="Symbol">=</a> <a id="849" class="Keyword">do</a>
  <a id="854" class="Comment">-- Ensure that codomain is a record type.</a>
  <a id="898" class="Keyword">let</a> <a id="902" href="Meta.Copattern.html#902" class="Bound">tele</a> <a id="907" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="909" href="Meta.Copattern.html#909" class="Bound">cod-tp</a> <a id="916" class="Symbol">=</a> <a id="918" href="Data.Reflection.Term.html#1483" class="Function">pi-view</a> <a id="926" href="Meta.Copattern.html#844" class="Bound">tp</a>
  <a id="931" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="935" href="Meta.Copattern.html#935" class="Bound">rec-name</a> <a id="944" href="Meta.Copattern.html#944" class="Bound">params</a> <a id="951" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="953" href="Meta.Effect.Idiom.html#408" class="Field">pure</a> <a id="958" href="Meta.Copattern.html#909" class="Bound">cod-tp</a>
    <a id="969" class="Keyword">where</a> <a id="975" class="CatchallClause Symbol">_</a> <a id="977" class="Symbol">→</a> <a id="979" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a> <a id="990" href="Meta.Literals.FromProduct.html#419" class="Function Operator">[</a> <a id="992" class="String">&quot;make-copattern: codomain of &quot;</a> <a id="1023" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1025" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="1034" href="Meta.Copattern.html#844" class="Bound">tp</a> <a id="1037" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1039" class="String">&quot; is not a record type.&quot;</a> <a id="1064" href="Meta.Literals.FromProduct.html#419" class="Function Operator">]</a>

  <a id="1069" href="Meta.Copattern.html#1069" class="Bound">inst-tm</a> <a id="1077" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="1079" href="Meta.Reflection.Subst.html#8139" class="Function">apply*TC</a> <a id="1088" href="Meta.Copattern.html#841" class="Bound">tm</a> <a id="1091" class="Symbol">(</a><a id="1092" href="Meta.Reflection.Base.html#5301" class="Function">tel→args</a> <a id="1101" class="Number">0</a> <a id="1103" href="Meta.Copattern.html#902" class="Bound">tele</a><a id="1107" class="Symbol">)</a>

  <a id="1112" class="Comment">-- Construct copattern clauses for each field.</a>
  <a id="1161" href="Meta.Copattern.html#1161" class="Bound">ctor</a> <a id="1166" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1168" href="Meta.Copattern.html#1168" class="Bound">fields</a> <a id="1175" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="1177" href="Meta.Reflection.Signature.html#1442" class="Function">get-record-type</a> <a id="1193" href="Meta.Copattern.html#935" class="Bound">rec-name</a>
  <a id="1204" href="Meta.Copattern.html#1204" class="Bound">clauses</a> <a id="1212" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a>
    <a id="1218" href="Agda.Builtin.Reflection.html#9365" class="Postulate">in-context</a> <a id="1229" class="Symbol">(</a><a id="1230" href="Data.List.Base.html#1014" class="Function">reverse-fast</a> <a id="1243" href="Meta.Copattern.html#902" class="Bound">tele</a><a id="1247" class="Symbol">)</a> <a id="1249" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a>
      <a id="1257" href="Meta.Effect.Traversable.html#418" class="Function">for</a> <a id="1261" href="Meta.Copattern.html#1168" class="Bound">fields</a> <a id="1268" class="Symbol">λ</a> <a id="1270" class="Keyword">where</a> <a id="1276" class="Symbol">(</a><a id="1277" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="1281" href="Meta.Copattern.html#1281" class="Bound">field-info</a> <a id="1292" href="Meta.Copattern.html#1292" class="Bound">field-name</a><a id="1302" class="Symbol">)</a> <a id="1304" class="Symbol">→</a> <a id="1306" class="Keyword">do</a>
      <a id="1315" class="Comment">-- Infer the type of the field with all known arguments instantiated.</a>
      <a id="1391" href="Meta.Copattern.html#1391" class="Bound">field-tp</a> <a id="1400" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="1402" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="1413" class="Symbol">(</a><a id="1414" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="1418" href="Meta.Copattern.html#1292" class="Bound">field-name</a> <a id="1429" href="Meta.Literals.FromProduct.html#419" class="Function Operator">[</a> <a id="1431" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="1436" href="Meta.Copattern.html#1069" class="Bound">inst-tm</a> <a id="1444" href="Meta.Literals.FromProduct.html#419" class="Function Operator">]</a><a id="1445" class="Symbol">)</a>

      <a id="1454" class="Comment">-- Agda will insert implicits when defining copatterns even</a>
      <a id="1520" class="Comment">-- with &#39;withExpandLast true&#39;, so we need to do implicit instantiation</a>
      <a id="1597" class="Comment">-- by hand. There are also cases where it&#39;s better to fully</a>
      <a id="1663" class="Comment">-- eta-expand than not (e.g. the &#39;helper&#39; we&#39;re expanding has a</a>
      <a id="1733" class="Comment">-- field defined by lazy matching, which does not reduce unless</a>
      <a id="1803" class="Comment">-- applied, and would cause duplication of the big input term). So</a>
      <a id="1876" class="Comment">-- we fully eta-expand clauses here.</a>
      <a id="1919" class="Comment">-- First, we strip off all leading quantifiers from the field</a>
      <a id="1987" class="Comment">-- type.</a>
      <a id="2002" class="Keyword">let</a> <a id="2006" href="Meta.Copattern.html#2006" class="Bound">field-tele</a> <a id="2017" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2019" href="Meta.Copattern.html#2019" class="Bound">tp</a> <a id="2022" class="Symbol">=</a> <a id="2024" href="Data.Reflection.Term.html#1483" class="Function">pi-view</a> <a id="2032" href="Meta.Copattern.html#1391" class="Bound">field-tp</a>
          <a id="2051" href="Meta.Copattern.html#2051" class="Bound">nargs</a> <a id="2057" class="Symbol">=</a> <a id="2059" href="Data.List.Operations.html#844" class="Function">length</a> <a id="2066" href="Meta.Copattern.html#2006" class="Bound">field-tele</a>
          <a id="2087" href="Meta.Copattern.html#2087" class="Bound">clause-tele</a> <a id="2099" class="Symbol">=</a> <a id="2101" href="Meta.Copattern.html#902" class="Bound">tele</a> <a id="2106" href="Data.List.Base.html#784" class="Function Operator">++</a> <a id="2109" href="Meta.Copattern.html#2006" class="Bound">field-tele</a>

      <a id="2127" class="Comment">-- Construct the pattern portion of the clause, making sure to bind</a>
      <a id="2201" class="Comment">-- all implicit variables. Note that copattern projections are always visible.</a>
      <a id="2286" class="Keyword">let</a> <a id="2290" href="Meta.Copattern.html#2290" class="Bound">pat</a> <a id="2294" class="Symbol">=</a>
            <a id="2308" href="Meta.Reflection.Base.html#5150" class="Function">tel→pats</a> <a id="2317" href="Meta.Copattern.html#2051" class="Bound">nargs</a> <a id="2323" href="Meta.Copattern.html#902" class="Bound">tele</a> <a id="2328" href="Data.List.Base.html#784" class="Function Operator">++</a>
            <a id="2343" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="2347" class="Symbol">(</a><a id="2348" href="Meta.Reflection.Argument.html#345" class="Field">set-visibility</a> <a id="2363" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="2371" href="Meta.Copattern.html#1281" class="Bound">field-info</a><a id="2381" class="Symbol">)</a> <a id="2383" class="Symbol">(</a><a id="2384" href="Agda.Builtin.Reflection.html#5977" class="InductiveConstructor">proj</a> <a id="2389" href="Meta.Copattern.html#1292" class="Bound">field-name</a><a id="2399" class="Symbol">)</a> <a id="2401" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
            <a id="2415" href="Meta.Reflection.Base.html#5150" class="Function">tel→pats</a> <a id="2424" class="Number">0</a> <a id="2426" href="Meta.Copattern.html#2006" class="Bound">field-tele</a>

      <a id="2444" class="Comment">-- Construct the body of the clause, making sure to apply all</a>
      <a id="2512" class="Comment">-- arguments bound outside the copattern match, and apply the</a>
      <a id="2580" class="Comment">-- eta-expanded arguments. We also need to apply all of the</a>
      <a id="2646" class="Comment">-- implicit arguments to &#39;tm&#39;.</a>
      <a id="2683" href="Meta.Copattern.html#2683" class="Bound">zz</a> <a id="2686" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="2688" href="Meta.Reflection.Subst.html#7636" class="Function">raiseTC</a> <a id="2696" href="Meta.Copattern.html#2051" class="Bound">nargs</a> <a id="2702" href="Meta.Copattern.html#1069" class="Bound">inst-tm</a>
      <a id="2716" href="Meta.Copattern.html#2716" class="Bound">body</a> <a id="2721" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a>
        <a id="2731" href="Agda.Builtin.Reflection.html#9365" class="Postulate">in-context</a> <a id="2742" class="Symbol">(</a><a id="2743" href="Data.List.Base.html#925" class="Function">reverse</a> <a id="2751" href="Meta.Copattern.html#2087" class="Bound">clause-tele</a><a id="2762" class="Symbol">)</a> <a id="2764" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a>
        <a id="2774" href="Agda.Builtin.Reflection.html#9008" class="Postulate">reduce</a> <a id="2781" class="Symbol">(</a><a id="2782" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2786" href="Meta.Copattern.html#1292" class="Bound">field-name</a> <a id="2797" class="Symbol">(</a><a id="2798" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="2803" href="Meta.Copattern.html#2683" class="Bound">zz</a> <a id="2806" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2808" href="Meta.Reflection.Base.html#5301" class="Function">tel→args</a> <a id="2817" class="Number">0</a> <a id="2819" href="Meta.Copattern.html#2006" class="Bound">field-tele</a><a id="2829" class="Symbol">))</a>

      <a id="2839" class="Comment">-- Construct the final clause.</a>
      <a id="2876" href="Meta.Effect.Idiom.html#408" class="Field">pure</a> <a id="2881" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="2883" href="Agda.Builtin.Reflection.html#6106" class="InductiveConstructor">clause</a> <a id="2890" href="Meta.Copattern.html#2087" class="Bound">clause-tele</a> <a id="2902" href="Meta.Copattern.html#2290" class="Bound">pat</a> <a id="2906" href="Meta.Copattern.html#2716" class="Bound">body</a>

  <a id="2914" class="Comment">-- Define a copattern binding, and predeclare its type if required.</a>
  <a id="2984" href="Meta.Effect.Idiom.html#587" class="Function">when</a> <a id="2989" href="Meta.Copattern.html#823" class="Bound">declare?</a> <a id="2998" class="Keyword">do</a>
    <a id="3005" href="Agda.Builtin.Reflection.html#9468" class="Postulate">declare-def</a> <a id="3017" class="Symbol">(</a><a id="3018" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="3023" href="Meta.Copattern.html#832" class="Bound">def-name</a><a id="3031" class="Symbol">)</a> <a id="3033" href="Meta.Copattern.html#844" class="Bound">tp</a> <a id="3036" href="Meta.Effect.Alt.html#369" class="Field Operator">&lt;|&gt;</a> <a id="3040" href="Meta.Effect.Idiom.html#408" class="Field">pure</a> <a id="3045" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>

  <a id="3051" class="Comment">-- Construct the final copattern.</a>
  <a id="3087" href="Agda.Builtin.Reflection.html#9683" class="Postulate">define-function</a> <a id="3103" href="Meta.Copattern.html#832" class="Bound">def-name</a> <a id="3112" href="Meta.Copattern.html#1204" class="Bound">clauses</a>

<a id="3121" class="Comment">-- Repack a record type.</a>
<a id="3146" class="Comment">-- Will also accept functions into record types like `A → Record`,</a>
<a id="3213" class="Comment">-- and will perform a pointwise repacking.</a>
<a id="repack-record"></a><a id="3256" href="Meta.Copattern.html#3256" class="Function">repack-record</a> <a id="3270" class="Symbol">:</a> <a id="3272" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3277" class="Symbol">→</a> <a id="3279" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3284" class="Symbol">→</a> <a id="3286" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="3289" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="3294" href="Meta.Copattern.html#3256" class="Function">repack-record</a> <a id="3308" href="Meta.Copattern.html#3308" class="Bound">tm</a> <a id="3311" href="Meta.Copattern.html#3311" class="Bound">tp</a> <a id="3314" class="Symbol">=</a> <a id="3316" class="Keyword">do</a>
  <a id="3321" class="Comment">-- Ensure that codomain is a record type.</a>
  <a id="3365" href="Meta.Copattern.html#3365" class="Bound">tele</a> <a id="3370" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3372" href="Meta.Copattern.html#3372" class="Bound">cod-tp</a> <a id="3379" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="3381" href="Data.Reflection.Term.html#1483" class="Function">pi-view</a> <a id="3389" href="Meta.Effect.Map.Base.html#411" class="Function Operator">&lt;$&gt;</a> <a id="3393" href="Agda.Builtin.Reflection.html#9008" class="Postulate">reduce</a> <a id="3400" href="Meta.Copattern.html#3311" class="Bound">tp</a>
  <a id="3405" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3409" href="Meta.Copattern.html#3409" class="Bound">rec-name</a> <a id="3418" href="Meta.Copattern.html#3418" class="Bound">params</a> <a id="3425" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="3427" href="Meta.Effect.Idiom.html#408" class="Field">pure</a> <a id="3432" href="Meta.Copattern.html#3372" class="Bound">cod-tp</a>
    <a id="3443" class="Keyword">where</a> <a id="3449" class="CatchallClause Symbol">_</a> <a id="3451" class="Symbol">→</a> <a id="3453" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a> <a id="3464" href="Meta.Literals.FromProduct.html#419" class="Function Operator">[</a> <a id="3466" class="String">&quot;repack-record: codomain of &quot;</a> <a id="3496" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3498" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="3507" href="Meta.Copattern.html#3311" class="Bound">tp</a> <a id="3510" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3512" class="String">&quot; is not a record type.&quot;</a> <a id="3537" href="Meta.Literals.FromProduct.html#419" class="Function Operator">]</a>

  <a id="3542" class="Comment">-- Instantiate the term with all telescope arguments to saturate it.</a>
  <a id="3613" href="Meta.Copattern.html#3613" class="Bound">inst-tm</a> <a id="3621" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="3623" href="Meta.Reflection.Subst.html#8139" class="Function">apply*TC</a> <a id="3632" href="Meta.Copattern.html#3308" class="Bound">tm</a> <a id="3635" class="Symbol">(</a><a id="3636" href="Meta.Reflection.Base.html#5301" class="Function">tel→args</a> <a id="3645" class="Number">0</a> <a id="3647" href="Meta.Copattern.html#3365" class="Bound">tele</a><a id="3651" class="Symbol">)</a>

  <a id="3656" class="Comment">-- Construct fields for each projection.</a>
  <a id="3699" href="Meta.Copattern.html#3699" class="Bound">ctor</a> <a id="3704" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3706" href="Meta.Copattern.html#3706" class="Bound">fields</a> <a id="3713" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="3715" href="Meta.Reflection.Signature.html#1442" class="Function">get-record-type</a> <a id="3731" href="Meta.Copattern.html#3409" class="Bound">rec-name</a>
  <a id="3742" href="Meta.Copattern.html#3742" class="Bound">args</a> <a id="3747" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="3749" href="Agda.Builtin.Reflection.html#9365" class="Postulate">in-context</a> <a id="3760" class="Symbol">(</a><a id="3761" href="Data.List.Base.html#1014" class="Function">reverse-fast</a> <a id="3774" href="Meta.Copattern.html#3365" class="Bound">tele</a><a id="3778" class="Symbol">)</a> <a id="3780" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a>
    <a id="3786" href="Meta.Effect.Traversable.html#418" class="Function">for</a> <a id="3790" href="Meta.Copattern.html#3706" class="Bound">fields</a> <a id="3797" class="Symbol">λ</a> <a id="3799" class="Keyword">where</a> <a id="3805" class="Symbol">(</a><a id="3806" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="3810" href="Meta.Copattern.html#3810" class="Bound">field-info</a> <a id="3821" href="Meta.Copattern.html#3821" class="Bound">field-name</a><a id="3831" class="Symbol">)</a> <a id="3833" class="Symbol">→</a>
                         <a id="3860" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="3865" href="Meta.Effect.Map.Base.html#411" class="Function Operator">&lt;$&gt;</a> <a id="3869" href="Agda.Builtin.Reflection.html#9008" class="Postulate">reduce</a> <a id="3876" class="Symbol">(</a><a id="3877" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3881" href="Meta.Copattern.html#3821" class="Bound">field-name</a> <a id="3892" href="Meta.Literals.FromProduct.html#419" class="Function Operator">[</a> <a id="3894" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="3899" href="Meta.Copattern.html#3613" class="Bound">inst-tm</a> <a id="3907" href="Meta.Literals.FromProduct.html#419" class="Function Operator">]</a><a id="3908" class="Symbol">)</a>

  <a id="3913" class="Comment">-- Builld a pointwise repacking.</a>
  <a id="3948" href="Meta.Effect.Idiom.html#408" class="Field">pure</a> <a id="3953" class="Symbol">(</a><a id="3954" href="Data.Reflection.Term.html#1951" class="Function">tel→lam</a> <a id="3962" href="Meta.Copattern.html#3365" class="Bound">tele</a> <a id="3967" class="Symbol">(</a><a id="3968" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="3972" href="Meta.Copattern.html#3699" class="Bound">ctor</a> <a id="3977" href="Meta.Copattern.html#3742" class="Bound">args</a><a id="3981" class="Symbol">))</a>

<a id="3985" class="Comment">-- Helper for the &#39;define&#39; macros; Unifies the given goal with the type</a>
<a id="4057" class="Comment">-- of the given function, if it has been defined. If the function has</a>
<a id="4127" class="Comment">-- not been defined, and the first argument is &#39;false&#39;, then an error is</a>
<a id="4200" class="Comment">-- raised.</a>
<a id="type-for"></a><a id="4211" href="Meta.Copattern.html#4211" class="Function">type-for</a> <a id="4220" class="Symbol">:</a> <a id="4222" href="Agda.Builtin.String.html#335" class="Postulate">String</a> <a id="4229" class="Symbol">→</a> <a id="4231" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="4236" class="Symbol">→</a> <a id="4238" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="4243" class="Symbol">→</a> <a id="4245" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="4250" class="Symbol">→</a> <a id="4252" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="4255" href="Foundations.Notation.Logic.html#4130" class="Field">⊤</a>
<a id="4257" href="Meta.Copattern.html#4211" class="Function">type-for</a> <a id="4266" href="Meta.Copattern.html#4266" class="Bound">tac</a> <a id="4270" href="Meta.Copattern.html#4270" class="Bound">decl?</a> <a id="4276" href="Meta.Copattern.html#4276" class="Bound">fun</a> <a id="4280" href="Meta.Copattern.html#4280" class="Bound">goal</a> <a id="4285" class="Symbol">=</a> <a id="4287" class="Symbol">(</a><a id="4288" href="Agda.Builtin.Reflection.html#9730" class="Postulate">get-type</a> <a id="4297" href="Meta.Copattern.html#4276" class="Bound">fun</a> <a id="4301" href="Meta.Effect.Bind.html#305" class="Field Operator">&gt;&gt;=</a> <a id="4305" href="Agda.Builtin.Reflection.html#8790" class="Postulate">unify</a> <a id="4311" href="Meta.Copattern.html#4280" class="Bound">goal</a><a id="4315" class="Symbol">)</a> <a id="4317" href="Meta.Effect.Alt.html#369" class="Field Operator">&lt;|&gt;</a> <a id="4321" class="Keyword">do</a>
  <a id="4326" href="Meta.Effect.Idiom.html#662" class="Function">unless</a> <a id="4333" href="Meta.Copattern.html#4270" class="Bound">decl?</a> <a id="4339" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="4341" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a>
    <a id="4356" href="Meta.Literals.FromProduct.html#419" class="Function Operator">[</a> <a id="4358" class="String">&quot;define-&quot;</a> <a id="4368" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4370" href="Data.Reflection.Error.html#159" class="InductiveConstructor">str-err</a> <a id="4378" href="Meta.Copattern.html#4266" class="Bound">tac</a> <a id="4382" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4384" class="String">&quot;: the function &quot;</a>
    <a id="4406" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4408" href="Data.Reflection.Error.html#256" class="InductiveConstructor">name-err</a> <a id="4417" href="Meta.Copattern.html#4276" class="Bound">fun</a> <a id="4421" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4423" class="String">&quot; should already have been declared.&quot;</a>
    <a id="4465" href="Meta.Literals.FromProduct.html#419" class="Function Operator">]</a>


<a id="4469" class="Comment">--------------------------------------------------------------------------------</a>
<a id="4550" class="Comment">-- Usage</a>

<a id="4560" class="Comment">{-
Write the following in a module:
&gt;  unquoteDecl copat = declare-copattern copat thing-to-be-expanded
If you wish to give the binding a type annotation, you can also use
&gt;  copat : Your-type
&gt;  unquoteDecl copat = declare-copattern copat thing-to-be-expanded
All features of non-recursive records are supported, including instance
fields and fields with implicit arguments.
These macros also allow you to lift functions &#39;A → some-record-type&#39;
into copattern definitions. Note that Agda will generate meta for
implicits before performing quotation, so we need to explicitly
bind all implicits using a lambda before quotation!
-}</a>

<a id="declare-copattern"></a><a id="5191" href="Meta.Copattern.html#5191" class="Function">declare-copattern</a> <a id="5209" class="Symbol">:</a> <a id="5211" class="Symbol">∀</a> <a id="5213" class="Symbol">{</a><a id="5214" href="Meta.Copattern.html#5214" class="Bound">ℓ</a><a id="5215" class="Symbol">}</a> <a id="5217" class="Symbol">{</a><a id="5218" href="Meta.Copattern.html#5218" class="Bound">A</a> <a id="5220" class="Symbol">:</a> <a id="5222" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="5227" href="Meta.Copattern.html#5214" class="Bound">ℓ</a><a id="5228" class="Symbol">}</a> <a id="5230" class="Symbol">→</a> <a id="5232" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="5237" class="Symbol">→</a> <a id="5239" href="Meta.Copattern.html#5218" class="Bound">A</a> <a id="5241" class="Symbol">→</a> <a id="5243" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="5246" href="Foundations.Notation.Logic.html#4130" class="Field">⊤</a>
<a id="5248" href="Meta.Copattern.html#5191" class="Function">declare-copattern</a> <a id="5266" class="Symbol">{</a><a id="5267" class="Argument">A</a> <a id="5269" class="Symbol">=</a> <a id="5271" href="Meta.Copattern.html#5271" class="Bound">A</a><a id="5272" class="Symbol">}</a> <a id="5274" href="Meta.Copattern.html#5274" class="Bound">nm</a> <a id="5277" href="Meta.Copattern.html#5277" class="Bound">x</a> <a id="5279" class="Symbol">=</a> <a id="5281" class="Keyword">do</a>
  <a id="5286" href="Meta.Copattern.html#5286" class="Bound">`x</a> <a id="5289" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5291" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="5299" href="Meta.Copattern.html#5277" class="Bound">x</a>
  <a id="5303" href="Meta.Copattern.html#5303" class="Bound">`A</a> <a id="5306" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5308" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="5316" href="Meta.Copattern.html#5271" class="Bound">A</a>
  <a id="5320" href="Meta.Copattern.html#758" class="Function">make-copattern</a> <a id="5335" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="5340" href="Meta.Copattern.html#5274" class="Bound">nm</a> <a id="5343" href="Meta.Copattern.html#5286" class="Bound">`x</a> <a id="5346" href="Meta.Copattern.html#5303" class="Bound">`A</a>

<a id="define-copattern"></a><a id="5350" href="Meta.Copattern.html#5350" class="Function">define-copattern</a>
  <a id="5369" class="Symbol">:</a> <a id="5371" class="Symbol">∀</a> <a id="5373" class="Symbol">{</a><a id="5374" href="Meta.Copattern.html#5374" class="Bound">ℓ</a><a id="5375" class="Symbol">}</a> <a id="5377" class="Symbol">(</a><a id="5378" href="Meta.Copattern.html#5378" class="Bound">nm</a> <a id="5381" class="Symbol">:</a> <a id="5383" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="5387" class="Symbol">)</a>
  <a id="5391" class="Symbol">→</a> <a id="5393" class="Symbol">{@(</a><a id="5396" class="Keyword">tactic</a> <a id="5403" class="Symbol">(</a><a id="5404" href="Meta.Copattern.html#4211" class="Function">type-for</a> <a id="5413" class="String">&quot;copattern&quot;</a> <a id="5425" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="5430" href="Meta.Copattern.html#5378" class="Bound">nm</a><a id="5432" class="Symbol">))</a> <a id="5435" href="Meta.Copattern.html#5435" class="Bound">A</a> <a id="5437" class="Symbol">:</a> <a id="5439" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="5444" href="Meta.Copattern.html#5374" class="Bound">ℓ</a><a id="5445" class="Symbol">}</a>
  <a id="5449" class="Symbol">→</a> <a id="5451" href="Meta.Copattern.html#5435" class="Bound">A</a> <a id="5453" class="Symbol">→</a> <a id="5455" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="5458" href="Foundations.Notation.Logic.html#4130" class="Field">⊤</a>
<a id="5460" href="Meta.Copattern.html#5350" class="Function">define-copattern</a> <a id="5477" href="Meta.Copattern.html#5477" class="Bound">nm</a> <a id="5480" class="Symbol">{</a><a id="5481" href="Meta.Copattern.html#5481" class="Bound">A</a><a id="5482" class="Symbol">}</a> <a id="5484" href="Meta.Copattern.html#5484" class="Bound">x</a> <a id="5486" class="Symbol">=</a> <a id="5488" class="Keyword">do</a>
  <a id="5493" href="Meta.Copattern.html#5493" class="Bound">`A</a> <a id="5496" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5498" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="5506" href="Meta.Copattern.html#5481" class="Bound">A</a>
  <a id="5510" href="Meta.Copattern.html#5510" class="Bound">`x</a> <a id="5513" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5515" href="Meta.Reflection.Signature.html#8364" class="Function">define-abbrev</a> <a id="5529" href="Meta.Copattern.html#5477" class="Bound">nm</a> <a id="5532" class="String">&quot;value&quot;</a> <a id="5540" href="Meta.Copattern.html#5493" class="Bound">`A</a> <a id="5543" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="5547" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="5555" href="Meta.Copattern.html#5484" class="Bound">x</a>
  <a id="5559" href="Meta.Copattern.html#758" class="Function">make-copattern</a> <a id="5574" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="5580" href="Meta.Copattern.html#5477" class="Bound">nm</a> <a id="5583" href="Meta.Copattern.html#5510" class="Bound">`x</a> <a id="5586" href="Meta.Copattern.html#5493" class="Bound">`A</a>

<a id="5590" class="Comment">{-
There is a slight caveat with level-polymorphic defintions, as
they cannot be quoted into any `Type ℓ`. With this in mind,
we also provide a pair of macros that work over `Typeω` instead.
-}</a>

<a id="declare-copatternω"></a><a id="5785" href="Meta.Copattern.html#5785" class="Function">declare-copatternω</a> <a id="5804" class="Symbol">:</a> <a id="5806" class="Symbol">∀</a> <a id="5808" class="Symbol">{</a><a id="5809" href="Meta.Copattern.html#5809" class="Bound">U</a> <a id="5811" class="Symbol">:</a> <a id="5813" href="Foundations.Prim.Type.html#349" class="Primitive">Typeω</a><a id="5818" class="Symbol">}</a> <a id="5820" class="Symbol">→</a> <a id="5822" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="5827" class="Symbol">→</a> <a id="5829" href="Meta.Copattern.html#5809" class="Bound">U</a> <a id="5831" class="Symbol">→</a> <a id="5833" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="5836" href="Foundations.Notation.Logic.html#4130" class="Field">⊤</a>
<a id="5838" href="Meta.Copattern.html#5785" class="Function">declare-copatternω</a> <a id="5857" href="Meta.Copattern.html#5857" class="Bound">nm</a> <a id="5860" href="Meta.Copattern.html#5860" class="Bound">A</a> <a id="5862" class="Symbol">=</a> <a id="5864" class="Keyword">do</a>
  <a id="5869" href="Meta.Copattern.html#5869" class="Bound">`A</a> <a id="5872" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5874" href="Agda.Builtin.Reflection.html#9210" class="Postulate">quoteωTC</a> <a id="5883" href="Meta.Copattern.html#5860" class="Bound">A</a>
  <a id="5887" class="Comment">-- Cannot quote things in type Typeω, but we can infer their type.</a>
  <a id="5956" href="Meta.Copattern.html#5956" class="Bound">`U</a> <a id="5959" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5961" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="5972" href="Meta.Copattern.html#5869" class="Bound">`A</a>
  <a id="5977" href="Meta.Copattern.html#758" class="Function">make-copattern</a> <a id="5992" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="5997" href="Meta.Copattern.html#5857" class="Bound">nm</a> <a id="6000" href="Meta.Copattern.html#5869" class="Bound">`A</a> <a id="6003" href="Meta.Copattern.html#5956" class="Bound">`U</a>

<a id="define-copatternω"></a><a id="6007" href="Meta.Copattern.html#6007" class="Function">define-copatternω</a>
  <a id="6027" class="Symbol">:</a> <a id="6029" class="Symbol">(</a><a id="6030" href="Meta.Copattern.html#6030" class="Bound">nm</a> <a id="6033" class="Symbol">:</a> <a id="6035" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="6039" class="Symbol">)</a> <a id="6041" class="Symbol">{@(</a><a id="6044" class="Keyword">tactic</a> <a id="6051" class="Symbol">(</a><a id="6052" href="Meta.Copattern.html#4211" class="Function">type-for</a> <a id="6061" class="String">&quot;copatternω&quot;</a> <a id="6074" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="6080" href="Meta.Copattern.html#6030" class="Bound">nm</a><a id="6082" class="Symbol">))</a> <a id="6085" href="Meta.Copattern.html#6085" class="Bound">U</a> <a id="6087" class="Symbol">:</a> <a id="6089" href="Foundations.Prim.Type.html#349" class="Primitive">Typeω</a><a id="6094" class="Symbol">}</a>
  <a id="6098" class="Symbol">→</a> <a id="6100" href="Meta.Copattern.html#6085" class="Bound">U</a> <a id="6102" class="Symbol">→</a> <a id="6104" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="6107" href="Foundations.Notation.Logic.html#4130" class="Field">⊤</a>
<a id="6109" href="Meta.Copattern.html#6007" class="Function">define-copatternω</a> <a id="6127" href="Meta.Copattern.html#6127" class="Bound">nm</a> <a id="6130" href="Meta.Copattern.html#6130" class="Bound">A</a> <a id="6132" class="Symbol">=</a> <a id="6134" class="Keyword">do</a>
  <a id="6139" href="Meta.Copattern.html#6139" class="Bound">`U</a> <a id="6142" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6144" href="Agda.Builtin.Reflection.html#9730" class="Postulate">get-type</a> <a id="6153" href="Meta.Copattern.html#6127" class="Bound">nm</a>
  <a id="6158" href="Meta.Copattern.html#6158" class="Bound">`A</a> <a id="6161" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6163" href="Meta.Reflection.Signature.html#8364" class="Function">define-abbrev</a> <a id="6177" href="Meta.Copattern.html#6127" class="Bound">nm</a> <a id="6180" class="String">&quot;vlaue&quot;</a> <a id="6188" href="Meta.Copattern.html#6139" class="Bound">`U</a> <a id="6191" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="6195" href="Agda.Builtin.Reflection.html#9210" class="Postulate">quoteωTC</a> <a id="6204" href="Meta.Copattern.html#6130" class="Bound">A</a>
  <a id="6208" href="Meta.Copattern.html#758" class="Function">make-copattern</a> <a id="6223" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="6229" href="Meta.Copattern.html#6127" class="Bound">nm</a> <a id="6232" href="Meta.Copattern.html#6158" class="Bound">`A</a> <a id="6235" href="Meta.Copattern.html#6139" class="Bound">`U</a>

<a id="6239" class="Comment">{-
Another common pattern is that two records `r : R p` and `s : R q` may contain
the same data, but they are parameterized by different values.
The `define-eta-expansion` macro will automatically construct a function
`R p → R q` that eta-expands the first record out into a copattern definition.
-}</a>

<a id="define-eta-expansion"></a><a id="6540" href="Meta.Copattern.html#6540" class="Function">define-eta-expansion</a> <a id="6561" class="Symbol">:</a> <a id="6563" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6568" class="Symbol">→</a> <a id="6570" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="6573" href="Foundations.Notation.Logic.html#4130" class="Field">⊤</a>
<a id="6575" href="Meta.Copattern.html#6540" class="Function">define-eta-expansion</a> <a id="6596" href="Meta.Copattern.html#6596" class="Bound">nm</a> <a id="6599" class="Symbol">=</a> <a id="6601" class="Keyword">do</a>
  <a id="6606" href="Meta.Copattern.html#6606" class="Bound">tp</a> <a id="6609" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6611" href="Agda.Builtin.Reflection.html#9008" class="Postulate">reduce</a> <a id="6618" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="6622" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="6633" class="Symbol">(</a><a id="6634" href="Data.Reflection.Term.html#2456" class="InductiveConstructor">def₀</a> <a id="6639" href="Meta.Copattern.html#6596" class="Bound">nm</a><a id="6641" class="Symbol">)</a>
  <a id="6645" class="Keyword">let</a> <a id="6649" href="Meta.Copattern.html#6649" class="Bound">tele</a> <a id="6654" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6656" class="Symbol">_</a> <a id="6658" class="Symbol">=</a> <a id="6660" href="Data.Reflection.Term.html#1483" class="Function">pi-view</a> <a id="6668" href="Meta.Copattern.html#6606" class="Bound">tp</a>
  <a id="6673" class="Keyword">let</a> <a id="6677" href="Meta.Copattern.html#6677" class="Bound">tm</a> <a id="6680" class="Symbol">=</a> <a id="6682" href="Data.Reflection.Term.html#1951" class="Function">tel→lam</a> <a id="6690" href="Meta.Copattern.html#6649" class="Bound">tele</a> <a id="6695" class="Symbol">(</a><a id="6696" href="Data.Reflection.Term.html#2482" class="InductiveConstructor">var₀</a> <a id="6701" class="Number">0</a><a id="6702" class="Symbol">)</a>
  <a id="6706" href="Meta.Copattern.html#758" class="Function">make-copattern</a> <a id="6721" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="6727" href="Meta.Copattern.html#6596" class="Bound">nm</a> <a id="6730" href="Meta.Copattern.html#6677" class="Bound">tm</a> <a id="6733" href="Meta.Copattern.html#6606" class="Bound">tp</a>

<a id="6737" class="Comment">--------------------------------------------------------------------------------</a>
<a id="6818" class="Comment">-- Tests</a>

<a id="6828" class="Keyword">private</a> <a id="6836" class="Keyword">module</a> <a id="Test"></a><a id="6843" href="Meta.Copattern.html#6843" class="Module">Test</a> <a id="6848" class="Keyword">where</a>
  <a id="6856" class="Comment">-- Record type that uses all interesting features.</a>
  <a id="6909" class="Keyword">record</a> <a id="Test.Record"></a><a id="6916" href="Meta.Copattern.html#6916" class="Record">Record</a> <a id="6923" class="Symbol">{</a><a id="6924" href="Meta.Copattern.html#6924" class="Bound">ℓ</a><a id="6925" class="Symbol">}</a> <a id="6927" class="Symbol">(</a><a id="6928" href="Meta.Copattern.html#6928" class="Bound">A</a> <a id="6930" class="Symbol">:</a> <a id="6932" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="6937" href="Meta.Copattern.html#6924" class="Bound">ℓ</a><a id="6938" class="Symbol">)</a> <a id="6940" class="Symbol">:</a> <a id="6942" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="6947" href="Meta.Copattern.html#6924" class="Bound">ℓ</a> <a id="6949" class="Keyword">where</a>
    <a id="6959" class="Keyword">no-eta-equality</a>
    <a id="6979" class="Keyword">constructor</a> <a id="Test.mk"></a><a id="6991" href="Meta.Copattern.html#6991" class="InductiveConstructor">mk</a>
    <a id="6998" class="Keyword">field</a>
      <a id="7010" class="Symbol">⦃</a> <a id="Test.Record.c"></a><a id="7012" href="Meta.Copattern.html#7012" class="Field">c</a> <a id="7014" class="Symbol">⦄</a> <a id="7016" class="Symbol">:</a> <a id="7018" href="Meta.Copattern.html#6928" class="Bound">A</a>
      <a id="7026" class="Symbol">{</a> <a id="Test.Record.f"></a><a id="7028" href="Meta.Copattern.html#7028" class="Field">f</a> <a id="7030" class="Symbol">}</a> <a id="7032" class="Symbol">:</a> <a id="7034" href="Meta.Copattern.html#6928" class="Bound">A</a> <a id="7036" class="Symbol">→</a> <a id="7038" href="Meta.Copattern.html#6928" class="Bound">A</a>
      <a id="Test.Record.const′"></a><a id="7046" href="Meta.Copattern.html#7046" class="Field">const′</a> <a id="7053" class="Symbol">:</a> <a id="7055" class="Symbol">∀</a> <a id="7057" class="Symbol">{</a><a id="7058" href="Meta.Copattern.html#7058" class="Bound">x</a><a id="7059" class="Symbol">}</a> <a id="7061" class="Symbol">→</a> <a id="7063" href="Meta.Copattern.html#7028" class="Field">f</a> <a id="7065" href="Meta.Copattern.html#7058" class="Bound">x</a> <a id="7067" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="7069" href="Meta.Copattern.html#7012" class="Field">c</a>

  <a id="7074" class="Comment">-- Record created via a constructor.</a>
  <a id="Test.via-ctor"></a><a id="7113" href="Meta.Copattern.html#7113" class="Function">via-ctor</a> <a id="7122" class="Symbol">:</a> <a id="7124" href="Meta.Copattern.html#6916" class="Record">Record</a> <a id="7131" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="7135" href="Meta.Copattern.html#7113" class="Function">via-ctor</a> <a id="7144" class="Symbol">=</a> <a id="7146" href="Meta.Copattern.html#6991" class="InductiveConstructor">mk</a> <a id="7149" class="Symbol">⦃</a> <a id="7151" class="Argument">c</a> <a id="7153" class="Symbol">=</a> <a id="7155" class="Number">0</a> <a id="7157" class="Symbol">⦄</a> <a id="7159" class="Symbol">{</a><a id="7160" class="Argument">f</a> <a id="7162" class="Symbol">=</a> <a id="7164" class="Symbol">λ</a> <a id="7166" href="Meta.Copattern.html#7166" class="Bound">_</a> <a id="7168" class="Symbol">→</a> <a id="7170" class="Number">0</a><a id="7171" class="Symbol">}</a> <a id="7173" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a>

  <a id="7181" class="Comment">-- Both macros work.</a>
  <a id="7204" class="Keyword">unquoteDecl</a> <a id="Test.copat-decl-via-ctor"></a><a id="7216" href="Meta.Copattern.html#7216" class="Function">copat-decl-via-ctor</a> <a id="7236" class="Symbol">=</a> <a id="7238" href="Meta.Copattern.html#5191" class="Function">declare-copattern</a> <a id="7256" href="Meta.Copattern.html#7216" class="Function">copat-decl-via-ctor</a> <a id="7276" href="Meta.Copattern.html#7113" class="Function">via-ctor</a>

  <a id="Test.copat-def-via-ctor"></a><a id="7288" href="Meta.Copattern.html#7288" class="Function">copat-def-via-ctor</a> <a id="7307" class="Symbol">:</a> <a id="7309" href="Meta.Copattern.html#6916" class="Record">Record</a> <a id="7316" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
  <a id="7320" class="Keyword">unquoteDef</a> <a id="7331" href="Meta.Copattern.html#7288" class="Function">copat-def-via-ctor</a> <a id="7350" class="Symbol">=</a> <a id="7352" href="Meta.Copattern.html#5350" class="Function">define-copattern</a> <a id="7369" href="Meta.Copattern.html#7288" class="Function">copat-def-via-ctor</a> <a id="7388" href="Meta.Copattern.html#7113" class="Function">via-ctor</a>

  <a id="7400" class="Comment">-- Record created by a function.</a>
  <a id="7435" class="Keyword">module</a> <a id="7442" href="Meta.Copattern.html#7442" class="Module">_</a> <a id="7444" class="Symbol">(</a><a id="7445" href="Meta.Copattern.html#7445" class="Bound">r</a> <a id="7447" class="Symbol">:</a> <a id="7449" href="Meta.Copattern.html#6916" class="Record">Record</a> <a id="7456" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="7457" class="Symbol">)</a> <a id="7459" class="Keyword">where</a>
    <a id="7469" class="Keyword">open</a> <a id="7474" href="Meta.Copattern.html#6916" class="Module">Record</a> <a id="7481" href="Meta.Copattern.html#7445" class="Bound">r</a>
    <a id="7487" href="Meta.Copattern.html#7487" class="Function">via-function</a> <a id="7500" class="Symbol">:</a> <a id="7502" href="Meta.Copattern.html#6916" class="Record">Record</a> <a id="7509" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
    <a id="7515" href="Meta.Copattern.html#7487" class="Function">via-function</a> <a id="7528" class="Symbol">.</a><a id="7529" href="Meta.Copattern.html#7012" class="Field">c</a> <a id="7531" class="Symbol">=</a> <a id="7533" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="7537" href="Meta.Copattern.html#7012" class="Field">c</a>
    <a id="7543" href="Meta.Copattern.html#7487" class="Function">via-function</a> <a id="7556" class="Symbol">.</a><a id="7557" href="Meta.Copattern.html#7028" class="Field">f</a> <a id="7559" class="Symbol">=</a> <a id="7561" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="7565" href="Foundations.Pi.Base.html#3422" class="Function Operator">∘</a> <a id="7567" href="Meta.Copattern.html#7028" class="Field">f</a>
    <a id="7573" href="Meta.Copattern.html#7487" class="Function">via-function</a> <a id="7586" class="Symbol">.</a><a id="7587" href="Meta.Copattern.html#7046" class="Field">const′</a> <a id="7594" class="Symbol">=</a> <a id="7596" href="Foundations.Prim.Kan.html#1724" class="Function">ap</a> <a id="7599" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="7603" href="Meta.Copattern.html#7046" class="Field">const′</a>

  <a id="7613" class="Comment">-- Also works when applied to the result of a function.</a>
  <a id="7671" class="Keyword">unquoteDecl</a> <a id="Test.copat-decl-via-function"></a><a id="7683" href="Meta.Copattern.html#7683" class="Function">copat-decl-via-function</a> <a id="7707" class="Symbol">=</a> <a id="7709" href="Meta.Copattern.html#5191" class="Function">declare-copattern</a> <a id="7727" href="Meta.Copattern.html#7683" class="Function">copat-decl-via-function</a> <a id="7751" class="Symbol">(</a><a id="7752" href="Meta.Copattern.html#7487" class="Function">via-function</a> <a id="7765" href="Meta.Copattern.html#7113" class="Function">via-ctor</a><a id="7773" class="Symbol">)</a>

  <a id="7778" class="Comment">-- Test to see how we handle unused parameters.</a>
  <a id="7828" class="Keyword">record</a> <a id="Test.Unused"></a><a id="7835" href="Meta.Copattern.html#7835" class="Record">Unused</a> <a id="7842" class="Symbol">(</a><a id="7843" href="Meta.Copattern.html#7843" class="Bound">n</a> <a id="7845" class="Symbol">:</a> <a id="7847" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="7848" class="Symbol">)</a> <a id="7850" class="Symbol">:</a> <a id="7852" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7857" class="Keyword">where</a>
    <a id="7867" class="Keyword">field</a> <a id="Test.Unused.actual"></a><a id="7873" href="Meta.Copattern.html#7873" class="Field">actual</a> <a id="7880" class="Symbol">:</a> <a id="7882" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>

  <a id="Test.zero-unused-param"></a><a id="7887" href="Meta.Copattern.html#7887" class="Function">zero-unused-param</a> <a id="7905" class="Symbol">:</a> <a id="7907" href="Meta.Copattern.html#7835" class="Record">Unused</a> <a id="7914" class="Number">0</a>
  <a id="7918" href="Meta.Copattern.html#7887" class="Function">zero-unused-param</a> <a id="7936" class="Symbol">=</a> <a id="7938" class="Keyword">record</a> <a id="7945" class="Symbol">{</a> <a id="7947" href="Meta.Copattern.html#7873" class="Field">actual</a> <a id="7954" class="Symbol">=</a> <a id="7956" class="Number">0</a> <a id="7958" class="Symbol">}</a>

  <a id="Test.one-unused-param"></a><a id="7963" href="Meta.Copattern.html#7963" class="Function">one-unused-param</a> <a id="7980" class="Symbol">:</a> <a id="7982" class="Symbol">∀</a> <a id="7984" class="Symbol">{</a><a id="7985" href="Meta.Copattern.html#7985" class="Bound">n</a><a id="7986" class="Symbol">}</a> <a id="7988" class="Symbol">→</a> <a id="7990" href="Meta.Copattern.html#7835" class="Record">Unused</a> <a id="7997" href="Meta.Copattern.html#7985" class="Bound">n</a>
  <a id="8001" class="Keyword">unquoteDef</a> <a id="8012" href="Meta.Copattern.html#7963" class="Function">one-unused-param</a> <a id="8029" class="Symbol">=</a> <a id="8031" href="Meta.Copattern.html#5191" class="Function">declare-copattern</a> <a id="8049" href="Meta.Copattern.html#7963" class="Function">one-unused-param</a> <a id="8066" href="Meta.Copattern.html#7887" class="Function">zero-unused-param</a>
  <a id="8086" class="Comment">-- This is a type error:</a>
  <a id="8113" class="Comment">-- unquoteDef one-unused-param = define-copattern one-unused-param zero-unused-param</a>
  <a id="8200" class="Comment">-- because the &#39;define&#39; macro propagates the type of the thing being</a>
  <a id="8271" class="Comment">-- defined inwards.</a>

  <a id="8294" class="Comment">-- Functions into records that are universe polymorphic</a>
  <a id="Test.neat"></a><a id="8352" href="Meta.Copattern.html#8352" class="Function">neat</a> <a id="8357" class="Symbol">:</a> <a id="8359" class="Symbol">∀</a> <a id="8361" class="Symbol">{</a><a id="8362" href="Meta.Copattern.html#8362" class="Bound">ℓ</a><a id="8363" class="Symbol">}</a> <a id="8365" class="Symbol">{</a><a id="8366" href="Meta.Copattern.html#8366" class="Bound">A</a> <a id="8368" class="Symbol">:</a> <a id="8370" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8375" href="Meta.Copattern.html#8362" class="Bound">ℓ</a><a id="8376" class="Symbol">}</a> <a id="8378" class="Symbol">→</a> <a id="8380" href="Meta.Copattern.html#8366" class="Bound">A</a> <a id="8382" class="Symbol">→</a> <a id="8384" href="Meta.Copattern.html#6916" class="Record">Record</a> <a id="8391" href="Meta.Copattern.html#8366" class="Bound">A</a>
  <a id="8395" href="Meta.Copattern.html#8352" class="Function">neat</a> <a id="8400" href="Meta.Copattern.html#8400" class="Bound">a</a> <a id="8402" class="Symbol">.</a><a id="8403" href="Meta.Copattern.html#7012" class="Field">Record.c</a> <a id="8412" class="Symbol">=</a> <a id="8414" href="Meta.Copattern.html#8400" class="Bound">a</a>
  <a id="8418" href="Meta.Copattern.html#8352" class="Function">neat</a> <a id="8423" href="Meta.Copattern.html#8423" class="Bound">a</a> <a id="8425" class="Symbol">.</a><a id="8426" href="Meta.Copattern.html#7028" class="Field">Record.f</a> <a id="8435" class="Symbol">_</a> <a id="8437" class="Symbol">=</a> <a id="8439" href="Meta.Copattern.html#8423" class="Bound">a</a>
  <a id="8443" href="Meta.Copattern.html#8352" class="Function">neat</a> <a id="8448" href="Meta.Copattern.html#8448" class="Bound">a</a> <a id="8450" class="Symbol">.</a><a id="8451" href="Meta.Copattern.html#7046" class="Field">Record.const′</a> <a id="8465" class="Symbol">=</a> <a id="8467" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a>

  <a id="8475" class="Comment">-- Implicit insertion is correct for the define- macro, since the type</a>
  <a id="8548" class="Comment">-- of the function is given.</a>
  <a id="Test.cool"></a><a id="8579" href="Meta.Copattern.html#8579" class="Function">cool</a> <a id="8584" class="Symbol">:</a> <a id="8586" class="Symbol">∀</a> <a id="8588" class="Symbol">{</a><a id="8589" href="Meta.Copattern.html#8589" class="Bound">ℓ</a><a id="8590" class="Symbol">}</a> <a id="8592" class="Symbol">{</a><a id="8593" href="Meta.Copattern.html#8593" class="Bound">A</a> <a id="8595" class="Symbol">:</a> <a id="8597" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8602" href="Meta.Copattern.html#8589" class="Bound">ℓ</a><a id="8603" class="Symbol">}</a> <a id="8605" class="Symbol">→</a> <a id="8607" href="Meta.Copattern.html#8593" class="Bound">A</a> <a id="8609" class="Symbol">→</a> <a id="8611" href="Meta.Copattern.html#6916" class="Record">Record</a> <a id="8618" href="Meta.Copattern.html#8593" class="Bound">A</a>
  <a id="8622" class="Keyword">unquoteDef</a> <a id="8633" href="Meta.Copattern.html#8579" class="Function">cool</a> <a id="8638" class="Symbol">=</a> <a id="8640" href="Meta.Copattern.html#6007" class="Function">define-copatternω</a> <a id="8658" href="Meta.Copattern.html#8579" class="Function">cool</a> <a id="8663" href="Meta.Copattern.html#8352" class="Function">neat</a>

  <a id="8671" class="Comment">-- Eta-expanders</a>
  <a id="Test.expander"></a><a id="8690" href="Meta.Copattern.html#8690" class="Function">expander</a> <a id="8699" class="Symbol">:</a> <a id="8701" class="Symbol">∀</a> <a id="8703" class="Symbol">{</a><a id="8704" href="Meta.Copattern.html#8704" class="Bound">m</a> <a id="8706" href="Meta.Copattern.html#8706" class="Bound">n</a> <a id="8708" class="Symbol">:</a> <a id="8710" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="8711" class="Symbol">}</a> <a id="8713" class="Symbol">→</a> <a id="8715" href="Meta.Copattern.html#7835" class="Record">Unused</a> <a id="8722" href="Meta.Copattern.html#8704" class="Bound">m</a> <a id="8724" class="Symbol">→</a> <a id="8726" href="Meta.Copattern.html#7835" class="Record">Unused</a> <a id="8733" href="Meta.Copattern.html#8706" class="Bound">n</a>
  <a id="8737" class="Keyword">unquoteDef</a> <a id="8748" href="Meta.Copattern.html#8690" class="Function">expander</a> <a id="8757" class="Symbol">=</a> <a id="8759" href="Meta.Copattern.html#6540" class="Function">define-eta-expansion</a> <a id="8780" href="Meta.Copattern.html#8690" class="Function">expander</a>

  <a id="8792" class="Comment">-- Raises a type error: the function should have a declaration.</a>
  <a id="8858" class="Comment">-- unquoteDecl uncool = define-copatternω uncool neat</a>
</pre></body></html>