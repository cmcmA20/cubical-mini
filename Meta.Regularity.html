<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Regularity</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Keyword">module</a> <a id="31" href="Meta.Regularity.html" class="Module">Meta.Regularity</a> <a id="47" class="Keyword">where</a>

<a id="54" class="Keyword">open</a> <a id="59" class="Keyword">import</a> <a id="66" href="Foundations.Base.html" class="Module">Foundations.Base</a>

<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="Meta.Effect.Alt.html" class="Module">Meta.Effect.Alt</a>
<a id="112" class="Keyword">open</a> <a id="117" class="Keyword">import</a> <a id="124" href="Meta.Reflection.Base.html" class="Module">Meta.Reflection.Base</a>
<a id="145" class="Keyword">open</a> <a id="150" class="Keyword">import</a> <a id="157" href="Meta.Reflection.Subst.html" class="Module">Meta.Reflection.Subst</a>

<a id="180" class="Keyword">open</a> <a id="185" class="Keyword">import</a> <a id="192" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="207" class="Keyword">open</a> <a id="212" class="Keyword">import</a> <a id="219" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="234" class="Keyword">open</a> <a id="239" class="Keyword">import</a> <a id="246" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="278" class="Keyword">open</a> <a id="283" class="Keyword">import</a> <a id="290" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="306" class="Keyword">open</a> <a id="311" class="Keyword">import</a> <a id="318" href="Data.Maybe.Instances.Alt.html" class="Module">Data.Maybe.Instances.Alt</a>


<a id="345" class="Comment">{-
A tactic for reducing &quot;transport refl x&quot; in other-wise normal terms. The
implementation is actually surprisingly simple: A term of the form (e.g.)

    transp (λ _ → A) i0 (f (transp (λ _ → B) i0 x))

is already a blueprint for how to normalise it. We simply have to turn it into

    λ i → transp (λ _ → A) i (f (transp (λ _ → B) i x))

so that the constant transports reduce away when (i = i1). Abstracting over i,
this gives a path from the initial term to its &quot;regular normal form&quot;, which
may be the worst name ever.

More generally, we replace terms of the form `transp Al φ x` with `transp Al (φ ∨ i) x`
recursively (inside-out), on the condition that Al is constant when i = i1.
-}</a>

<a id="1038" class="Keyword">private</a>
  <a id="1048" class="Keyword">open</a> <a id="1053" class="Keyword">import</a> <a id="1060" href="Agda.Primitive.Cubical.html" class="Module">Agda.Primitive.Cubical</a> <a id="1083" class="Keyword">using</a> <a id="1089" class="Symbol">(</a> <a id="1091" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a> <a id="1101" class="Symbol">)</a>
  <a id="1105" class="Comment">-- We have a double composition operator that doesn&#39;t use the</a>
  <a id="1169" class="Comment">-- fancy hcomp syntax in its definition. This has better type</a>
  <a id="1233" class="Comment">-- inference for one of the macros since it guarantees that the base</a>
  <a id="1304" class="Comment">-- (q i) is independent of j without any reduction.</a>
  <a id="double-comp"></a><a id="1358" href="Meta.Regularity.html#1358" class="Function">double-comp</a>
    <a id="1374" class="Symbol">:</a> <a id="1376" class="Symbol">∀</a> <a id="1378" class="Symbol">{</a><a id="1379" href="Meta.Regularity.html#1379" class="Bound">ℓ</a><a id="1380" class="Symbol">}</a> <a id="1382" class="Symbol">{</a><a id="1383" href="Meta.Regularity.html#1383" class="Bound">A</a> <a id="1385" class="Symbol">:</a> <a id="1387" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="1392" href="Meta.Regularity.html#1379" class="Bound">ℓ</a><a id="1393" class="Symbol">}</a> <a id="1395" class="Symbol">{</a><a id="1396" href="Meta.Regularity.html#1396" class="Bound">w</a> <a id="1398" href="Meta.Regularity.html#1398" class="Bound">z</a> <a id="1400" class="Symbol">:</a> <a id="1402" href="Meta.Regularity.html#1383" class="Bound">A</a><a id="1403" class="Symbol">}</a> <a id="1405" class="Symbol">(</a><a id="1406" href="Meta.Regularity.html#1406" class="Bound">x</a> <a id="1408" href="Meta.Regularity.html#1408" class="Bound">y</a> <a id="1410" class="Symbol">:</a> <a id="1412" href="Meta.Regularity.html#1383" class="Bound">A</a><a id="1413" class="Symbol">)</a>
    <a id="1419" class="Symbol">→</a> <a id="1421" href="Meta.Regularity.html#1396" class="Bound">w</a> <a id="1423" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="1425" href="Meta.Regularity.html#1406" class="Bound">x</a> <a id="1427" class="Symbol">→</a> <a id="1429" href="Meta.Regularity.html#1406" class="Bound">x</a> <a id="1431" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="1433" href="Meta.Regularity.html#1408" class="Bound">y</a> <a id="1435" class="Symbol">→</a> <a id="1437" href="Meta.Regularity.html#1408" class="Bound">y</a> <a id="1439" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="1441" href="Meta.Regularity.html#1398" class="Bound">z</a>
    <a id="1447" class="Symbol">→</a> <a id="1449" href="Meta.Regularity.html#1396" class="Bound">w</a> <a id="1451" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="1453" href="Meta.Regularity.html#1398" class="Bound">z</a>
  <a id="1457" href="Meta.Regularity.html#1358" class="Function">double-comp</a> <a id="1469" href="Meta.Regularity.html#1469" class="Bound">x</a> <a id="1471" href="Meta.Regularity.html#1471" class="Bound">y</a> <a id="1473" href="Meta.Regularity.html#1473" class="Bound">p</a> <a id="1475" href="Meta.Regularity.html#1475" class="Bound">q</a> <a id="1477" href="Meta.Regularity.html#1477" class="Bound">r</a> <a id="1479" href="Meta.Regularity.html#1479" class="Bound">i</a> <a id="1481" class="Symbol">=</a> <a id="1483" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a>
    <a id="1497" class="Symbol">(λ</a> <a id="1500" class="Symbol">{</a> <a id="1502" href="Meta.Regularity.html#1502" class="Bound">j</a> <a id="1504" class="Symbol">(</a><a id="1505" href="Meta.Regularity.html#1479" class="Bound">i</a> <a id="1507" class="Symbol">=</a> <a id="1509" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="1511" class="Symbol">)</a> <a id="1513" class="Symbol">→</a> <a id="1515" href="Meta.Regularity.html#1473" class="Bound">p</a> <a id="1517" class="Symbol">(</a><a id="1518" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="1520" href="Meta.Regularity.html#1502" class="Bound">j</a><a id="1521" class="Symbol">)</a> <a id="1523" class="Symbol">;</a> <a id="1525" href="Meta.Regularity.html#1525" class="Bound">j</a> <a id="1527" class="Symbol">(</a><a id="1528" href="Meta.Regularity.html#1479" class="Bound">i</a> <a id="1530" class="Symbol">=</a> <a id="1532" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="1534" class="Symbol">)</a> <a id="1536" class="Symbol">→</a> <a id="1538" href="Meta.Regularity.html#1477" class="Bound">r</a> <a id="1540" href="Meta.Regularity.html#1525" class="Bound">j</a> <a id="1542" class="Symbol">})</a> <a id="1545" class="Symbol">(</a><a id="1546" href="Meta.Regularity.html#1475" class="Bound">q</a> <a id="1548" href="Meta.Regularity.html#1479" class="Bound">i</a><a id="1549" class="Symbol">)</a>

  <a id="1554" class="Comment">-- The regularity tactic can operate in two modes: `precise` will work</a>
  <a id="1627" class="Comment">-- with the type-checker to identify which `transp`s are along refl,</a>
  <a id="1698" class="Comment">-- and which should be preserved. The `fast` mode says YOLO and</a>
  <a id="1764" class="Comment">-- assumes that **every** application of `transp` is one that would</a>
  <a id="1834" class="Comment">-- reduce by regularity. Needless to say, only use `fast` when you&#39;re</a>
  <a id="1906" class="Comment">-- sure that&#39;s the case (e.g. the fibres of a displayed category over</a>
  <a id="1978" class="Comment">-- Sets)</a>
  <a id="1989" class="Keyword">data</a> <a id="Regularity-precision"></a><a id="1994" href="Meta.Regularity.html#1994" class="Datatype">Regularity-precision</a> <a id="2015" class="Symbol">:</a> <a id="2017" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="2022" class="Keyword">where</a>
    <a id="Regularity-precision.precise"></a><a id="2032" href="Meta.Regularity.html#2032" class="InductiveConstructor">precise</a> <a id="Regularity-precision.fast"></a><a id="2040" href="Meta.Regularity.html#2040" class="InductiveConstructor">fast</a> <a id="2045" class="Symbol">:</a> <a id="2047" href="Meta.Regularity.html#1994" class="Datatype">Regularity-precision</a>
  <a id="2070" class="Comment">-- As the name implies, `precise` is `precise`, while `fast` is</a>
  <a id="2136" class="Comment">-- `fast`. The reason is that `fast` will avoid traversing many of the</a>
  <a id="2209" class="Comment">-- terms involved in a `transp`: It doesn&#39;t care about the level, it</a>
  <a id="2280" class="Comment">-- doesn&#39;t care about the line, and it doesn&#39;t care about the</a>
  <a id="2344" class="Comment">-- cofibration.</a>

  <a id="2363" class="Comment">-- The core of the tactic is this triad of mutually recursive</a>
  <a id="2427" class="Comment">-- functions. In all three of them, the `Nat` argument indicates how</a>
  <a id="2498" class="Comment">-- many binders we&#39;ve gone under: it is the dimension variable we</a>
  <a id="2566" class="Comment">-- abstracted over at the start.</a>
  <a id="refl-transport"></a><a id="2601" href="Meta.Regularity.html#2601" class="Function">refl-transport</a> <a id="2616" class="Symbol">:</a> <a id="2618" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2620" class="Symbol">→</a> <a id="2622" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2627" class="Symbol">→</a> <a id="2629" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2632" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2639" class="Comment">-- ^ Determines whether an application of `transp` is a case of</a>
  <a id="2705" class="Comment">-- regularity, and if so, replaces it by `regular`. Precondition: its</a>
  <a id="2777" class="Comment">-- subterms must already be reduced.</a>
  <a id="go"></a><a id="2816" href="Meta.Regularity.html#2816" class="Function">go</a>  <a id="2820" class="Symbol">:</a> <a id="2822" href="Meta.Regularity.html#1994" class="Datatype">Regularity-precision</a> <a id="2843" class="Symbol">→</a> <a id="2845" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2847" class="Symbol">→</a> <a id="2849" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2854" class="Symbol">→</a> <a id="2856" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2859" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2866" class="Comment">-- ^ Reduces all the subterms, and finds applications of `transp` to</a>
  <a id="2937" class="Comment">-- hand off to `refl-transport`.</a>
  <a id="go*"></a><a id="2972" href="Meta.Regularity.html#2972" class="Function">go*</a> <a id="2976" class="Symbol">:</a> <a id="2978" href="Meta.Regularity.html#1994" class="Datatype">Regularity-precision</a> <a id="2999" class="Symbol">→</a> <a id="3001" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3003" class="Symbol">→</a> <a id="3005" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3010" class="Symbol">(</a><a id="3011" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3015" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3019" class="Symbol">)</a> <a id="3021" class="Symbol">→</a> <a id="3023" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="3026" class="Symbol">(</a><a id="3027" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3032" class="Symbol">(</a><a id="3033" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3037" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3041" class="Symbol">))</a>
  <a id="3046" class="Comment">-- ^ Isn&#39;t the termination checker just lovely?</a>

  <a id="3097" href="Meta.Regularity.html#2601" class="Function">refl-transport</a> <a id="3112" href="Meta.Regularity.html#3112" class="Bound">n</a> <a id="3114" href="Meta.Regularity.html#3114" class="Bound">tm</a><a id="3116" class="Symbol">@(</a><a id="3118" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3122" class="Symbol">(</a><a id="3123" class="Keyword">quote</a> <a id="3129" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3135" class="Symbol">)</a> <a id="3137" class="Symbol">(</a><a id="3138" href="Meta.Regularity.html#3138" class="Bound">ℓ</a> <a id="3140" href="Meta.Reflection.Base.html#4976" class="InductiveConstructor Operator">h∷</a> <a id="3143" href="Meta.Regularity.html#3143" class="Bound">Al</a> <a id="3146" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="3149" href="Meta.Regularity.html#3149" class="Bound">φ</a> <a id="3151" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="3154" href="Meta.Regularity.html#3154" class="Bound">x</a> <a id="3156" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="3159" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3161" class="Symbol">))</a> <a id="3164" class="Symbol">=</a>
    <a id="3170" class="Comment">-- This match might make you wonder: Can&#39;t Al be a line of</a>
    <a id="3233" class="Comment">-- functions, so that the transport will have more arguments? No:</a>
    <a id="3303" class="Comment">-- The term is in normal form.</a>
    <a id="3338" class="Symbol">(</a><a id="3339" class="Keyword">do</a>
      <a id="3348" href="Agda.Builtin.Reflection.html#11057" class="Postulate">debug-print</a> <a id="3360" class="String">&quot;tactic.regularity&quot;</a> <a id="3380" class="Number">10</a> <a id="3383" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="3385" class="String">&quot;Checking regularity of &quot;</a> <a id="3411" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3413" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="3421" href="Meta.Regularity.html#3114" class="Bound">tm</a> <a id="3424" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3426" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="3435" class="Keyword">let</a> <a id="3439" href="Meta.Regularity.html#3439" class="Bound">φ′</a> <a id="3442" class="Symbol">=</a> <a id="3444" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3448" class="Symbol">(</a><a id="3449" class="Keyword">quote</a> <a id="3455" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="3458" class="Symbol">)</a> <a id="3460" class="Symbol">(</a><a id="3461" href="Meta.Regularity.html#3149" class="Bound">φ</a> <a id="3463" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="3466" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="3470" href="Meta.Regularity.html#3112" class="Bound">n</a> <a id="3472" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="3475" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="3478" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3480" class="Symbol">)</a>
      <a id="3488" class="Keyword">let</a> <a id="3492" href="Meta.Regularity.html#3492" class="Bound">tm′</a> <a id="3496" class="Symbol">=</a> <a id="3498" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3502" class="Symbol">(</a><a id="3503" class="Keyword">quote</a> <a id="3509" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3515" class="Symbol">)</a> <a id="3517" class="Symbol">(</a><a id="3518" href="Meta.Regularity.html#3138" class="Bound">ℓ</a> <a id="3520" href="Meta.Reflection.Base.html#4976" class="InductiveConstructor Operator">h∷</a> <a id="3523" href="Meta.Regularity.html#3143" class="Bound">Al</a> <a id="3526" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="3529" href="Meta.Regularity.html#3439" class="Bound">φ′</a> <a id="3532" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="3535" href="Meta.Regularity.html#3154" class="Bound">x</a> <a id="3537" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="3540" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3542" class="Symbol">)</a>
      <a id="3550" class="Comment">-- We simply ask Agda to check that the newly constructed term `transp Al (φ ∨ i) x`</a>
      <a id="3641" class="Comment">-- is correct, i.e. that Al is constant on (i = i1).</a>
      <a id="3700" class="Comment">-- If it isn&#39;t, we backtrack and leave the term unchanged.</a>
      <a id="3765" class="Comment">-- Note that if Al itself contains constant transports, we have already processed those,</a>
      <a id="3860" class="Comment">-- so they reduce away when (i = i1).</a>
      <a id="3904" href="Agda.Builtin.Reflection.html#8914" class="Postulate">check-type</a> <a id="3915" href="Meta.Regularity.html#3492" class="Bound">tm′</a> <a id="3919" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="3927" class="Comment">-- inferType doesn&#39;t trigger the constancy check https://github.com/agda/agda/issues/6585</a>
      <a id="4023" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4028" href="Meta.Regularity.html#3492" class="Bound">tm′</a><a id="4031" class="Symbol">)</a> <a id="4033" href="Meta.Effect.Alt.html#320" class="Field Operator">&lt;|&gt;</a>
    <a id="4041" class="Symbol">(</a><a id="4042" class="Keyword">do</a>
      <a id="4051" href="Agda.Builtin.Reflection.html#11057" class="Postulate">debug-print</a> <a id="4063" class="String">&quot;tactic.regularity&quot;</a> <a id="4083" class="Number">10</a> <a id="4086" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="4088" class="String">&quot;NOT a (transport refl): &quot;</a> <a id="4115" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4117" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="4125" href="Meta.Regularity.html#3114" class="Bound">tm</a> <a id="4128" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4130" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="4139" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4144" href="Meta.Regularity.html#3114" class="Bound">tm</a><a id="4146" class="Symbol">)</a>
  <a id="4150" href="Meta.Regularity.html#2601" class="CatchallClause Function">refl-transport</a><a id="4164" class="CatchallClause"> </a><a id="4165" class="CatchallClause Symbol">_</a><a id="4166" class="CatchallClause"> </a><a id="4167" href="Meta.Regularity.html#4167" class="CatchallClause Bound">tm</a> <a id="4170" class="Symbol">=</a> <a id="4172" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4177" href="Meta.Regularity.html#4167" class="Bound">tm</a>

  <a id="4183" class="Comment">-- Boring term traversal.</a>
  <a id="4211" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4214" href="Meta.Regularity.html#4214" class="Bound">pre</a> <a id="4218" href="Meta.Regularity.html#4218" class="Bound">n</a> <a id="4220" class="Symbol">(</a><a id="4221" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4225" href="Meta.Regularity.html#4225" class="Bound">x</a> <a id="4227" href="Meta.Regularity.html#4227" class="Bound">args</a><a id="4231" class="Symbol">)</a> <a id="4233" class="Symbol">=</a> <a id="4235" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4239" href="Meta.Regularity.html#4225" class="Bound">x</a> <a id="4241" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4245" href="Meta.Regularity.html#2972" class="Function">go*</a> <a id="4249" href="Meta.Regularity.html#4214" class="Bound">pre</a> <a id="4253" href="Meta.Regularity.html#4218" class="Bound">n</a> <a id="4255" href="Meta.Regularity.html#4227" class="Bound">args</a>
  <a id="4262" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4265" href="Meta.Regularity.html#4265" class="Bound">pre</a> <a id="4269" href="Meta.Regularity.html#4269" class="Bound">n</a> <a id="4271" class="Symbol">(</a><a id="4272" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4276" href="Meta.Regularity.html#4276" class="Bound">c</a> <a id="4278" href="Meta.Regularity.html#4278" class="Bound">args</a><a id="4282" class="Symbol">)</a> <a id="4284" class="Symbol">=</a> <a id="4286" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4290" href="Meta.Regularity.html#4276" class="Bound">c</a> <a id="4292" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4296" href="Meta.Regularity.html#2972" class="Function">go*</a> <a id="4300" href="Meta.Regularity.html#4265" class="Bound">pre</a> <a id="4304" href="Meta.Regularity.html#4269" class="Bound">n</a> <a id="4306" href="Meta.Regularity.html#4278" class="Bound">args</a>
  <a id="4313" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4316" href="Meta.Regularity.html#2040" class="InductiveConstructor">fast</a> <a id="4321" href="Meta.Regularity.html#4321" class="Bound">n</a> <a id="4323" class="Symbol">(</a><a id="4324" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4328" class="Symbol">(</a><a id="4329" class="Keyword">quote</a> <a id="4335" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4341" class="Symbol">)</a> <a id="4343" class="Symbol">(</a><a id="4344" href="Meta.Regularity.html#4344" class="Bound">ℓ</a> <a id="4346" href="Meta.Reflection.Base.html#4976" class="InductiveConstructor Operator">h∷</a> <a id="4349" href="Meta.Regularity.html#4349" class="Bound">Al</a> <a id="4352" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="4355" href="Meta.Regularity.html#4355" class="Bound">φ</a> <a id="4357" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="4360" href="Meta.Regularity.html#4360" class="Bound">x</a> <a id="4362" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="4365" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4367" class="Symbol">))</a> <a id="4370" class="Symbol">=</a> <a id="4372" class="Keyword">do</a>
    <a id="4379" href="Meta.Regularity.html#4379" class="Bound">x</a> <a id="4381" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="4383" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4386" href="Meta.Regularity.html#2040" class="InductiveConstructor">fast</a> <a id="4391" href="Meta.Regularity.html#4321" class="Bound">n</a> <a id="4393" href="Meta.Regularity.html#4360" class="Bound">x</a>
    <a id="4399" class="Keyword">let</a> <a id="4403" href="Meta.Regularity.html#4403" class="Bound">φ′</a> <a id="4406" class="Symbol">=</a> <a id="4408" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4412" class="Symbol">(</a><a id="4413" class="Keyword">quote</a> <a id="4419" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="4422" class="Symbol">)</a> <a id="4424" class="Symbol">(</a><a id="4425" href="Meta.Regularity.html#4355" class="Bound">φ</a> <a id="4427" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="4430" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4434" href="Meta.Regularity.html#4321" class="Bound">n</a> <a id="4436" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4439" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="4442" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4444" class="Symbol">)</a>
    <a id="4450" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4455" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="4457" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4461" class="Symbol">(</a><a id="4462" class="Keyword">quote</a> <a id="4468" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4474" class="Symbol">)</a> <a id="4476" class="Symbol">(</a><a id="4477" href="Meta.Regularity.html#4344" class="Bound">ℓ</a> <a id="4479" href="Meta.Reflection.Base.html#4976" class="InductiveConstructor Operator">h∷</a> <a id="4482" href="Meta.Regularity.html#4349" class="Bound">Al</a> <a id="4485" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="4488" href="Meta.Regularity.html#4403" class="Bound">φ′</a> <a id="4491" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="4494" href="Meta.Regularity.html#4379" class="Bound">x</a> <a id="4496" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="4499" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4501" class="Symbol">)</a>
  <a id="4505" href="Meta.Regularity.html#2816" class="CatchallClause Function">go</a><a id="4507" class="CatchallClause"> </a><a id="4508" href="Meta.Regularity.html#4508" class="CatchallClause Bound">pre</a><a id="4511" class="CatchallClause"> </a><a id="4512" href="Meta.Regularity.html#4512" class="CatchallClause Bound">n</a><a id="4513" class="CatchallClause"> </a><a id="4514" class="CatchallClause Symbol">(</a><a id="4515" href="Agda.Builtin.Reflection.html#5251" class="CatchallClause InductiveConstructor">def</a><a id="4518" class="CatchallClause"> </a><a id="4519" href="Meta.Regularity.html#4519" class="CatchallClause Bound">f</a><a id="4520" class="CatchallClause"> </a><a id="4521" href="Meta.Regularity.html#4521" class="CatchallClause Bound">args</a><a id="4525" class="CatchallClause Symbol">)</a> <a id="4527" class="Symbol">=</a> <a id="4529" class="Keyword">do</a>
    <a id="4536" href="Meta.Regularity.html#4536" class="Bound">as</a> <a id="4539" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="4541" href="Meta.Regularity.html#2972" class="Function">go*</a> <a id="4545" href="Meta.Regularity.html#4508" class="Bound">pre</a> <a id="4549" href="Meta.Regularity.html#4512" class="Bound">n</a> <a id="4551" href="Meta.Regularity.html#4521" class="Bound">args</a>
    <a id="4560" href="Meta.Regularity.html#2601" class="Function">refl-transport</a> <a id="4575" href="Meta.Regularity.html#4512" class="Bound">n</a> <a id="4577" class="Symbol">(</a><a id="4578" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4582" href="Meta.Regularity.html#4519" class="Bound">f</a> <a id="4584" href="Meta.Regularity.html#4536" class="Bound">as</a><a id="4586" class="Symbol">)</a>
  <a id="4590" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4593" href="Meta.Regularity.html#4593" class="Bound">pre</a> <a id="4597" href="Meta.Regularity.html#4597" class="Bound">k</a> <a id="4599" href="Meta.Regularity.html#4599" class="Bound">t</a><a id="4600" class="Symbol">@(</a><a id="4602" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4606" href="Meta.Regularity.html#4606" class="Bound">v</a> <a id="4608" class="Symbol">(</a><a id="4609" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4613" href="Meta.Regularity.html#4613" class="Bound">nm</a> <a id="4616" href="Meta.Regularity.html#4616" class="Bound">b</a><a id="4617" class="Symbol">))</a> <a id="4620" class="Symbol">=</a> <a id="4622" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4626" href="Meta.Regularity.html#4606" class="Bound">v</a> <a id="4628" href="Foundations.Pi.Base.html#1761" class="Function Operator">∘</a> <a id="4630" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4634" href="Meta.Regularity.html#4613" class="Bound">nm</a> <a id="4637" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4641" href="Meta.Reflection.Base.html#3793" class="Function">under-abs</a> <a id="4651" href="Meta.Regularity.html#4599" class="Bound">t</a> <a id="4653" class="Symbol">(</a><a id="4654" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4657" href="Meta.Regularity.html#4593" class="Bound">pre</a> <a id="4661" class="Symbol">(</a><a id="4662" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4666" href="Meta.Regularity.html#4597" class="Bound">k</a><a id="4667" class="Symbol">)</a> <a id="4669" href="Meta.Regularity.html#4616" class="Bound">b</a><a id="4670" class="Symbol">)</a>
  <a id="4674" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4677" href="Meta.Regularity.html#4677" class="Bound">pre</a> <a id="4681" href="Meta.Regularity.html#4681" class="Bound">n</a> <a id="4683" class="Symbol">(</a><a id="4684" href="Agda.Builtin.Reflection.html#5361" class="InductiveConstructor">pat-lam</a> <a id="4692" href="Meta.Regularity.html#4692" class="Bound">cs</a> <a id="4695" href="Meta.Regularity.html#4695" class="Bound">args</a><a id="4699" class="Symbol">)</a> <a id="4701" class="Symbol">=</a> <a id="4703" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="4714" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="4716" class="String">&quot;regularity: Can not deal with pattern lambdas&quot;</a> <a id="4764" class="Comment">-- TODO can we do something about this?</a>
  <a id="4806" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4809" href="Meta.Regularity.html#4809" class="Bound">pre</a> <a id="4813" href="Meta.Regularity.html#4813" class="Bound">n</a> <a id="4815" href="Meta.Regularity.html#4815" class="Bound">t</a><a id="4816" class="Symbol">@(</a><a id="4818" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="4821" class="Symbol">(</a><a id="4822" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="4826" href="Meta.Regularity.html#4826" class="Bound">i</a> <a id="4828" href="Meta.Regularity.html#4828" class="Bound">a</a><a id="4829" class="Symbol">)</a> <a id="4831" class="Symbol">(</a><a id="4832" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4836" href="Meta.Regularity.html#4836" class="Bound">nm</a> <a id="4839" href="Meta.Regularity.html#4839" class="Bound">b</a><a id="4840" class="Symbol">))</a> <a id="4843" class="Symbol">=</a> <a id="4845" class="Keyword">do</a>
    <a id="4852" href="Meta.Regularity.html#4852" class="Bound">a</a> <a id="4854" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="4856" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4859" href="Meta.Regularity.html#4809" class="Bound">pre</a> <a id="4863" href="Meta.Regularity.html#4813" class="Bound">n</a> <a id="4865" href="Meta.Regularity.html#4828" class="Bound">a</a>
    <a id="4871" href="Meta.Regularity.html#4871" class="Bound">b</a> <a id="4873" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="4875" href="Meta.Reflection.Base.html#3793" class="Function">under-abs</a> <a id="4885" href="Meta.Regularity.html#4815" class="Bound">t</a> <a id="4887" class="Symbol">(</a><a id="4888" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4891" href="Meta.Regularity.html#4809" class="Bound">pre</a> <a id="4895" class="Symbol">(</a><a id="4896" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4900" href="Meta.Regularity.html#4813" class="Bound">n</a><a id="4901" class="Symbol">)</a> <a id="4903" href="Meta.Regularity.html#4839" class="Bound">b</a><a id="4904" class="Symbol">)</a>
    <a id="4910" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4915" class="Symbol">(</a><a id="4916" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="4919" class="Symbol">(</a><a id="4920" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="4924" href="Meta.Regularity.html#4826" class="Bound">i</a> <a id="4926" href="Meta.Regularity.html#4852" class="Bound">a</a><a id="4927" class="Symbol">)</a> <a id="4929" class="Symbol">(</a><a id="4930" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4934" href="Meta.Regularity.html#4836" class="Bound">nm</a> <a id="4937" href="Meta.Regularity.html#4871" class="Bound">b</a><a id="4938" class="Symbol">))</a>
  <a id="4943" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4946" href="Meta.Regularity.html#4946" class="Bound">pre</a> <a id="4950" href="Meta.Regularity.html#4950" class="Bound">n</a> <a id="4952" class="Symbol">(</a><a id="4953" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="4963" href="Meta.Regularity.html#4963" class="Bound">s</a><a id="4964" class="Symbol">)</a> <a id="4966" class="Symbol">=</a> <a id="4968" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4973" class="Symbol">(</a><a id="4974" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="4984" href="Meta.Regularity.html#4963" class="Bound">s</a><a id="4985" class="Symbol">)</a>
  <a id="4989" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="4992" href="Meta.Regularity.html#4992" class="Bound">pre</a> <a id="4996" href="Meta.Regularity.html#4996" class="Bound">n</a> <a id="4998" class="Symbol">(</a><a id="4999" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5003" href="Meta.Regularity.html#5003" class="Bound">l</a><a id="5004" class="Symbol">)</a> <a id="5006" class="Symbol">=</a> <a id="5008" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5013" class="Symbol">(</a><a id="5014" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5018" href="Meta.Regularity.html#5003" class="Bound">l</a><a id="5019" class="Symbol">)</a>
  <a id="5023" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="5026" href="Meta.Regularity.html#5026" class="Bound">pre</a> <a id="5030" href="Meta.Regularity.html#5030" class="Bound">n</a> <a id="5032" class="Symbol">(</a><a id="5033" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5038" href="Meta.Regularity.html#5038" class="Bound">x</a> <a id="5040" href="Meta.Regularity.html#5040" class="Bound">args</a><a id="5044" class="Symbol">)</a> <a id="5046" class="Symbol">=</a> <a id="5048" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5053" href="Meta.Regularity.html#5038" class="Bound">x</a> <a id="5055" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="5059" href="Meta.Regularity.html#2972" class="Function">go*</a> <a id="5063" href="Meta.Regularity.html#5026" class="Bound">pre</a> <a id="5067" href="Meta.Regularity.html#5030" class="Bound">n</a> <a id="5069" href="Meta.Regularity.html#5040" class="Bound">args</a>
  <a id="5076" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="5079" href="Meta.Regularity.html#5079" class="Bound">pre</a> <a id="5083" href="Meta.Regularity.html#5083" class="Bound">n</a> <a id="5085" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="5093" class="Symbol">=</a> <a id="5095" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5100" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

  <a id="5111" href="Meta.Regularity.html#2972" class="Function">go*</a> <a id="5115" href="Meta.Regularity.html#5115" class="Bound">pre</a> <a id="5119" href="Meta.Regularity.html#5119" class="Bound">n</a> <a id="5121" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5124" class="Symbol">=</a> <a id="5126" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5131" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="5136" href="Meta.Regularity.html#2972" class="Function">go*</a> <a id="5140" href="Meta.Regularity.html#5140" class="Bound">pre</a> <a id="5144" href="Meta.Regularity.html#5144" class="Bound">n</a> <a id="5146" class="Symbol">(</a><a id="5147" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5151" href="Meta.Regularity.html#5151" class="Bound">i</a> <a id="5153" href="Meta.Regularity.html#5153" class="Bound">a</a> <a id="5155" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5157" href="Meta.Regularity.html#5157" class="Bound">as</a><a id="5159" class="Symbol">)</a> <a id="5161" class="Symbol">=</a> <a id="5163" class="Keyword">do</a>
    <a id="5170" href="Meta.Regularity.html#5170" class="Bound">a</a> <a id="5172" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="5174" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="5177" href="Meta.Regularity.html#5140" class="Bound">pre</a> <a id="5181" href="Meta.Regularity.html#5144" class="Bound">n</a> <a id="5183" href="Meta.Regularity.html#5153" class="Bound">a</a>
    <a id="5189" class="Symbol">(</a><a id="5190" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5194" href="Meta.Regularity.html#5151" class="Bound">i</a> <a id="5196" href="Meta.Regularity.html#5170" class="Bound">a</a> <a id="5198" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷_</a><a id="5200" class="Symbol">)</a> <a id="5202" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="5206" href="Meta.Regularity.html#2972" class="Function">go*</a> <a id="5210" href="Meta.Regularity.html#5140" class="Bound">pre</a> <a id="5214" href="Meta.Regularity.html#5144" class="Bound">n</a> <a id="5216" href="Meta.Regularity.html#5157" class="Bound">as</a>

  <a id="5222" class="Comment">-- To turn a term into a regularity path, given a level of precision,</a>
  <a id="5294" class="Comment">-- all we have to do is raise the term by one, do the procedure above,</a>
  <a id="5367" class="Comment">-- then wrap it in a lambda. Nice!</a>
  <a id="to-regularity-path"></a><a id="5404" href="Meta.Regularity.html#5404" class="Function">to-regularity-path</a> <a id="5423" class="Symbol">:</a> <a id="5425" href="Meta.Regularity.html#1994" class="Datatype">Regularity-precision</a> <a id="5446" class="Symbol">→</a> <a id="5448" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5453" class="Symbol">→</a> <a id="5455" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="5458" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5465" href="Meta.Regularity.html#5404" class="Function">to-regularity-path</a> <a id="5484" href="Meta.Regularity.html#5484" class="Bound">pre</a> <a id="5488" href="Meta.Regularity.html#5488" class="Bound">tm</a> <a id="5491" class="Symbol">=</a> <a id="5493" class="Keyword">do</a>
    <a id="5500" href="Meta.Regularity.html#5500" class="Bound">tm</a> <a id="5503" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="5505" href="Meta.Reflection.Subst.html#7159" class="Function">raiseTC</a> <a id="5513" class="Number">1</a> <a id="5515" href="Meta.Regularity.html#5488" class="Bound">tm</a>
    <a id="5522" class="Comment">-- Since we&#39;ll be comparing terms, Agda really wants them to be</a>
    <a id="5590" class="Comment">-- well-scoped. Since we shifted eeeverything up by one, we have to</a>
    <a id="5662" class="Comment">-- grow the context, too.</a>
    <a id="5692" href="Meta.Regularity.html#5692" class="Bound">tm</a> <a id="5695" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="5697" href="Meta.Reflection.Base.html#8134" class="Function">resetting</a> <a id="5707" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="5709" href="Agda.Builtin.Reflection.html#9277" class="Postulate">extend-context</a> <a id="5724" class="String">&quot;i&quot;</a> <a id="5728" class="Symbol">(</a><a id="5729" href="Meta.Reflection.Base.html#5153" class="Function">argN</a> <a id="5734" class="Symbol">(</a><a id="5735" class="Keyword">quoteTerm</a> <a id="5745" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="5746" class="Symbol">))</a> <a id="5749" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="5751" href="Meta.Regularity.html#2816" class="Function">go</a> <a id="5754" href="Meta.Regularity.html#5484" class="Bound">pre</a> <a id="5758" class="Number">0</a> <a id="5760" href="Meta.Regularity.html#5500" class="Bound">tm</a>
    <a id="5767" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5772" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="5774" href="Meta.Reflection.Base.html#4457" class="Function">vlam</a> <a id="5779" class="String">&quot;i&quot;</a> <a id="5783" href="Meta.Regularity.html#5692" class="Bound">tm</a>

  <a id="5789" class="Comment">-- Extend a path x ＝ y to a path x′ ＝ y′, where x′ --&gt; x and y′ --&gt; y</a>
  <a id="5861" class="Comment">-- under the given regularity precision. Shorthand for composing</a>
  <a id="5928" class="Comment">--    regularity! ∙ p ∙ sym regularity!.</a>
  <a id="regular!-worker"></a><a id="5971" href="Meta.Regularity.html#5971" class="Function">regular!-worker</a> <a id="5987" class="Symbol">:</a>
    <a id="5993" class="Symbol">∀</a> <a id="5995" class="Symbol">{</a><a id="5996" href="Meta.Regularity.html#5996" class="Bound">ℓ</a><a id="5997" class="Symbol">}</a> <a id="5999" class="Symbol">{</a><a id="6000" href="Meta.Regularity.html#6000" class="Bound">A</a> <a id="6002" class="Symbol">:</a> <a id="6004" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="6009" href="Meta.Regularity.html#5996" class="Bound">ℓ</a><a id="6010" class="Symbol">}</a> <a id="6012" class="Symbol">{</a><a id="6013" href="Meta.Regularity.html#6013" class="Bound">x</a> <a id="6015" href="Meta.Regularity.html#6015" class="Bound">y</a> <a id="6017" class="Symbol">:</a> <a id="6019" href="Meta.Regularity.html#6000" class="Bound">A</a><a id="6020" class="Symbol">}</a>
    <a id="6026" class="Symbol">→</a> <a id="6028" href="Meta.Regularity.html#1994" class="Datatype">Regularity-precision</a>
    <a id="6053" class="Symbol">→</a> <a id="6055" href="Meta.Regularity.html#6013" class="Bound">x</a> <a id="6057" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="6059" href="Meta.Regularity.html#6015" class="Bound">y</a>
    <a id="6065" class="Symbol">→</a> <a id="6067" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="6076" class="Symbol">→</a> <a id="6078" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="6081" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="6085" href="Meta.Regularity.html#5971" class="Function">regular!-worker</a> <a id="6101" class="Symbol">{</a><a id="6102" class="Argument">x</a> <a id="6104" class="Symbol">=</a> <a id="6106" href="Meta.Regularity.html#6106" class="Bound">x</a><a id="6107" class="Symbol">}</a> <a id="6109" class="Symbol">{</a><a id="6110" href="Meta.Regularity.html#6110" class="Bound">y</a><a id="6111" class="Symbol">}</a> <a id="6113" href="Meta.Regularity.html#6113" class="Bound">pre</a> <a id="6117" href="Meta.Regularity.html#6117" class="Bound">p</a> <a id="6119" href="Meta.Regularity.html#6119" class="Bound">goal</a> <a id="6124" class="Symbol">=</a> <a id="6126" class="Keyword">do</a>
    <a id="6133" href="Meta.Regularity.html#6133" class="Bound">gt</a> <a id="6136" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6138" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6149" href="Meta.Regularity.html#6119" class="Bound">goal</a>
    <a id="6158" href="Meta.Regularity.html#6158" class="Bound">`x</a> <a id="6161" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6163" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6171" href="Meta.Regularity.html#6106" class="Bound">x</a>
    <a id="6177" href="Meta.Regularity.html#6177" class="Bound">`y</a> <a id="6180" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6182" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6190" href="Meta.Regularity.html#6110" class="Bound">y</a>
    <a id="6196" href="Meta.Regularity.html#6196" class="Bound">`p</a> <a id="6199" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6201" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6209" href="Meta.Regularity.html#6117" class="Bound">p</a>
    <a id="6215" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6220" class="Symbol">(_</a> <a id="6223" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6225" href="Meta.Regularity.html#6225" class="Bound">l</a> <a id="6227" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6229" href="Meta.Regularity.html#6229" class="Bound">r</a><a id="6230" class="Symbol">)</a> <a id="6232" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6234" href="Meta.Reflection.Base.html#10274" class="Function">unapply-path</a> <a id="6247" href="Meta.Effect.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6251" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6262" href="Meta.Regularity.html#6119" class="Bound">goal</a>
      <a id="6273" class="Keyword">where</a> <a id="6279" class="CatchallClause Symbol">_</a> <a id="6281" class="Symbol">→</a> <a id="6283" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="6294" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="6301" href="Meta.Regularity.html#6301" class="Bound">l</a> <a id="6303" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6305" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6315" href="Meta.Effect.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6319" href="Meta.Reflection.Base.html#9445" class="Function">wait-for-type</a> <a id="6333" href="Meta.Regularity.html#6225" class="Bound">l</a>
    <a id="6339" href="Meta.Regularity.html#6339" class="Bound">r</a> <a id="6341" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6343" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6353" href="Meta.Effect.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6357" href="Meta.Reflection.Base.html#9445" class="Function">wait-for-type</a> <a id="6371" href="Meta.Regularity.html#6229" class="Bound">r</a>
    <a id="6377" href="Meta.Regularity.html#6377" class="Bound">reg</a> <a id="6381" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6383" href="Meta.Regularity.html#5404" class="Function">to-regularity-path</a> <a id="6402" href="Meta.Regularity.html#6113" class="Bound">pre</a> <a id="6406" href="Meta.Regularity.html#6301" class="Bound">l</a>
    <a id="6412" href="Meta.Regularity.html#6412" class="Bound">reg′</a> <a id="6417" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6419" href="Meta.Regularity.html#5404" class="Function">to-regularity-path</a> <a id="6438" href="Meta.Regularity.html#6113" class="Bound">pre</a> <a id="6442" href="Meta.Regularity.html#6339" class="Bound">r</a>
    <a id="6448" href="Meta.Reflection.Base.html#12158" class="Function">unify-loudly</a> <a id="6461" href="Meta.Regularity.html#6119" class="Bound">goal</a> <a id="6466" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="6468" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6472" class="Symbol">(</a><a id="6473" class="Keyword">quote</a> <a id="6479" href="Meta.Regularity.html#1358" class="Function">double-comp</a><a id="6490" class="Symbol">)</a> <a id="6492" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a>
         <a id="6503" href="Meta.Regularity.html#6158" class="Bound">`x</a> <a id="6506" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="6509" href="Meta.Regularity.html#6177" class="Bound">`y</a> <a id="6512" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="6515" href="Meta.Regularity.html#6377" class="Bound">reg</a>
      <a id="6525" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="6528" href="Meta.Regularity.html#6196" class="Bound">`p</a>
      <a id="6537" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="6540" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6544" class="Symbol">(</a><a id="6545" class="Keyword">quote</a> <a id="6551" href="Foundations.Prim.Kan.html#1504" class="Function">sym</a><a id="6554" class="Symbol">)</a> <a id="6556" class="Symbol">(</a><a id="6557" href="Meta.Regularity.html#6412" class="Bound">reg′</a> <a id="6562" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="6565" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6567" class="Symbol">)</a>
      <a id="6575" href="Meta.Reflection.Base.html#4944" class="InductiveConstructor Operator">v∷</a> <a id="6578" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="6582" class="Keyword">module</a> <a id="Regularity"></a><a id="6589" href="Meta.Regularity.html#6589" class="Module">Regularity</a> <a id="6600" class="Keyword">where</a>
  <a id="6608" class="Keyword">open</a> <a id="6613" href="Meta.Regularity.html#1994" class="Module">Regularity-precision</a> <a id="6634" class="Keyword">public</a>
  <a id="6643" class="Comment">-- The reflection interface: Regularity.reduce! will, well, reduce a</a>
  <a id="6714" class="Comment">-- term. There&#39;s a lot of blocking involved in making this work.</a>
  <a id="6781" class="Keyword">macro</a>
    <a id="Regularity.reduce!"></a><a id="6791" href="Meta.Regularity.html#6791" class="Function">reduce!</a> <a id="6799" class="Symbol">:</a> <a id="6801" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6806" class="Symbol">→</a> <a id="6808" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="6811" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="6817" href="Meta.Regularity.html#6791" class="Function">reduce!</a> <a id="6825" href="Meta.Regularity.html#6825" class="Bound">goal</a> <a id="6830" class="Symbol">=</a> <a id="6832" class="Keyword">do</a>
      <a id="6841" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6846" class="Symbol">(_</a> <a id="6849" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6851" href="Meta.Regularity.html#6851" class="Bound">l</a> <a id="6853" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6855" href="Meta.Regularity.html#6855" class="Bound">r</a><a id="6856" class="Symbol">)</a> <a id="6858" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6860" href="Meta.Reflection.Base.html#10274" class="Function">unapply-path</a> <a id="6873" href="Meta.Effect.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6877" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6888" href="Meta.Regularity.html#6825" class="Bound">goal</a>
        <a id="6901" class="Keyword">where</a> <a id="6907" class="CatchallClause Symbol">_</a> <a id="6909" class="Symbol">→</a> <a id="6911" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="6922" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="6931" href="Meta.Regularity.html#6931" class="Bound">reg</a> <a id="6935" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="6937" href="Meta.Regularity.html#5404" class="Function">to-regularity-path</a> <a id="6956" href="Meta.Regularity.html#2032" class="InductiveConstructor">precise</a> <a id="6964" href="Meta.Effect.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6968" class="Symbol">(</a><a id="6969" href="Meta.Reflection.Base.html#9445" class="Function">wait-for-type</a> <a id="6983" href="Meta.Effect.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6987" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6997" href="Meta.Regularity.html#6851" class="Bound">l</a><a id="6998" class="Symbol">)</a>
      <a id="7006" href="Meta.Reflection.Base.html#12158" class="Function">unify-loudly</a> <a id="7019" href="Meta.Regularity.html#6825" class="Bound">goal</a> <a id="7024" href="Meta.Regularity.html#6931" class="Bound">reg</a>

    <a id="7033" class="Comment">-- We then have wrappers that reduce on one side, and expand on the</a>
    <a id="7105" class="Comment">-- other, depending on how precise you want the reduction to be.</a>
    <a id="Regularity.precise!"></a><a id="7174" href="Meta.Regularity.html#7174" class="Function">precise!</a> <a id="7183" class="Symbol">:</a> <a id="7185" class="Symbol">∀</a> <a id="7187" class="Symbol">{</a><a id="7188" href="Meta.Regularity.html#7188" class="Bound">ℓ</a><a id="7189" class="Symbol">}</a> <a id="7191" class="Symbol">{</a><a id="7192" href="Meta.Regularity.html#7192" class="Bound">A</a> <a id="7194" class="Symbol">:</a> <a id="7196" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7201" href="Meta.Regularity.html#7188" class="Bound">ℓ</a><a id="7202" class="Symbol">}</a> <a id="7204" class="Symbol">{</a><a id="7205" href="Meta.Regularity.html#7205" class="Bound">x</a> <a id="7207" href="Meta.Regularity.html#7207" class="Bound">y</a> <a id="7209" class="Symbol">:</a> <a id="7211" href="Meta.Regularity.html#7192" class="Bound">A</a><a id="7212" class="Symbol">}</a> <a id="7214" class="Symbol">→</a> <a id="7216" href="Meta.Regularity.html#7205" class="Bound">x</a> <a id="7218" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="7220" href="Meta.Regularity.html#7207" class="Bound">y</a> <a id="7222" class="Symbol">→</a> <a id="7224" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7229" class="Symbol">→</a> <a id="7231" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7234" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="Regularity.fast!"></a><a id="7240" href="Meta.Regularity.html#7240" class="Function">fast!</a> <a id="7246" class="Symbol">:</a> <a id="7248" class="Symbol">∀</a> <a id="7250" class="Symbol">{</a><a id="7251" href="Meta.Regularity.html#7251" class="Bound">ℓ</a><a id="7252" class="Symbol">}</a> <a id="7254" class="Symbol">{</a><a id="7255" href="Meta.Regularity.html#7255" class="Bound">A</a> <a id="7257" class="Symbol">:</a> <a id="7259" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7264" href="Meta.Regularity.html#7251" class="Bound">ℓ</a><a id="7265" class="Symbol">}</a> <a id="7267" class="Symbol">{</a><a id="7268" href="Meta.Regularity.html#7268" class="Bound">x</a> <a id="7270" href="Meta.Regularity.html#7270" class="Bound">y</a> <a id="7272" class="Symbol">:</a> <a id="7274" href="Meta.Regularity.html#7255" class="Bound">A</a><a id="7275" class="Symbol">}</a> <a id="7277" class="Symbol">→</a> <a id="7279" href="Meta.Regularity.html#7268" class="Bound">x</a> <a id="7281" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="7283" href="Meta.Regularity.html#7270" class="Bound">y</a> <a id="7285" class="Symbol">→</a> <a id="7287" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7292" class="Symbol">→</a> <a id="7294" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7297" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="7304" href="Meta.Regularity.html#7174" class="Function">precise!</a> <a id="7313" href="Meta.Regularity.html#7313" class="Bound">p</a> <a id="7315" href="Meta.Regularity.html#7315" class="Bound">goal</a> <a id="7320" class="Symbol">=</a> <a id="7322" href="Meta.Regularity.html#5971" class="Function">regular!-worker</a> <a id="7338" href="Meta.Regularity.html#2032" class="InductiveConstructor">precise</a> <a id="7346" href="Meta.Regularity.html#7313" class="Bound">p</a> <a id="7348" href="Meta.Regularity.html#7315" class="Bound">goal</a>
    <a id="7357" href="Meta.Regularity.html#7240" class="Function">fast!</a> <a id="7363" href="Meta.Regularity.html#7363" class="Bound">p</a> <a id="7365" href="Meta.Regularity.html#7365" class="Bound">goal</a> <a id="7370" class="Symbol">=</a> <a id="7372" href="Meta.Regularity.html#5971" class="Function">regular!-worker</a> <a id="7388" href="Meta.Regularity.html#2040" class="InductiveConstructor">fast</a> <a id="7393" href="Meta.Regularity.html#7363" class="Bound">p</a> <a id="7395" href="Meta.Regularity.html#7365" class="Bound">goal</a>

    <a id="7405" class="Comment">-- For debugging purposes, this macro will take a term and output</a>
    <a id="7475" class="Comment">-- its (transport refl)-normal form, according to the given level of</a>
    <a id="7548" class="Comment">-- precision.</a>
    <a id="Regularity.reduct"></a><a id="7566" href="Meta.Regularity.html#7566" class="Function">reduct</a> <a id="7573" class="Symbol">:</a> <a id="7575" href="Meta.Regularity.html#1994" class="Datatype">Regularity-precision</a> <a id="7596" class="Symbol">→</a> <a id="7598" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7603" class="Symbol">→</a> <a id="7605" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7610" class="Symbol">→</a> <a id="7612" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7615" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="7621" href="Meta.Regularity.html#7566" class="Function">reduct</a> <a id="7628" href="Meta.Regularity.html#7628" class="Bound">pres</a> <a id="7633" href="Meta.Regularity.html#7633" class="Bound">tm</a> <a id="7636" class="Symbol">_</a> <a id="7638" class="Symbol">=</a> <a id="7640" class="Keyword">do</a>
      <a id="7649" href="Meta.Regularity.html#7649" class="Bound">orig</a> <a id="7654" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="7656" href="Meta.Reflection.Base.html#9445" class="Function">wait-for-type</a> <a id="7670" href="Meta.Effect.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="7674" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="7684" href="Meta.Regularity.html#7633" class="Bound">tm</a>
      <a id="7693" href="Meta.Regularity.html#7693" class="Bound">tm</a> <a id="7696" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="7698" href="Meta.Regularity.html#5404" class="Function">to-regularity-path</a> <a id="7717" href="Meta.Regularity.html#7628" class="Bound">pres</a> <a id="7722" href="Meta.Regularity.html#7649" class="Bound">orig</a>
      <a id="7733" href="Meta.Regularity.html#7733" class="Bound">red</a> <a id="7737" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="7739" href="Meta.Reflection.Subst.html#7388" class="Function">applyTC</a> <a id="7747" href="Meta.Regularity.html#7693" class="Bound">tm</a> <a id="7750" class="Symbol">(</a><a id="7751" href="Meta.Reflection.Base.html#5153" class="Function">argN</a> <a id="7756" class="Symbol">(</a><a id="7757" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="7761" class="Symbol">(</a><a id="7762" class="Keyword">quote</a> <a id="7768" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="7770" class="Symbol">)</a> <a id="7772" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7774" class="Symbol">))</a> <a id="7777" href="Meta.Effect.Bind.html#266" class="Field Operator">&gt;&gt;=</a> <a id="7781" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a>
      <a id="7797" href="Meta.Regularity.html#7797" class="Bound">`pres</a> <a id="7803" href="Meta.Effect.Bind.html#266" class="Field Operator">←</a> <a id="7805" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="7813" href="Meta.Regularity.html#7628" class="Bound">pres</a>
      <a id="7824" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a>
        <a id="7843" href="Meta.Literals.FromProduct.html#385" class="Function Operator">[</a> <a id="7845" class="String">&quot;The term\n\n  &quot;</a> <a id="7862" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7864" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="7872" href="Meta.Regularity.html#7649" class="Bound">orig</a> <a id="7877" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7879" class="String">&quot;\n\nreduces modulo &quot;</a>
        <a id="7909" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7911" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="7919" href="Meta.Regularity.html#7797" class="Bound">`pres</a> <a id="7925" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7927" class="String">&quot; regularity to\n\n  &quot;</a>
        <a id="7958" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7960" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="7968" href="Meta.Regularity.html#7733" class="Bound">red</a> <a id="7972" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7974" class="String">&quot;\n&quot;</a> <a id="7979" href="Meta.Literals.FromProduct.html#385" class="Function Operator">]</a>

<a id="7982" class="Comment">-- Test cases.</a>
<a id="7997" class="Keyword">module</a>
  <a id="8006" href="Meta.Regularity.html#8006" class="Module">_</a> <a id="8008" class="Symbol">{</a><a id="8009" href="Meta.Regularity.html#8009" class="Bound">ℓ</a> <a id="8011" href="Meta.Regularity.html#8011" class="Bound">ℓ′</a><a id="8013" class="Symbol">}</a> <a id="8015" class="Symbol">{</a><a id="8016" href="Meta.Regularity.html#8016" class="Bound">A</a> <a id="8018" class="Symbol">:</a> <a id="8020" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8025" href="Meta.Regularity.html#8009" class="Bound">ℓ</a><a id="8026" class="Symbol">}</a> <a id="8028" class="Symbol">{</a><a id="8029" href="Meta.Regularity.html#8029" class="Bound">B</a> <a id="8031" class="Symbol">:</a> <a id="8033" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8038" href="Meta.Regularity.html#8011" class="Bound">ℓ′</a><a id="8040" class="Symbol">}</a> <a id="8042" class="Symbol">(</a><a id="8043" href="Meta.Regularity.html#8043" class="Bound">f</a> <a id="8045" href="Meta.Regularity.html#8045" class="Bound">g</a> <a id="8047" class="Symbol">:</a> <a id="8049" href="Meta.Regularity.html#8016" class="Bound">A</a> <a id="8051" class="Symbol">→</a> <a id="8053" href="Meta.Regularity.html#8029" class="Bound">B</a><a id="8054" class="Symbol">)</a> <a id="8056" class="Symbol">(</a><a id="8057" href="Meta.Regularity.html#8057" class="Bound">x</a> <a id="8059" class="Symbol">:</a> <a id="8061" href="Meta.Regularity.html#8016" class="Bound">A</a><a id="8062" class="Symbol">)</a>
    <a id="8068" class="Symbol">(</a><a id="8069" href="Meta.Regularity.html#8069" class="Bound">a-loop</a> <a id="8076" class="Symbol">:</a> <a id="8078" class="Symbol">(</a><a id="8079" href="Meta.Regularity.html#8079" class="Bound">i</a> <a id="8081" class="Symbol">:</a> <a id="8083" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="8084" class="Symbol">)</a> <a id="8086" class="Symbol">→</a> <a id="8088" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8093" href="Meta.Regularity.html#8009" class="Bound">ℓ</a> <a id="8095" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">[</a> <a id="8097" class="Symbol">(</a><a id="8098" href="Meta.Regularity.html#8079" class="Bound">i</a> <a id="8100" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">∨</a> <a id="8102" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="8104" href="Meta.Regularity.html#8079" class="Bound">i</a><a id="8105" class="Symbol">)</a> <a id="8107" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">↦</a> <a id="8109" class="Symbol">(λ</a> <a id="8112" class="Symbol">.</a><a id="8113" href="Meta.Regularity.html#8113" class="Bound">_</a> <a id="8115" class="Symbol">→</a> <a id="8117" href="Meta.Regularity.html#8016" class="Bound">A</a><a id="8118" class="Symbol">)</a> <a id="8120" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">]</a><a id="8121" class="Symbol">)</a>
  <a id="8125" class="Keyword">where</a> <a id="8131" class="Keyword">private</a>

  <a id="8142" href="Meta.Regularity.html#8142" class="Function">p</a> <a id="8144" class="Symbol">:</a> <a id="8146" class="Symbol">(</a><a id="8147" href="Meta.Regularity.html#8147" class="Bound">h</a> <a id="8149" class="Symbol">:</a> <a id="8151" class="Symbol">∀</a> <a id="8153" href="Meta.Regularity.html#8153" class="Bound">x</a> <a id="8155" class="Symbol">→</a> <a id="8157" href="Meta.Regularity.html#8043" class="Bound">f</a> <a id="8159" href="Meta.Regularity.html#8153" class="Bound">x</a> <a id="8161" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8163" href="Meta.Regularity.html#8045" class="Bound">g</a> <a id="8165" href="Meta.Regularity.html#8153" class="Bound">x</a><a id="8166" class="Symbol">)</a>
    <a id="8172" class="Symbol">→</a> <a id="8174" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8184" class="Symbol">(λ</a> <a id="8187" href="Meta.Regularity.html#8187" class="Bound">i</a> <a id="8189" class="Symbol">→</a> <a id="8191" href="Meta.Regularity.html#8016" class="Bound">A</a> <a id="8193" class="Symbol">→</a> <a id="8195" href="Meta.Regularity.html#8029" class="Bound">B</a><a id="8196" class="Symbol">)</a>
        <a id="8206" class="Symbol">(λ</a> <a id="8209" href="Meta.Regularity.html#8209" class="Bound">x</a> <a id="8211" class="Symbol">→</a> <a id="8213" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8223" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8228" class="Symbol">(</a><a id="8229" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8239" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8244" class="Symbol">(</a><a id="8245" href="Meta.Regularity.html#8043" class="Bound">f</a> <a id="8247" class="Symbol">(</a><a id="8248" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8258" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8263" href="Meta.Regularity.html#8209" class="Bound">x</a><a id="8264" class="Symbol">))))</a> <a id="8269" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8271" href="Meta.Regularity.html#8045" class="Bound">g</a>
  <a id="8275" href="Meta.Regularity.html#8142" class="Function">p</a> <a id="8277" href="Meta.Regularity.html#8277" class="Bound">h</a> <a id="8279" class="Symbol">=</a> <a id="8281" href="Meta.Regularity.html#6791" class="Macro">Regularity.reduce!</a> <a id="8300" href="Foundations.Base.html#5702" class="Function Operator">∙</a> <a id="8302" href="Foundations.Base.html#10961" class="Function">fun-ext</a> <a id="8310" href="Meta.Regularity.html#8277" class="Bound">h</a>

  <a id="8315" href="Meta.Regularity.html#8315" class="Function">q</a> <a id="8317" class="Symbol">:</a> <a id="8319" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8329" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8334" class="Symbol">(</a><a id="8335" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8342" class="Symbol">(λ</a> <a id="8345" href="Meta.Regularity.html#8345" class="Bound">i</a> <a id="8347" class="Symbol">→</a> <a id="8349" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8354" class="Symbol">(</a><a id="8355" href="Meta.Regularity.html#8069" class="Bound">a-loop</a> <a id="8362" href="Meta.Regularity.html#8345" class="Bound">i</a><a id="8363" class="Symbol">))</a> <a id="8366" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8369" href="Meta.Regularity.html#8057" class="Bound">x</a><a id="8370" class="Symbol">)</a> <a id="8372" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8374" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8381" class="Symbol">(λ</a> <a id="8384" href="Meta.Regularity.html#8384" class="Bound">i</a> <a id="8386" class="Symbol">→</a> <a id="8388" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8393" class="Symbol">(</a><a id="8394" href="Meta.Regularity.html#8069" class="Bound">a-loop</a> <a id="8401" href="Meta.Regularity.html#8384" class="Bound">i</a><a id="8402" class="Symbol">))</a> <a id="8405" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8408" href="Meta.Regularity.html#8057" class="Bound">x</a>
  <a id="8412" href="Meta.Regularity.html#8315" class="Function">q</a> <a id="8414" class="Symbol">=</a> <a id="8416" href="Meta.Regularity.html#6791" class="Macro">Regularity.reduce!</a>

  <a id="8438" class="Comment">-- Imprecise/fast reduction: According to it, the normal form of the</a>
  <a id="8509" class="Comment">-- transport below is refl. That&#39;s.. not the case, at least we don&#39;t</a>
  <a id="8580" class="Comment">-- know so. Precise regularity handles it, though.</a>
  <a id="8633" class="Comment">-- q′ : ⊤</a>
  <a id="8645" class="Comment">-- q′ = {! Regularity.reduct Regularity.fast (transp (λ i → outS (a-loop i)) i0 x) !}</a>

  <a id="8734" href="Meta.Regularity.html#8734" class="Function">r</a> <a id="8736" class="Symbol">:</a> <a id="8738" class="Symbol">(</a><a id="8739" href="Meta.Regularity.html#8739" class="Bound">h</a> <a id="8741" class="Symbol">:</a> <a id="8743" class="Symbol">∀</a> <a id="8745" href="Meta.Regularity.html#8745" class="Bound">x</a> <a id="8747" class="Symbol">→</a> <a id="8749" href="Meta.Regularity.html#8043" class="Bound">f</a> <a id="8751" href="Meta.Regularity.html#8745" class="Bound">x</a> <a id="8753" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8755" href="Meta.Regularity.html#8045" class="Bound">g</a> <a id="8757" href="Meta.Regularity.html#8745" class="Bound">x</a><a id="8758" class="Symbol">)</a> <a id="8760" class="Symbol">→</a> <a id="8762" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8772" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8777" class="Symbol">(</a><a id="8778" href="Meta.Regularity.html#8043" class="Bound">f</a> <a id="8780" href="Meta.Regularity.html#8057" class="Bound">x</a><a id="8781" class="Symbol">)</a> <a id="8783" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8785" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8795" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8800" class="Symbol">(</a><a id="8801" href="Meta.Regularity.html#8045" class="Bound">g</a> <a id="8803" href="Meta.Regularity.html#8057" class="Bound">x</a><a id="8804" class="Symbol">)</a>
  <a id="8808" href="Meta.Regularity.html#8734" class="Function">r</a> <a id="8810" href="Meta.Regularity.html#8810" class="Bound">h</a> <a id="8812" class="Symbol">=</a> <a id="8814" href="Meta.Regularity.html#7174" class="Macro">Regularity.precise!</a> <a id="8834" class="Symbol">(</a><a id="8835" href="Meta.Regularity.html#8810" class="Bound">h</a> <a id="8837" href="Meta.Regularity.html#8057" class="Bound">x</a><a id="8838" class="Symbol">)</a>

  <a id="8843" href="Meta.Regularity.html#8843" class="Function">s</a> <a id="8845" class="Symbol">:</a> <a id="8847" class="Symbol">(</a><a id="8848" href="Meta.Regularity.html#8848" class="Bound">h</a> <a id="8850" class="Symbol">:</a> <a id="8852" class="Symbol">∀</a> <a id="8854" href="Meta.Regularity.html#8854" class="Bound">x</a> <a id="8856" class="Symbol">→</a> <a id="8858" href="Meta.Regularity.html#8043" class="Bound">f</a> <a id="8860" href="Meta.Regularity.html#8854" class="Bound">x</a> <a id="8862" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8864" href="Meta.Regularity.html#8045" class="Bound">g</a> <a id="8866" href="Meta.Regularity.html#8854" class="Bound">x</a><a id="8867" class="Symbol">)</a> <a id="8869" class="Symbol">→</a> <a id="8871" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8881" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8886" class="Symbol">(</a><a id="8887" href="Meta.Regularity.html#8045" class="Bound">g</a> <a id="8889" href="Meta.Regularity.html#8057" class="Bound">x</a><a id="8890" class="Symbol">)</a> <a id="8892" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8894" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8904" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8909" class="Symbol">(</a><a id="8910" href="Meta.Regularity.html#8043" class="Bound">f</a> <a id="8912" href="Meta.Regularity.html#8057" class="Bound">x</a><a id="8913" class="Symbol">)</a>
  <a id="8917" href="Meta.Regularity.html#8843" class="Function">s</a> <a id="8919" href="Meta.Regularity.html#8919" class="Bound">h</a> <a id="8921" class="Symbol">=</a> <a id="8923" href="Foundations.Prim.Kan.html#1504" class="Function">sym</a> <a id="8927" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="8929" href="Meta.Regularity.html#7240" class="Macro">Regularity.fast!</a> <a id="8946" class="Symbol">(</a><a id="8947" href="Meta.Regularity.html#8919" class="Bound">h</a> <a id="8949" href="Meta.Regularity.html#8057" class="Bound">x</a><a id="8950" class="Symbol">)</a>
</pre></body></html>