<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Regularity</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Keyword">module</a> <a id="31" href="Meta.Regularity.html" class="Module">Meta.Regularity</a> <a id="47" class="Keyword">where</a>

<a id="54" class="Keyword">open</a> <a id="59" class="Keyword">import</a> <a id="66" href="Foundations.Base.html" class="Module">Foundations.Base</a>

<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="Meta.Effect.Alt.html" class="Module">Meta.Effect.Alt</a>
<a id="112" class="Keyword">open</a> <a id="117" class="Keyword">import</a> <a id="124" href="Meta.Reflection.Base.html" class="Module">Meta.Reflection.Base</a>
<a id="145" class="Keyword">open</a> <a id="150" class="Keyword">import</a> <a id="157" href="Meta.Reflection.Subst.html" class="Module">Meta.Reflection.Subst</a>

<a id="180" class="Keyword">open</a> <a id="185" class="Keyword">import</a> <a id="192" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="207" class="Keyword">open</a> <a id="212" class="Keyword">import</a> <a id="219" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="234" class="Keyword">open</a> <a id="239" class="Keyword">import</a> <a id="246" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="278" class="Keyword">open</a> <a id="283" class="Keyword">import</a> <a id="290" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="306" class="Keyword">open</a> <a id="311" class="Keyword">import</a> <a id="318" href="Data.Maybe.Instances.Alt.html" class="Module">Data.Maybe.Instances.Alt</a>
<a id="343" class="Keyword">open</a> <a id="348" class="Keyword">import</a> <a id="355" href="Data.Reflection.Abs.html" class="Module">Data.Reflection.Abs</a>
<a id="375" class="Keyword">open</a> <a id="380" class="Keyword">import</a> <a id="387" href="Data.Reflection.Argument.html" class="Module">Data.Reflection.Argument</a>
<a id="412" class="Keyword">open</a> <a id="417" class="Keyword">import</a> <a id="424" href="Data.Reflection.Error.html" class="Module">Data.Reflection.Error</a>
<a id="446" class="Keyword">open</a> <a id="451" class="Keyword">import</a> <a id="458" href="Data.Reflection.Fixity.html" class="Module">Data.Reflection.Fixity</a>
<a id="481" class="Keyword">open</a> <a id="486" class="Keyword">import</a> <a id="493" href="Data.Reflection.Instances.FromString.html" class="Module">Data.Reflection.Instances.FromString</a>
<a id="530" class="Keyword">open</a> <a id="535" class="Keyword">import</a> <a id="542" href="Data.Reflection.Literal.html" class="Module">Data.Reflection.Literal</a>
<a id="566" class="Keyword">open</a> <a id="571" class="Keyword">import</a> <a id="578" href="Data.Reflection.Meta.html" class="Module">Data.Reflection.Meta</a>
<a id="599" class="Keyword">open</a> <a id="604" class="Keyword">import</a> <a id="611" href="Data.Reflection.Name.html" class="Module">Data.Reflection.Name</a>
<a id="632" class="Keyword">open</a> <a id="637" class="Keyword">import</a> <a id="644" href="Data.Reflection.Term.html" class="Module">Data.Reflection.Term</a>


<a id="667" class="Comment">{-
A tactic for reducing &quot;transport refl x&quot; in other-wise normal terms. The
implementation is actually surprisingly simple: A term of the form (e.g.)

    transp (λ _ → A) i0 (f (transp (λ _ → B) i0 x))

is already a blueprint for how to normalise it. We simply have to turn it into

    λ i → transp (λ _ → A) i (f (transp (λ _ → B) i x))

so that the constant transports reduce away when (i = i1). Abstracting over i,
this gives a path from the initial term to its &quot;regular normal form&quot;, which
may be the worst name ever.

More generally, we replace terms of the form `transp Al φ x` with `transp Al (φ ∨ i) x`
recursively (inside-out), on the condition that Al is constant when i = i1.
-}</a>

<a id="1360" class="Keyword">private</a>
  <a id="1370" class="Keyword">open</a> <a id="1375" class="Keyword">import</a> <a id="1382" href="Agda.Primitive.Cubical.html" class="Module">Agda.Primitive.Cubical</a> <a id="1405" class="Keyword">using</a> <a id="1411" class="Symbol">(</a> <a id="1413" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a> <a id="1423" class="Symbol">)</a>
  <a id="1427" class="Comment">-- We have a double composition operator that doesn&#39;t use the</a>
  <a id="1491" class="Comment">-- fancy hcomp syntax in its definition. This has better type</a>
  <a id="1555" class="Comment">-- inference for one of the macros since it guarantees that the base</a>
  <a id="1626" class="Comment">-- (q i) is independent of j without any reduction.</a>
  <a id="double-comp"></a><a id="1680" href="Meta.Regularity.html#1680" class="Function">double-comp</a>
    <a id="1696" class="Symbol">:</a> <a id="1698" class="Symbol">∀</a> <a id="1700" class="Symbol">{</a><a id="1701" href="Meta.Regularity.html#1701" class="Bound">ℓ</a><a id="1702" class="Symbol">}</a> <a id="1704" class="Symbol">{</a><a id="1705" href="Meta.Regularity.html#1705" class="Bound">A</a> <a id="1707" class="Symbol">:</a> <a id="1709" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="1714" href="Meta.Regularity.html#1701" class="Bound">ℓ</a><a id="1715" class="Symbol">}</a> <a id="1717" class="Symbol">{</a><a id="1718" href="Meta.Regularity.html#1718" class="Bound">w</a> <a id="1720" href="Meta.Regularity.html#1720" class="Bound">z</a> <a id="1722" class="Symbol">:</a> <a id="1724" href="Meta.Regularity.html#1705" class="Bound">A</a><a id="1725" class="Symbol">}</a> <a id="1727" class="Symbol">(</a><a id="1728" href="Meta.Regularity.html#1728" class="Bound">x</a> <a id="1730" href="Meta.Regularity.html#1730" class="Bound">y</a> <a id="1732" class="Symbol">:</a> <a id="1734" href="Meta.Regularity.html#1705" class="Bound">A</a><a id="1735" class="Symbol">)</a>
    <a id="1741" class="Symbol">→</a> <a id="1743" href="Meta.Regularity.html#1718" class="Bound">w</a> <a id="1745" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="1747" href="Meta.Regularity.html#1728" class="Bound">x</a> <a id="1749" class="Symbol">→</a> <a id="1751" href="Meta.Regularity.html#1728" class="Bound">x</a> <a id="1753" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="1755" href="Meta.Regularity.html#1730" class="Bound">y</a> <a id="1757" class="Symbol">→</a> <a id="1759" href="Meta.Regularity.html#1730" class="Bound">y</a> <a id="1761" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="1763" href="Meta.Regularity.html#1720" class="Bound">z</a>
    <a id="1769" class="Symbol">→</a> <a id="1771" href="Meta.Regularity.html#1718" class="Bound">w</a> <a id="1773" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="1775" href="Meta.Regularity.html#1720" class="Bound">z</a>
  <a id="1779" href="Meta.Regularity.html#1680" class="Function">double-comp</a> <a id="1791" href="Meta.Regularity.html#1791" class="Bound">x</a> <a id="1793" href="Meta.Regularity.html#1793" class="Bound">y</a> <a id="1795" href="Meta.Regularity.html#1795" class="Bound">p</a> <a id="1797" href="Meta.Regularity.html#1797" class="Bound">q</a> <a id="1799" href="Meta.Regularity.html#1799" class="Bound">r</a> <a id="1801" href="Meta.Regularity.html#1801" class="Bound">i</a> <a id="1803" class="Symbol">=</a> <a id="1805" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a>
    <a id="1819" class="Symbol">(λ</a> <a id="1822" class="Symbol">{</a> <a id="1824" href="Meta.Regularity.html#1824" class="Bound">j</a> <a id="1826" class="Symbol">(</a><a id="1827" href="Meta.Regularity.html#1801" class="Bound">i</a> <a id="1829" class="Symbol">=</a> <a id="1831" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="1833" class="Symbol">)</a> <a id="1835" class="Symbol">→</a> <a id="1837" href="Meta.Regularity.html#1795" class="Bound">p</a> <a id="1839" class="Symbol">(</a><a id="1840" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="1842" href="Meta.Regularity.html#1824" class="Bound">j</a><a id="1843" class="Symbol">)</a> <a id="1845" class="Symbol">;</a> <a id="1847" href="Meta.Regularity.html#1847" class="Bound">j</a> <a id="1849" class="Symbol">(</a><a id="1850" href="Meta.Regularity.html#1801" class="Bound">i</a> <a id="1852" class="Symbol">=</a> <a id="1854" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="1856" class="Symbol">)</a> <a id="1858" class="Symbol">→</a> <a id="1860" href="Meta.Regularity.html#1799" class="Bound">r</a> <a id="1862" href="Meta.Regularity.html#1847" class="Bound">j</a> <a id="1864" class="Symbol">})</a> <a id="1867" class="Symbol">(</a><a id="1868" href="Meta.Regularity.html#1797" class="Bound">q</a> <a id="1870" href="Meta.Regularity.html#1801" class="Bound">i</a><a id="1871" class="Symbol">)</a>

  <a id="1876" class="Comment">-- The regularity tactic can operate in two modes: `precise` will work</a>
  <a id="1949" class="Comment">-- with the type-checker to identify which `transp`s are along refl,</a>
  <a id="2020" class="Comment">-- and which should be preserved. The `fast` mode says YOLO and</a>
  <a id="2086" class="Comment">-- assumes that **every** application of `transp` is one that would</a>
  <a id="2156" class="Comment">-- reduce by regularity. Needless to say, only use `fast` when you&#39;re</a>
  <a id="2228" class="Comment">-- sure that&#39;s the case (e.g. the fibres of a displayed category over</a>
  <a id="2300" class="Comment">-- Sets)</a>
  <a id="2311" class="Keyword">data</a> <a id="Regularity-precision"></a><a id="2316" href="Meta.Regularity.html#2316" class="Datatype">Regularity-precision</a> <a id="2337" class="Symbol">:</a> <a id="2339" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="2344" class="Keyword">where</a>
    <a id="Regularity-precision.precise"></a><a id="2354" href="Meta.Regularity.html#2354" class="InductiveConstructor">precise</a> <a id="Regularity-precision.fast"></a><a id="2362" href="Meta.Regularity.html#2362" class="InductiveConstructor">fast</a> <a id="2367" class="Symbol">:</a> <a id="2369" href="Meta.Regularity.html#2316" class="Datatype">Regularity-precision</a>
  <a id="2392" class="Comment">-- As the name implies, `precise` is `precise`, while `fast` is</a>
  <a id="2458" class="Comment">-- `fast`. The reason is that `fast` will avoid traversing many of the</a>
  <a id="2531" class="Comment">-- terms involved in a `transp`: It doesn&#39;t care about the level, it</a>
  <a id="2602" class="Comment">-- doesn&#39;t care about the line, and it doesn&#39;t care about the</a>
  <a id="2666" class="Comment">-- cofibration.</a>

  <a id="2685" class="Comment">-- The core of the tactic is this triad of mutually recursive</a>
  <a id="2749" class="Comment">-- functions. In all three of them, the `Nat` argument indicates how</a>
  <a id="2820" class="Comment">-- many binders we&#39;ve gone under: it is the dimension variable we</a>
  <a id="2888" class="Comment">-- abstracted over at the start.</a>
  <a id="refl-transport"></a><a id="2923" href="Meta.Regularity.html#2923" class="Function">refl-transport</a> <a id="2938" class="Symbol">:</a> <a id="2940" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2942" class="Symbol">→</a> <a id="2944" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2949" class="Symbol">→</a> <a id="2951" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2954" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2961" class="Comment">-- ^ Determines whether an application of `transp` is a case of</a>
  <a id="3027" class="Comment">-- regularity, and if so, replaces it by `regular`. Precondition: its</a>
  <a id="3099" class="Comment">-- subterms must already be reduced.</a>
  <a id="go"></a><a id="3138" href="Meta.Regularity.html#3138" class="Function">go</a>  <a id="3142" class="Symbol">:</a> <a id="3144" href="Meta.Regularity.html#2316" class="Datatype">Regularity-precision</a> <a id="3165" class="Symbol">→</a> <a id="3167" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3169" class="Symbol">→</a> <a id="3171" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3176" class="Symbol">→</a> <a id="3178" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="3181" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3188" class="Comment">-- ^ Reduces all the subterms, and finds applications of `transp` to</a>
  <a id="3259" class="Comment">-- hand off to `refl-transport`.</a>
  <a id="go*"></a><a id="3294" href="Meta.Regularity.html#3294" class="Function">go*</a> <a id="3298" class="Symbol">:</a> <a id="3300" href="Meta.Regularity.html#2316" class="Datatype">Regularity-precision</a> <a id="3321" class="Symbol">→</a> <a id="3323" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3325" class="Symbol">→</a> <a id="3327" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3332" class="Symbol">(</a><a id="3333" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3337" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3341" class="Symbol">)</a> <a id="3343" class="Symbol">→</a> <a id="3345" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="3348" class="Symbol">(</a><a id="3349" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3354" class="Symbol">(</a><a id="3355" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3359" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3363" class="Symbol">))</a>
  <a id="3368" class="Comment">-- ^ Isn&#39;t the termination checker just lovely?</a>

  <a id="3419" href="Meta.Regularity.html#2923" class="Function">refl-transport</a> <a id="3434" href="Meta.Regularity.html#3434" class="Bound">n</a> <a id="3436" href="Meta.Regularity.html#3436" class="Bound">tm</a><a id="3438" class="Symbol">@(</a><a id="3440" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3444" class="Symbol">(</a><a id="3445" class="Keyword">quote</a> <a id="3451" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3457" class="Symbol">)</a> <a id="3459" class="Symbol">(</a><a id="3460" href="Meta.Regularity.html#3460" class="Bound">ℓ</a> <a id="3462" href="Data.Reflection.Argument.html#1396" class="InductiveConstructor Operator">h∷</a> <a id="3465" href="Meta.Regularity.html#3465" class="Bound">Al</a> <a id="3468" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3471" href="Meta.Regularity.html#3471" class="Bound">φ</a> <a id="3473" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3476" href="Meta.Regularity.html#3476" class="Bound">x</a> <a id="3478" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3481" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3483" class="Symbol">))</a> <a id="3486" class="Symbol">=</a>
    <a id="3492" class="Comment">-- This match might make you wonder: Can&#39;t Al be a line of</a>
    <a id="3555" class="Comment">-- functions, so that the transport will have more arguments? No:</a>
    <a id="3625" class="Comment">-- The term is in normal form.</a>
    <a id="3660" class="Symbol">(</a><a id="3661" class="Keyword">do</a>
      <a id="3670" href="Agda.Builtin.Reflection.html#11057" class="Postulate">debug-print</a> <a id="3682" class="String">&quot;tactic.regularity&quot;</a> <a id="3702" class="Number">10</a> <a id="3705" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="3707" class="String">&quot;Checking regularity of &quot;</a> <a id="3733" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3735" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="3744" href="Meta.Regularity.html#3436" class="Bound">tm</a> <a id="3747" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3749" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="3758" class="Keyword">let</a> <a id="3762" href="Meta.Regularity.html#3762" class="Bound">φ′</a> <a id="3765" class="Symbol">=</a> <a id="3767" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3771" class="Symbol">(</a><a id="3772" class="Keyword">quote</a> <a id="3778" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="3781" class="Symbol">)</a> <a id="3783" class="Symbol">(</a><a id="3784" href="Meta.Regularity.html#3471" class="Bound">φ</a> <a id="3786" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3789" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="3793" href="Meta.Regularity.html#3434" class="Bound">n</a> <a id="3795" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="3798" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3801" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3803" class="Symbol">)</a>
      <a id="3811" class="Keyword">let</a> <a id="3815" href="Meta.Regularity.html#3815" class="Bound">tm′</a> <a id="3819" class="Symbol">=</a> <a id="3821" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3825" class="Symbol">(</a><a id="3826" class="Keyword">quote</a> <a id="3832" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3838" class="Symbol">)</a> <a id="3840" class="Symbol">(</a><a id="3841" href="Meta.Regularity.html#3460" class="Bound">ℓ</a> <a id="3843" href="Data.Reflection.Argument.html#1396" class="InductiveConstructor Operator">h∷</a> <a id="3846" href="Meta.Regularity.html#3465" class="Bound">Al</a> <a id="3849" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3852" href="Meta.Regularity.html#3762" class="Bound">φ′</a> <a id="3855" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3858" href="Meta.Regularity.html#3476" class="Bound">x</a> <a id="3860" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3863" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3865" class="Symbol">)</a>
      <a id="3873" class="Comment">-- We simply ask Agda to check that the newly constructed term `transp Al (φ ∨ i) x`</a>
      <a id="3964" class="Comment">-- is correct, i.e. that Al is constant on (i = i1).</a>
      <a id="4023" class="Comment">-- If it isn&#39;t, we backtrack and leave the term unchanged.</a>
      <a id="4088" class="Comment">-- Note that if Al itself contains constant transports, we have already processed those,</a>
      <a id="4183" class="Comment">-- so they reduce away when (i = i1).</a>
      <a id="4227" href="Agda.Builtin.Reflection.html#8914" class="Postulate">check-type</a> <a id="4238" href="Meta.Regularity.html#3815" class="Bound">tm′</a> <a id="4242" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="4250" class="Comment">-- inferType doesn&#39;t trigger the constancy check https://github.com/agda/agda/issues/6585</a>
      <a id="4346" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4351" href="Meta.Regularity.html#3815" class="Bound">tm′</a><a id="4354" class="Symbol">)</a> <a id="4356" href="Meta.Effect.Alt.html#320" class="Field Operator">&lt;|&gt;</a>
    <a id="4364" class="Symbol">(</a><a id="4365" class="Keyword">do</a>
      <a id="4374" href="Agda.Builtin.Reflection.html#11057" class="Postulate">debug-print</a> <a id="4386" class="String">&quot;tactic.regularity&quot;</a> <a id="4406" class="Number">10</a> <a id="4409" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="4411" class="String">&quot;NOT a (transport refl): &quot;</a> <a id="4438" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4440" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="4449" href="Meta.Regularity.html#3436" class="Bound">tm</a> <a id="4452" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4454" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="4463" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4468" href="Meta.Regularity.html#3436" class="Bound">tm</a><a id="4470" class="Symbol">)</a>
  <a id="4474" href="Meta.Regularity.html#2923" class="CatchallClause Function">refl-transport</a><a id="4488" class="CatchallClause"> </a><a id="4489" class="CatchallClause Symbol">_</a><a id="4490" class="CatchallClause"> </a><a id="4491" href="Meta.Regularity.html#4491" class="CatchallClause Bound">tm</a> <a id="4494" class="Symbol">=</a> <a id="4496" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4501" href="Meta.Regularity.html#4491" class="Bound">tm</a>

  <a id="4507" class="Comment">-- Boring term traversal.</a>
  <a id="4535" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="4538" href="Meta.Regularity.html#4538" class="Bound">pre</a> <a id="4542" href="Meta.Regularity.html#4542" class="Bound">n</a> <a id="4544" class="Symbol">(</a><a id="4545" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4549" href="Meta.Regularity.html#4549" class="Bound">x</a> <a id="4551" href="Meta.Regularity.html#4551" class="Bound">args</a><a id="4555" class="Symbol">)</a> <a id="4557" class="Symbol">=</a> <a id="4559" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4563" href="Meta.Regularity.html#4549" class="Bound">x</a> <a id="4565" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4569" href="Meta.Regularity.html#3294" class="Function">go*</a> <a id="4573" href="Meta.Regularity.html#4538" class="Bound">pre</a> <a id="4577" href="Meta.Regularity.html#4542" class="Bound">n</a> <a id="4579" href="Meta.Regularity.html#4551" class="Bound">args</a>
  <a id="4586" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="4589" href="Meta.Regularity.html#4589" class="Bound">pre</a> <a id="4593" href="Meta.Regularity.html#4593" class="Bound">n</a> <a id="4595" class="Symbol">(</a><a id="4596" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4600" href="Meta.Regularity.html#4600" class="Bound">c</a> <a id="4602" href="Meta.Regularity.html#4602" class="Bound">args</a><a id="4606" class="Symbol">)</a> <a id="4608" class="Symbol">=</a> <a id="4610" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4614" href="Meta.Regularity.html#4600" class="Bound">c</a> <a id="4616" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4620" href="Meta.Regularity.html#3294" class="Function">go*</a> <a id="4624" href="Meta.Regularity.html#4589" class="Bound">pre</a> <a id="4628" href="Meta.Regularity.html#4593" class="Bound">n</a> <a id="4630" href="Meta.Regularity.html#4602" class="Bound">args</a>
  <a id="4637" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="4640" href="Meta.Regularity.html#2362" class="InductiveConstructor">fast</a> <a id="4645" href="Meta.Regularity.html#4645" class="Bound">n</a> <a id="4647" class="Symbol">(</a><a id="4648" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4652" class="Symbol">(</a><a id="4653" class="Keyword">quote</a> <a id="4659" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4665" class="Symbol">)</a> <a id="4667" class="Symbol">(</a><a id="4668" href="Meta.Regularity.html#4668" class="Bound">ℓ</a> <a id="4670" href="Data.Reflection.Argument.html#1396" class="InductiveConstructor Operator">h∷</a> <a id="4673" href="Meta.Regularity.html#4673" class="Bound">Al</a> <a id="4676" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4679" href="Meta.Regularity.html#4679" class="Bound">φ</a> <a id="4681" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4684" href="Meta.Regularity.html#4684" class="Bound">x</a> <a id="4686" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4689" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4691" class="Symbol">))</a> <a id="4694" class="Symbol">=</a> <a id="4696" class="Keyword">do</a>
    <a id="4703" href="Meta.Regularity.html#4703" class="Bound">x</a> <a id="4705" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="4707" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="4710" href="Meta.Regularity.html#2362" class="InductiveConstructor">fast</a> <a id="4715" href="Meta.Regularity.html#4645" class="Bound">n</a> <a id="4717" href="Meta.Regularity.html#4684" class="Bound">x</a>
    <a id="4723" class="Keyword">let</a> <a id="4727" href="Meta.Regularity.html#4727" class="Bound">φ′</a> <a id="4730" class="Symbol">=</a> <a id="4732" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4736" class="Symbol">(</a><a id="4737" class="Keyword">quote</a> <a id="4743" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="4746" class="Symbol">)</a> <a id="4748" class="Symbol">(</a><a id="4749" href="Meta.Regularity.html#4679" class="Bound">φ</a> <a id="4751" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4754" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4758" href="Meta.Regularity.html#4645" class="Bound">n</a> <a id="4760" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4763" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4766" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4768" class="Symbol">)</a>
    <a id="4774" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4779" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="4781" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4785" class="Symbol">(</a><a id="4786" class="Keyword">quote</a> <a id="4792" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4798" class="Symbol">)</a> <a id="4800" class="Symbol">(</a><a id="4801" href="Meta.Regularity.html#4668" class="Bound">ℓ</a> <a id="4803" href="Data.Reflection.Argument.html#1396" class="InductiveConstructor Operator">h∷</a> <a id="4806" href="Meta.Regularity.html#4673" class="Bound">Al</a> <a id="4809" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4812" href="Meta.Regularity.html#4727" class="Bound">φ′</a> <a id="4815" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4818" href="Meta.Regularity.html#4703" class="Bound">x</a> <a id="4820" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4823" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4825" class="Symbol">)</a>
  <a id="4829" href="Meta.Regularity.html#3138" class="CatchallClause Function">go</a><a id="4831" class="CatchallClause"> </a><a id="4832" href="Meta.Regularity.html#4832" class="CatchallClause Bound">pre</a><a id="4835" class="CatchallClause"> </a><a id="4836" href="Meta.Regularity.html#4836" class="CatchallClause Bound">n</a><a id="4837" class="CatchallClause"> </a><a id="4838" class="CatchallClause Symbol">(</a><a id="4839" href="Agda.Builtin.Reflection.html#5251" class="CatchallClause InductiveConstructor">def</a><a id="4842" class="CatchallClause"> </a><a id="4843" href="Meta.Regularity.html#4843" class="CatchallClause Bound">f</a><a id="4844" class="CatchallClause"> </a><a id="4845" href="Meta.Regularity.html#4845" class="CatchallClause Bound">args</a><a id="4849" class="CatchallClause Symbol">)</a> <a id="4851" class="Symbol">=</a> <a id="4853" class="Keyword">do</a>
    <a id="4860" href="Meta.Regularity.html#4860" class="Bound">as</a> <a id="4863" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="4865" href="Meta.Regularity.html#3294" class="Function">go*</a> <a id="4869" href="Meta.Regularity.html#4832" class="Bound">pre</a> <a id="4873" href="Meta.Regularity.html#4836" class="Bound">n</a> <a id="4875" href="Meta.Regularity.html#4845" class="Bound">args</a>
    <a id="4884" href="Meta.Regularity.html#2923" class="Function">refl-transport</a> <a id="4899" href="Meta.Regularity.html#4836" class="Bound">n</a> <a id="4901" class="Symbol">(</a><a id="4902" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4906" href="Meta.Regularity.html#4843" class="Bound">f</a> <a id="4908" href="Meta.Regularity.html#4860" class="Bound">as</a><a id="4910" class="Symbol">)</a>
  <a id="4914" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="4917" href="Meta.Regularity.html#4917" class="Bound">pre</a> <a id="4921" href="Meta.Regularity.html#4921" class="Bound">k</a> <a id="4923" href="Meta.Regularity.html#4923" class="Bound">t</a><a id="4924" class="Symbol">@(</a><a id="4926" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4930" href="Meta.Regularity.html#4930" class="Bound">v</a> <a id="4932" class="Symbol">(</a><a id="4933" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4937" href="Meta.Regularity.html#4937" class="Bound">nm</a> <a id="4940" href="Meta.Regularity.html#4940" class="Bound">b</a><a id="4941" class="Symbol">))</a> <a id="4944" class="Symbol">=</a> <a id="4946" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4950" href="Meta.Regularity.html#4930" class="Bound">v</a> <a id="4952" href="Foundations.Pi.Base.html#1761" class="Function Operator">∘</a> <a id="4954" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4958" href="Meta.Regularity.html#4937" class="Bound">nm</a> <a id="4961" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4965" href="Meta.Reflection.Base.html#3329" class="Function">under-abs</a> <a id="4975" href="Meta.Regularity.html#4923" class="Bound">t</a> <a id="4977" class="Symbol">(</a><a id="4978" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="4981" href="Meta.Regularity.html#4917" class="Bound">pre</a> <a id="4985" class="Symbol">(</a><a id="4986" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4990" href="Meta.Regularity.html#4921" class="Bound">k</a><a id="4991" class="Symbol">)</a> <a id="4993" href="Meta.Regularity.html#4940" class="Bound">b</a><a id="4994" class="Symbol">)</a>
  <a id="4998" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5001" href="Meta.Regularity.html#5001" class="Bound">pre</a> <a id="5005" href="Meta.Regularity.html#5005" class="Bound">n</a> <a id="5007" class="Symbol">(</a><a id="5008" href="Agda.Builtin.Reflection.html#5361" class="InductiveConstructor">pat-lam</a> <a id="5016" href="Meta.Regularity.html#5016" class="Bound">cs</a> <a id="5019" href="Meta.Regularity.html#5019" class="Bound">args</a><a id="5023" class="Symbol">)</a> <a id="5025" class="Symbol">=</a> <a id="5027" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="5038" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="5040" class="String">&quot;regularity: Can not deal with pattern lambdas&quot;</a> <a id="5088" class="Comment">-- TODO can we do something about this?</a>
  <a id="5130" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5133" href="Meta.Regularity.html#5133" class="Bound">pre</a> <a id="5137" href="Meta.Regularity.html#5137" class="Bound">n</a> <a id="5139" href="Meta.Regularity.html#5139" class="Bound">t</a><a id="5140" class="Symbol">@(</a><a id="5142" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="5145" class="Symbol">(</a><a id="5146" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5150" href="Meta.Regularity.html#5150" class="Bound">i</a> <a id="5152" href="Meta.Regularity.html#5152" class="Bound">a</a><a id="5153" class="Symbol">)</a> <a id="5155" class="Symbol">(</a><a id="5156" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="5160" href="Meta.Regularity.html#5160" class="Bound">nm</a> <a id="5163" href="Meta.Regularity.html#5163" class="Bound">b</a><a id="5164" class="Symbol">))</a> <a id="5167" class="Symbol">=</a> <a id="5169" class="Keyword">do</a>
    <a id="5176" href="Meta.Regularity.html#5176" class="Bound">a</a> <a id="5178" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="5180" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5183" href="Meta.Regularity.html#5133" class="Bound">pre</a> <a id="5187" href="Meta.Regularity.html#5137" class="Bound">n</a> <a id="5189" href="Meta.Regularity.html#5152" class="Bound">a</a>
    <a id="5195" href="Meta.Regularity.html#5195" class="Bound">b</a> <a id="5197" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="5199" href="Meta.Reflection.Base.html#3329" class="Function">under-abs</a> <a id="5209" href="Meta.Regularity.html#5139" class="Bound">t</a> <a id="5211" class="Symbol">(</a><a id="5212" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5215" href="Meta.Regularity.html#5133" class="Bound">pre</a> <a id="5219" class="Symbol">(</a><a id="5220" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5224" href="Meta.Regularity.html#5137" class="Bound">n</a><a id="5225" class="Symbol">)</a> <a id="5227" href="Meta.Regularity.html#5163" class="Bound">b</a><a id="5228" class="Symbol">)</a>
    <a id="5234" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5239" class="Symbol">(</a><a id="5240" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="5243" class="Symbol">(</a><a id="5244" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5248" href="Meta.Regularity.html#5150" class="Bound">i</a> <a id="5250" href="Meta.Regularity.html#5176" class="Bound">a</a><a id="5251" class="Symbol">)</a> <a id="5253" class="Symbol">(</a><a id="5254" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="5258" href="Meta.Regularity.html#5160" class="Bound">nm</a> <a id="5261" href="Meta.Regularity.html#5195" class="Bound">b</a><a id="5262" class="Symbol">))</a>
  <a id="5267" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5270" href="Meta.Regularity.html#5270" class="Bound">pre</a> <a id="5274" href="Meta.Regularity.html#5274" class="Bound">n</a> <a id="5276" class="Symbol">(</a><a id="5277" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="5287" href="Meta.Regularity.html#5287" class="Bound">s</a><a id="5288" class="Symbol">)</a> <a id="5290" class="Symbol">=</a> <a id="5292" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5297" class="Symbol">(</a><a id="5298" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="5308" href="Meta.Regularity.html#5287" class="Bound">s</a><a id="5309" class="Symbol">)</a>
  <a id="5313" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5316" href="Meta.Regularity.html#5316" class="Bound">pre</a> <a id="5320" href="Meta.Regularity.html#5320" class="Bound">n</a> <a id="5322" class="Symbol">(</a><a id="5323" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5327" href="Meta.Regularity.html#5327" class="Bound">l</a><a id="5328" class="Symbol">)</a> <a id="5330" class="Symbol">=</a> <a id="5332" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5337" class="Symbol">(</a><a id="5338" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5342" href="Meta.Regularity.html#5327" class="Bound">l</a><a id="5343" class="Symbol">)</a>
  <a id="5347" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5350" href="Meta.Regularity.html#5350" class="Bound">pre</a> <a id="5354" href="Meta.Regularity.html#5354" class="Bound">n</a> <a id="5356" class="Symbol">(</a><a id="5357" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5362" href="Meta.Regularity.html#5362" class="Bound">x</a> <a id="5364" href="Meta.Regularity.html#5364" class="Bound">args</a><a id="5368" class="Symbol">)</a> <a id="5370" class="Symbol">=</a> <a id="5372" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5377" href="Meta.Regularity.html#5362" class="Bound">x</a> <a id="5379" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="5383" href="Meta.Regularity.html#3294" class="Function">go*</a> <a id="5387" href="Meta.Regularity.html#5350" class="Bound">pre</a> <a id="5391" href="Meta.Regularity.html#5354" class="Bound">n</a> <a id="5393" href="Meta.Regularity.html#5364" class="Bound">args</a>
  <a id="5400" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5403" href="Meta.Regularity.html#5403" class="Bound">pre</a> <a id="5407" href="Meta.Regularity.html#5407" class="Bound">n</a> <a id="5409" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="5417" class="Symbol">=</a> <a id="5419" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5424" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

  <a id="5435" href="Meta.Regularity.html#3294" class="Function">go*</a> <a id="5439" href="Meta.Regularity.html#5439" class="Bound">pre</a> <a id="5443" href="Meta.Regularity.html#5443" class="Bound">n</a> <a id="5445" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5448" class="Symbol">=</a> <a id="5450" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5455" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="5460" href="Meta.Regularity.html#3294" class="Function">go*</a> <a id="5464" href="Meta.Regularity.html#5464" class="Bound">pre</a> <a id="5468" href="Meta.Regularity.html#5468" class="Bound">n</a> <a id="5470" class="Symbol">(</a><a id="5471" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5475" href="Meta.Regularity.html#5475" class="Bound">i</a> <a id="5477" href="Meta.Regularity.html#5477" class="Bound">a</a> <a id="5479" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5481" href="Meta.Regularity.html#5481" class="Bound">as</a><a id="5483" class="Symbol">)</a> <a id="5485" class="Symbol">=</a> <a id="5487" class="Keyword">do</a>
    <a id="5494" href="Meta.Regularity.html#5494" class="Bound">a</a> <a id="5496" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="5498" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="5501" href="Meta.Regularity.html#5464" class="Bound">pre</a> <a id="5505" href="Meta.Regularity.html#5468" class="Bound">n</a> <a id="5507" href="Meta.Regularity.html#5477" class="Bound">a</a>
    <a id="5513" class="Symbol">(</a><a id="5514" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5518" href="Meta.Regularity.html#5475" class="Bound">i</a> <a id="5520" href="Meta.Regularity.html#5494" class="Bound">a</a> <a id="5522" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷_</a><a id="5524" class="Symbol">)</a> <a id="5526" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="5530" href="Meta.Regularity.html#3294" class="Function">go*</a> <a id="5534" href="Meta.Regularity.html#5464" class="Bound">pre</a> <a id="5538" href="Meta.Regularity.html#5468" class="Bound">n</a> <a id="5540" href="Meta.Regularity.html#5481" class="Bound">as</a>

  <a id="5546" class="Comment">-- To turn a term into a regularity path, given a level of precision,</a>
  <a id="5618" class="Comment">-- all we have to do is raise the term by one, do the procedure above,</a>
  <a id="5691" class="Comment">-- then wrap it in a lambda. Nice!</a>
  <a id="to-regularity-path"></a><a id="5728" href="Meta.Regularity.html#5728" class="Function">to-regularity-path</a> <a id="5747" class="Symbol">:</a> <a id="5749" href="Meta.Regularity.html#2316" class="Datatype">Regularity-precision</a> <a id="5770" class="Symbol">→</a> <a id="5772" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5777" class="Symbol">→</a> <a id="5779" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="5782" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5789" href="Meta.Regularity.html#5728" class="Function">to-regularity-path</a> <a id="5808" href="Meta.Regularity.html#5808" class="Bound">pre</a> <a id="5812" href="Meta.Regularity.html#5812" class="Bound">tm</a> <a id="5815" class="Symbol">=</a> <a id="5817" class="Keyword">do</a>
    <a id="5824" href="Meta.Regularity.html#5824" class="Bound">tm</a> <a id="5827" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="5829" href="Meta.Reflection.Subst.html#7456" class="Function">raiseTC</a> <a id="5837" class="Number">1</a> <a id="5839" href="Meta.Regularity.html#5812" class="Bound">tm</a>
    <a id="5846" class="Comment">-- Since we&#39;ll be comparing terms, Agda really wants them to be</a>
    <a id="5914" class="Comment">-- well-scoped. Since we shifted eeeverything up by one, we have to</a>
    <a id="5986" class="Comment">-- grow the context, too.</a>
    <a id="6016" href="Meta.Regularity.html#6016" class="Bound">tm</a> <a id="6019" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6021" href="Meta.Reflection.Base.html#4673" class="Function">resetting</a> <a id="6031" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="6033" href="Agda.Builtin.Reflection.html#9277" class="Postulate">extend-context</a> <a id="6048" class="String">&quot;i&quot;</a> <a id="6052" class="Symbol">(</a><a id="6053" href="Data.Reflection.Argument.html#1573" class="Function">argN</a> <a id="6058" class="Symbol">(</a><a id="6059" class="Keyword">quoteTerm</a> <a id="6069" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="6070" class="Symbol">))</a> <a id="6073" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="6075" href="Meta.Regularity.html#3138" class="Function">go</a> <a id="6078" href="Meta.Regularity.html#5808" class="Bound">pre</a> <a id="6082" class="Number">0</a> <a id="6084" href="Meta.Regularity.html#5824" class="Bound">tm</a>
    <a id="6091" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="6096" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="6098" href="Meta.Reflection.Base.html#4157" class="Function">vlam</a> <a id="6103" class="String">&quot;i&quot;</a> <a id="6107" href="Meta.Regularity.html#6016" class="Bound">tm</a>

  <a id="6113" class="Comment">-- Extend a path x ＝ y to a path x′ ＝ y′, where x′ --&gt; x and y′ --&gt; y</a>
  <a id="6185" class="Comment">-- under the given regularity precision. Shorthand for composing</a>
  <a id="6252" class="Comment">--    regularity! ∙ p ∙ sym regularity!.</a>
  <a id="regular!-worker"></a><a id="6295" href="Meta.Regularity.html#6295" class="Function">regular!-worker</a> <a id="6311" class="Symbol">:</a>
    <a id="6317" class="Symbol">∀</a> <a id="6319" class="Symbol">{</a><a id="6320" href="Meta.Regularity.html#6320" class="Bound">ℓ</a><a id="6321" class="Symbol">}</a> <a id="6323" class="Symbol">{</a><a id="6324" href="Meta.Regularity.html#6324" class="Bound">A</a> <a id="6326" class="Symbol">:</a> <a id="6328" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="6333" href="Meta.Regularity.html#6320" class="Bound">ℓ</a><a id="6334" class="Symbol">}</a> <a id="6336" class="Symbol">{</a><a id="6337" href="Meta.Regularity.html#6337" class="Bound">x</a> <a id="6339" href="Meta.Regularity.html#6339" class="Bound">y</a> <a id="6341" class="Symbol">:</a> <a id="6343" href="Meta.Regularity.html#6324" class="Bound">A</a><a id="6344" class="Symbol">}</a>
    <a id="6350" class="Symbol">→</a> <a id="6352" href="Meta.Regularity.html#2316" class="Datatype">Regularity-precision</a>
    <a id="6377" class="Symbol">→</a> <a id="6379" href="Meta.Regularity.html#6337" class="Bound">x</a> <a id="6381" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="6383" href="Meta.Regularity.html#6339" class="Bound">y</a>
    <a id="6389" class="Symbol">→</a> <a id="6391" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="6400" class="Symbol">→</a> <a id="6402" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="6405" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="6409" href="Meta.Regularity.html#6295" class="Function">regular!-worker</a> <a id="6425" class="Symbol">{</a><a id="6426" class="Argument">x</a> <a id="6428" class="Symbol">=</a> <a id="6430" href="Meta.Regularity.html#6430" class="Bound">x</a><a id="6431" class="Symbol">}</a> <a id="6433" class="Symbol">{</a><a id="6434" href="Meta.Regularity.html#6434" class="Bound">y</a><a id="6435" class="Symbol">}</a> <a id="6437" href="Meta.Regularity.html#6437" class="Bound">pre</a> <a id="6441" href="Meta.Regularity.html#6441" class="Bound">p</a> <a id="6443" href="Meta.Regularity.html#6443" class="Bound">goal</a> <a id="6448" class="Symbol">=</a> <a id="6450" class="Keyword">do</a>
    <a id="6457" href="Meta.Regularity.html#6457" class="Bound">gt</a> <a id="6460" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6462" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6473" href="Meta.Regularity.html#6443" class="Bound">goal</a>
    <a id="6482" href="Meta.Regularity.html#6482" class="Bound">`x</a> <a id="6485" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6487" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6495" href="Meta.Regularity.html#6430" class="Bound">x</a>
    <a id="6501" href="Meta.Regularity.html#6501" class="Bound">`y</a> <a id="6504" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6506" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6514" href="Meta.Regularity.html#6434" class="Bound">y</a>
    <a id="6520" href="Meta.Regularity.html#6520" class="Bound">`p</a> <a id="6523" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6525" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6533" href="Meta.Regularity.html#6441" class="Bound">p</a>
    <a id="6539" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6544" class="Symbol">(_</a> <a id="6547" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6549" href="Meta.Regularity.html#6549" class="Bound">l</a> <a id="6551" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6553" href="Meta.Regularity.html#6553" class="Bound">r</a><a id="6554" class="Symbol">)</a> <a id="6556" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6558" href="Meta.Reflection.Base.html#7275" class="Function">unapply-path</a> <a id="6571" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="6575" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6586" href="Meta.Regularity.html#6443" class="Bound">goal</a>
      <a id="6597" class="Keyword">where</a> <a id="6603" class="CatchallClause Symbol">_</a> <a id="6605" class="Symbol">→</a> <a id="6607" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="6618" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="6625" href="Meta.Regularity.html#6625" class="Bound">l</a> <a id="6627" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6629" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6639" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="6643" href="Meta.Reflection.Base.html#5530" class="Function">wait-for-type</a> <a id="6657" href="Meta.Regularity.html#6549" class="Bound">l</a>
    <a id="6663" href="Meta.Regularity.html#6663" class="Bound">r</a> <a id="6665" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6667" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6677" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="6681" href="Meta.Reflection.Base.html#5530" class="Function">wait-for-type</a> <a id="6695" href="Meta.Regularity.html#6553" class="Bound">r</a>
    <a id="6701" href="Meta.Regularity.html#6701" class="Bound">reg</a> <a id="6705" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6707" href="Meta.Regularity.html#5728" class="Function">to-regularity-path</a> <a id="6726" href="Meta.Regularity.html#6437" class="Bound">pre</a> <a id="6730" href="Meta.Regularity.html#6625" class="Bound">l</a>
    <a id="6736" href="Meta.Regularity.html#6736" class="Bound">reg′</a> <a id="6741" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6743" href="Meta.Regularity.html#5728" class="Function">to-regularity-path</a> <a id="6762" href="Meta.Regularity.html#6437" class="Bound">pre</a> <a id="6766" href="Meta.Regularity.html#6663" class="Bound">r</a>
    <a id="6772" href="Meta.Reflection.Base.html#8999" class="Function">unify-loudly</a> <a id="6785" href="Meta.Regularity.html#6443" class="Bound">goal</a> <a id="6790" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="6792" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6796" class="Symbol">(</a><a id="6797" class="Keyword">quote</a> <a id="6803" href="Meta.Regularity.html#1680" class="Function">double-comp</a><a id="6814" class="Symbol">)</a> <a id="6816" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a>
         <a id="6827" href="Meta.Regularity.html#6482" class="Bound">`x</a> <a id="6830" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6833" href="Meta.Regularity.html#6501" class="Bound">`y</a> <a id="6836" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6839" href="Meta.Regularity.html#6701" class="Bound">reg</a>
      <a id="6849" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6852" href="Meta.Regularity.html#6520" class="Bound">`p</a>
      <a id="6861" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6864" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6868" class="Symbol">(</a><a id="6869" class="Keyword">quote</a> <a id="6875" href="Foundations.Prim.Kan.html#1504" class="Function">sym</a><a id="6878" class="Symbol">)</a> <a id="6880" class="Symbol">(</a><a id="6881" href="Meta.Regularity.html#6736" class="Bound">reg′</a> <a id="6886" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6889" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6891" class="Symbol">)</a>
      <a id="6899" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6902" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="6906" class="Keyword">module</a> <a id="Regularity"></a><a id="6913" href="Meta.Regularity.html#6913" class="Module">Regularity</a> <a id="6924" class="Keyword">where</a>
  <a id="6932" class="Keyword">open</a> <a id="6937" href="Meta.Regularity.html#2316" class="Module">Regularity-precision</a> <a id="6958" class="Keyword">public</a>
  <a id="6967" class="Comment">-- The reflection interface: Regularity.reduce! will, well, reduce a</a>
  <a id="7038" class="Comment">-- term. There&#39;s a lot of blocking involved in making this work.</a>
  <a id="7105" class="Keyword">macro</a>
    <a id="Regularity.reduce!"></a><a id="7115" href="Meta.Regularity.html#7115" class="Function">reduce!</a> <a id="7123" class="Symbol">:</a> <a id="7125" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7130" class="Symbol">→</a> <a id="7132" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7135" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="7141" href="Meta.Regularity.html#7115" class="Function">reduce!</a> <a id="7149" href="Meta.Regularity.html#7149" class="Bound">goal</a> <a id="7154" class="Symbol">=</a> <a id="7156" class="Keyword">do</a>
      <a id="7165" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="7170" class="Symbol">(_</a> <a id="7173" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7175" href="Meta.Regularity.html#7175" class="Bound">l</a> <a id="7177" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7179" href="Meta.Regularity.html#7179" class="Bound">r</a><a id="7180" class="Symbol">)</a> <a id="7182" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="7184" href="Meta.Reflection.Base.html#7275" class="Function">unapply-path</a> <a id="7197" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="7201" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="7212" href="Meta.Regularity.html#7149" class="Bound">goal</a>
        <a id="7225" class="Keyword">where</a> <a id="7231" class="CatchallClause Symbol">_</a> <a id="7233" class="Symbol">→</a> <a id="7235" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="7246" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="7255" href="Meta.Regularity.html#7255" class="Bound">reg</a> <a id="7259" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="7261" href="Meta.Regularity.html#5728" class="Function">to-regularity-path</a> <a id="7280" href="Meta.Regularity.html#2354" class="InductiveConstructor">precise</a> <a id="7288" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="7292" class="Symbol">(</a><a id="7293" href="Meta.Reflection.Base.html#5530" class="Function">wait-for-type</a> <a id="7307" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="7311" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="7321" href="Meta.Regularity.html#7175" class="Bound">l</a><a id="7322" class="Symbol">)</a>
      <a id="7330" href="Meta.Reflection.Base.html#8999" class="Function">unify-loudly</a> <a id="7343" href="Meta.Regularity.html#7149" class="Bound">goal</a> <a id="7348" href="Meta.Regularity.html#7255" class="Bound">reg</a>

    <a id="7357" class="Comment">-- We then have wrappers that reduce on one side, and expand on the</a>
    <a id="7429" class="Comment">-- other, depending on how precise you want the reduction to be.</a>
    <a id="Regularity.precise!"></a><a id="7498" href="Meta.Regularity.html#7498" class="Function">precise!</a> <a id="7507" class="Symbol">:</a> <a id="7509" class="Symbol">∀</a> <a id="7511" class="Symbol">{</a><a id="7512" href="Meta.Regularity.html#7512" class="Bound">ℓ</a><a id="7513" class="Symbol">}</a> <a id="7515" class="Symbol">{</a><a id="7516" href="Meta.Regularity.html#7516" class="Bound">A</a> <a id="7518" class="Symbol">:</a> <a id="7520" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7525" href="Meta.Regularity.html#7512" class="Bound">ℓ</a><a id="7526" class="Symbol">}</a> <a id="7528" class="Symbol">{</a><a id="7529" href="Meta.Regularity.html#7529" class="Bound">x</a> <a id="7531" href="Meta.Regularity.html#7531" class="Bound">y</a> <a id="7533" class="Symbol">:</a> <a id="7535" href="Meta.Regularity.html#7516" class="Bound">A</a><a id="7536" class="Symbol">}</a> <a id="7538" class="Symbol">→</a> <a id="7540" href="Meta.Regularity.html#7529" class="Bound">x</a> <a id="7542" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="7544" href="Meta.Regularity.html#7531" class="Bound">y</a> <a id="7546" class="Symbol">→</a> <a id="7548" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7553" class="Symbol">→</a> <a id="7555" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7558" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="Regularity.fast!"></a><a id="7564" href="Meta.Regularity.html#7564" class="Function">fast!</a> <a id="7570" class="Symbol">:</a> <a id="7572" class="Symbol">∀</a> <a id="7574" class="Symbol">{</a><a id="7575" href="Meta.Regularity.html#7575" class="Bound">ℓ</a><a id="7576" class="Symbol">}</a> <a id="7578" class="Symbol">{</a><a id="7579" href="Meta.Regularity.html#7579" class="Bound">A</a> <a id="7581" class="Symbol">:</a> <a id="7583" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7588" href="Meta.Regularity.html#7575" class="Bound">ℓ</a><a id="7589" class="Symbol">}</a> <a id="7591" class="Symbol">{</a><a id="7592" href="Meta.Regularity.html#7592" class="Bound">x</a> <a id="7594" href="Meta.Regularity.html#7594" class="Bound">y</a> <a id="7596" class="Symbol">:</a> <a id="7598" href="Meta.Regularity.html#7579" class="Bound">A</a><a id="7599" class="Symbol">}</a> <a id="7601" class="Symbol">→</a> <a id="7603" href="Meta.Regularity.html#7592" class="Bound">x</a> <a id="7605" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="7607" href="Meta.Regularity.html#7594" class="Bound">y</a> <a id="7609" class="Symbol">→</a> <a id="7611" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7616" class="Symbol">→</a> <a id="7618" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7621" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="7628" href="Meta.Regularity.html#7498" class="Function">precise!</a> <a id="7637" href="Meta.Regularity.html#7637" class="Bound">p</a> <a id="7639" href="Meta.Regularity.html#7639" class="Bound">goal</a> <a id="7644" class="Symbol">=</a> <a id="7646" href="Meta.Regularity.html#6295" class="Function">regular!-worker</a> <a id="7662" href="Meta.Regularity.html#2354" class="InductiveConstructor">precise</a> <a id="7670" href="Meta.Regularity.html#7637" class="Bound">p</a> <a id="7672" href="Meta.Regularity.html#7639" class="Bound">goal</a>
    <a id="7681" href="Meta.Regularity.html#7564" class="Function">fast!</a> <a id="7687" href="Meta.Regularity.html#7687" class="Bound">p</a> <a id="7689" href="Meta.Regularity.html#7689" class="Bound">goal</a> <a id="7694" class="Symbol">=</a> <a id="7696" href="Meta.Regularity.html#6295" class="Function">regular!-worker</a> <a id="7712" href="Meta.Regularity.html#2362" class="InductiveConstructor">fast</a> <a id="7717" href="Meta.Regularity.html#7687" class="Bound">p</a> <a id="7719" href="Meta.Regularity.html#7689" class="Bound">goal</a>

    <a id="7729" class="Comment">-- For debugging purposes, this macro will take a term and output</a>
    <a id="7799" class="Comment">-- its (transport refl)-normal form, according to the given level of</a>
    <a id="7872" class="Comment">-- precision.</a>
    <a id="Regularity.reduct"></a><a id="7890" href="Meta.Regularity.html#7890" class="Function">reduct</a> <a id="7897" class="Symbol">:</a> <a id="7899" href="Meta.Regularity.html#2316" class="Datatype">Regularity-precision</a> <a id="7920" class="Symbol">→</a> <a id="7922" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7927" class="Symbol">→</a> <a id="7929" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7934" class="Symbol">→</a> <a id="7936" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7939" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="7945" href="Meta.Regularity.html#7890" class="Function">reduct</a> <a id="7952" href="Meta.Regularity.html#7952" class="Bound">pres</a> <a id="7957" href="Meta.Regularity.html#7957" class="Bound">tm</a> <a id="7960" class="Symbol">_</a> <a id="7962" class="Symbol">=</a> <a id="7964" class="Keyword">do</a>
      <a id="7973" href="Meta.Regularity.html#7973" class="Bound">orig</a> <a id="7978" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="7980" href="Meta.Reflection.Base.html#5530" class="Function">wait-for-type</a> <a id="7994" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="7998" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="8008" href="Meta.Regularity.html#7957" class="Bound">tm</a>
      <a id="8017" href="Meta.Regularity.html#8017" class="Bound">tm</a> <a id="8020" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="8022" href="Meta.Regularity.html#5728" class="Function">to-regularity-path</a> <a id="8041" href="Meta.Regularity.html#7952" class="Bound">pres</a> <a id="8046" href="Meta.Regularity.html#7973" class="Bound">orig</a>
      <a id="8057" href="Meta.Regularity.html#8057" class="Bound">red</a> <a id="8061" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="8063" href="Meta.Reflection.Subst.html#7824" class="Function">applyTC</a> <a id="8071" href="Meta.Regularity.html#8017" class="Bound">tm</a> <a id="8074" class="Symbol">(</a><a id="8075" href="Data.Reflection.Argument.html#1573" class="Function">argN</a> <a id="8080" class="Symbol">(</a><a id="8081" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8085" class="Symbol">(</a><a id="8086" class="Keyword">quote</a> <a id="8092" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="8094" class="Symbol">)</a> <a id="8096" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8098" class="Symbol">))</a> <a id="8101" href="Meta.Effect.Bind.html#283" class="Field Operator">&gt;&gt;=</a> <a id="8105" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a>
      <a id="8121" href="Meta.Regularity.html#8121" class="Bound">`pres</a> <a id="8127" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="8129" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="8137" href="Meta.Regularity.html#7952" class="Bound">pres</a>
      <a id="8148" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a>
        <a id="8167" href="Meta.Literals.FromProduct.html#385" class="Function Operator">[</a> <a id="8169" class="String">&quot;The term\n\n  &quot;</a> <a id="8186" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8188" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8197" href="Meta.Regularity.html#7973" class="Bound">orig</a> <a id="8202" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8204" class="String">&quot;\n\nreduces modulo &quot;</a>
        <a id="8234" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8236" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8245" href="Meta.Regularity.html#8121" class="Bound">`pres</a> <a id="8251" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8253" class="String">&quot; regularity to\n\n  &quot;</a>
        <a id="8284" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8286" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8295" href="Meta.Regularity.html#8057" class="Bound">red</a> <a id="8299" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8301" class="String">&quot;\n&quot;</a> <a id="8306" href="Meta.Literals.FromProduct.html#385" class="Function Operator">]</a>

<a id="8309" class="Comment">-- Test cases.</a>
<a id="8324" class="Keyword">module</a>
  <a id="8333" href="Meta.Regularity.html#8333" class="Module">_</a> <a id="8335" class="Symbol">{</a><a id="8336" href="Meta.Regularity.html#8336" class="Bound">ℓ</a> <a id="8338" href="Meta.Regularity.html#8338" class="Bound">ℓ′</a><a id="8340" class="Symbol">}</a> <a id="8342" class="Symbol">{</a><a id="8343" href="Meta.Regularity.html#8343" class="Bound">A</a> <a id="8345" class="Symbol">:</a> <a id="8347" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8352" href="Meta.Regularity.html#8336" class="Bound">ℓ</a><a id="8353" class="Symbol">}</a> <a id="8355" class="Symbol">{</a><a id="8356" href="Meta.Regularity.html#8356" class="Bound">B</a> <a id="8358" class="Symbol">:</a> <a id="8360" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8365" href="Meta.Regularity.html#8338" class="Bound">ℓ′</a><a id="8367" class="Symbol">}</a> <a id="8369" class="Symbol">(</a><a id="8370" href="Meta.Regularity.html#8370" class="Bound">f</a> <a id="8372" href="Meta.Regularity.html#8372" class="Bound">g</a> <a id="8374" class="Symbol">:</a> <a id="8376" href="Meta.Regularity.html#8343" class="Bound">A</a> <a id="8378" class="Symbol">→</a> <a id="8380" href="Meta.Regularity.html#8356" class="Bound">B</a><a id="8381" class="Symbol">)</a> <a id="8383" class="Symbol">(</a><a id="8384" href="Meta.Regularity.html#8384" class="Bound">x</a> <a id="8386" class="Symbol">:</a> <a id="8388" href="Meta.Regularity.html#8343" class="Bound">A</a><a id="8389" class="Symbol">)</a>
    <a id="8395" class="Symbol">(</a><a id="8396" href="Meta.Regularity.html#8396" class="Bound">a-loop</a> <a id="8403" class="Symbol">:</a> <a id="8405" class="Symbol">(</a><a id="8406" href="Meta.Regularity.html#8406" class="Bound">i</a> <a id="8408" class="Symbol">:</a> <a id="8410" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="8411" class="Symbol">)</a> <a id="8413" class="Symbol">→</a> <a id="8415" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8420" href="Meta.Regularity.html#8336" class="Bound">ℓ</a> <a id="8422" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">[</a> <a id="8424" class="Symbol">(</a><a id="8425" href="Meta.Regularity.html#8406" class="Bound">i</a> <a id="8427" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">∨</a> <a id="8429" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="8431" href="Meta.Regularity.html#8406" class="Bound">i</a><a id="8432" class="Symbol">)</a> <a id="8434" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">↦</a> <a id="8436" class="Symbol">(λ</a> <a id="8439" class="Symbol">.</a><a id="8440" href="Meta.Regularity.html#8440" class="Bound">_</a> <a id="8442" class="Symbol">→</a> <a id="8444" href="Meta.Regularity.html#8343" class="Bound">A</a><a id="8445" class="Symbol">)</a> <a id="8447" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">]</a><a id="8448" class="Symbol">)</a>
  <a id="8452" class="Keyword">where</a> <a id="8458" class="Keyword">private</a>

  <a id="8469" href="Meta.Regularity.html#8469" class="Function">p</a> <a id="8471" class="Symbol">:</a> <a id="8473" class="Symbol">(</a><a id="8474" href="Meta.Regularity.html#8474" class="Bound">h</a> <a id="8476" class="Symbol">:</a> <a id="8478" class="Symbol">∀</a> <a id="8480" href="Meta.Regularity.html#8480" class="Bound">x</a> <a id="8482" class="Symbol">→</a> <a id="8484" href="Meta.Regularity.html#8370" class="Bound">f</a> <a id="8486" href="Meta.Regularity.html#8480" class="Bound">x</a> <a id="8488" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8490" href="Meta.Regularity.html#8372" class="Bound">g</a> <a id="8492" href="Meta.Regularity.html#8480" class="Bound">x</a><a id="8493" class="Symbol">)</a>
    <a id="8499" class="Symbol">→</a> <a id="8501" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8511" class="Symbol">(λ</a> <a id="8514" href="Meta.Regularity.html#8514" class="Bound">i</a> <a id="8516" class="Symbol">→</a> <a id="8518" href="Meta.Regularity.html#8343" class="Bound">A</a> <a id="8520" class="Symbol">→</a> <a id="8522" href="Meta.Regularity.html#8356" class="Bound">B</a><a id="8523" class="Symbol">)</a>
        <a id="8533" class="Symbol">(λ</a> <a id="8536" href="Meta.Regularity.html#8536" class="Bound">x</a> <a id="8538" class="Symbol">→</a> <a id="8540" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8550" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8555" class="Symbol">(</a><a id="8556" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8566" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8571" class="Symbol">(</a><a id="8572" href="Meta.Regularity.html#8370" class="Bound">f</a> <a id="8574" class="Symbol">(</a><a id="8575" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8585" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8590" href="Meta.Regularity.html#8536" class="Bound">x</a><a id="8591" class="Symbol">))))</a> <a id="8596" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8598" href="Meta.Regularity.html#8372" class="Bound">g</a>
  <a id="8602" href="Meta.Regularity.html#8469" class="Function">p</a> <a id="8604" href="Meta.Regularity.html#8604" class="Bound">h</a> <a id="8606" class="Symbol">=</a> <a id="8608" href="Meta.Regularity.html#7115" class="Macro">Regularity.reduce!</a> <a id="8627" href="Foundations.Base.html#5702" class="Function Operator">∙</a> <a id="8629" href="Foundations.Base.html#10961" class="Function">fun-ext</a> <a id="8637" href="Meta.Regularity.html#8604" class="Bound">h</a>

  <a id="8642" href="Meta.Regularity.html#8642" class="Function">q</a> <a id="8644" class="Symbol">:</a> <a id="8646" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="8656" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="8661" class="Symbol">(</a><a id="8662" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8669" class="Symbol">(λ</a> <a id="8672" href="Meta.Regularity.html#8672" class="Bound">i</a> <a id="8674" class="Symbol">→</a> <a id="8676" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8681" class="Symbol">(</a><a id="8682" href="Meta.Regularity.html#8396" class="Bound">a-loop</a> <a id="8689" href="Meta.Regularity.html#8672" class="Bound">i</a><a id="8690" class="Symbol">))</a> <a id="8693" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8696" href="Meta.Regularity.html#8384" class="Bound">x</a><a id="8697" class="Symbol">)</a> <a id="8699" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="8701" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8708" class="Symbol">(λ</a> <a id="8711" href="Meta.Regularity.html#8711" class="Bound">i</a> <a id="8713" class="Symbol">→</a> <a id="8715" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8720" class="Symbol">(</a><a id="8721" href="Meta.Regularity.html#8396" class="Bound">a-loop</a> <a id="8728" href="Meta.Regularity.html#8711" class="Bound">i</a><a id="8729" class="Symbol">))</a> <a id="8732" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8735" href="Meta.Regularity.html#8384" class="Bound">x</a>
  <a id="8739" href="Meta.Regularity.html#8642" class="Function">q</a> <a id="8741" class="Symbol">=</a> <a id="8743" href="Meta.Regularity.html#7115" class="Macro">Regularity.reduce!</a>

  <a id="8765" class="Comment">-- Imprecise/fast reduction: According to it, the normal form of the</a>
  <a id="8836" class="Comment">-- transport below is refl. That&#39;s.. not the case, at least we don&#39;t</a>
  <a id="8907" class="Comment">-- know so. Precise regularity handles it, though.</a>
  <a id="8960" class="Comment">-- q′ : ⊤</a>
  <a id="8972" class="Comment">-- q′ = {! Regularity.reduct Regularity.fast (transp (λ i → outS (a-loop i)) i0 x) !}</a>

  <a id="9061" href="Meta.Regularity.html#9061" class="Function">r</a> <a id="9063" class="Symbol">:</a> <a id="9065" class="Symbol">(</a><a id="9066" href="Meta.Regularity.html#9066" class="Bound">h</a> <a id="9068" class="Symbol">:</a> <a id="9070" class="Symbol">∀</a> <a id="9072" href="Meta.Regularity.html#9072" class="Bound">x</a> <a id="9074" class="Symbol">→</a> <a id="9076" href="Meta.Regularity.html#8370" class="Bound">f</a> <a id="9078" href="Meta.Regularity.html#9072" class="Bound">x</a> <a id="9080" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="9082" href="Meta.Regularity.html#8372" class="Bound">g</a> <a id="9084" href="Meta.Regularity.html#9072" class="Bound">x</a><a id="9085" class="Symbol">)</a> <a id="9087" class="Symbol">→</a> <a id="9089" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="9099" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="9104" class="Symbol">(</a><a id="9105" href="Meta.Regularity.html#8370" class="Bound">f</a> <a id="9107" href="Meta.Regularity.html#8384" class="Bound">x</a><a id="9108" class="Symbol">)</a> <a id="9110" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="9112" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="9122" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="9127" class="Symbol">(</a><a id="9128" href="Meta.Regularity.html#8372" class="Bound">g</a> <a id="9130" href="Meta.Regularity.html#8384" class="Bound">x</a><a id="9131" class="Symbol">)</a>
  <a id="9135" href="Meta.Regularity.html#9061" class="Function">r</a> <a id="9137" href="Meta.Regularity.html#9137" class="Bound">h</a> <a id="9139" class="Symbol">=</a> <a id="9141" href="Meta.Regularity.html#7498" class="Macro">Regularity.precise!</a> <a id="9161" class="Symbol">(</a><a id="9162" href="Meta.Regularity.html#9137" class="Bound">h</a> <a id="9164" href="Meta.Regularity.html#8384" class="Bound">x</a><a id="9165" class="Symbol">)</a>

  <a id="9170" href="Meta.Regularity.html#9170" class="Function">s</a> <a id="9172" class="Symbol">:</a> <a id="9174" class="Symbol">(</a><a id="9175" href="Meta.Regularity.html#9175" class="Bound">h</a> <a id="9177" class="Symbol">:</a> <a id="9179" class="Symbol">∀</a> <a id="9181" href="Meta.Regularity.html#9181" class="Bound">x</a> <a id="9183" class="Symbol">→</a> <a id="9185" href="Meta.Regularity.html#8370" class="Bound">f</a> <a id="9187" href="Meta.Regularity.html#9181" class="Bound">x</a> <a id="9189" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="9191" href="Meta.Regularity.html#8372" class="Bound">g</a> <a id="9193" href="Meta.Regularity.html#9181" class="Bound">x</a><a id="9194" class="Symbol">)</a> <a id="9196" class="Symbol">→</a> <a id="9198" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="9208" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="9213" class="Symbol">(</a><a id="9214" href="Meta.Regularity.html#8372" class="Bound">g</a> <a id="9216" href="Meta.Regularity.html#8384" class="Bound">x</a><a id="9217" class="Symbol">)</a> <a id="9219" href="Foundations.Prim.Kan.html#1262" class="Function Operator">＝</a> <a id="9221" href="Foundations.Prim.Kan.html#1690" class="Function">transport</a> <a id="9231" href="Foundations.Prim.Kan.html#1465" class="Function">refl</a> <a id="9236" class="Symbol">(</a><a id="9237" href="Meta.Regularity.html#8370" class="Bound">f</a> <a id="9239" href="Meta.Regularity.html#8384" class="Bound">x</a><a id="9240" class="Symbol">)</a>
  <a id="9244" href="Meta.Regularity.html#9170" class="Function">s</a> <a id="9246" href="Meta.Regularity.html#9246" class="Bound">h</a> <a id="9248" class="Symbol">=</a> <a id="9250" href="Foundations.Prim.Kan.html#1504" class="Function">sym</a> <a id="9254" href="Foundations.Pi.Base.html#1574" class="Function Operator">$</a> <a id="9256" href="Meta.Regularity.html#7564" class="Macro">Regularity.fast!</a> <a id="9273" class="Symbol">(</a><a id="9274" href="Meta.Regularity.html#9246" class="Bound">h</a> <a id="9276" href="Meta.Regularity.html#8384" class="Bound">x</a><a id="9277" class="Symbol">)</a>
</pre></body></html>