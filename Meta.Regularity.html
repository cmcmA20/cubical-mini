<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Regularity</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Pragma">--no-exact-split</a> <a id="37" class="Symbol">#-}</a>
<a id="41" class="Keyword">module</a> <a id="48" href="Meta.Regularity.html" class="Module">Meta.Regularity</a> <a id="64" class="Keyword">where</a>

<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="Foundations.Base.html" class="Module">Foundations.Base</a>

<a id="101" class="Keyword">open</a> <a id="106" class="Keyword">import</a> <a id="113" href="Meta.Effect.Alt.html" class="Module">Meta.Effect.Alt</a>
<a id="129" class="Keyword">open</a> <a id="134" class="Keyword">import</a> <a id="141" href="Meta.Reflection.Base.html" class="Module">Meta.Reflection.Base</a>
<a id="162" class="Keyword">open</a> <a id="167" class="Keyword">import</a> <a id="174" href="Meta.Reflection.Subst.html" class="Module">Meta.Reflection.Subst</a>

<a id="197" class="Keyword">open</a> <a id="202" class="Keyword">import</a> <a id="209" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="224" class="Keyword">open</a> <a id="229" class="Keyword">import</a> <a id="236" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="251" class="Keyword">open</a> <a id="256" class="Keyword">import</a> <a id="263" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="295" class="Keyword">open</a> <a id="300" class="Keyword">import</a> <a id="307" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="323" class="Keyword">open</a> <a id="328" class="Keyword">import</a> <a id="335" href="Data.Maybe.Instances.Alt.html" class="Module">Data.Maybe.Instances.Alt</a>
<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="Data.Reflection.Abs.html" class="Module">Data.Reflection.Abs</a>
<a id="392" class="Keyword">open</a> <a id="397" class="Keyword">import</a> <a id="404" href="Data.Reflection.Argument.html" class="Module">Data.Reflection.Argument</a>
<a id="429" class="Keyword">open</a> <a id="434" class="Keyword">import</a> <a id="441" href="Data.Reflection.Error.html" class="Module">Data.Reflection.Error</a>
<a id="463" class="Keyword">open</a> <a id="468" class="Keyword">import</a> <a id="475" href="Data.Reflection.Fixity.html" class="Module">Data.Reflection.Fixity</a>
<a id="498" class="Keyword">open</a> <a id="503" class="Keyword">import</a> <a id="510" href="Data.Reflection.Instances.FromString.html" class="Module">Data.Reflection.Instances.FromString</a>
<a id="547" class="Keyword">open</a> <a id="552" class="Keyword">import</a> <a id="559" href="Data.Reflection.Literal.html" class="Module">Data.Reflection.Literal</a>
<a id="583" class="Keyword">open</a> <a id="588" class="Keyword">import</a> <a id="595" href="Data.Reflection.Meta.html" class="Module">Data.Reflection.Meta</a>
<a id="616" class="Keyword">open</a> <a id="621" class="Keyword">import</a> <a id="628" href="Data.Reflection.Name.html" class="Module">Data.Reflection.Name</a>
<a id="649" class="Keyword">open</a> <a id="654" class="Keyword">import</a> <a id="661" href="Data.Reflection.Term.html" class="Module">Data.Reflection.Term</a>


<a id="684" class="Comment">{-
A tactic for reducing &quot;transport refl x&quot; in other-wise normal terms. The
implementation is actually surprisingly simple: A term of the form (e.g.)

    transp (λ _ → A) i0 (f (transp (λ _ → B) i0 x))

is already a blueprint for how to normalise it. We simply have to turn it into

    λ i → transp (λ _ → A) i (f (transp (λ _ → B) i x))

so that the constant transports reduce away when (i = i1). Abstracting over i,
this gives a path from the initial term to its &quot;regular normal form&quot;, which
may be the worst name ever.

More generally, we replace terms of the form `transp Al φ x` with `transp Al (φ ∨ i) x`
recursively (inside-out), on the condition that Al is constant when i = i1.
-}</a>

<a id="1377" class="Keyword">private</a>
  <a id="1387" class="Keyword">open</a> <a id="1392" class="Keyword">import</a> <a id="1399" href="Agda.Primitive.Cubical.html" class="Module">Agda.Primitive.Cubical</a> <a id="1422" class="Keyword">using</a> <a id="1428" class="Symbol">(</a> <a id="1430" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a> <a id="1440" class="Symbol">)</a>
  <a id="1444" class="Comment">-- We have a double composition operator that doesn&#39;t use the</a>
  <a id="1508" class="Comment">-- fancy hcomp syntax in its definition. This has better type</a>
  <a id="1572" class="Comment">-- inference for one of the macros since it guarantees that the base</a>
  <a id="1643" class="Comment">-- (q i) is independent of j without any reduction.</a>
  <a id="double-comp"></a><a id="1697" href="Meta.Regularity.html#1697" class="Function">double-comp</a>
    <a id="1713" class="Symbol">:</a> <a id="1715" class="Symbol">∀</a> <a id="1717" class="Symbol">{</a><a id="1718" href="Meta.Regularity.html#1718" class="Bound">ℓ</a><a id="1719" class="Symbol">}</a> <a id="1721" class="Symbol">{</a><a id="1722" href="Meta.Regularity.html#1722" class="Bound">A</a> <a id="1724" class="Symbol">:</a> <a id="1726" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="1731" href="Meta.Regularity.html#1718" class="Bound">ℓ</a><a id="1732" class="Symbol">}</a> <a id="1734" class="Symbol">{</a><a id="1735" href="Meta.Regularity.html#1735" class="Bound">w</a> <a id="1737" href="Meta.Regularity.html#1737" class="Bound">z</a> <a id="1739" class="Symbol">:</a> <a id="1741" href="Meta.Regularity.html#1722" class="Bound">A</a><a id="1742" class="Symbol">}</a> <a id="1744" class="Symbol">(</a><a id="1745" href="Meta.Regularity.html#1745" class="Bound">x</a> <a id="1747" href="Meta.Regularity.html#1747" class="Bound">y</a> <a id="1749" class="Symbol">:</a> <a id="1751" href="Meta.Regularity.html#1722" class="Bound">A</a><a id="1752" class="Symbol">)</a>
    <a id="1758" class="Symbol">→</a> <a id="1760" href="Meta.Regularity.html#1735" class="Bound">w</a> <a id="1762" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1764" href="Meta.Regularity.html#1745" class="Bound">x</a> <a id="1766" class="Symbol">→</a> <a id="1768" href="Meta.Regularity.html#1745" class="Bound">x</a> <a id="1770" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1772" href="Meta.Regularity.html#1747" class="Bound">y</a> <a id="1774" class="Symbol">→</a> <a id="1776" href="Meta.Regularity.html#1747" class="Bound">y</a> <a id="1778" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1780" href="Meta.Regularity.html#1737" class="Bound">z</a>
    <a id="1786" class="Symbol">→</a> <a id="1788" href="Meta.Regularity.html#1735" class="Bound">w</a> <a id="1790" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1792" href="Meta.Regularity.html#1737" class="Bound">z</a>
  <a id="1796" href="Meta.Regularity.html#1697" class="Function">double-comp</a> <a id="1808" href="Meta.Regularity.html#1808" class="Bound">x</a> <a id="1810" href="Meta.Regularity.html#1810" class="Bound">y</a> <a id="1812" href="Meta.Regularity.html#1812" class="Bound">p</a> <a id="1814" href="Meta.Regularity.html#1814" class="Bound">q</a> <a id="1816" href="Meta.Regularity.html#1816" class="Bound">r</a> <a id="1818" href="Meta.Regularity.html#1818" class="Bound">i</a> <a id="1820" class="Symbol">=</a> <a id="1822" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a>
    <a id="1836" class="Symbol">(λ</a> <a id="1839" class="Symbol">{</a> <a id="1841" href="Meta.Regularity.html#1841" class="Bound">j</a> <a id="1843" class="Symbol">(</a><a id="1844" href="Meta.Regularity.html#1818" class="Bound">i</a> <a id="1846" class="Symbol">=</a> <a id="1848" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="1850" class="Symbol">)</a> <a id="1852" class="Symbol">→</a> <a id="1854" href="Meta.Regularity.html#1812" class="Bound">p</a> <a id="1856" class="Symbol">(</a><a id="1857" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="1859" href="Meta.Regularity.html#1841" class="Bound">j</a><a id="1860" class="Symbol">)</a> <a id="1862" class="Symbol">;</a> <a id="1864" href="Meta.Regularity.html#1864" class="Bound">j</a> <a id="1866" class="Symbol">(</a><a id="1867" href="Meta.Regularity.html#1818" class="Bound">i</a> <a id="1869" class="Symbol">=</a> <a id="1871" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="1873" class="Symbol">)</a> <a id="1875" class="Symbol">→</a> <a id="1877" href="Meta.Regularity.html#1816" class="Bound">r</a> <a id="1879" href="Meta.Regularity.html#1864" class="Bound">j</a> <a id="1881" class="Symbol">})</a> <a id="1884" class="Symbol">(</a><a id="1885" href="Meta.Regularity.html#1814" class="Bound">q</a> <a id="1887" href="Meta.Regularity.html#1818" class="Bound">i</a><a id="1888" class="Symbol">)</a>

  <a id="1893" class="Comment">-- The regularity tactic can operate in two modes: `precise` will work</a>
  <a id="1966" class="Comment">-- with the type-checker to identify which `transp`s are along refl,</a>
  <a id="2037" class="Comment">-- and which should be preserved. The `fast` mode says YOLO and</a>
  <a id="2103" class="Comment">-- assumes that **every** application of `transp` is one that would</a>
  <a id="2173" class="Comment">-- reduce by regularity. Needless to say, only use `fast` when you&#39;re</a>
  <a id="2245" class="Comment">-- sure that&#39;s the case (e.g. the fibres of a displayed category over</a>
  <a id="2317" class="Comment">-- Sets)</a>
  <a id="2328" class="Keyword">data</a> <a id="Regularity-precision"></a><a id="2333" href="Meta.Regularity.html#2333" class="Datatype">Regularity-precision</a> <a id="2354" class="Symbol">:</a> <a id="2356" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="2361" class="Keyword">where</a>
    <a id="Regularity-precision.precise"></a><a id="2371" href="Meta.Regularity.html#2371" class="InductiveConstructor">precise</a> <a id="Regularity-precision.fast"></a><a id="2379" href="Meta.Regularity.html#2379" class="InductiveConstructor">fast</a> <a id="2384" class="Symbol">:</a> <a id="2386" href="Meta.Regularity.html#2333" class="Datatype">Regularity-precision</a>
  <a id="2409" class="Comment">-- As the name implies, `precise` is `precise`, while `fast` is</a>
  <a id="2475" class="Comment">-- `fast`. The reason is that `fast` will avoid traversing many of the</a>
  <a id="2548" class="Comment">-- terms involved in a `transp`: It doesn&#39;t care about the level, it</a>
  <a id="2619" class="Comment">-- doesn&#39;t care about the line, and it doesn&#39;t care about the</a>
  <a id="2683" class="Comment">-- cofibration.</a>

  <a id="2702" class="Comment">-- The core of the tactic is this triad of mutually recursive</a>
  <a id="2766" class="Comment">-- functions. In all three of them, the `Nat` argument indicates how</a>
  <a id="2837" class="Comment">-- many binders we&#39;ve gone under: it is the dimension variable we</a>
  <a id="2905" class="Comment">-- abstracted over at the start.</a>
  <a id="refl-transport"></a><a id="2940" href="Meta.Regularity.html#2940" class="Function">refl-transport</a> <a id="2955" class="Symbol">:</a> <a id="2957" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2959" class="Symbol">→</a> <a id="2961" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2966" class="Symbol">→</a> <a id="2968" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2971" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2978" class="Comment">-- ^ Determines whether an application of `transp` is a case of</a>
  <a id="3044" class="Comment">-- regularity, and if so, replaces it by `regular`. Precondition: its</a>
  <a id="3116" class="Comment">-- subterms must already be reduced.</a>
  <a id="go"></a><a id="3155" href="Meta.Regularity.html#3155" class="Function">go</a>  <a id="3159" class="Symbol">:</a> <a id="3161" href="Meta.Regularity.html#2333" class="Datatype">Regularity-precision</a> <a id="3182" class="Symbol">→</a> <a id="3184" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3186" class="Symbol">→</a> <a id="3188" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3193" class="Symbol">→</a> <a id="3195" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="3198" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3205" class="Comment">-- ^ Reduces all the subterms, and finds applications of `transp` to</a>
  <a id="3276" class="Comment">-- hand off to `refl-transport`.</a>
  <a id="go*"></a><a id="3311" href="Meta.Regularity.html#3311" class="Function">go*</a> <a id="3315" class="Symbol">:</a> <a id="3317" href="Meta.Regularity.html#2333" class="Datatype">Regularity-precision</a> <a id="3338" class="Symbol">→</a> <a id="3340" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3342" class="Symbol">→</a> <a id="3344" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3349" class="Symbol">(</a><a id="3350" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3354" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3358" class="Symbol">)</a> <a id="3360" class="Symbol">→</a> <a id="3362" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="3365" class="Symbol">(</a><a id="3366" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3371" class="Symbol">(</a><a id="3372" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3376" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3380" class="Symbol">))</a>
  <a id="3385" class="Comment">-- ^ Isn&#39;t the termination checker just lovely?</a>

  <a id="3436" href="Meta.Regularity.html#2940" class="Function">refl-transport</a> <a id="3451" href="Meta.Regularity.html#3451" class="Bound">n</a> <a id="3453" href="Meta.Regularity.html#3453" class="Bound">tm</a><a id="3455" class="Symbol">@(</a><a id="3457" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3461" class="Symbol">(</a><a id="3462" class="Keyword">quote</a> <a id="3468" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3474" class="Symbol">)</a> <a id="3476" class="Symbol">(</a><a id="3477" href="Meta.Regularity.html#3477" class="Bound">ℓ</a> <a id="3479" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="3482" href="Meta.Regularity.html#3482" class="Bound">Al</a> <a id="3485" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3488" href="Meta.Regularity.html#3488" class="Bound">φ</a> <a id="3490" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3493" href="Meta.Regularity.html#3493" class="Bound">x</a> <a id="3495" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3498" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3500" class="Symbol">))</a> <a id="3503" class="Symbol">=</a>
    <a id="3509" class="Comment">-- This match might make you wonder: Can&#39;t Al be a line of</a>
    <a id="3572" class="Comment">-- functions, so that the transport will have more arguments? No:</a>
    <a id="3642" class="Comment">-- The term is in normal form.</a>
    <a id="3677" class="Symbol">(</a><a id="3678" class="Keyword">do</a>
      <a id="3687" href="Agda.Builtin.Reflection.html#11057" class="Postulate">debug-print</a> <a id="3699" class="String">&quot;tactic.regularity&quot;</a> <a id="3719" class="Number">10</a> <a id="3722" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="3724" class="String">&quot;Checking regularity of &quot;</a> <a id="3750" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3752" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="3761" href="Meta.Regularity.html#3453" class="Bound">tm</a> <a id="3764" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3766" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="3775" class="Keyword">let</a> <a id="3779" href="Meta.Regularity.html#3779" class="Bound">φ′</a> <a id="3782" class="Symbol">=</a> <a id="3784" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3788" class="Symbol">(</a><a id="3789" class="Keyword">quote</a> <a id="3795" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="3798" class="Symbol">)</a> <a id="3800" class="Symbol">(</a><a id="3801" href="Meta.Regularity.html#3488" class="Bound">φ</a> <a id="3803" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3806" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="3810" href="Meta.Regularity.html#3451" class="Bound">n</a> <a id="3812" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="3815" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3818" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3820" class="Symbol">)</a>
      <a id="3828" class="Keyword">let</a> <a id="3832" href="Meta.Regularity.html#3832" class="Bound">tm′</a> <a id="3836" class="Symbol">=</a> <a id="3838" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3842" class="Symbol">(</a><a id="3843" class="Keyword">quote</a> <a id="3849" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3855" class="Symbol">)</a> <a id="3857" class="Symbol">(</a><a id="3858" href="Meta.Regularity.html#3477" class="Bound">ℓ</a> <a id="3860" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="3863" href="Meta.Regularity.html#3482" class="Bound">Al</a> <a id="3866" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3869" href="Meta.Regularity.html#3779" class="Bound">φ′</a> <a id="3872" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3875" href="Meta.Regularity.html#3493" class="Bound">x</a> <a id="3877" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3880" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3882" class="Symbol">)</a>
      <a id="3890" class="Comment">-- We simply ask Agda to check that the newly constructed term `transp Al (φ ∨ i) x`</a>
      <a id="3981" class="Comment">-- is correct, i.e. that Al is constant on (i = i1).</a>
      <a id="4040" class="Comment">-- If it isn&#39;t, we backtrack and leave the term unchanged.</a>
      <a id="4105" class="Comment">-- Note that if Al itself contains constant transports, we have already processed those,</a>
      <a id="4200" class="Comment">-- so they reduce away when (i = i1).</a>
      <a id="4244" href="Agda.Builtin.Reflection.html#8914" class="Postulate">check-type</a> <a id="4255" href="Meta.Regularity.html#3832" class="Bound">tm′</a> <a id="4259" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="4267" class="Comment">-- inferType doesn&#39;t trigger the constancy check https://github.com/agda/agda/issues/6585</a>
      <a id="4363" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4368" href="Meta.Regularity.html#3832" class="Bound">tm′</a><a id="4371" class="Symbol">)</a> <a id="4373" href="Meta.Effect.Alt.html#320" class="Field Operator">&lt;|&gt;</a>
    <a id="4381" class="Symbol">(</a><a id="4382" class="Keyword">do</a>
      <a id="4391" href="Agda.Builtin.Reflection.html#11057" class="Postulate">debug-print</a> <a id="4403" class="String">&quot;tactic.regularity&quot;</a> <a id="4423" class="Number">10</a> <a id="4426" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="4428" class="String">&quot;NOT a (transport refl): &quot;</a> <a id="4455" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4457" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="4466" href="Meta.Regularity.html#3453" class="Bound">tm</a> <a id="4469" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4471" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="4480" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4485" href="Meta.Regularity.html#3453" class="Bound">tm</a><a id="4487" class="Symbol">)</a>
  <a id="4491" href="Meta.Regularity.html#2940" class="CatchallClause Function">refl-transport</a><a id="4505" class="CatchallClause"> </a><a id="4506" class="CatchallClause Symbol">_</a><a id="4507" class="CatchallClause"> </a><a id="4508" href="Meta.Regularity.html#4508" class="CatchallClause Bound">tm</a> <a id="4511" class="Symbol">=</a> <a id="4513" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4518" href="Meta.Regularity.html#4508" class="Bound">tm</a>

  <a id="4524" class="Comment">-- Boring term traversal.</a>
  <a id="4552" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="4555" href="Meta.Regularity.html#4555" class="Bound">pre</a> <a id="4559" href="Meta.Regularity.html#4559" class="Bound">n</a> <a id="4561" class="Symbol">(</a><a id="4562" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4566" href="Meta.Regularity.html#4566" class="Bound">x</a> <a id="4568" href="Meta.Regularity.html#4568" class="Bound">args</a><a id="4572" class="Symbol">)</a> <a id="4574" class="Symbol">=</a> <a id="4576" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4580" href="Meta.Regularity.html#4566" class="Bound">x</a> <a id="4582" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4586" href="Meta.Regularity.html#3311" class="Function">go*</a> <a id="4590" href="Meta.Regularity.html#4555" class="Bound">pre</a> <a id="4594" href="Meta.Regularity.html#4559" class="Bound">n</a> <a id="4596" href="Meta.Regularity.html#4568" class="Bound">args</a>
  <a id="4603" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="4606" href="Meta.Regularity.html#4606" class="Bound">pre</a> <a id="4610" href="Meta.Regularity.html#4610" class="Bound">n</a> <a id="4612" class="Symbol">(</a><a id="4613" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4617" href="Meta.Regularity.html#4617" class="Bound">c</a> <a id="4619" href="Meta.Regularity.html#4619" class="Bound">args</a><a id="4623" class="Symbol">)</a> <a id="4625" class="Symbol">=</a> <a id="4627" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4631" href="Meta.Regularity.html#4617" class="Bound">c</a> <a id="4633" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4637" href="Meta.Regularity.html#3311" class="Function">go*</a> <a id="4641" href="Meta.Regularity.html#4606" class="Bound">pre</a> <a id="4645" href="Meta.Regularity.html#4610" class="Bound">n</a> <a id="4647" href="Meta.Regularity.html#4619" class="Bound">args</a>
  <a id="4654" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="4657" href="Meta.Regularity.html#2379" class="InductiveConstructor">fast</a> <a id="4662" href="Meta.Regularity.html#4662" class="Bound">n</a> <a id="4664" class="Symbol">(</a><a id="4665" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4669" class="Symbol">(</a><a id="4670" class="Keyword">quote</a> <a id="4676" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4682" class="Symbol">)</a> <a id="4684" class="Symbol">(</a><a id="4685" href="Meta.Regularity.html#4685" class="Bound">ℓ</a> <a id="4687" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="4690" href="Meta.Regularity.html#4690" class="Bound">Al</a> <a id="4693" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4696" href="Meta.Regularity.html#4696" class="Bound">φ</a> <a id="4698" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4701" href="Meta.Regularity.html#4701" class="Bound">x</a> <a id="4703" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4706" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4708" class="Symbol">))</a> <a id="4711" class="Symbol">=</a> <a id="4713" class="Keyword">do</a>
    <a id="4720" href="Meta.Regularity.html#4720" class="Bound">x</a> <a id="4722" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="4724" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="4727" href="Meta.Regularity.html#2379" class="InductiveConstructor">fast</a> <a id="4732" href="Meta.Regularity.html#4662" class="Bound">n</a> <a id="4734" href="Meta.Regularity.html#4701" class="Bound">x</a>
    <a id="4740" class="Keyword">let</a> <a id="4744" href="Meta.Regularity.html#4744" class="Bound">φ′</a> <a id="4747" class="Symbol">=</a> <a id="4749" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4753" class="Symbol">(</a><a id="4754" class="Keyword">quote</a> <a id="4760" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="4763" class="Symbol">)</a> <a id="4765" class="Symbol">(</a><a id="4766" href="Meta.Regularity.html#4696" class="Bound">φ</a> <a id="4768" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4771" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4775" href="Meta.Regularity.html#4662" class="Bound">n</a> <a id="4777" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4780" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4783" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4785" class="Symbol">)</a>
    <a id="4791" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="4796" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="4798" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4802" class="Symbol">(</a><a id="4803" class="Keyword">quote</a> <a id="4809" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4815" class="Symbol">)</a> <a id="4817" class="Symbol">(</a><a id="4818" href="Meta.Regularity.html#4685" class="Bound">ℓ</a> <a id="4820" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="4823" href="Meta.Regularity.html#4690" class="Bound">Al</a> <a id="4826" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4829" href="Meta.Regularity.html#4744" class="Bound">φ′</a> <a id="4832" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4835" href="Meta.Regularity.html#4720" class="Bound">x</a> <a id="4837" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4840" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4842" class="Symbol">)</a>
  <a id="4846" href="Meta.Regularity.html#3155" class="CatchallClause Function">go</a><a id="4848" class="CatchallClause"> </a><a id="4849" href="Meta.Regularity.html#4849" class="CatchallClause Bound">pre</a><a id="4852" class="CatchallClause"> </a><a id="4853" href="Meta.Regularity.html#4853" class="CatchallClause Bound">n</a><a id="4854" class="CatchallClause"> </a><a id="4855" class="CatchallClause Symbol">(</a><a id="4856" href="Agda.Builtin.Reflection.html#5251" class="CatchallClause InductiveConstructor">def</a><a id="4859" class="CatchallClause"> </a><a id="4860" href="Meta.Regularity.html#4860" class="CatchallClause Bound">f</a><a id="4861" class="CatchallClause"> </a><a id="4862" href="Meta.Regularity.html#4862" class="CatchallClause Bound">args</a><a id="4866" class="CatchallClause Symbol">)</a> <a id="4868" class="Symbol">=</a> <a id="4870" class="Keyword">do</a>
    <a id="4877" href="Meta.Regularity.html#4877" class="Bound">as</a> <a id="4880" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="4882" href="Meta.Regularity.html#3311" class="Function">go*</a> <a id="4886" href="Meta.Regularity.html#4849" class="Bound">pre</a> <a id="4890" href="Meta.Regularity.html#4853" class="Bound">n</a> <a id="4892" href="Meta.Regularity.html#4862" class="Bound">args</a>
    <a id="4901" href="Meta.Regularity.html#2940" class="Function">refl-transport</a> <a id="4916" href="Meta.Regularity.html#4853" class="Bound">n</a> <a id="4918" class="Symbol">(</a><a id="4919" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4923" href="Meta.Regularity.html#4860" class="Bound">f</a> <a id="4925" href="Meta.Regularity.html#4877" class="Bound">as</a><a id="4927" class="Symbol">)</a>
  <a id="4931" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="4934" href="Meta.Regularity.html#4934" class="Bound">pre</a> <a id="4938" href="Meta.Regularity.html#4938" class="Bound">k</a> <a id="4940" href="Meta.Regularity.html#4940" class="Bound">t</a><a id="4941" class="Symbol">@(</a><a id="4943" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4947" href="Meta.Regularity.html#4947" class="Bound">v</a> <a id="4949" class="Symbol">(</a><a id="4950" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4954" href="Meta.Regularity.html#4954" class="Bound">nm</a> <a id="4957" href="Meta.Regularity.html#4957" class="Bound">b</a><a id="4958" class="Symbol">))</a> <a id="4961" class="Symbol">=</a> <a id="4963" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4967" href="Meta.Regularity.html#4947" class="Bound">v</a> <a id="4969" href="Foundations.Pi.Base.html#2101" class="Function Operator">∘</a> <a id="4971" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4975" href="Meta.Regularity.html#4954" class="Bound">nm</a> <a id="4978" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="4982" href="Meta.Reflection.Base.html#3293" class="Function">under-abs</a> <a id="4992" href="Meta.Regularity.html#4940" class="Bound">t</a> <a id="4994" class="Symbol">(</a><a id="4995" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="4998" href="Meta.Regularity.html#4934" class="Bound">pre</a> <a id="5002" class="Symbol">(</a><a id="5003" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5007" href="Meta.Regularity.html#4938" class="Bound">k</a><a id="5008" class="Symbol">)</a> <a id="5010" href="Meta.Regularity.html#4957" class="Bound">b</a><a id="5011" class="Symbol">)</a>
  <a id="5015" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5018" href="Meta.Regularity.html#5018" class="Bound">pre</a> <a id="5022" href="Meta.Regularity.html#5022" class="Bound">n</a> <a id="5024" class="Symbol">(</a><a id="5025" href="Agda.Builtin.Reflection.html#5361" class="InductiveConstructor">pat-lam</a> <a id="5033" href="Meta.Regularity.html#5033" class="Bound">cs</a> <a id="5036" href="Meta.Regularity.html#5036" class="Bound">args</a><a id="5040" class="Symbol">)</a> <a id="5042" class="Symbol">=</a> <a id="5044" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="5055" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="5057" class="String">&quot;regularity: Can not deal with pattern lambdas&quot;</a> <a id="5105" class="Comment">-- TODO can we do something about this?</a>
  <a id="5147" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5150" href="Meta.Regularity.html#5150" class="Bound">pre</a> <a id="5154" href="Meta.Regularity.html#5154" class="Bound">n</a> <a id="5156" href="Meta.Regularity.html#5156" class="Bound">t</a><a id="5157" class="Symbol">@(</a><a id="5159" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="5162" class="Symbol">(</a><a id="5163" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5167" href="Meta.Regularity.html#5167" class="Bound">i</a> <a id="5169" href="Meta.Regularity.html#5169" class="Bound">a</a><a id="5170" class="Symbol">)</a> <a id="5172" class="Symbol">(</a><a id="5173" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="5177" href="Meta.Regularity.html#5177" class="Bound">nm</a> <a id="5180" href="Meta.Regularity.html#5180" class="Bound">b</a><a id="5181" class="Symbol">))</a> <a id="5184" class="Symbol">=</a> <a id="5186" class="Keyword">do</a>
    <a id="5193" href="Meta.Regularity.html#5193" class="Bound">a</a> <a id="5195" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="5197" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5200" href="Meta.Regularity.html#5150" class="Bound">pre</a> <a id="5204" href="Meta.Regularity.html#5154" class="Bound">n</a> <a id="5206" href="Meta.Regularity.html#5169" class="Bound">a</a>
    <a id="5212" href="Meta.Regularity.html#5212" class="Bound">b</a> <a id="5214" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="5216" href="Meta.Reflection.Base.html#3293" class="Function">under-abs</a> <a id="5226" href="Meta.Regularity.html#5156" class="Bound">t</a> <a id="5228" class="Symbol">(</a><a id="5229" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5232" href="Meta.Regularity.html#5150" class="Bound">pre</a> <a id="5236" class="Symbol">(</a><a id="5237" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5241" href="Meta.Regularity.html#5154" class="Bound">n</a><a id="5242" class="Symbol">)</a> <a id="5244" href="Meta.Regularity.html#5180" class="Bound">b</a><a id="5245" class="Symbol">)</a>
    <a id="5251" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5256" class="Symbol">(</a><a id="5257" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="5260" class="Symbol">(</a><a id="5261" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5265" href="Meta.Regularity.html#5167" class="Bound">i</a> <a id="5267" href="Meta.Regularity.html#5193" class="Bound">a</a><a id="5268" class="Symbol">)</a> <a id="5270" class="Symbol">(</a><a id="5271" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="5275" href="Meta.Regularity.html#5177" class="Bound">nm</a> <a id="5278" href="Meta.Regularity.html#5212" class="Bound">b</a><a id="5279" class="Symbol">))</a>
  <a id="5284" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5287" href="Meta.Regularity.html#5287" class="Bound">pre</a> <a id="5291" href="Meta.Regularity.html#5291" class="Bound">n</a> <a id="5293" class="Symbol">(</a><a id="5294" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="5304" href="Meta.Regularity.html#5304" class="Bound">s</a><a id="5305" class="Symbol">)</a> <a id="5307" class="Symbol">=</a> <a id="5309" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5314" class="Symbol">(</a><a id="5315" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="5325" href="Meta.Regularity.html#5304" class="Bound">s</a><a id="5326" class="Symbol">)</a>
  <a id="5330" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5333" href="Meta.Regularity.html#5333" class="Bound">pre</a> <a id="5337" href="Meta.Regularity.html#5337" class="Bound">n</a> <a id="5339" class="Symbol">(</a><a id="5340" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5344" href="Meta.Regularity.html#5344" class="Bound">l</a><a id="5345" class="Symbol">)</a> <a id="5347" class="Symbol">=</a> <a id="5349" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5354" class="Symbol">(</a><a id="5355" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5359" href="Meta.Regularity.html#5344" class="Bound">l</a><a id="5360" class="Symbol">)</a>
  <a id="5364" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5367" href="Meta.Regularity.html#5367" class="Bound">pre</a> <a id="5371" href="Meta.Regularity.html#5371" class="Bound">n</a> <a id="5373" class="Symbol">(</a><a id="5374" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5379" href="Meta.Regularity.html#5379" class="Bound">x</a> <a id="5381" href="Meta.Regularity.html#5381" class="Bound">args</a><a id="5385" class="Symbol">)</a> <a id="5387" class="Symbol">=</a> <a id="5389" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5394" href="Meta.Regularity.html#5379" class="Bound">x</a> <a id="5396" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="5400" href="Meta.Regularity.html#3311" class="Function">go*</a> <a id="5404" href="Meta.Regularity.html#5367" class="Bound">pre</a> <a id="5408" href="Meta.Regularity.html#5371" class="Bound">n</a> <a id="5410" href="Meta.Regularity.html#5381" class="Bound">args</a>
  <a id="5417" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5420" href="Meta.Regularity.html#5420" class="Bound">pre</a> <a id="5424" href="Meta.Regularity.html#5424" class="Bound">n</a> <a id="5426" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="5434" class="Symbol">=</a> <a id="5436" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5441" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

  <a id="5452" href="Meta.Regularity.html#3311" class="Function">go*</a> <a id="5456" href="Meta.Regularity.html#5456" class="Bound">pre</a> <a id="5460" href="Meta.Regularity.html#5460" class="Bound">n</a> <a id="5462" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5465" class="Symbol">=</a> <a id="5467" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="5472" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="5477" href="Meta.Regularity.html#3311" class="Function">go*</a> <a id="5481" href="Meta.Regularity.html#5481" class="Bound">pre</a> <a id="5485" href="Meta.Regularity.html#5485" class="Bound">n</a> <a id="5487" class="Symbol">(</a><a id="5488" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5492" href="Meta.Regularity.html#5492" class="Bound">i</a> <a id="5494" href="Meta.Regularity.html#5494" class="Bound">a</a> <a id="5496" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5498" href="Meta.Regularity.html#5498" class="Bound">as</a><a id="5500" class="Symbol">)</a> <a id="5502" class="Symbol">=</a> <a id="5504" class="Keyword">do</a>
    <a id="5511" href="Meta.Regularity.html#5511" class="Bound">a</a> <a id="5513" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="5515" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="5518" href="Meta.Regularity.html#5481" class="Bound">pre</a> <a id="5522" href="Meta.Regularity.html#5485" class="Bound">n</a> <a id="5524" href="Meta.Regularity.html#5494" class="Bound">a</a>
    <a id="5530" class="Symbol">(</a><a id="5531" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5535" href="Meta.Regularity.html#5492" class="Bound">i</a> <a id="5537" href="Meta.Regularity.html#5511" class="Bound">a</a> <a id="5539" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷_</a><a id="5541" class="Symbol">)</a> <a id="5543" href="Meta.Effect.Map.html#494" class="Function Operator">&lt;$&gt;</a> <a id="5547" href="Meta.Regularity.html#3311" class="Function">go*</a> <a id="5551" href="Meta.Regularity.html#5481" class="Bound">pre</a> <a id="5555" href="Meta.Regularity.html#5485" class="Bound">n</a> <a id="5557" href="Meta.Regularity.html#5498" class="Bound">as</a>

  <a id="5563" class="Comment">-- To turn a term into a regularity path, given a level of precision,</a>
  <a id="5635" class="Comment">-- all we have to do is raise the term by one, do the procedure above,</a>
  <a id="5708" class="Comment">-- then wrap it in a lambda. Nice!</a>
  <a id="to-regularity-path"></a><a id="5745" href="Meta.Regularity.html#5745" class="Function">to-regularity-path</a> <a id="5764" class="Symbol">:</a> <a id="5766" href="Meta.Regularity.html#2333" class="Datatype">Regularity-precision</a> <a id="5787" class="Symbol">→</a> <a id="5789" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5794" class="Symbol">→</a> <a id="5796" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="5799" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5806" href="Meta.Regularity.html#5745" class="Function">to-regularity-path</a> <a id="5825" href="Meta.Regularity.html#5825" class="Bound">pre</a> <a id="5829" href="Meta.Regularity.html#5829" class="Bound">tm</a> <a id="5832" class="Symbol">=</a> <a id="5834" class="Keyword">do</a>
    <a id="5841" href="Meta.Regularity.html#5841" class="Bound">tm</a> <a id="5844" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="5846" href="Meta.Reflection.Subst.html#7503" class="Function">raiseTC</a> <a id="5854" class="Number">1</a> <a id="5856" href="Meta.Regularity.html#5829" class="Bound">tm</a>
    <a id="5863" class="Comment">-- Since we&#39;ll be comparing terms, Agda really wants them to be</a>
    <a id="5931" class="Comment">-- well-scoped. Since we shifted eeeverything up by one, we have to</a>
    <a id="6003" class="Comment">-- grow the context, too.</a>
    <a id="6033" href="Meta.Regularity.html#6033" class="Bound">tm</a> <a id="6036" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6038" href="Meta.Reflection.Base.html#4645" class="Function">resetting</a> <a id="6048" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="6050" href="Agda.Builtin.Reflection.html#9277" class="Postulate">extend-context</a> <a id="6065" class="String">&quot;i&quot;</a> <a id="6069" class="Symbol">(</a><a id="6070" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="6075" class="Symbol">(</a><a id="6076" class="Keyword">quoteTerm</a> <a id="6086" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="6087" class="Symbol">))</a> <a id="6090" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="6092" href="Meta.Regularity.html#3155" class="Function">go</a> <a id="6095" href="Meta.Regularity.html#5825" class="Bound">pre</a> <a id="6099" class="Number">0</a> <a id="6101" href="Meta.Regularity.html#5841" class="Bound">tm</a>
    <a id="6108" href="Meta.Effect.Idiom.html#354" class="Field">pure</a> <a id="6113" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="6115" href="Meta.Reflection.Base.html#4121" class="Function">vlam</a> <a id="6120" class="String">&quot;i&quot;</a> <a id="6124" href="Meta.Regularity.html#6033" class="Bound">tm</a>

  <a id="6130" class="Comment">-- Extend a path x ＝ y to a path x′ ＝ y′, where x′ --&gt; x and y′ --&gt; y</a>
  <a id="6202" class="Comment">-- under the given regularity precision. Shorthand for composing</a>
  <a id="6269" class="Comment">--    regularity! ∙ p ∙ sym regularity!.</a>
  <a id="regular!-worker"></a><a id="6312" href="Meta.Regularity.html#6312" class="Function">regular!-worker</a> <a id="6328" class="Symbol">:</a>
    <a id="6334" class="Symbol">∀</a> <a id="6336" class="Symbol">{</a><a id="6337" href="Meta.Regularity.html#6337" class="Bound">ℓ</a><a id="6338" class="Symbol">}</a> <a id="6340" class="Symbol">{</a><a id="6341" href="Meta.Regularity.html#6341" class="Bound">A</a> <a id="6343" class="Symbol">:</a> <a id="6345" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="6350" href="Meta.Regularity.html#6337" class="Bound">ℓ</a><a id="6351" class="Symbol">}</a> <a id="6353" class="Symbol">{</a><a id="6354" href="Meta.Regularity.html#6354" class="Bound">x</a> <a id="6356" href="Meta.Regularity.html#6356" class="Bound">y</a> <a id="6358" class="Symbol">:</a> <a id="6360" href="Meta.Regularity.html#6341" class="Bound">A</a><a id="6361" class="Symbol">}</a>
    <a id="6367" class="Symbol">→</a> <a id="6369" href="Meta.Regularity.html#2333" class="Datatype">Regularity-precision</a>
    <a id="6394" class="Symbol">→</a> <a id="6396" href="Meta.Regularity.html#6354" class="Bound">x</a> <a id="6398" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="6400" href="Meta.Regularity.html#6356" class="Bound">y</a>
    <a id="6406" class="Symbol">→</a> <a id="6408" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="6417" class="Symbol">→</a> <a id="6419" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="6422" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="6426" href="Meta.Regularity.html#6312" class="Function">regular!-worker</a> <a id="6442" class="Symbol">{</a><a id="6443" class="Argument">x</a> <a id="6445" class="Symbol">=</a> <a id="6447" href="Meta.Regularity.html#6447" class="Bound">x</a><a id="6448" class="Symbol">}</a> <a id="6450" class="Symbol">{</a><a id="6451" href="Meta.Regularity.html#6451" class="Bound">y</a><a id="6452" class="Symbol">}</a> <a id="6454" href="Meta.Regularity.html#6454" class="Bound">pre</a> <a id="6458" href="Meta.Regularity.html#6458" class="Bound">p</a> <a id="6460" href="Meta.Regularity.html#6460" class="Bound">goal</a> <a id="6465" class="Symbol">=</a> <a id="6467" class="Keyword">do</a>
    <a id="6474" href="Meta.Regularity.html#6474" class="Bound">gt</a> <a id="6477" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6479" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6490" href="Meta.Regularity.html#6460" class="Bound">goal</a>
    <a id="6499" href="Meta.Regularity.html#6499" class="Bound">`x</a> <a id="6502" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6504" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6512" href="Meta.Regularity.html#6447" class="Bound">x</a>
    <a id="6518" href="Meta.Regularity.html#6518" class="Bound">`y</a> <a id="6521" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6523" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6531" href="Meta.Regularity.html#6451" class="Bound">y</a>
    <a id="6537" href="Meta.Regularity.html#6537" class="Bound">`p</a> <a id="6540" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6542" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6550" href="Meta.Regularity.html#6458" class="Bound">p</a>
    <a id="6556" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6561" class="Symbol">(_</a> <a id="6564" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6566" href="Meta.Regularity.html#6566" class="Bound">l</a> <a id="6568" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6570" href="Meta.Regularity.html#6570" class="Bound">r</a><a id="6571" class="Symbol">)</a> <a id="6573" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6575" href="Meta.Reflection.Base.html#7247" class="Function">unapply-path</a> <a id="6588" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="6592" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6603" href="Meta.Regularity.html#6460" class="Bound">goal</a>
      <a id="6614" class="Keyword">where</a> <a id="6620" class="CatchallClause Symbol">_</a> <a id="6622" class="Symbol">→</a> <a id="6624" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="6635" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="6642" href="Meta.Regularity.html#6642" class="Bound">l</a> <a id="6644" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6646" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6656" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="6660" href="Meta.Reflection.Base.html#5502" class="Function">wait-for-type</a> <a id="6674" href="Meta.Regularity.html#6566" class="Bound">l</a>
    <a id="6680" href="Meta.Regularity.html#6680" class="Bound">r</a> <a id="6682" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6684" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6694" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="6698" href="Meta.Reflection.Base.html#5502" class="Function">wait-for-type</a> <a id="6712" href="Meta.Regularity.html#6570" class="Bound">r</a>
    <a id="6718" href="Meta.Regularity.html#6718" class="Bound">reg</a> <a id="6722" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6724" href="Meta.Regularity.html#5745" class="Function">to-regularity-path</a> <a id="6743" href="Meta.Regularity.html#6454" class="Bound">pre</a> <a id="6747" href="Meta.Regularity.html#6642" class="Bound">l</a>
    <a id="6753" href="Meta.Regularity.html#6753" class="Bound">reg′</a> <a id="6758" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="6760" href="Meta.Regularity.html#5745" class="Function">to-regularity-path</a> <a id="6779" href="Meta.Regularity.html#6454" class="Bound">pre</a> <a id="6783" href="Meta.Regularity.html#6680" class="Bound">r</a>
    <a id="6789" href="Meta.Reflection.Base.html#8972" class="Function">unify-loudly</a> <a id="6802" href="Meta.Regularity.html#6460" class="Bound">goal</a> <a id="6807" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="6809" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6813" class="Symbol">(</a><a id="6814" class="Keyword">quote</a> <a id="6820" href="Meta.Regularity.html#1697" class="Function">double-comp</a><a id="6831" class="Symbol">)</a> <a id="6833" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a>
         <a id="6844" href="Meta.Regularity.html#6499" class="Bound">`x</a> <a id="6847" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6850" href="Meta.Regularity.html#6518" class="Bound">`y</a> <a id="6853" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6856" href="Meta.Regularity.html#6718" class="Bound">reg</a>
      <a id="6866" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6869" href="Meta.Regularity.html#6537" class="Bound">`p</a>
      <a id="6878" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6881" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6885" class="Symbol">(</a><a id="6886" class="Keyword">quote</a> <a id="6892" href="Foundations.Correspondences.Binary.Symmetric.html#515" class="Function">sym</a><a id="6895" class="Symbol">)</a> <a id="6897" class="Symbol">(</a><a id="6898" href="Meta.Regularity.html#6753" class="Bound">reg′</a> <a id="6903" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6906" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6908" class="Symbol">)</a>
      <a id="6916" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6919" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="6923" class="Keyword">module</a> <a id="Regularity"></a><a id="6930" href="Meta.Regularity.html#6930" class="Module">Regularity</a> <a id="6941" class="Keyword">where</a>
  <a id="6949" class="Keyword">open</a> <a id="6954" href="Meta.Regularity.html#2333" class="Module">Regularity-precision</a> <a id="6975" class="Keyword">public</a>
  <a id="6984" class="Comment">-- The reflection interface: Regularity.reduce! will, well, reduce a</a>
  <a id="7055" class="Comment">-- term. There&#39;s a lot of blocking involved in making this work.</a>
  <a id="7122" class="Keyword">macro</a>
    <a id="Regularity.reduce!"></a><a id="7132" href="Meta.Regularity.html#7132" class="Function">reduce!</a> <a id="7140" class="Symbol">:</a> <a id="7142" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7147" class="Symbol">→</a> <a id="7149" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7152" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="7158" href="Meta.Regularity.html#7132" class="Function">reduce!</a> <a id="7166" href="Meta.Regularity.html#7166" class="Bound">goal</a> <a id="7171" class="Symbol">=</a> <a id="7173" class="Keyword">do</a>
      <a id="7182" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="7187" class="Symbol">(_</a> <a id="7190" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7192" href="Meta.Regularity.html#7192" class="Bound">l</a> <a id="7194" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7196" href="Meta.Regularity.html#7196" class="Bound">r</a><a id="7197" class="Symbol">)</a> <a id="7199" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="7201" href="Meta.Reflection.Base.html#7247" class="Function">unapply-path</a> <a id="7214" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="7218" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="7229" href="Meta.Regularity.html#7166" class="Bound">goal</a>
        <a id="7242" class="Keyword">where</a> <a id="7248" class="CatchallClause Symbol">_</a> <a id="7250" class="Symbol">→</a> <a id="7252" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="7263" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="7272" href="Meta.Regularity.html#7272" class="Bound">reg</a> <a id="7276" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="7278" href="Meta.Regularity.html#5745" class="Function">to-regularity-path</a> <a id="7297" href="Meta.Regularity.html#2371" class="InductiveConstructor">precise</a> <a id="7305" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="7309" class="Symbol">(</a><a id="7310" href="Meta.Reflection.Base.html#5502" class="Function">wait-for-type</a> <a id="7324" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="7328" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="7338" href="Meta.Regularity.html#7192" class="Bound">l</a><a id="7339" class="Symbol">)</a>
      <a id="7347" href="Meta.Reflection.Base.html#8972" class="Function">unify-loudly</a> <a id="7360" href="Meta.Regularity.html#7166" class="Bound">goal</a> <a id="7365" href="Meta.Regularity.html#7272" class="Bound">reg</a>

    <a id="7374" class="Comment">-- We then have wrappers that reduce on one side, and expand on the</a>
    <a id="7446" class="Comment">-- other, depending on how precise you want the reduction to be.</a>
    <a id="Regularity.precise!"></a><a id="7515" href="Meta.Regularity.html#7515" class="Function">precise!</a> <a id="7524" class="Symbol">:</a> <a id="7526" class="Symbol">∀</a> <a id="7528" class="Symbol">{</a><a id="7529" href="Meta.Regularity.html#7529" class="Bound">ℓ</a><a id="7530" class="Symbol">}</a> <a id="7532" class="Symbol">{</a><a id="7533" href="Meta.Regularity.html#7533" class="Bound">A</a> <a id="7535" class="Symbol">:</a> <a id="7537" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7542" href="Meta.Regularity.html#7529" class="Bound">ℓ</a><a id="7543" class="Symbol">}</a> <a id="7545" class="Symbol">{</a><a id="7546" href="Meta.Regularity.html#7546" class="Bound">x</a> <a id="7548" href="Meta.Regularity.html#7548" class="Bound">y</a> <a id="7550" class="Symbol">:</a> <a id="7552" href="Meta.Regularity.html#7533" class="Bound">A</a><a id="7553" class="Symbol">}</a> <a id="7555" class="Symbol">→</a> <a id="7557" href="Meta.Regularity.html#7546" class="Bound">x</a> <a id="7559" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="7561" href="Meta.Regularity.html#7548" class="Bound">y</a> <a id="7563" class="Symbol">→</a> <a id="7565" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7570" class="Symbol">→</a> <a id="7572" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7575" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="Regularity.fast!"></a><a id="7581" href="Meta.Regularity.html#7581" class="Function">fast!</a> <a id="7587" class="Symbol">:</a> <a id="7589" class="Symbol">∀</a> <a id="7591" class="Symbol">{</a><a id="7592" href="Meta.Regularity.html#7592" class="Bound">ℓ</a><a id="7593" class="Symbol">}</a> <a id="7595" class="Symbol">{</a><a id="7596" href="Meta.Regularity.html#7596" class="Bound">A</a> <a id="7598" class="Symbol">:</a> <a id="7600" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7605" href="Meta.Regularity.html#7592" class="Bound">ℓ</a><a id="7606" class="Symbol">}</a> <a id="7608" class="Symbol">{</a><a id="7609" href="Meta.Regularity.html#7609" class="Bound">x</a> <a id="7611" href="Meta.Regularity.html#7611" class="Bound">y</a> <a id="7613" class="Symbol">:</a> <a id="7615" href="Meta.Regularity.html#7596" class="Bound">A</a><a id="7616" class="Symbol">}</a> <a id="7618" class="Symbol">→</a> <a id="7620" href="Meta.Regularity.html#7609" class="Bound">x</a> <a id="7622" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="7624" href="Meta.Regularity.html#7611" class="Bound">y</a> <a id="7626" class="Symbol">→</a> <a id="7628" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7633" class="Symbol">→</a> <a id="7635" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7638" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="7645" href="Meta.Regularity.html#7515" class="Function">precise!</a> <a id="7654" href="Meta.Regularity.html#7654" class="Bound">p</a> <a id="7656" href="Meta.Regularity.html#7656" class="Bound">goal</a> <a id="7661" class="Symbol">=</a> <a id="7663" href="Meta.Regularity.html#6312" class="Function">regular!-worker</a> <a id="7679" href="Meta.Regularity.html#2371" class="InductiveConstructor">precise</a> <a id="7687" href="Meta.Regularity.html#7654" class="Bound">p</a> <a id="7689" href="Meta.Regularity.html#7656" class="Bound">goal</a>
    <a id="7698" href="Meta.Regularity.html#7581" class="Function">fast!</a> <a id="7704" href="Meta.Regularity.html#7704" class="Bound">p</a> <a id="7706" href="Meta.Regularity.html#7706" class="Bound">goal</a> <a id="7711" class="Symbol">=</a> <a id="7713" href="Meta.Regularity.html#6312" class="Function">regular!-worker</a> <a id="7729" href="Meta.Regularity.html#2379" class="InductiveConstructor">fast</a> <a id="7734" href="Meta.Regularity.html#7704" class="Bound">p</a> <a id="7736" href="Meta.Regularity.html#7706" class="Bound">goal</a>

    <a id="7746" class="Comment">-- For debugging purposes, this macro will take a term and output</a>
    <a id="7816" class="Comment">-- its (transport refl)-normal form, according to the given level of</a>
    <a id="7889" class="Comment">-- precision.</a>
    <a id="Regularity.reduct"></a><a id="7907" href="Meta.Regularity.html#7907" class="Function">reduct</a> <a id="7914" class="Symbol">:</a> <a id="7916" href="Meta.Regularity.html#2333" class="Datatype">Regularity-precision</a> <a id="7937" class="Symbol">→</a> <a id="7939" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7944" class="Symbol">→</a> <a id="7946" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7951" class="Symbol">→</a> <a id="7953" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7956" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="7962" href="Meta.Regularity.html#7907" class="Function">reduct</a> <a id="7969" href="Meta.Regularity.html#7969" class="Bound">pres</a> <a id="7974" href="Meta.Regularity.html#7974" class="Bound">tm</a> <a id="7977" class="Symbol">_</a> <a id="7979" class="Symbol">=</a> <a id="7981" class="Keyword">do</a>
      <a id="7990" href="Meta.Regularity.html#7990" class="Bound">orig</a> <a id="7995" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="7997" href="Meta.Reflection.Base.html#5502" class="Function">wait-for-type</a> <a id="8011" href="Meta.Effect.Bind.html#427" class="Function Operator">=&lt;&lt;</a> <a id="8015" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="8025" href="Meta.Regularity.html#7974" class="Bound">tm</a>
      <a id="8034" href="Meta.Regularity.html#8034" class="Bound">tm</a> <a id="8037" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="8039" href="Meta.Regularity.html#5745" class="Function">to-regularity-path</a> <a id="8058" href="Meta.Regularity.html#7969" class="Bound">pres</a> <a id="8063" href="Meta.Regularity.html#7990" class="Bound">orig</a>
      <a id="8074" href="Meta.Regularity.html#8074" class="Bound">red</a> <a id="8078" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="8080" href="Meta.Reflection.Subst.html#7871" class="Function">applyTC</a> <a id="8088" href="Meta.Regularity.html#8034" class="Bound">tm</a> <a id="8091" class="Symbol">(</a><a id="8092" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="8097" class="Symbol">(</a><a id="8098" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8102" class="Symbol">(</a><a id="8103" class="Keyword">quote</a> <a id="8109" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="8111" class="Symbol">)</a> <a id="8113" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8115" class="Symbol">))</a> <a id="8118" href="Meta.Effect.Bind.html#283" class="Field Operator">&gt;&gt;=</a> <a id="8122" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a>
      <a id="8138" href="Meta.Regularity.html#8138" class="Bound">`pres</a> <a id="8144" href="Meta.Effect.Bind.html#283" class="Field Operator">←</a> <a id="8146" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="8154" href="Meta.Regularity.html#7969" class="Bound">pres</a>
      <a id="8165" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a>
        <a id="8184" href="Meta.Literals.FromProduct.html#385" class="Function Operator">[</a> <a id="8186" class="String">&quot;The term\n\n  &quot;</a> <a id="8203" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8205" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8214" href="Meta.Regularity.html#7990" class="Bound">orig</a> <a id="8219" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8221" class="String">&quot;\n\nreduces modulo &quot;</a>
        <a id="8251" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8253" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8262" href="Meta.Regularity.html#8138" class="Bound">`pres</a> <a id="8268" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8270" class="String">&quot; regularity to\n\n  &quot;</a>
        <a id="8301" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8303" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8312" href="Meta.Regularity.html#8074" class="Bound">red</a> <a id="8316" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8318" class="String">&quot;\n&quot;</a> <a id="8323" href="Meta.Literals.FromProduct.html#385" class="Function Operator">]</a>

<a id="8326" class="Comment">-- Test cases.</a>
<a id="8341" class="Keyword">module</a>
  <a id="8350" href="Meta.Regularity.html#8350" class="Module">_</a> <a id="8352" class="Symbol">{</a><a id="8353" href="Meta.Regularity.html#8353" class="Bound">ℓ</a> <a id="8355" href="Meta.Regularity.html#8355" class="Bound">ℓ′</a><a id="8357" class="Symbol">}</a> <a id="8359" class="Symbol">{</a><a id="8360" href="Meta.Regularity.html#8360" class="Bound">A</a> <a id="8362" class="Symbol">:</a> <a id="8364" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8369" href="Meta.Regularity.html#8353" class="Bound">ℓ</a><a id="8370" class="Symbol">}</a> <a id="8372" class="Symbol">{</a><a id="8373" href="Meta.Regularity.html#8373" class="Bound">B</a> <a id="8375" class="Symbol">:</a> <a id="8377" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8382" href="Meta.Regularity.html#8355" class="Bound">ℓ′</a><a id="8384" class="Symbol">}</a> <a id="8386" class="Symbol">(</a><a id="8387" href="Meta.Regularity.html#8387" class="Bound">f</a> <a id="8389" href="Meta.Regularity.html#8389" class="Bound">g</a> <a id="8391" class="Symbol">:</a> <a id="8393" href="Meta.Regularity.html#8360" class="Bound">A</a> <a id="8395" class="Symbol">→</a> <a id="8397" href="Meta.Regularity.html#8373" class="Bound">B</a><a id="8398" class="Symbol">)</a> <a id="8400" class="Symbol">(</a><a id="8401" href="Meta.Regularity.html#8401" class="Bound">x</a> <a id="8403" class="Symbol">:</a> <a id="8405" href="Meta.Regularity.html#8360" class="Bound">A</a><a id="8406" class="Symbol">)</a>
    <a id="8412" class="Symbol">(</a><a id="8413" href="Meta.Regularity.html#8413" class="Bound">a-loop</a> <a id="8420" class="Symbol">:</a> <a id="8422" class="Symbol">(</a><a id="8423" href="Meta.Regularity.html#8423" class="Bound">i</a> <a id="8425" class="Symbol">:</a> <a id="8427" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="8428" class="Symbol">)</a> <a id="8430" class="Symbol">→</a> <a id="8432" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8437" href="Meta.Regularity.html#8353" class="Bound">ℓ</a> <a id="8439" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">[</a> <a id="8441" class="Symbol">(</a><a id="8442" href="Meta.Regularity.html#8423" class="Bound">i</a> <a id="8444" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">∨</a> <a id="8446" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="8448" href="Meta.Regularity.html#8423" class="Bound">i</a><a id="8449" class="Symbol">)</a> <a id="8451" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">↦</a> <a id="8453" class="Symbol">(λ</a> <a id="8456" class="Symbol">.</a><a id="8457" href="Meta.Regularity.html#8457" class="Bound">_</a> <a id="8459" class="Symbol">→</a> <a id="8461" href="Meta.Regularity.html#8360" class="Bound">A</a><a id="8462" class="Symbol">)</a> <a id="8464" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">]</a><a id="8465" class="Symbol">)</a>
  <a id="8469" class="Keyword">where</a> <a id="8475" class="Keyword">private</a>

  <a id="8486" href="Meta.Regularity.html#8486" class="Function">p</a> <a id="8488" class="Symbol">:</a> <a id="8490" class="Symbol">(</a><a id="8491" href="Meta.Regularity.html#8491" class="Bound">h</a> <a id="8493" class="Symbol">:</a> <a id="8495" class="Symbol">∀</a> <a id="8497" href="Meta.Regularity.html#8497" class="Bound">x</a> <a id="8499" class="Symbol">→</a> <a id="8501" href="Meta.Regularity.html#8387" class="Bound">f</a> <a id="8503" href="Meta.Regularity.html#8497" class="Bound">x</a> <a id="8505" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8507" href="Meta.Regularity.html#8389" class="Bound">g</a> <a id="8509" href="Meta.Regularity.html#8497" class="Bound">x</a><a id="8510" class="Symbol">)</a>
    <a id="8516" class="Symbol">→</a> <a id="8518" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8528" class="Symbol">(λ</a> <a id="8531" href="Meta.Regularity.html#8531" class="Bound">i</a> <a id="8533" class="Symbol">→</a> <a id="8535" href="Meta.Regularity.html#8360" class="Bound">A</a> <a id="8537" class="Symbol">→</a> <a id="8539" href="Meta.Regularity.html#8373" class="Bound">B</a><a id="8540" class="Symbol">)</a>
        <a id="8550" class="Symbol">(λ</a> <a id="8553" href="Meta.Regularity.html#8553" class="Bound">x</a> <a id="8555" class="Symbol">→</a> <a id="8557" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8567" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="8572" class="Symbol">(</a><a id="8573" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8583" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="8588" class="Symbol">(</a><a id="8589" href="Meta.Regularity.html#8387" class="Bound">f</a> <a id="8591" class="Symbol">(</a><a id="8592" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8602" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="8607" href="Meta.Regularity.html#8553" class="Bound">x</a><a id="8608" class="Symbol">))))</a> <a id="8613" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8615" href="Meta.Regularity.html#8389" class="Bound">g</a>
  <a id="8619" href="Meta.Regularity.html#8486" class="Function">p</a> <a id="8621" href="Meta.Regularity.html#8621" class="Bound">h</a> <a id="8623" class="Symbol">=</a> <a id="8625" href="Meta.Regularity.html#7132" class="Macro">Regularity.reduce!</a> <a id="8644" href="Foundations.Correspondences.Binary.Transitive.html#475" class="Field Operator">∙</a> <a id="8646" href="Foundations.Base.html#10718" class="Function">fun-ext</a> <a id="8654" href="Meta.Regularity.html#8621" class="Bound">h</a>

  <a id="8659" href="Meta.Regularity.html#8659" class="Function">q</a> <a id="8661" class="Symbol">:</a> <a id="8663" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8673" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="8678" class="Symbol">(</a><a id="8679" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8686" class="Symbol">(λ</a> <a id="8689" href="Meta.Regularity.html#8689" class="Bound">i</a> <a id="8691" class="Symbol">→</a> <a id="8693" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8698" class="Symbol">(</a><a id="8699" href="Meta.Regularity.html#8413" class="Bound">a-loop</a> <a id="8706" href="Meta.Regularity.html#8689" class="Bound">i</a><a id="8707" class="Symbol">))</a> <a id="8710" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8713" href="Meta.Regularity.html#8401" class="Bound">x</a><a id="8714" class="Symbol">)</a> <a id="8716" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8718" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8725" class="Symbol">(λ</a> <a id="8728" href="Meta.Regularity.html#8728" class="Bound">i</a> <a id="8730" class="Symbol">→</a> <a id="8732" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8737" class="Symbol">(</a><a id="8738" href="Meta.Regularity.html#8413" class="Bound">a-loop</a> <a id="8745" href="Meta.Regularity.html#8728" class="Bound">i</a><a id="8746" class="Symbol">))</a> <a id="8749" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8752" href="Meta.Regularity.html#8401" class="Bound">x</a>
  <a id="8756" href="Meta.Regularity.html#8659" class="Function">q</a> <a id="8758" class="Symbol">=</a> <a id="8760" href="Meta.Regularity.html#7132" class="Macro">Regularity.reduce!</a>

  <a id="8782" class="Comment">-- Imprecise/fast reduction: According to it, the normal form of the</a>
  <a id="8853" class="Comment">-- transport below is refl. That&#39;s.. not the case, at least we don&#39;t</a>
  <a id="8924" class="Comment">-- know so. Precise regularity handles it, though.</a>
  <a id="8977" class="Comment">-- q′ : ⊤</a>
  <a id="8989" class="Comment">-- q′ = {! Regularity.reduct Regularity.fast (transp (λ i → outS (a-loop i)) i0 x) !}</a>

  <a id="9078" href="Meta.Regularity.html#9078" class="Function">r</a> <a id="9080" class="Symbol">:</a> <a id="9082" class="Symbol">(</a><a id="9083" href="Meta.Regularity.html#9083" class="Bound">h</a> <a id="9085" class="Symbol">:</a> <a id="9087" class="Symbol">∀</a> <a id="9089" href="Meta.Regularity.html#9089" class="Bound">x</a> <a id="9091" class="Symbol">→</a> <a id="9093" href="Meta.Regularity.html#8387" class="Bound">f</a> <a id="9095" href="Meta.Regularity.html#9089" class="Bound">x</a> <a id="9097" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9099" href="Meta.Regularity.html#8389" class="Bound">g</a> <a id="9101" href="Meta.Regularity.html#9089" class="Bound">x</a><a id="9102" class="Symbol">)</a> <a id="9104" class="Symbol">→</a> <a id="9106" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9116" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="9121" class="Symbol">(</a><a id="9122" href="Meta.Regularity.html#8387" class="Bound">f</a> <a id="9124" href="Meta.Regularity.html#8401" class="Bound">x</a><a id="9125" class="Symbol">)</a> <a id="9127" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9129" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9139" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="9144" class="Symbol">(</a><a id="9145" href="Meta.Regularity.html#8389" class="Bound">g</a> <a id="9147" href="Meta.Regularity.html#8401" class="Bound">x</a><a id="9148" class="Symbol">)</a>
  <a id="9152" href="Meta.Regularity.html#9078" class="Function">r</a> <a id="9154" href="Meta.Regularity.html#9154" class="Bound">h</a> <a id="9156" class="Symbol">=</a> <a id="9158" href="Meta.Regularity.html#7515" class="Macro">Regularity.precise!</a> <a id="9178" class="Symbol">(</a><a id="9179" href="Meta.Regularity.html#9154" class="Bound">h</a> <a id="9181" href="Meta.Regularity.html#8401" class="Bound">x</a><a id="9182" class="Symbol">)</a>

  <a id="9187" href="Meta.Regularity.html#9187" class="Function">s</a> <a id="9189" class="Symbol">:</a> <a id="9191" class="Symbol">(</a><a id="9192" href="Meta.Regularity.html#9192" class="Bound">h</a> <a id="9194" class="Symbol">:</a> <a id="9196" class="Symbol">∀</a> <a id="9198" href="Meta.Regularity.html#9198" class="Bound">x</a> <a id="9200" class="Symbol">→</a> <a id="9202" href="Meta.Regularity.html#8387" class="Bound">f</a> <a id="9204" href="Meta.Regularity.html#9198" class="Bound">x</a> <a id="9206" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9208" href="Meta.Regularity.html#8389" class="Bound">g</a> <a id="9210" href="Meta.Regularity.html#9198" class="Bound">x</a><a id="9211" class="Symbol">)</a> <a id="9213" class="Symbol">→</a> <a id="9215" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9225" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="9230" class="Symbol">(</a><a id="9231" href="Meta.Regularity.html#8389" class="Bound">g</a> <a id="9233" href="Meta.Regularity.html#8401" class="Bound">x</a><a id="9234" class="Symbol">)</a> <a id="9236" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9238" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9248" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="9253" class="Symbol">(</a><a id="9254" href="Meta.Regularity.html#8387" class="Bound">f</a> <a id="9256" href="Meta.Regularity.html#8401" class="Bound">x</a><a id="9257" class="Symbol">)</a>
  <a id="9261" href="Meta.Regularity.html#9187" class="Function">s</a> <a id="9263" href="Meta.Regularity.html#9263" class="Bound">h</a> <a id="9265" class="Symbol">=</a> <a id="9267" href="Foundations.Correspondences.Binary.Symmetric.html#515" class="Function">sym</a> <a id="9271" href="Foundations.Pi.Base.html#1914" class="Function Operator">$</a> <a id="9273" href="Meta.Regularity.html#7581" class="Macro">Regularity.fast!</a> <a id="9290" class="Symbol">(</a><a id="9291" href="Meta.Regularity.html#9263" class="Bound">h</a> <a id="9293" href="Meta.Regularity.html#8401" class="Bound">x</a><a id="9294" class="Symbol">)</a>
</pre></body></html>