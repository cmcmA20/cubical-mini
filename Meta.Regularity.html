<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Regularity</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Keyword">module</a> <a id="31" href="Meta.Regularity.html" class="Module">Meta.Regularity</a> <a id="47" class="Keyword">where</a>

<a id="54" class="Keyword">open</a> <a id="59" class="Keyword">import</a> <a id="66" href="Foundations.Base.html" class="Module">Foundations.Base</a>

<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="Meta.Alt.html" class="Module">Meta.Alt</a>
<a id="105" class="Keyword">open</a> <a id="110" class="Keyword">import</a> <a id="117" href="Meta.Reflection.Base.html" class="Module">Meta.Reflection.Base</a>
<a id="138" class="Keyword">open</a> <a id="143" class="Keyword">import</a> <a id="150" href="Meta.Reflection.Subst.html" class="Module">Meta.Reflection.Subst</a>

<a id="173" class="Keyword">open</a> <a id="178" class="Keyword">import</a> <a id="185" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="200" class="Keyword">open</a> <a id="205" class="Keyword">import</a> <a id="212" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="227" class="Keyword">open</a> <a id="232" class="Keyword">import</a> <a id="239" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="271" class="Keyword">open</a> <a id="276" class="Keyword">import</a> <a id="283" href="Data.Maybe.Instances.Alt.html" class="Module">Data.Maybe.Instances.Alt</a>


<a id="310" class="Comment">{-
A tactic for reducing &quot;transport refl x&quot; in other-wise normal terms. The
implementation is actually surprisingly simple: A term of the form (e.g.)

    transp (λ _ → A) i0 (f (transp (λ _ → B) i0 x))

is already a blueprint for how to normalise it. We simply have to turn it into

    λ i → transp (λ _ → A) i (f (transp (λ _ → B) i x))

so that the constant transports reduce away when (i = i1). Abstracting over i,
this gives a path from the initial term to its &quot;regular normal form&quot;, which
may be the worst name ever.

More generally, we replace terms of the form `transp Al φ x` with `transp Al (φ ∨ i) x`
recursively (inside-out), on the condition that Al is constant when i = i1.
-}</a>

<a id="1003" class="Keyword">private</a>
  <a id="1013" class="Keyword">open</a> <a id="1018" class="Keyword">import</a> <a id="1025" href="Agda.Primitive.Cubical.html" class="Module">Agda.Primitive.Cubical</a> <a id="1048" class="Keyword">using</a> <a id="1054" class="Symbol">(</a> <a id="1056" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a> <a id="1066" class="Symbol">)</a>
  <a id="1070" class="Comment">-- We have a double composition operator that doesn&#39;t use the</a>
  <a id="1134" class="Comment">-- fancy hcomp syntax in its definition. This has better type</a>
  <a id="1198" class="Comment">-- inference for one of the macros since it guarantees that the base</a>
  <a id="1269" class="Comment">-- (q i) is independent of j without any reduction.</a>
  <a id="double-comp"></a><a id="1323" href="Meta.Regularity.html#1323" class="Function">double-comp</a>
    <a id="1339" class="Symbol">:</a> <a id="1341" class="Symbol">∀</a> <a id="1343" class="Symbol">{</a><a id="1344" href="Meta.Regularity.html#1344" class="Bound">ℓ</a><a id="1345" class="Symbol">}</a> <a id="1347" class="Symbol">{</a><a id="1348" href="Meta.Regularity.html#1348" class="Bound">A</a> <a id="1350" class="Symbol">:</a> <a id="1352" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="1357" href="Meta.Regularity.html#1344" class="Bound">ℓ</a><a id="1358" class="Symbol">}</a> <a id="1360" class="Symbol">{</a><a id="1361" href="Meta.Regularity.html#1361" class="Bound">w</a> <a id="1363" href="Meta.Regularity.html#1363" class="Bound">z</a> <a id="1365" class="Symbol">:</a> <a id="1367" href="Meta.Regularity.html#1348" class="Bound">A</a><a id="1368" class="Symbol">}</a> <a id="1370" class="Symbol">(</a><a id="1371" href="Meta.Regularity.html#1371" class="Bound">x</a> <a id="1373" href="Meta.Regularity.html#1373" class="Bound">y</a> <a id="1375" class="Symbol">:</a> <a id="1377" href="Meta.Regularity.html#1348" class="Bound">A</a><a id="1378" class="Symbol">)</a>
    <a id="1384" class="Symbol">→</a> <a id="1386" href="Meta.Regularity.html#1361" class="Bound">w</a> <a id="1388" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="1390" href="Meta.Regularity.html#1371" class="Bound">x</a> <a id="1392" class="Symbol">→</a> <a id="1394" href="Meta.Regularity.html#1371" class="Bound">x</a> <a id="1396" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="1398" href="Meta.Regularity.html#1373" class="Bound">y</a> <a id="1400" class="Symbol">→</a> <a id="1402" href="Meta.Regularity.html#1373" class="Bound">y</a> <a id="1404" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="1406" href="Meta.Regularity.html#1363" class="Bound">z</a>
    <a id="1412" class="Symbol">→</a> <a id="1414" href="Meta.Regularity.html#1361" class="Bound">w</a> <a id="1416" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="1418" href="Meta.Regularity.html#1363" class="Bound">z</a>
  <a id="1422" href="Meta.Regularity.html#1323" class="Function">double-comp</a> <a id="1434" href="Meta.Regularity.html#1434" class="Bound">x</a> <a id="1436" href="Meta.Regularity.html#1436" class="Bound">y</a> <a id="1438" href="Meta.Regularity.html#1438" class="Bound">p</a> <a id="1440" href="Meta.Regularity.html#1440" class="Bound">q</a> <a id="1442" href="Meta.Regularity.html#1442" class="Bound">r</a> <a id="1444" href="Meta.Regularity.html#1444" class="Bound">i</a> <a id="1446" class="Symbol">=</a> <a id="1448" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a>
    <a id="1462" class="Symbol">(λ</a> <a id="1465" class="Symbol">{</a> <a id="1467" href="Meta.Regularity.html#1467" class="Bound">j</a> <a id="1469" class="Symbol">(</a><a id="1470" href="Meta.Regularity.html#1444" class="Bound">i</a> <a id="1472" class="Symbol">=</a> <a id="1474" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="1476" class="Symbol">)</a> <a id="1478" class="Symbol">→</a> <a id="1480" href="Meta.Regularity.html#1438" class="Bound">p</a> <a id="1482" class="Symbol">(</a><a id="1483" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="1485" href="Meta.Regularity.html#1467" class="Bound">j</a><a id="1486" class="Symbol">)</a> <a id="1488" class="Symbol">;</a> <a id="1490" href="Meta.Regularity.html#1490" class="Bound">j</a> <a id="1492" class="Symbol">(</a><a id="1493" href="Meta.Regularity.html#1444" class="Bound">i</a> <a id="1495" class="Symbol">=</a> <a id="1497" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="1499" class="Symbol">)</a> <a id="1501" class="Symbol">→</a> <a id="1503" href="Meta.Regularity.html#1442" class="Bound">r</a> <a id="1505" href="Meta.Regularity.html#1490" class="Bound">j</a> <a id="1507" class="Symbol">})</a> <a id="1510" class="Symbol">(</a><a id="1511" href="Meta.Regularity.html#1440" class="Bound">q</a> <a id="1513" href="Meta.Regularity.html#1444" class="Bound">i</a><a id="1514" class="Symbol">)</a>

  <a id="1519" class="Comment">-- The regularity tactic can operate in two modes: `precise` will work</a>
  <a id="1592" class="Comment">-- with the type-checker to identify which `transp`s are along refl,</a>
  <a id="1663" class="Comment">-- and which should be preserved. The `fast` mode says YOLO and</a>
  <a id="1729" class="Comment">-- assumes that **every** application of `transp` is one that would</a>
  <a id="1799" class="Comment">-- reduce by regularity. Needless to say, only use `fast` when you&#39;re</a>
  <a id="1871" class="Comment">-- sure that&#39;s the case (e.g. the fibres of a displayed category over</a>
  <a id="1943" class="Comment">-- Sets)</a>
  <a id="1954" class="Keyword">data</a> <a id="Regularity-precision"></a><a id="1959" href="Meta.Regularity.html#1959" class="Datatype">Regularity-precision</a> <a id="1980" class="Symbol">:</a> <a id="1982" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="1987" class="Keyword">where</a>
    <a id="Regularity-precision.precise"></a><a id="1997" href="Meta.Regularity.html#1997" class="InductiveConstructor">precise</a> <a id="Regularity-precision.fast"></a><a id="2005" href="Meta.Regularity.html#2005" class="InductiveConstructor">fast</a> <a id="2010" class="Symbol">:</a> <a id="2012" href="Meta.Regularity.html#1959" class="Datatype">Regularity-precision</a>
  <a id="2035" class="Comment">-- As the name implies, `precise` is `precise`, while `fast` is</a>
  <a id="2101" class="Comment">-- `fast`. The reason is that `fast` will avoid traversing many of the</a>
  <a id="2174" class="Comment">-- terms involved in a `transp`: It doesn&#39;t care about the level, it</a>
  <a id="2245" class="Comment">-- doesn&#39;t care about the line, and it doesn&#39;t care about the</a>
  <a id="2309" class="Comment">-- cofibration.</a>

  <a id="2328" class="Comment">-- The core of the tactic is this triad of mutually recursive</a>
  <a id="2392" class="Comment">-- functions. In all three of them, the `Nat` argument indicates how</a>
  <a id="2463" class="Comment">-- many binders we&#39;ve gone under: it is the dimension variable we</a>
  <a id="2531" class="Comment">-- abstracted over at the start.</a>
  <a id="refl-transport"></a><a id="2566" href="Meta.Regularity.html#2566" class="Function">refl-transport</a> <a id="2581" class="Symbol">:</a> <a id="2583" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2585" class="Symbol">→</a> <a id="2587" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2592" class="Symbol">→</a> <a id="2594" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2597" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2604" class="Comment">-- ^ Determines whether an application of `transp` is a case of</a>
  <a id="2670" class="Comment">-- regularity, and if so, replaces it by `regular`. Precondition: its</a>
  <a id="2742" class="Comment">-- subterms must already be reduced.</a>
  <a id="go"></a><a id="2781" href="Meta.Regularity.html#2781" class="Function">go</a>  <a id="2785" class="Symbol">:</a> <a id="2787" href="Meta.Regularity.html#1959" class="Datatype">Regularity-precision</a> <a id="2808" class="Symbol">→</a> <a id="2810" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2812" class="Symbol">→</a> <a id="2814" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2819" class="Symbol">→</a> <a id="2821" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2824" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2831" class="Comment">-- ^ Reduces all the subterms, and finds applications of `transp` to</a>
  <a id="2902" class="Comment">-- hand off to `refl-transport`.</a>
  <a id="go*"></a><a id="2937" href="Meta.Regularity.html#2937" class="Function">go*</a> <a id="2941" class="Symbol">:</a> <a id="2943" href="Meta.Regularity.html#1959" class="Datatype">Regularity-precision</a> <a id="2964" class="Symbol">→</a> <a id="2966" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2968" class="Symbol">→</a> <a id="2970" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2975" class="Symbol">(</a><a id="2976" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="2980" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="2984" class="Symbol">)</a> <a id="2986" class="Symbol">→</a> <a id="2988" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2991" class="Symbol">(</a><a id="2992" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2997" class="Symbol">(</a><a id="2998" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3002" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3006" class="Symbol">))</a>
  <a id="3011" class="Comment">-- ^ Isn&#39;t the termination checker just lovely?</a>

  <a id="3062" href="Meta.Regularity.html#2566" class="Function">refl-transport</a> <a id="3077" href="Meta.Regularity.html#3077" class="Bound">n</a> <a id="3079" href="Meta.Regularity.html#3079" class="Bound">tm</a><a id="3081" class="Symbol">@(</a><a id="3083" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3087" class="Symbol">(</a><a id="3088" class="Keyword">quote</a> <a id="3094" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3100" class="Symbol">)</a> <a id="3102" class="Symbol">(</a><a id="3103" href="Meta.Regularity.html#3103" class="Bound">ℓ</a> <a id="3105" href="Meta.Reflection.Base.html#4160" class="InductiveConstructor Operator">h∷</a> <a id="3108" href="Meta.Regularity.html#3108" class="Bound">Al</a> <a id="3111" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="3114" href="Meta.Regularity.html#3114" class="Bound">φ</a> <a id="3116" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="3119" href="Meta.Regularity.html#3119" class="Bound">x</a> <a id="3121" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="3124" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3126" class="Symbol">))</a> <a id="3129" class="Symbol">=</a>
    <a id="3135" class="Comment">-- This match might make you wonder: Can&#39;t Al be a line of</a>
    <a id="3198" class="Comment">-- functions, so that the transport will have more arguments? No:</a>
    <a id="3268" class="Comment">-- The term is in normal form.</a>
    <a id="3303" class="Symbol">(</a><a id="3304" class="Keyword">do</a>
      <a id="3313" href="Agda.Builtin.Reflection.html#11057" class="Postulate">debug-print</a> <a id="3325" class="String">&quot;tactic.regularity&quot;</a> <a id="3345" class="Number">10</a> <a id="3348" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="3350" class="String">&quot;Checking regularity of &quot;</a> <a id="3376" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3378" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="3386" href="Meta.Regularity.html#3079" class="Bound">tm</a> <a id="3389" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3391" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="3400" class="Keyword">let</a> <a id="3404" href="Meta.Regularity.html#3404" class="Bound">φ′</a> <a id="3407" class="Symbol">=</a> <a id="3409" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3413" class="Symbol">(</a><a id="3414" class="Keyword">quote</a> <a id="3420" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="3423" class="Symbol">)</a> <a id="3425" class="Symbol">(</a><a id="3426" href="Meta.Regularity.html#3114" class="Bound">φ</a> <a id="3428" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="3431" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="3435" href="Meta.Regularity.html#3077" class="Bound">n</a> <a id="3437" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="3440" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="3443" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3445" class="Symbol">)</a>
      <a id="3453" class="Keyword">let</a> <a id="3457" href="Meta.Regularity.html#3457" class="Bound">tm′</a> <a id="3461" class="Symbol">=</a> <a id="3463" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3467" class="Symbol">(</a><a id="3468" class="Keyword">quote</a> <a id="3474" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3480" class="Symbol">)</a> <a id="3482" class="Symbol">(</a><a id="3483" href="Meta.Regularity.html#3103" class="Bound">ℓ</a> <a id="3485" href="Meta.Reflection.Base.html#4160" class="InductiveConstructor Operator">h∷</a> <a id="3488" href="Meta.Regularity.html#3108" class="Bound">Al</a> <a id="3491" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="3494" href="Meta.Regularity.html#3404" class="Bound">φ′</a> <a id="3497" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="3500" href="Meta.Regularity.html#3119" class="Bound">x</a> <a id="3502" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="3505" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3507" class="Symbol">)</a>
      <a id="3515" class="Comment">-- We simply ask Agda to check that the newly constructed term `transp Al (φ ∨ i) x`</a>
      <a id="3606" class="Comment">-- is correct, i.e. that Al is constant on (i = i1).</a>
      <a id="3665" class="Comment">-- If it isn&#39;t, we backtrack and leave the term unchanged.</a>
      <a id="3730" class="Comment">-- Note that if Al itself contains constant transports, we have already processed those,</a>
      <a id="3825" class="Comment">-- so they reduce away when (i = i1).</a>
      <a id="3869" href="Agda.Builtin.Reflection.html#8914" class="Postulate">check-type</a> <a id="3880" href="Meta.Regularity.html#3457" class="Bound">tm′</a> <a id="3884" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="3892" class="Comment">-- inferType doesn&#39;t trigger the constancy check https://github.com/agda/agda/issues/6585</a>
      <a id="3988" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="3993" href="Meta.Regularity.html#3457" class="Bound">tm′</a><a id="3996" class="Symbol">)</a> <a id="3998" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a>
    <a id="4006" class="Symbol">(</a><a id="4007" class="Keyword">do</a>
      <a id="4016" href="Agda.Builtin.Reflection.html#11057" class="Postulate">debug-print</a> <a id="4028" class="String">&quot;tactic.regularity&quot;</a> <a id="4048" class="Number">10</a> <a id="4051" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="4053" class="String">&quot;NOT a (transport refl): &quot;</a> <a id="4080" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4082" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="4090" href="Meta.Regularity.html#3079" class="Bound">tm</a> <a id="4093" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4095" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="4104" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="4109" href="Meta.Regularity.html#3079" class="Bound">tm</a><a id="4111" class="Symbol">)</a>
  <a id="4115" href="Meta.Regularity.html#2566" class="CatchallClause Function">refl-transport</a><a id="4129" class="CatchallClause"> </a><a id="4130" class="CatchallClause Symbol">_</a><a id="4131" class="CatchallClause"> </a><a id="4132" href="Meta.Regularity.html#4132" class="CatchallClause Bound">tm</a> <a id="4135" class="Symbol">=</a> <a id="4137" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="4142" href="Meta.Regularity.html#4132" class="Bound">tm</a>

  <a id="4148" class="Comment">-- Boring term traversal.</a>
  <a id="4176" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4179" href="Meta.Regularity.html#4179" class="Bound">pre</a> <a id="4183" href="Meta.Regularity.html#4183" class="Bound">n</a> <a id="4185" class="Symbol">(</a><a id="4186" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4190" href="Meta.Regularity.html#4190" class="Bound">x</a> <a id="4192" href="Meta.Regularity.html#4192" class="Bound">args</a><a id="4196" class="Symbol">)</a> <a id="4198" class="Symbol">=</a> <a id="4200" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4204" href="Meta.Regularity.html#4190" class="Bound">x</a> <a id="4206" href="Meta.Idiom.html#334" class="Field Operator">&lt;$&gt;</a> <a id="4210" href="Meta.Regularity.html#2937" class="Function">go*</a> <a id="4214" href="Meta.Regularity.html#4179" class="Bound">pre</a> <a id="4218" href="Meta.Regularity.html#4183" class="Bound">n</a> <a id="4220" href="Meta.Regularity.html#4192" class="Bound">args</a>
  <a id="4227" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4230" href="Meta.Regularity.html#4230" class="Bound">pre</a> <a id="4234" href="Meta.Regularity.html#4234" class="Bound">n</a> <a id="4236" class="Symbol">(</a><a id="4237" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4241" href="Meta.Regularity.html#4241" class="Bound">c</a> <a id="4243" href="Meta.Regularity.html#4243" class="Bound">args</a><a id="4247" class="Symbol">)</a> <a id="4249" class="Symbol">=</a> <a id="4251" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4255" href="Meta.Regularity.html#4241" class="Bound">c</a> <a id="4257" href="Meta.Idiom.html#334" class="Field Operator">&lt;$&gt;</a> <a id="4261" href="Meta.Regularity.html#2937" class="Function">go*</a> <a id="4265" href="Meta.Regularity.html#4230" class="Bound">pre</a> <a id="4269" href="Meta.Regularity.html#4234" class="Bound">n</a> <a id="4271" href="Meta.Regularity.html#4243" class="Bound">args</a>
  <a id="4278" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4281" href="Meta.Regularity.html#2005" class="InductiveConstructor">fast</a> <a id="4286" href="Meta.Regularity.html#4286" class="Bound">n</a> <a id="4288" class="Symbol">(</a><a id="4289" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4293" class="Symbol">(</a><a id="4294" class="Keyword">quote</a> <a id="4300" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4306" class="Symbol">)</a> <a id="4308" class="Symbol">(</a><a id="4309" href="Meta.Regularity.html#4309" class="Bound">ℓ</a> <a id="4311" href="Meta.Reflection.Base.html#4160" class="InductiveConstructor Operator">h∷</a> <a id="4314" href="Meta.Regularity.html#4314" class="Bound">Al</a> <a id="4317" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="4320" href="Meta.Regularity.html#4320" class="Bound">φ</a> <a id="4322" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="4325" href="Meta.Regularity.html#4325" class="Bound">x</a> <a id="4327" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="4330" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4332" class="Symbol">))</a> <a id="4335" class="Symbol">=</a> <a id="4337" class="Keyword">do</a>
    <a id="4344" href="Meta.Regularity.html#4344" class="Bound">x</a> <a id="4346" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="4348" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4351" href="Meta.Regularity.html#2005" class="InductiveConstructor">fast</a> <a id="4356" href="Meta.Regularity.html#4286" class="Bound">n</a> <a id="4358" href="Meta.Regularity.html#4325" class="Bound">x</a>
    <a id="4364" class="Keyword">let</a> <a id="4368" href="Meta.Regularity.html#4368" class="Bound">φ′</a> <a id="4371" class="Symbol">=</a> <a id="4373" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4377" class="Symbol">(</a><a id="4378" class="Keyword">quote</a> <a id="4384" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="4387" class="Symbol">)</a> <a id="4389" class="Symbol">(</a><a id="4390" href="Meta.Regularity.html#4320" class="Bound">φ</a> <a id="4392" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="4395" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4399" href="Meta.Regularity.html#4286" class="Bound">n</a> <a id="4401" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4404" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="4407" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4409" class="Symbol">)</a>
    <a id="4415" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="4420" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="4422" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4426" class="Symbol">(</a><a id="4427" class="Keyword">quote</a> <a id="4433" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4439" class="Symbol">)</a> <a id="4441" class="Symbol">(</a><a id="4442" href="Meta.Regularity.html#4309" class="Bound">ℓ</a> <a id="4444" href="Meta.Reflection.Base.html#4160" class="InductiveConstructor Operator">h∷</a> <a id="4447" href="Meta.Regularity.html#4314" class="Bound">Al</a> <a id="4450" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="4453" href="Meta.Regularity.html#4368" class="Bound">φ′</a> <a id="4456" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="4459" href="Meta.Regularity.html#4344" class="Bound">x</a> <a id="4461" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="4464" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4466" class="Symbol">)</a>
  <a id="4470" href="Meta.Regularity.html#2781" class="CatchallClause Function">go</a><a id="4472" class="CatchallClause"> </a><a id="4473" href="Meta.Regularity.html#4473" class="CatchallClause Bound">pre</a><a id="4476" class="CatchallClause"> </a><a id="4477" href="Meta.Regularity.html#4477" class="CatchallClause Bound">n</a><a id="4478" class="CatchallClause"> </a><a id="4479" class="CatchallClause Symbol">(</a><a id="4480" href="Agda.Builtin.Reflection.html#5251" class="CatchallClause InductiveConstructor">def</a><a id="4483" class="CatchallClause"> </a><a id="4484" href="Meta.Regularity.html#4484" class="CatchallClause Bound">f</a><a id="4485" class="CatchallClause"> </a><a id="4486" href="Meta.Regularity.html#4486" class="CatchallClause Bound">args</a><a id="4490" class="CatchallClause Symbol">)</a> <a id="4492" class="Symbol">=</a> <a id="4494" class="Keyword">do</a>
    <a id="4501" href="Meta.Regularity.html#4501" class="Bound">as</a> <a id="4504" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="4506" href="Meta.Regularity.html#2937" class="Function">go*</a> <a id="4510" href="Meta.Regularity.html#4473" class="Bound">pre</a> <a id="4514" href="Meta.Regularity.html#4477" class="Bound">n</a> <a id="4516" href="Meta.Regularity.html#4486" class="Bound">args</a>
    <a id="4525" href="Meta.Regularity.html#2566" class="Function">refl-transport</a> <a id="4540" href="Meta.Regularity.html#4477" class="Bound">n</a> <a id="4542" class="Symbol">(</a><a id="4543" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4547" href="Meta.Regularity.html#4484" class="Bound">f</a> <a id="4549" href="Meta.Regularity.html#4501" class="Bound">as</a><a id="4551" class="Symbol">)</a>
  <a id="4555" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4558" href="Meta.Regularity.html#4558" class="Bound">pre</a> <a id="4562" href="Meta.Regularity.html#4562" class="Bound">k</a> <a id="4564" href="Meta.Regularity.html#4564" class="Bound">t</a><a id="4565" class="Symbol">@(</a><a id="4567" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4571" href="Meta.Regularity.html#4571" class="Bound">v</a> <a id="4573" class="Symbol">(</a><a id="4574" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4578" href="Meta.Regularity.html#4578" class="Bound">nm</a> <a id="4581" href="Meta.Regularity.html#4581" class="Bound">b</a><a id="4582" class="Symbol">))</a> <a id="4585" class="Symbol">=</a> <a id="4587" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4591" href="Meta.Regularity.html#4571" class="Bound">v</a> <a id="4593" href="Foundations.Pi.Base.html#1711" class="Function Operator">∘</a> <a id="4595" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4599" href="Meta.Regularity.html#4578" class="Bound">nm</a> <a id="4602" href="Meta.Idiom.html#334" class="Field Operator">&lt;$&gt;</a> <a id="4606" href="Meta.Reflection.Base.html#2977" class="Function">under-abs</a> <a id="4616" href="Meta.Regularity.html#4564" class="Bound">t</a> <a id="4618" class="Symbol">(</a><a id="4619" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4622" href="Meta.Regularity.html#4558" class="Bound">pre</a> <a id="4626" class="Symbol">(</a><a id="4627" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4631" href="Meta.Regularity.html#4562" class="Bound">k</a><a id="4632" class="Symbol">)</a> <a id="4634" href="Meta.Regularity.html#4581" class="Bound">b</a><a id="4635" class="Symbol">)</a>
  <a id="4639" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4642" href="Meta.Regularity.html#4642" class="Bound">pre</a> <a id="4646" href="Meta.Regularity.html#4646" class="Bound">n</a> <a id="4648" class="Symbol">(</a><a id="4649" href="Agda.Builtin.Reflection.html#5361" class="InductiveConstructor">pat-lam</a> <a id="4657" href="Meta.Regularity.html#4657" class="Bound">cs</a> <a id="4660" href="Meta.Regularity.html#4660" class="Bound">args</a><a id="4664" class="Symbol">)</a> <a id="4666" class="Symbol">=</a> <a id="4668" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="4679" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="4681" class="String">&quot;regularity: Can not deal with pattern lambdas&quot;</a> <a id="4729" class="Comment">-- TODO can we do something about this?</a>
  <a id="4771" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4774" href="Meta.Regularity.html#4774" class="Bound">pre</a> <a id="4778" href="Meta.Regularity.html#4778" class="Bound">n</a> <a id="4780" href="Meta.Regularity.html#4780" class="Bound">t</a><a id="4781" class="Symbol">@(</a><a id="4783" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="4786" class="Symbol">(</a><a id="4787" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="4791" href="Meta.Regularity.html#4791" class="Bound">i</a> <a id="4793" href="Meta.Regularity.html#4793" class="Bound">a</a><a id="4794" class="Symbol">)</a> <a id="4796" class="Symbol">(</a><a id="4797" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4801" href="Meta.Regularity.html#4801" class="Bound">nm</a> <a id="4804" href="Meta.Regularity.html#4804" class="Bound">b</a><a id="4805" class="Symbol">))</a> <a id="4808" class="Symbol">=</a> <a id="4810" class="Keyword">do</a>
    <a id="4817" href="Meta.Regularity.html#4817" class="Bound">a</a> <a id="4819" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="4821" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4824" href="Meta.Regularity.html#4774" class="Bound">pre</a> <a id="4828" href="Meta.Regularity.html#4778" class="Bound">n</a> <a id="4830" href="Meta.Regularity.html#4793" class="Bound">a</a>
    <a id="4836" href="Meta.Regularity.html#4836" class="Bound">b</a> <a id="4838" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="4840" href="Meta.Reflection.Base.html#2977" class="Function">under-abs</a> <a id="4850" href="Meta.Regularity.html#4780" class="Bound">t</a> <a id="4852" class="Symbol">(</a><a id="4853" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4856" href="Meta.Regularity.html#4774" class="Bound">pre</a> <a id="4860" class="Symbol">(</a><a id="4861" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4865" href="Meta.Regularity.html#4778" class="Bound">n</a><a id="4866" class="Symbol">)</a> <a id="4868" href="Meta.Regularity.html#4804" class="Bound">b</a><a id="4869" class="Symbol">)</a>
    <a id="4875" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="4880" class="Symbol">(</a><a id="4881" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="4884" class="Symbol">(</a><a id="4885" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="4889" href="Meta.Regularity.html#4791" class="Bound">i</a> <a id="4891" href="Meta.Regularity.html#4817" class="Bound">a</a><a id="4892" class="Symbol">)</a> <a id="4894" class="Symbol">(</a><a id="4895" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4899" href="Meta.Regularity.html#4801" class="Bound">nm</a> <a id="4902" href="Meta.Regularity.html#4836" class="Bound">b</a><a id="4903" class="Symbol">))</a>
  <a id="4908" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4911" href="Meta.Regularity.html#4911" class="Bound">pre</a> <a id="4915" href="Meta.Regularity.html#4915" class="Bound">n</a> <a id="4917" class="Symbol">(</a><a id="4918" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="4928" href="Meta.Regularity.html#4928" class="Bound">s</a><a id="4929" class="Symbol">)</a> <a id="4931" class="Symbol">=</a> <a id="4933" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="4938" class="Symbol">(</a><a id="4939" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="4949" href="Meta.Regularity.html#4928" class="Bound">s</a><a id="4950" class="Symbol">)</a>
  <a id="4954" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4957" href="Meta.Regularity.html#4957" class="Bound">pre</a> <a id="4961" href="Meta.Regularity.html#4961" class="Bound">n</a> <a id="4963" class="Symbol">(</a><a id="4964" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="4968" href="Meta.Regularity.html#4968" class="Bound">l</a><a id="4969" class="Symbol">)</a> <a id="4971" class="Symbol">=</a> <a id="4973" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="4978" class="Symbol">(</a><a id="4979" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="4983" href="Meta.Regularity.html#4968" class="Bound">l</a><a id="4984" class="Symbol">)</a>
  <a id="4988" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="4991" href="Meta.Regularity.html#4991" class="Bound">pre</a> <a id="4995" href="Meta.Regularity.html#4995" class="Bound">n</a> <a id="4997" class="Symbol">(</a><a id="4998" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5003" href="Meta.Regularity.html#5003" class="Bound">x</a> <a id="5005" href="Meta.Regularity.html#5005" class="Bound">args</a><a id="5009" class="Symbol">)</a> <a id="5011" class="Symbol">=</a> <a id="5013" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5018" href="Meta.Regularity.html#5003" class="Bound">x</a> <a id="5020" href="Meta.Idiom.html#334" class="Field Operator">&lt;$&gt;</a> <a id="5024" href="Meta.Regularity.html#2937" class="Function">go*</a> <a id="5028" href="Meta.Regularity.html#4991" class="Bound">pre</a> <a id="5032" href="Meta.Regularity.html#4995" class="Bound">n</a> <a id="5034" href="Meta.Regularity.html#5005" class="Bound">args</a>
  <a id="5041" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="5044" href="Meta.Regularity.html#5044" class="Bound">pre</a> <a id="5048" href="Meta.Regularity.html#5048" class="Bound">n</a> <a id="5050" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="5058" class="Symbol">=</a> <a id="5060" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="5065" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

  <a id="5076" href="Meta.Regularity.html#2937" class="Function">go*</a> <a id="5080" href="Meta.Regularity.html#5080" class="Bound">pre</a> <a id="5084" href="Meta.Regularity.html#5084" class="Bound">n</a> <a id="5086" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5089" class="Symbol">=</a> <a id="5091" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="5096" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="5101" href="Meta.Regularity.html#2937" class="Function">go*</a> <a id="5105" href="Meta.Regularity.html#5105" class="Bound">pre</a> <a id="5109" href="Meta.Regularity.html#5109" class="Bound">n</a> <a id="5111" class="Symbol">(</a><a id="5112" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5116" href="Meta.Regularity.html#5116" class="Bound">i</a> <a id="5118" href="Meta.Regularity.html#5118" class="Bound">a</a> <a id="5120" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5122" href="Meta.Regularity.html#5122" class="Bound">as</a><a id="5124" class="Symbol">)</a> <a id="5126" class="Symbol">=</a> <a id="5128" class="Keyword">do</a>
    <a id="5135" href="Meta.Regularity.html#5135" class="Bound">a</a> <a id="5137" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="5139" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="5142" href="Meta.Regularity.html#5105" class="Bound">pre</a> <a id="5146" href="Meta.Regularity.html#5109" class="Bound">n</a> <a id="5148" href="Meta.Regularity.html#5118" class="Bound">a</a>
    <a id="5154" class="Symbol">(</a><a id="5155" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5159" href="Meta.Regularity.html#5116" class="Bound">i</a> <a id="5161" href="Meta.Regularity.html#5135" class="Bound">a</a> <a id="5163" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷_</a><a id="5165" class="Symbol">)</a> <a id="5167" href="Meta.Idiom.html#334" class="Field Operator">&lt;$&gt;</a> <a id="5171" href="Meta.Regularity.html#2937" class="Function">go*</a> <a id="5175" href="Meta.Regularity.html#5105" class="Bound">pre</a> <a id="5179" href="Meta.Regularity.html#5109" class="Bound">n</a> <a id="5181" href="Meta.Regularity.html#5122" class="Bound">as</a>

  <a id="5187" class="Comment">-- To turn a term into a regularity path, given a level of precision,</a>
  <a id="5259" class="Comment">-- all we have to do is raise the term by one, do the procedure above,</a>
  <a id="5332" class="Comment">-- then wrap it in a lambda. Nice!</a>
  <a id="to-regularity-path"></a><a id="5369" href="Meta.Regularity.html#5369" class="Function">to-regularity-path</a> <a id="5388" class="Symbol">:</a> <a id="5390" href="Meta.Regularity.html#1959" class="Datatype">Regularity-precision</a> <a id="5411" class="Symbol">→</a> <a id="5413" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5418" class="Symbol">→</a> <a id="5420" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="5423" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5430" href="Meta.Regularity.html#5369" class="Function">to-regularity-path</a> <a id="5449" href="Meta.Regularity.html#5449" class="Bound">pre</a> <a id="5453" href="Meta.Regularity.html#5453" class="Bound">tm</a> <a id="5456" class="Symbol">=</a> <a id="5458" class="Keyword">do</a>
    <a id="5465" href="Meta.Regularity.html#5465" class="Bound">tm</a> <a id="5468" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="5470" href="Meta.Reflection.Subst.html#4221" class="Function">raiseTC</a> <a id="5478" class="Number">1</a> <a id="5480" href="Meta.Regularity.html#5453" class="Bound">tm</a>
    <a id="5487" class="Comment">-- Since we&#39;ll be comparing terms, Agda really wants them to be</a>
    <a id="5555" class="Comment">-- well-scoped. Since we shifted eeeverything up by one, we have to</a>
    <a id="5627" class="Comment">-- grow the context, too.</a>
    <a id="5657" href="Meta.Regularity.html#5657" class="Bound">tm</a> <a id="5660" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="5662" href="Meta.Reflection.Base.html#7263" class="Function">resetting</a> <a id="5672" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="5674" href="Agda.Builtin.Reflection.html#9277" class="Postulate">extend-context</a> <a id="5689" class="String">&quot;i&quot;</a> <a id="5693" class="Symbol">(</a><a id="5694" href="Meta.Reflection.Base.html#4332" class="Function">argN</a> <a id="5699" class="Symbol">(</a><a id="5700" class="Keyword">quoteTerm</a> <a id="5710" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="5711" class="Symbol">))</a> <a id="5714" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="5716" href="Meta.Regularity.html#2781" class="Function">go</a> <a id="5719" href="Meta.Regularity.html#5449" class="Bound">pre</a> <a id="5723" class="Number">0</a> <a id="5725" href="Meta.Regularity.html#5465" class="Bound">tm</a>
    <a id="5732" href="Meta.Idiom.html#555" class="Field">pure</a> <a id="5737" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="5739" href="Meta.Reflection.Base.html#3641" class="Function">vlam</a> <a id="5744" class="String">&quot;i&quot;</a> <a id="5748" href="Meta.Regularity.html#5657" class="Bound">tm</a>

  <a id="5754" class="Comment">-- Extend a path x ＝ y to a path x′ ＝ y′, where x′ --&gt; x and y′ --&gt; y</a>
  <a id="5826" class="Comment">-- under the given regularity precision. Shorthand for composing</a>
  <a id="5893" class="Comment">--    regularity! ∙ p ∙ sym regularity!.</a>
  <a id="regular!-worker"></a><a id="5936" href="Meta.Regularity.html#5936" class="Function">regular!-worker</a> <a id="5952" class="Symbol">:</a>
    <a id="5958" class="Symbol">∀</a> <a id="5960" class="Symbol">{</a><a id="5961" href="Meta.Regularity.html#5961" class="Bound">ℓ</a><a id="5962" class="Symbol">}</a> <a id="5964" class="Symbol">{</a><a id="5965" href="Meta.Regularity.html#5965" class="Bound">A</a> <a id="5967" class="Symbol">:</a> <a id="5969" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="5974" href="Meta.Regularity.html#5961" class="Bound">ℓ</a><a id="5975" class="Symbol">}</a> <a id="5977" class="Symbol">{</a><a id="5978" href="Meta.Regularity.html#5978" class="Bound">x</a> <a id="5980" href="Meta.Regularity.html#5980" class="Bound">y</a> <a id="5982" class="Symbol">:</a> <a id="5984" href="Meta.Regularity.html#5965" class="Bound">A</a><a id="5985" class="Symbol">}</a>
    <a id="5991" class="Symbol">→</a> <a id="5993" href="Meta.Regularity.html#1959" class="Datatype">Regularity-precision</a>
    <a id="6018" class="Symbol">→</a> <a id="6020" href="Meta.Regularity.html#5978" class="Bound">x</a> <a id="6022" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="6024" href="Meta.Regularity.html#5980" class="Bound">y</a>
    <a id="6030" class="Symbol">→</a> <a id="6032" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="6041" class="Symbol">→</a> <a id="6043" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="6046" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="6050" href="Meta.Regularity.html#5936" class="Function">regular!-worker</a> <a id="6066" class="Symbol">{</a><a id="6067" class="Argument">x</a> <a id="6069" class="Symbol">=</a> <a id="6071" href="Meta.Regularity.html#6071" class="Bound">x</a><a id="6072" class="Symbol">}</a> <a id="6074" class="Symbol">{</a><a id="6075" href="Meta.Regularity.html#6075" class="Bound">y</a><a id="6076" class="Symbol">}</a> <a id="6078" href="Meta.Regularity.html#6078" class="Bound">pre</a> <a id="6082" href="Meta.Regularity.html#6082" class="Bound">p</a> <a id="6084" href="Meta.Regularity.html#6084" class="Bound">goal</a> <a id="6089" class="Symbol">=</a> <a id="6091" class="Keyword">do</a>
    <a id="6098" href="Meta.Regularity.html#6098" class="Bound">gt</a> <a id="6101" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6103" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6114" href="Meta.Regularity.html#6084" class="Bound">goal</a>
    <a id="6123" href="Meta.Regularity.html#6123" class="Bound">`x</a> <a id="6126" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6128" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6136" href="Meta.Regularity.html#6071" class="Bound">x</a>
    <a id="6142" href="Meta.Regularity.html#6142" class="Bound">`y</a> <a id="6145" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6147" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6155" href="Meta.Regularity.html#6075" class="Bound">y</a>
    <a id="6161" href="Meta.Regularity.html#6161" class="Bound">`p</a> <a id="6164" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6166" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="6174" href="Meta.Regularity.html#6082" class="Bound">p</a>
    <a id="6180" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6185" class="Symbol">(_</a> <a id="6188" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6190" href="Meta.Regularity.html#6190" class="Bound">l</a> <a id="6192" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6194" href="Meta.Regularity.html#6194" class="Bound">r</a><a id="6195" class="Symbol">)</a> <a id="6197" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6199" href="Meta.Reflection.Base.html#8221" class="Function">unapply-path</a> <a id="6212" href="Meta.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6216" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6227" href="Meta.Regularity.html#6084" class="Bound">goal</a>
      <a id="6238" class="Keyword">where</a> <a id="6244" class="CatchallClause Symbol">_</a> <a id="6246" class="Symbol">→</a> <a id="6248" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="6259" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="6266" href="Meta.Regularity.html#6266" class="Bound">l</a> <a id="6268" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6270" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6280" href="Meta.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6284" href="Meta.Reflection.Base.html#7392" class="Function">wait-for-type</a> <a id="6298" href="Meta.Regularity.html#6190" class="Bound">l</a>
    <a id="6304" href="Meta.Regularity.html#6304" class="Bound">r</a> <a id="6306" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6308" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6318" href="Meta.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6322" href="Meta.Reflection.Base.html#7392" class="Function">wait-for-type</a> <a id="6336" href="Meta.Regularity.html#6194" class="Bound">r</a>
    <a id="6342" href="Meta.Regularity.html#6342" class="Bound">reg</a> <a id="6346" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6348" href="Meta.Regularity.html#5369" class="Function">to-regularity-path</a> <a id="6367" href="Meta.Regularity.html#6078" class="Bound">pre</a> <a id="6371" href="Meta.Regularity.html#6266" class="Bound">l</a>
    <a id="6377" href="Meta.Regularity.html#6377" class="Bound">reg′</a> <a id="6382" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6384" href="Meta.Regularity.html#5369" class="Function">to-regularity-path</a> <a id="6403" href="Meta.Regularity.html#6078" class="Bound">pre</a> <a id="6407" href="Meta.Regularity.html#6304" class="Bound">r</a>
    <a id="6413" href="Meta.Reflection.Base.html#10094" class="Function">unify-loudly</a> <a id="6426" href="Meta.Regularity.html#6084" class="Bound">goal</a> <a id="6431" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="6433" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6437" class="Symbol">(</a><a id="6438" class="Keyword">quote</a> <a id="6444" href="Meta.Regularity.html#1323" class="Function">double-comp</a><a id="6455" class="Symbol">)</a> <a id="6457" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a>
         <a id="6468" href="Meta.Regularity.html#6123" class="Bound">`x</a> <a id="6471" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="6474" href="Meta.Regularity.html#6142" class="Bound">`y</a> <a id="6477" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="6480" href="Meta.Regularity.html#6342" class="Bound">reg</a>
      <a id="6490" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="6493" href="Meta.Regularity.html#6161" class="Bound">`p</a>
      <a id="6502" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="6505" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6509" class="Symbol">(</a><a id="6510" class="Keyword">quote</a> <a id="6516" href="Foundations.Prim.Kan.html#1519" class="Function">sym</a><a id="6519" class="Symbol">)</a> <a id="6521" class="Symbol">(</a><a id="6522" href="Meta.Regularity.html#6377" class="Bound">reg′</a> <a id="6527" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="6530" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6532" class="Symbol">)</a>
      <a id="6540" href="Meta.Reflection.Base.html#4128" class="InductiveConstructor Operator">v∷</a> <a id="6543" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="6547" class="Keyword">module</a> <a id="Regularity"></a><a id="6554" href="Meta.Regularity.html#6554" class="Module">Regularity</a> <a id="6565" class="Keyword">where</a>
  <a id="6573" class="Keyword">open</a> <a id="6578" href="Meta.Regularity.html#1959" class="Module">Regularity-precision</a> <a id="6599" class="Keyword">public</a>
  <a id="6608" class="Comment">-- The reflection interface: Regularity.reduce! will, well, reduce a</a>
  <a id="6679" class="Comment">-- term. There&#39;s a lot of blocking involved in making this work.</a>
  <a id="6746" class="Keyword">macro</a>
    <a id="Regularity.reduce!"></a><a id="6756" href="Meta.Regularity.html#6756" class="Function">reduce!</a> <a id="6764" class="Symbol">:</a> <a id="6766" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6771" class="Symbol">→</a> <a id="6773" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="6776" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="6782" href="Meta.Regularity.html#6756" class="Function">reduce!</a> <a id="6790" href="Meta.Regularity.html#6790" class="Bound">goal</a> <a id="6795" class="Symbol">=</a> <a id="6797" class="Keyword">do</a>
      <a id="6806" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6811" class="Symbol">(_</a> <a id="6814" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6816" href="Meta.Regularity.html#6816" class="Bound">l</a> <a id="6818" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6820" href="Meta.Regularity.html#6820" class="Bound">r</a><a id="6821" class="Symbol">)</a> <a id="6823" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6825" href="Meta.Reflection.Base.html#8221" class="Function">unapply-path</a> <a id="6838" href="Meta.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6842" href="Agda.Builtin.Reflection.html#8878" class="Postulate">infer-type</a> <a id="6853" href="Meta.Regularity.html#6790" class="Bound">goal</a>
        <a id="6866" class="Keyword">where</a> <a id="6872" class="CatchallClause Symbol">_</a> <a id="6874" class="Symbol">→</a> <a id="6876" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a> <a id="6887" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="6896" href="Meta.Regularity.html#6896" class="Bound">reg</a> <a id="6900" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6902" href="Meta.Regularity.html#5369" class="Function">to-regularity-path</a> <a id="6921" href="Meta.Regularity.html#1997" class="InductiveConstructor">precise</a> <a id="6929" href="Meta.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6933" class="Symbol">(</a><a id="6934" href="Meta.Reflection.Base.html#7392" class="Function">wait-for-type</a> <a id="6948" href="Meta.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="6952" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="6962" href="Meta.Regularity.html#6816" class="Bound">l</a><a id="6963" class="Symbol">)</a>
      <a id="6971" href="Meta.Reflection.Base.html#10094" class="Function">unify-loudly</a> <a id="6984" href="Meta.Regularity.html#6790" class="Bound">goal</a> <a id="6989" href="Meta.Regularity.html#6896" class="Bound">reg</a>

    <a id="6998" class="Comment">-- We then have wrappers that reduce on one side, and expand on the</a>
    <a id="7070" class="Comment">-- other, depending on how precise you want the reduction to be.</a>
    <a id="Regularity.precise!"></a><a id="7139" href="Meta.Regularity.html#7139" class="Function">precise!</a> <a id="7148" class="Symbol">:</a> <a id="7150" class="Symbol">∀</a> <a id="7152" class="Symbol">{</a><a id="7153" href="Meta.Regularity.html#7153" class="Bound">ℓ</a><a id="7154" class="Symbol">}</a> <a id="7156" class="Symbol">{</a><a id="7157" href="Meta.Regularity.html#7157" class="Bound">A</a> <a id="7159" class="Symbol">:</a> <a id="7161" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="7166" href="Meta.Regularity.html#7153" class="Bound">ℓ</a><a id="7167" class="Symbol">}</a> <a id="7169" class="Symbol">{</a><a id="7170" href="Meta.Regularity.html#7170" class="Bound">x</a> <a id="7172" href="Meta.Regularity.html#7172" class="Bound">y</a> <a id="7174" class="Symbol">:</a> <a id="7176" href="Meta.Regularity.html#7157" class="Bound">A</a><a id="7177" class="Symbol">}</a> <a id="7179" class="Symbol">→</a> <a id="7181" href="Meta.Regularity.html#7170" class="Bound">x</a> <a id="7183" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="7185" href="Meta.Regularity.html#7172" class="Bound">y</a> <a id="7187" class="Symbol">→</a> <a id="7189" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7194" class="Symbol">→</a> <a id="7196" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7199" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="Regularity.fast!"></a><a id="7205" href="Meta.Regularity.html#7205" class="Function">fast!</a> <a id="7211" class="Symbol">:</a> <a id="7213" class="Symbol">∀</a> <a id="7215" class="Symbol">{</a><a id="7216" href="Meta.Regularity.html#7216" class="Bound">ℓ</a><a id="7217" class="Symbol">}</a> <a id="7219" class="Symbol">{</a><a id="7220" href="Meta.Regularity.html#7220" class="Bound">A</a> <a id="7222" class="Symbol">:</a> <a id="7224" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="7229" href="Meta.Regularity.html#7216" class="Bound">ℓ</a><a id="7230" class="Symbol">}</a> <a id="7232" class="Symbol">{</a><a id="7233" href="Meta.Regularity.html#7233" class="Bound">x</a> <a id="7235" href="Meta.Regularity.html#7235" class="Bound">y</a> <a id="7237" class="Symbol">:</a> <a id="7239" href="Meta.Regularity.html#7220" class="Bound">A</a><a id="7240" class="Symbol">}</a> <a id="7242" class="Symbol">→</a> <a id="7244" href="Meta.Regularity.html#7233" class="Bound">x</a> <a id="7246" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="7248" href="Meta.Regularity.html#7235" class="Bound">y</a> <a id="7250" class="Symbol">→</a> <a id="7252" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7257" class="Symbol">→</a> <a id="7259" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7262" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="7269" href="Meta.Regularity.html#7139" class="Function">precise!</a> <a id="7278" href="Meta.Regularity.html#7278" class="Bound">p</a> <a id="7280" href="Meta.Regularity.html#7280" class="Bound">goal</a> <a id="7285" class="Symbol">=</a> <a id="7287" href="Meta.Regularity.html#5936" class="Function">regular!-worker</a> <a id="7303" href="Meta.Regularity.html#1997" class="InductiveConstructor">precise</a> <a id="7311" href="Meta.Regularity.html#7278" class="Bound">p</a> <a id="7313" href="Meta.Regularity.html#7280" class="Bound">goal</a>
    <a id="7322" href="Meta.Regularity.html#7205" class="Function">fast!</a> <a id="7328" href="Meta.Regularity.html#7328" class="Bound">p</a> <a id="7330" href="Meta.Regularity.html#7330" class="Bound">goal</a> <a id="7335" class="Symbol">=</a> <a id="7337" href="Meta.Regularity.html#5936" class="Function">regular!-worker</a> <a id="7353" href="Meta.Regularity.html#2005" class="InductiveConstructor">fast</a> <a id="7358" href="Meta.Regularity.html#7328" class="Bound">p</a> <a id="7360" href="Meta.Regularity.html#7330" class="Bound">goal</a>

    <a id="7370" class="Comment">-- For debugging purposes, this macro will take a term and output</a>
    <a id="7440" class="Comment">-- its (transport refl)-normal form, according to the given level of</a>
    <a id="7513" class="Comment">-- precision.</a>
    <a id="Regularity.reduct"></a><a id="7531" href="Meta.Regularity.html#7531" class="Function">reduct</a> <a id="7538" class="Symbol">:</a> <a id="7540" href="Meta.Regularity.html#1959" class="Datatype">Regularity-precision</a> <a id="7561" class="Symbol">→</a> <a id="7563" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7568" class="Symbol">→</a> <a id="7570" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7575" class="Symbol">→</a> <a id="7577" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7580" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="7586" href="Meta.Regularity.html#7531" class="Function">reduct</a> <a id="7593" href="Meta.Regularity.html#7593" class="Bound">pres</a> <a id="7598" href="Meta.Regularity.html#7598" class="Bound">tm</a> <a id="7601" class="Symbol">_</a> <a id="7603" class="Symbol">=</a> <a id="7605" class="Keyword">do</a>
      <a id="7614" href="Meta.Regularity.html#7614" class="Bound">orig</a> <a id="7619" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7621" href="Meta.Reflection.Base.html#7392" class="Function">wait-for-type</a> <a id="7635" href="Meta.Bind.html#393" class="Function Operator">=&lt;&lt;</a> <a id="7639" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="7649" href="Meta.Regularity.html#7598" class="Bound">tm</a>
      <a id="7658" href="Meta.Regularity.html#7658" class="Bound">tm</a> <a id="7661" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7663" href="Meta.Regularity.html#5369" class="Function">to-regularity-path</a> <a id="7682" href="Meta.Regularity.html#7593" class="Bound">pres</a> <a id="7687" href="Meta.Regularity.html#7614" class="Bound">orig</a>
      <a id="7698" href="Meta.Regularity.html#7698" class="Bound">red</a> <a id="7702" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7704" href="Meta.Reflection.Subst.html#4556" class="Function">applyTC</a> <a id="7712" href="Meta.Regularity.html#7658" class="Bound">tm</a> <a id="7715" class="Symbol">(</a><a id="7716" href="Meta.Reflection.Base.html#4332" class="Function">argN</a> <a id="7721" class="Symbol">(</a><a id="7722" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="7726" class="Symbol">(</a><a id="7727" class="Keyword">quote</a> <a id="7733" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="7735" class="Symbol">)</a> <a id="7737" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7739" class="Symbol">))</a> <a id="7742" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="7746" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a>
      <a id="7762" href="Meta.Regularity.html#7762" class="Bound">`pres</a> <a id="7768" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7770" href="Agda.Builtin.Reflection.html#9089" class="Postulate">quoteTC</a> <a id="7778" href="Meta.Regularity.html#7593" class="Bound">pres</a>
      <a id="7789" href="Agda.Builtin.Reflection.html#8815" class="Postulate">type-error</a>
        <a id="7808" href="Meta.Literals.FromProduct.html#346" class="Function Operator">[</a> <a id="7810" class="String">&quot;The term\n\n  &quot;</a> <a id="7827" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7829" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="7837" href="Meta.Regularity.html#7614" class="Bound">orig</a> <a id="7842" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7844" class="String">&quot;\n\nreduces modulo &quot;</a>
        <a id="7874" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7876" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="7884" href="Meta.Regularity.html#7762" class="Bound">`pres</a> <a id="7890" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7892" class="String">&quot; regularity to\n\n  &quot;</a>
        <a id="7923" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7925" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="7933" href="Meta.Regularity.html#7698" class="Bound">red</a> <a id="7937" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7939" class="String">&quot;\n&quot;</a> <a id="7944" href="Meta.Literals.FromProduct.html#346" class="Function Operator">]</a>

<a id="7947" class="Comment">-- Test cases.</a>
<a id="7962" class="Keyword">module</a>
  <a id="7971" href="Meta.Regularity.html#7971" class="Module">_</a> <a id="7973" class="Symbol">{</a><a id="7974" href="Meta.Regularity.html#7974" class="Bound">ℓ</a> <a id="7976" href="Meta.Regularity.html#7976" class="Bound">ℓ′</a><a id="7978" class="Symbol">}</a> <a id="7980" class="Symbol">{</a><a id="7981" href="Meta.Regularity.html#7981" class="Bound">A</a> <a id="7983" class="Symbol">:</a> <a id="7985" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="7990" href="Meta.Regularity.html#7974" class="Bound">ℓ</a><a id="7991" class="Symbol">}</a> <a id="7993" class="Symbol">{</a><a id="7994" href="Meta.Regularity.html#7994" class="Bound">B</a> <a id="7996" class="Symbol">:</a> <a id="7998" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="8003" href="Meta.Regularity.html#7976" class="Bound">ℓ′</a><a id="8005" class="Symbol">}</a> <a id="8007" class="Symbol">(</a><a id="8008" href="Meta.Regularity.html#8008" class="Bound">f</a> <a id="8010" href="Meta.Regularity.html#8010" class="Bound">g</a> <a id="8012" class="Symbol">:</a> <a id="8014" href="Meta.Regularity.html#7981" class="Bound">A</a> <a id="8016" class="Symbol">→</a> <a id="8018" href="Meta.Regularity.html#7994" class="Bound">B</a><a id="8019" class="Symbol">)</a> <a id="8021" class="Symbol">(</a><a id="8022" href="Meta.Regularity.html#8022" class="Bound">x</a> <a id="8024" class="Symbol">:</a> <a id="8026" href="Meta.Regularity.html#7981" class="Bound">A</a><a id="8027" class="Symbol">)</a>
    <a id="8033" class="Symbol">(</a><a id="8034" href="Meta.Regularity.html#8034" class="Bound">a-loop</a> <a id="8041" class="Symbol">:</a> <a id="8043" class="Symbol">(</a><a id="8044" href="Meta.Regularity.html#8044" class="Bound">i</a> <a id="8046" class="Symbol">:</a> <a id="8048" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="8049" class="Symbol">)</a> <a id="8051" class="Symbol">→</a> <a id="8053" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="8058" href="Meta.Regularity.html#7974" class="Bound">ℓ</a> <a id="8060" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">[</a> <a id="8062" class="Symbol">(</a><a id="8063" href="Meta.Regularity.html#8044" class="Bound">i</a> <a id="8065" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">∨</a> <a id="8067" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="8069" href="Meta.Regularity.html#8044" class="Bound">i</a><a id="8070" class="Symbol">)</a> <a id="8072" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">↦</a> <a id="8074" class="Symbol">(λ</a> <a id="8077" class="Symbol">.</a><a id="8078" href="Meta.Regularity.html#8078" class="Bound">_</a> <a id="8080" class="Symbol">→</a> <a id="8082" href="Meta.Regularity.html#7981" class="Bound">A</a><a id="8083" class="Symbol">)</a> <a id="8085" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">]</a><a id="8086" class="Symbol">)</a>
  <a id="8090" class="Keyword">where</a> <a id="8096" class="Keyword">private</a>

  <a id="8107" href="Meta.Regularity.html#8107" class="Function">p</a> <a id="8109" class="Symbol">:</a> <a id="8111" class="Symbol">(</a><a id="8112" href="Meta.Regularity.html#8112" class="Bound">h</a> <a id="8114" class="Symbol">:</a> <a id="8116" class="Symbol">∀</a> <a id="8118" href="Meta.Regularity.html#8118" class="Bound">x</a> <a id="8120" class="Symbol">→</a> <a id="8122" href="Meta.Regularity.html#8008" class="Bound">f</a> <a id="8124" href="Meta.Regularity.html#8118" class="Bound">x</a> <a id="8126" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="8128" href="Meta.Regularity.html#8010" class="Bound">g</a> <a id="8130" href="Meta.Regularity.html#8118" class="Bound">x</a><a id="8131" class="Symbol">)</a>
    <a id="8137" class="Symbol">→</a> <a id="8139" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8149" class="Symbol">(λ</a> <a id="8152" href="Meta.Regularity.html#8152" class="Bound">i</a> <a id="8154" class="Symbol">→</a> <a id="8156" href="Meta.Regularity.html#7981" class="Bound">A</a> <a id="8158" class="Symbol">→</a> <a id="8160" href="Meta.Regularity.html#7994" class="Bound">B</a><a id="8161" class="Symbol">)</a>
        <a id="8171" class="Symbol">(λ</a> <a id="8174" href="Meta.Regularity.html#8174" class="Bound">x</a> <a id="8176" class="Symbol">→</a> <a id="8178" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8188" href="Foundations.Prim.Kan.html#1476" class="Function">refl</a> <a id="8193" class="Symbol">(</a><a id="8194" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8204" href="Foundations.Prim.Kan.html#1476" class="Function">refl</a> <a id="8209" class="Symbol">(</a><a id="8210" href="Meta.Regularity.html#8008" class="Bound">f</a> <a id="8212" class="Symbol">(</a><a id="8213" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8223" href="Foundations.Prim.Kan.html#1476" class="Function">refl</a> <a id="8228" href="Meta.Regularity.html#8174" class="Bound">x</a><a id="8229" class="Symbol">))))</a> <a id="8234" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="8236" href="Meta.Regularity.html#8010" class="Bound">g</a>
  <a id="8240" href="Meta.Regularity.html#8107" class="Function">p</a> <a id="8242" href="Meta.Regularity.html#8242" class="Bound">h</a> <a id="8244" class="Symbol">=</a> <a id="8246" href="Meta.Regularity.html#6756" class="Macro">Regularity.reduce!</a> <a id="8265" href="Foundations.Base.html#5726" class="Function Operator">∙</a> <a id="8267" href="Foundations.Base.html#10985" class="Function">fun-ext</a> <a id="8275" href="Meta.Regularity.html#8242" class="Bound">h</a>

  <a id="8280" href="Meta.Regularity.html#8280" class="Function">q</a> <a id="8282" class="Symbol">:</a> <a id="8284" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8294" href="Foundations.Prim.Kan.html#1476" class="Function">refl</a> <a id="8299" class="Symbol">(</a><a id="8300" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8307" class="Symbol">(λ</a> <a id="8310" href="Meta.Regularity.html#8310" class="Bound">i</a> <a id="8312" class="Symbol">→</a> <a id="8314" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8319" class="Symbol">(</a><a id="8320" href="Meta.Regularity.html#8034" class="Bound">a-loop</a> <a id="8327" href="Meta.Regularity.html#8310" class="Bound">i</a><a id="8328" class="Symbol">))</a> <a id="8331" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8334" href="Meta.Regularity.html#8022" class="Bound">x</a><a id="8335" class="Symbol">)</a> <a id="8337" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="8339" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8346" class="Symbol">(λ</a> <a id="8349" href="Meta.Regularity.html#8349" class="Bound">i</a> <a id="8351" class="Symbol">→</a> <a id="8353" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8358" class="Symbol">(</a><a id="8359" href="Meta.Regularity.html#8034" class="Bound">a-loop</a> <a id="8366" href="Meta.Regularity.html#8349" class="Bound">i</a><a id="8367" class="Symbol">))</a> <a id="8370" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8373" href="Meta.Regularity.html#8022" class="Bound">x</a>
  <a id="8377" href="Meta.Regularity.html#8280" class="Function">q</a> <a id="8379" class="Symbol">=</a> <a id="8381" href="Meta.Regularity.html#6756" class="Macro">Regularity.reduce!</a>

  <a id="8403" class="Comment">-- Imprecise/fast reduction: According to it, the normal form of the</a>
  <a id="8474" class="Comment">-- transport below is refl. That&#39;s.. not the case, at least we don&#39;t</a>
  <a id="8545" class="Comment">-- know so. Precise regularity handles it, though.</a>
  <a id="8598" class="Comment">-- q′ : ⊤</a>
  <a id="8610" class="Comment">-- q′ = {! Regularity.reduct Regularity.fast (transp (λ i → outS (a-loop i)) i0 x) !}</a>

  <a id="8699" href="Meta.Regularity.html#8699" class="Function">r</a> <a id="8701" class="Symbol">:</a> <a id="8703" class="Symbol">(</a><a id="8704" href="Meta.Regularity.html#8704" class="Bound">h</a> <a id="8706" class="Symbol">:</a> <a id="8708" class="Symbol">∀</a> <a id="8710" href="Meta.Regularity.html#8710" class="Bound">x</a> <a id="8712" class="Symbol">→</a> <a id="8714" href="Meta.Regularity.html#8008" class="Bound">f</a> <a id="8716" href="Meta.Regularity.html#8710" class="Bound">x</a> <a id="8718" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="8720" href="Meta.Regularity.html#8010" class="Bound">g</a> <a id="8722" href="Meta.Regularity.html#8710" class="Bound">x</a><a id="8723" class="Symbol">)</a> <a id="8725" class="Symbol">→</a> <a id="8727" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8737" href="Foundations.Prim.Kan.html#1476" class="Function">refl</a> <a id="8742" class="Symbol">(</a><a id="8743" href="Meta.Regularity.html#8008" class="Bound">f</a> <a id="8745" href="Meta.Regularity.html#8022" class="Bound">x</a><a id="8746" class="Symbol">)</a> <a id="8748" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="8750" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8760" href="Foundations.Prim.Kan.html#1476" class="Function">refl</a> <a id="8765" class="Symbol">(</a><a id="8766" href="Meta.Regularity.html#8010" class="Bound">g</a> <a id="8768" href="Meta.Regularity.html#8022" class="Bound">x</a><a id="8769" class="Symbol">)</a>
  <a id="8773" href="Meta.Regularity.html#8699" class="Function">r</a> <a id="8775" href="Meta.Regularity.html#8775" class="Bound">h</a> <a id="8777" class="Symbol">=</a> <a id="8779" href="Meta.Regularity.html#7139" class="Macro">Regularity.precise!</a> <a id="8799" class="Symbol">(</a><a id="8800" href="Meta.Regularity.html#8775" class="Bound">h</a> <a id="8802" href="Meta.Regularity.html#8022" class="Bound">x</a><a id="8803" class="Symbol">)</a>

  <a id="8808" href="Meta.Regularity.html#8808" class="Function">s</a> <a id="8810" class="Symbol">:</a> <a id="8812" class="Symbol">(</a><a id="8813" href="Meta.Regularity.html#8813" class="Bound">h</a> <a id="8815" class="Symbol">:</a> <a id="8817" class="Symbol">∀</a> <a id="8819" href="Meta.Regularity.html#8819" class="Bound">x</a> <a id="8821" class="Symbol">→</a> <a id="8823" href="Meta.Regularity.html#8008" class="Bound">f</a> <a id="8825" href="Meta.Regularity.html#8819" class="Bound">x</a> <a id="8827" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="8829" href="Meta.Regularity.html#8010" class="Bound">g</a> <a id="8831" href="Meta.Regularity.html#8819" class="Bound">x</a><a id="8832" class="Symbol">)</a> <a id="8834" class="Symbol">→</a> <a id="8836" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8846" href="Foundations.Prim.Kan.html#1476" class="Function">refl</a> <a id="8851" class="Symbol">(</a><a id="8852" href="Meta.Regularity.html#8010" class="Bound">g</a> <a id="8854" href="Meta.Regularity.html#8022" class="Bound">x</a><a id="8855" class="Symbol">)</a> <a id="8857" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="8859" href="Foundations.Prim.Kan.html#1735" class="Function">transport</a> <a id="8869" href="Foundations.Prim.Kan.html#1476" class="Function">refl</a> <a id="8874" class="Symbol">(</a><a id="8875" href="Meta.Regularity.html#8008" class="Bound">f</a> <a id="8877" href="Meta.Regularity.html#8022" class="Bound">x</a><a id="8878" class="Symbol">)</a>
  <a id="8882" href="Meta.Regularity.html#8808" class="Function">s</a> <a id="8884" href="Meta.Regularity.html#8884" class="Bound">h</a> <a id="8886" class="Symbol">=</a> <a id="8888" href="Foundations.Prim.Kan.html#1519" class="Function">sym</a> <a id="8892" href="Foundations.Pi.Base.html#1524" class="Function Operator">$</a> <a id="8894" href="Meta.Regularity.html#7205" class="Macro">Regularity.fast!</a> <a id="8911" class="Symbol">(</a><a id="8912" href="Meta.Regularity.html#8884" class="Bound">h</a> <a id="8914" href="Meta.Regularity.html#8022" class="Bound">x</a><a id="8915" class="Symbol">)</a>
</pre></body></html>