<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Regularity</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Pragma">--no-exact-split</a> <a id="37" class="Symbol">#-}</a>
<a id="41" class="Keyword">module</a> <a id="48" href="Meta.Regularity.html" class="Module">Meta.Regularity</a> <a id="64" class="Keyword">where</a>

<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="Meta.Prelude.html" class="Module">Meta.Prelude</a>
<a id="96" class="Keyword">open</a> <a id="101" class="Keyword">import</a> <a id="108" href="Meta.Effect.html" class="Module">Meta.Effect</a>
<a id="120" class="Keyword">open</a> <a id="125" class="Keyword">import</a> <a id="132" href="Meta.Reflection.Base.html" class="Module">Meta.Reflection.Base</a>
<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Meta.Reflection.Subst.html" class="Module">Meta.Reflection.Subst</a>

<a id="188" class="Keyword">open</a> <a id="193" class="Keyword">import</a> <a id="200" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="215" class="Keyword">open</a> <a id="220" class="Keyword">import</a> <a id="227" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="242" class="Keyword">open</a> <a id="247" class="Keyword">import</a> <a id="254" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="286" class="Keyword">open</a> <a id="291" class="Keyword">import</a> <a id="298" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="314" class="Keyword">open</a> <a id="319" class="Keyword">import</a> <a id="326" href="Data.Maybe.Instances.Alt.html" class="Module">Data.Maybe.Instances.Alt</a>
<a id="351" class="Keyword">open</a> <a id="356" class="Keyword">import</a> <a id="363" href="Data.Reflection.Abs.html" class="Module">Data.Reflection.Abs</a>
<a id="383" class="Keyword">open</a> <a id="388" class="Keyword">import</a> <a id="395" href="Data.Reflection.Argument.html" class="Module">Data.Reflection.Argument</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Reflection.Error.html" class="Module">Data.Reflection.Error</a>
<a id="454" class="Keyword">open</a> <a id="459" class="Keyword">import</a> <a id="466" href="Data.Reflection.Fixity.html" class="Module">Data.Reflection.Fixity</a>
<a id="489" class="Keyword">open</a> <a id="494" class="Keyword">import</a> <a id="501" href="Data.Reflection.Instances.FromString.html" class="Module">Data.Reflection.Instances.FromString</a>
<a id="538" class="Keyword">open</a> <a id="543" class="Keyword">import</a> <a id="550" href="Data.Reflection.Literal.html" class="Module">Data.Reflection.Literal</a>
<a id="574" class="Keyword">open</a> <a id="579" class="Keyword">import</a> <a id="586" href="Data.Reflection.Meta.html" class="Module">Data.Reflection.Meta</a>
<a id="607" class="Keyword">open</a> <a id="612" class="Keyword">import</a> <a id="619" href="Data.Reflection.Name.html" class="Module">Data.Reflection.Name</a>
<a id="640" class="Keyword">open</a> <a id="645" class="Keyword">import</a> <a id="652" href="Data.Reflection.Term.html" class="Module">Data.Reflection.Term</a>
<a id="673" class="Keyword">open</a> <a id="678" class="Keyword">import</a> <a id="685" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>


<a id="702" class="Comment">{-
A tactic for reducing &quot;transport refl x&quot; in other-wise normal terms. The
implementation is actually surprisingly simple: A term of the form (e.g.)

    transp (λ _ → A) i0 (f (transp (λ _ → B) i0 x))

is already a blueprint for how to normalise it. We simply have to turn it into

    λ i → transp (λ _ → A) i (f (transp (λ _ → B) i x))

so that the constant transports reduce away when (i = i1). Abstracting over i,
this gives a path from the initial term to its &quot;regular normal form&quot;, which
may be the worst name ever.

More generally, we replace terms of the form `transp Al φ x` with `transp Al (φ ∨ i) x`
recursively (inside-out), on the condition that Al is constant when i = i1.
-}</a>

<a id="1395" class="Keyword">private</a>
  <a id="1405" class="Keyword">open</a> <a id="1410" class="Keyword">import</a> <a id="1417" href="Agda.Primitive.Cubical.html" class="Module">Agda.Primitive.Cubical</a> <a id="1440" class="Keyword">using</a> <a id="1446" class="Symbol">(</a> <a id="1448" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a> <a id="1458" class="Symbol">)</a>
  <a id="1462" class="Comment">-- We have a double composition operator that doesn&#39;t use the</a>
  <a id="1526" class="Comment">-- fancy hcomp syntax in its definition. This has better type</a>
  <a id="1590" class="Comment">-- inference for one of the macros since it guarantees that the base</a>
  <a id="1661" class="Comment">-- (q i) is independent of j without any reduction.</a>
  <a id="double-comp"></a><a id="1715" href="Meta.Regularity.html#1715" class="Function">double-comp</a>
    <a id="1731" class="Symbol">:</a> <a id="1733" class="Symbol">∀</a> <a id="1735" class="Symbol">{</a><a id="1736" href="Meta.Regularity.html#1736" class="Bound">ℓ</a><a id="1737" class="Symbol">}</a> <a id="1739" class="Symbol">{</a><a id="1740" href="Meta.Regularity.html#1740" class="Bound">A</a> <a id="1742" class="Symbol">:</a> <a id="1744" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="1749" href="Meta.Regularity.html#1736" class="Bound">ℓ</a><a id="1750" class="Symbol">}</a> <a id="1752" class="Symbol">{</a><a id="1753" href="Meta.Regularity.html#1753" class="Bound">w</a> <a id="1755" href="Meta.Regularity.html#1755" class="Bound">z</a> <a id="1757" class="Symbol">:</a> <a id="1759" href="Meta.Regularity.html#1740" class="Bound">A</a><a id="1760" class="Symbol">}</a> <a id="1762" class="Symbol">(</a><a id="1763" href="Meta.Regularity.html#1763" class="Bound">x</a> <a id="1765" href="Meta.Regularity.html#1765" class="Bound">y</a> <a id="1767" class="Symbol">:</a> <a id="1769" href="Meta.Regularity.html#1740" class="Bound">A</a><a id="1770" class="Symbol">)</a>
    <a id="1776" class="Symbol">→</a> <a id="1778" href="Meta.Regularity.html#1753" class="Bound">w</a> <a id="1780" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1782" href="Meta.Regularity.html#1763" class="Bound">x</a> <a id="1784" class="Symbol">→</a> <a id="1786" href="Meta.Regularity.html#1763" class="Bound">x</a> <a id="1788" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1790" href="Meta.Regularity.html#1765" class="Bound">y</a> <a id="1792" class="Symbol">→</a> <a id="1794" href="Meta.Regularity.html#1765" class="Bound">y</a> <a id="1796" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1798" href="Meta.Regularity.html#1755" class="Bound">z</a>
    <a id="1804" class="Symbol">→</a> <a id="1806" href="Meta.Regularity.html#1753" class="Bound">w</a> <a id="1808" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1810" href="Meta.Regularity.html#1755" class="Bound">z</a>
  <a id="1814" href="Meta.Regularity.html#1715" class="Function">double-comp</a> <a id="1826" href="Meta.Regularity.html#1826" class="Bound">x</a> <a id="1828" href="Meta.Regularity.html#1828" class="Bound">y</a> <a id="1830" href="Meta.Regularity.html#1830" class="Bound">p</a> <a id="1832" href="Meta.Regularity.html#1832" class="Bound">q</a> <a id="1834" href="Meta.Regularity.html#1834" class="Bound">r</a> <a id="1836" href="Meta.Regularity.html#1836" class="Bound">i</a> <a id="1838" class="Symbol">=</a> <a id="1840" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a>
    <a id="1854" class="Symbol">(λ</a> <a id="1857" class="Symbol">{</a> <a id="1859" href="Meta.Regularity.html#1859" class="Bound">j</a> <a id="1861" class="Symbol">(</a><a id="1862" href="Meta.Regularity.html#1836" class="Bound">i</a> <a id="1864" class="Symbol">=</a> <a id="1866" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="1868" class="Symbol">)</a> <a id="1870" class="Symbol">→</a> <a id="1872" href="Meta.Regularity.html#1830" class="Bound">p</a> <a id="1874" class="Symbol">(</a><a id="1875" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="1877" href="Meta.Regularity.html#1859" class="Bound">j</a><a id="1878" class="Symbol">)</a> <a id="1880" class="Symbol">;</a> <a id="1882" href="Meta.Regularity.html#1882" class="Bound">j</a> <a id="1884" class="Symbol">(</a><a id="1885" href="Meta.Regularity.html#1836" class="Bound">i</a> <a id="1887" class="Symbol">=</a> <a id="1889" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="1891" class="Symbol">)</a> <a id="1893" class="Symbol">→</a> <a id="1895" href="Meta.Regularity.html#1834" class="Bound">r</a> <a id="1897" href="Meta.Regularity.html#1882" class="Bound">j</a> <a id="1899" class="Symbol">})</a> <a id="1902" class="Symbol">(</a><a id="1903" href="Meta.Regularity.html#1832" class="Bound">q</a> <a id="1905" href="Meta.Regularity.html#1836" class="Bound">i</a><a id="1906" class="Symbol">)</a>

  <a id="1911" class="Comment">-- The regularity tactic can operate in two modes: `precise` will work</a>
  <a id="1984" class="Comment">-- with the type-checker to identify which `transp`s are along refl,</a>
  <a id="2055" class="Comment">-- and which should be preserved. The `fast` mode says YOLO and</a>
  <a id="2121" class="Comment">-- assumes that **every** application of `transp` is one that would</a>
  <a id="2191" class="Comment">-- reduce by regularity. Needless to say, only use `fast` when you&#39;re</a>
  <a id="2263" class="Comment">-- sure that&#39;s the case (e.g. the fibres of a displayed category over</a>
  <a id="2335" class="Comment">-- Sets)</a>
  <a id="2346" class="Keyword">data</a> <a id="Regularity-precision"></a><a id="2351" href="Meta.Regularity.html#2351" class="Datatype">Regularity-precision</a> <a id="2372" class="Symbol">:</a> <a id="2374" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="2379" class="Keyword">where</a>
    <a id="Regularity-precision.precise"></a><a id="2389" href="Meta.Regularity.html#2389" class="InductiveConstructor">precise</a> <a id="Regularity-precision.fast"></a><a id="2397" href="Meta.Regularity.html#2397" class="InductiveConstructor">fast</a> <a id="2402" class="Symbol">:</a> <a id="2404" href="Meta.Regularity.html#2351" class="Datatype">Regularity-precision</a>
  <a id="2427" class="Comment">-- As the name implies, `precise` is `precise`, while `fast` is</a>
  <a id="2493" class="Comment">-- `fast`. The reason is that `fast` will avoid traversing many of the</a>
  <a id="2566" class="Comment">-- terms involved in a `transp`: It doesn&#39;t care about the level, it</a>
  <a id="2637" class="Comment">-- doesn&#39;t care about the line, and it doesn&#39;t care about the</a>
  <a id="2701" class="Comment">-- cofibration.</a>

  <a id="2720" class="Comment">-- The core of the tactic is this triad of mutually recursive</a>
  <a id="2784" class="Comment">-- functions. In all three of them, the `Nat` argument indicates how</a>
  <a id="2855" class="Comment">-- many binders we&#39;ve gone under: it is the dimension variable we</a>
  <a id="2923" class="Comment">-- abstracted over at the start.</a>
  <a id="refl-transport"></a><a id="2958" href="Meta.Regularity.html#2958" class="Function">refl-transport</a> <a id="2973" class="Symbol">:</a> <a id="2975" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2977" class="Symbol">→</a> <a id="2979" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2984" class="Symbol">→</a> <a id="2986" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="2989" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2996" class="Comment">-- ^ Determines whether an application of `transp` is a case of</a>
  <a id="3062" class="Comment">-- regularity, and if so, replaces it by `regular`. Precondition: its</a>
  <a id="3134" class="Comment">-- subterms must already be reduced.</a>
  <a id="go"></a><a id="3173" href="Meta.Regularity.html#3173" class="Function">go</a>  <a id="3177" class="Symbol">:</a> <a id="3179" href="Meta.Regularity.html#2351" class="Datatype">Regularity-precision</a> <a id="3200" class="Symbol">→</a> <a id="3202" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3204" class="Symbol">→</a> <a id="3206" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3211" class="Symbol">→</a> <a id="3213" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="3216" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3223" class="Comment">-- ^ Reduces all the subterms, and finds applications of `transp` to</a>
  <a id="3294" class="Comment">-- hand off to `refl-transport`.</a>
  <a id="go*"></a><a id="3329" href="Meta.Regularity.html#3329" class="Function">go*</a> <a id="3333" class="Symbol">:</a> <a id="3335" href="Meta.Regularity.html#2351" class="Datatype">Regularity-precision</a> <a id="3356" class="Symbol">→</a> <a id="3358" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3360" class="Symbol">→</a> <a id="3362" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3367" class="Symbol">(</a><a id="3368" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3372" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3376" class="Symbol">)</a> <a id="3378" class="Symbol">→</a> <a id="3380" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="3383" class="Symbol">(</a><a id="3384" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3389" class="Symbol">(</a><a id="3390" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3394" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3398" class="Symbol">))</a>
  <a id="3403" class="Comment">-- ^ Isn&#39;t the termination checker just lovely?</a>

  <a id="3454" href="Meta.Regularity.html#2958" class="Function">refl-transport</a> <a id="3469" href="Meta.Regularity.html#3469" class="Bound">n</a> <a id="3471" href="Meta.Regularity.html#3471" class="Bound">tm</a><a id="3473" class="Symbol">@(</a><a id="3475" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3479" class="Symbol">(</a><a id="3480" class="Keyword">quote</a> <a id="3486" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3492" class="Symbol">)</a> <a id="3494" class="Symbol">(</a><a id="3495" href="Meta.Regularity.html#3495" class="Bound">ℓ</a> <a id="3497" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="3500" href="Meta.Regularity.html#3500" class="Bound">Al</a> <a id="3503" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3506" href="Meta.Regularity.html#3506" class="Bound">φ</a> <a id="3508" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3511" href="Meta.Regularity.html#3511" class="Bound">x</a> <a id="3513" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3516" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3518" class="Symbol">))</a> <a id="3521" class="Symbol">=</a>
    <a id="3527" class="Comment">-- This match might make you wonder: Can&#39;t Al be a line of</a>
    <a id="3590" class="Comment">-- functions, so that the transport will have more arguments? No:</a>
    <a id="3660" class="Comment">-- The term is in normal form.</a>
    <a id="3695" class="Symbol">(</a><a id="3696" class="Keyword">do</a>
      <a id="3705" href="Agda.Builtin.Reflection.html#11091" class="Postulate">debug-print</a> <a id="3717" class="String">&quot;tactic.regularity&quot;</a> <a id="3737" class="Number">10</a> <a id="3740" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="3742" class="String">&quot;Checking regularity of &quot;</a> <a id="3768" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3770" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="3779" href="Meta.Regularity.html#3471" class="Bound">tm</a> <a id="3782" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3784" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="3793" class="Keyword">let</a> <a id="3797" href="Meta.Regularity.html#3797" class="Bound">φ′</a> <a id="3800" class="Symbol">=</a> <a id="3802" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3806" class="Symbol">(</a><a id="3807" class="Keyword">quote</a> <a id="3813" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="3816" class="Symbol">)</a> <a id="3818" class="Symbol">(</a><a id="3819" href="Meta.Regularity.html#3506" class="Bound">φ</a> <a id="3821" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3824" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="3828" href="Meta.Regularity.html#3469" class="Bound">n</a> <a id="3830" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="3833" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3836" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3838" class="Symbol">)</a>
      <a id="3846" class="Keyword">let</a> <a id="3850" href="Meta.Regularity.html#3850" class="Bound">tm′</a> <a id="3854" class="Symbol">=</a> <a id="3856" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3860" class="Symbol">(</a><a id="3861" class="Keyword">quote</a> <a id="3867" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3873" class="Symbol">)</a> <a id="3875" class="Symbol">(</a><a id="3876" href="Meta.Regularity.html#3495" class="Bound">ℓ</a> <a id="3878" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="3881" href="Meta.Regularity.html#3500" class="Bound">Al</a> <a id="3884" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3887" href="Meta.Regularity.html#3797" class="Bound">φ′</a> <a id="3890" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3893" href="Meta.Regularity.html#3511" class="Bound">x</a> <a id="3895" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3898" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3900" class="Symbol">)</a>
      <a id="3908" class="Comment">-- We simply ask Agda to check that the newly constructed term `transp Al (φ ∨ i) x`</a>
      <a id="3999" class="Comment">-- is correct, i.e. that Al is constant on (i = i1).</a>
      <a id="4058" class="Comment">-- If it isn&#39;t, we backtrack and leave the term unchanged.</a>
      <a id="4123" class="Comment">-- Note that if Al itself contains constant transports, we have already processed those,</a>
      <a id="4218" class="Comment">-- so they reduce away when (i = i1).</a>
      <a id="4262" href="Agda.Builtin.Reflection.html#8929" class="Postulate">check-type</a> <a id="4273" href="Meta.Regularity.html#3850" class="Bound">tm′</a> <a id="4277" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="4285" class="Comment">-- inferType doesn&#39;t trigger the constancy check https://github.com/agda/agda/issues/6585</a>
      <a id="4381" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="4386" href="Meta.Regularity.html#3850" class="Bound">tm′</a><a id="4389" class="Symbol">)</a> <a id="4391" href="Meta.Effect.Alt.html#369" class="Field Operator">&lt;|&gt;</a>
    <a id="4399" class="Symbol">(</a><a id="4400" class="Keyword">do</a>
      <a id="4409" href="Agda.Builtin.Reflection.html#11091" class="Postulate">debug-print</a> <a id="4421" class="String">&quot;tactic.regularity&quot;</a> <a id="4441" class="Number">10</a> <a id="4444" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="4446" class="String">&quot;NOT a (transport refl): &quot;</a> <a id="4473" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4475" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="4484" href="Meta.Regularity.html#3471" class="Bound">tm</a> <a id="4487" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4489" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="4498" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="4503" href="Meta.Regularity.html#3471" class="Bound">tm</a><a id="4505" class="Symbol">)</a>
  <a id="4509" href="Meta.Regularity.html#2958" class="CatchallClause Function">refl-transport</a><a id="4523" class="CatchallClause"> </a><a id="4524" class="CatchallClause Symbol">_</a><a id="4525" class="CatchallClause"> </a><a id="4526" href="Meta.Regularity.html#4526" class="CatchallClause Bound">tm</a> <a id="4529" class="Symbol">=</a> <a id="4531" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="4536" href="Meta.Regularity.html#4526" class="Bound">tm</a>

  <a id="4542" class="Comment">-- Boring term traversal.</a>
  <a id="4570" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="4573" href="Meta.Regularity.html#4573" class="Bound">pre</a> <a id="4577" href="Meta.Regularity.html#4577" class="Bound">n</a> <a id="4579" class="Symbol">(</a><a id="4580" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4584" href="Meta.Regularity.html#4584" class="Bound">x</a> <a id="4586" href="Meta.Regularity.html#4586" class="Bound">args</a><a id="4590" class="Symbol">)</a> <a id="4592" class="Symbol">=</a> <a id="4594" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4598" href="Meta.Regularity.html#4584" class="Bound">x</a> <a id="4600" href="Meta.Effect.Map.Base.html#398" class="Function Operator">&lt;$&gt;</a> <a id="4604" href="Meta.Regularity.html#3329" class="Function">go*</a> <a id="4608" href="Meta.Regularity.html#4573" class="Bound">pre</a> <a id="4612" href="Meta.Regularity.html#4577" class="Bound">n</a> <a id="4614" href="Meta.Regularity.html#4586" class="Bound">args</a>
  <a id="4621" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="4624" href="Meta.Regularity.html#4624" class="Bound">pre</a> <a id="4628" href="Meta.Regularity.html#4628" class="Bound">n</a> <a id="4630" class="Symbol">(</a><a id="4631" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4635" href="Meta.Regularity.html#4635" class="Bound">c</a> <a id="4637" href="Meta.Regularity.html#4637" class="Bound">args</a><a id="4641" class="Symbol">)</a> <a id="4643" class="Symbol">=</a> <a id="4645" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4649" href="Meta.Regularity.html#4635" class="Bound">c</a> <a id="4651" href="Meta.Effect.Map.Base.html#398" class="Function Operator">&lt;$&gt;</a> <a id="4655" href="Meta.Regularity.html#3329" class="Function">go*</a> <a id="4659" href="Meta.Regularity.html#4624" class="Bound">pre</a> <a id="4663" href="Meta.Regularity.html#4628" class="Bound">n</a> <a id="4665" href="Meta.Regularity.html#4637" class="Bound">args</a>
  <a id="4672" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="4675" href="Meta.Regularity.html#2397" class="InductiveConstructor">fast</a> <a id="4680" href="Meta.Regularity.html#4680" class="Bound">n</a> <a id="4682" class="Symbol">(</a><a id="4683" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4687" class="Symbol">(</a><a id="4688" class="Keyword">quote</a> <a id="4694" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4700" class="Symbol">)</a> <a id="4702" class="Symbol">(</a><a id="4703" href="Meta.Regularity.html#4703" class="Bound">ℓ</a> <a id="4705" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="4708" href="Meta.Regularity.html#4708" class="Bound">Al</a> <a id="4711" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4714" href="Meta.Regularity.html#4714" class="Bound">φ</a> <a id="4716" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4719" href="Meta.Regularity.html#4719" class="Bound">x</a> <a id="4721" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4724" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4726" class="Symbol">))</a> <a id="4729" class="Symbol">=</a> <a id="4731" class="Keyword">do</a>
    <a id="4738" href="Meta.Regularity.html#4738" class="Bound">x</a> <a id="4740" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="4742" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="4745" href="Meta.Regularity.html#2397" class="InductiveConstructor">fast</a> <a id="4750" href="Meta.Regularity.html#4680" class="Bound">n</a> <a id="4752" href="Meta.Regularity.html#4719" class="Bound">x</a>
    <a id="4758" class="Keyword">let</a> <a id="4762" href="Meta.Regularity.html#4762" class="Bound">φ′</a> <a id="4765" class="Symbol">=</a> <a id="4767" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4771" class="Symbol">(</a><a id="4772" class="Keyword">quote</a> <a id="4778" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="4781" class="Symbol">)</a> <a id="4783" class="Symbol">(</a><a id="4784" href="Meta.Regularity.html#4714" class="Bound">φ</a> <a id="4786" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4789" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4793" href="Meta.Regularity.html#4680" class="Bound">n</a> <a id="4795" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4798" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4801" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4803" class="Symbol">)</a>
    <a id="4809" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="4814" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="4816" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4820" class="Symbol">(</a><a id="4821" class="Keyword">quote</a> <a id="4827" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4833" class="Symbol">)</a> <a id="4835" class="Symbol">(</a><a id="4836" href="Meta.Regularity.html#4703" class="Bound">ℓ</a> <a id="4838" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="4841" href="Meta.Regularity.html#4708" class="Bound">Al</a> <a id="4844" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4847" href="Meta.Regularity.html#4762" class="Bound">φ′</a> <a id="4850" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4853" href="Meta.Regularity.html#4738" class="Bound">x</a> <a id="4855" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4858" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4860" class="Symbol">)</a>
  <a id="4864" href="Meta.Regularity.html#3173" class="CatchallClause Function">go</a><a id="4866" class="CatchallClause"> </a><a id="4867" href="Meta.Regularity.html#4867" class="CatchallClause Bound">pre</a><a id="4870" class="CatchallClause"> </a><a id="4871" href="Meta.Regularity.html#4871" class="CatchallClause Bound">n</a><a id="4872" class="CatchallClause"> </a><a id="4873" class="CatchallClause Symbol">(</a><a id="4874" href="Agda.Builtin.Reflection.html#5251" class="CatchallClause InductiveConstructor">def</a><a id="4877" class="CatchallClause"> </a><a id="4878" href="Meta.Regularity.html#4878" class="CatchallClause Bound">f</a><a id="4879" class="CatchallClause"> </a><a id="4880" href="Meta.Regularity.html#4880" class="CatchallClause Bound">args</a><a id="4884" class="CatchallClause Symbol">)</a> <a id="4886" class="Symbol">=</a> <a id="4888" class="Keyword">do</a>
    <a id="4895" href="Meta.Regularity.html#4895" class="Bound">as</a> <a id="4898" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="4900" href="Meta.Regularity.html#3329" class="Function">go*</a> <a id="4904" href="Meta.Regularity.html#4867" class="Bound">pre</a> <a id="4908" href="Meta.Regularity.html#4871" class="Bound">n</a> <a id="4910" href="Meta.Regularity.html#4880" class="Bound">args</a>
    <a id="4919" href="Meta.Regularity.html#2958" class="Function">refl-transport</a> <a id="4934" href="Meta.Regularity.html#4871" class="Bound">n</a> <a id="4936" class="Symbol">(</a><a id="4937" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4941" href="Meta.Regularity.html#4878" class="Bound">f</a> <a id="4943" href="Meta.Regularity.html#4895" class="Bound">as</a><a id="4945" class="Symbol">)</a>
  <a id="4949" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="4952" href="Meta.Regularity.html#4952" class="Bound">pre</a> <a id="4956" href="Meta.Regularity.html#4956" class="Bound">k</a> <a id="4958" href="Meta.Regularity.html#4958" class="Bound">t</a><a id="4959" class="Symbol">@(</a><a id="4961" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4965" href="Meta.Regularity.html#4965" class="Bound">v</a> <a id="4967" class="Symbol">(</a><a id="4968" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4972" href="Meta.Regularity.html#4972" class="Bound">nm</a> <a id="4975" href="Meta.Regularity.html#4975" class="Bound">b</a><a id="4976" class="Symbol">))</a> <a id="4979" class="Symbol">=</a> <a id="4981" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4985" href="Meta.Regularity.html#4965" class="Bound">v</a> <a id="4987" href="Foundations.Pi.Base.html#3422" class="Function Operator">∘</a> <a id="4989" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4993" href="Meta.Regularity.html#4972" class="Bound">nm</a> <a id="4996" href="Meta.Effect.Map.Base.html#398" class="Function Operator">&lt;$&gt;</a> <a id="5000" href="Meta.Reflection.Base.html#3333" class="Function">under-abs</a> <a id="5010" href="Meta.Regularity.html#4958" class="Bound">t</a> <a id="5012" class="Symbol">(</a><a id="5013" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5016" href="Meta.Regularity.html#4952" class="Bound">pre</a> <a id="5020" class="Symbol">(</a><a id="5021" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5025" href="Meta.Regularity.html#4956" class="Bound">k</a><a id="5026" class="Symbol">)</a> <a id="5028" href="Meta.Regularity.html#4975" class="Bound">b</a><a id="5029" class="Symbol">)</a>
  <a id="5033" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5036" href="Meta.Regularity.html#5036" class="Bound">pre</a> <a id="5040" href="Meta.Regularity.html#5040" class="Bound">n</a> <a id="5042" class="Symbol">(</a><a id="5043" href="Agda.Builtin.Reflection.html#5361" class="InductiveConstructor">pat-lam</a> <a id="5051" href="Meta.Regularity.html#5051" class="Bound">cs</a> <a id="5054" href="Meta.Regularity.html#5054" class="Bound">args</a><a id="5058" class="Symbol">)</a> <a id="5060" class="Symbol">=</a> <a id="5062" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a> <a id="5073" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="5075" class="String">&quot;regularity: Can not deal with pattern lambdas&quot;</a> <a id="5123" class="Comment">-- TODO can we do something about this?</a>
  <a id="5165" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5168" href="Meta.Regularity.html#5168" class="Bound">pre</a> <a id="5172" href="Meta.Regularity.html#5172" class="Bound">n</a> <a id="5174" href="Meta.Regularity.html#5174" class="Bound">t</a><a id="5175" class="Symbol">@(</a><a id="5177" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="5180" class="Symbol">(</a><a id="5181" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5185" href="Meta.Regularity.html#5185" class="Bound">i</a> <a id="5187" href="Meta.Regularity.html#5187" class="Bound">a</a><a id="5188" class="Symbol">)</a> <a id="5190" class="Symbol">(</a><a id="5191" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="5195" href="Meta.Regularity.html#5195" class="Bound">nm</a> <a id="5198" href="Meta.Regularity.html#5198" class="Bound">b</a><a id="5199" class="Symbol">))</a> <a id="5202" class="Symbol">=</a> <a id="5204" class="Keyword">do</a>
    <a id="5211" href="Meta.Regularity.html#5211" class="Bound">a</a> <a id="5213" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="5215" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5218" href="Meta.Regularity.html#5168" class="Bound">pre</a> <a id="5222" href="Meta.Regularity.html#5172" class="Bound">n</a> <a id="5224" href="Meta.Regularity.html#5187" class="Bound">a</a>
    <a id="5230" href="Meta.Regularity.html#5230" class="Bound">b</a> <a id="5232" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="5234" href="Meta.Reflection.Base.html#3333" class="Function">under-abs</a> <a id="5244" href="Meta.Regularity.html#5174" class="Bound">t</a> <a id="5246" class="Symbol">(</a><a id="5247" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5250" href="Meta.Regularity.html#5168" class="Bound">pre</a> <a id="5254" class="Symbol">(</a><a id="5255" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5259" href="Meta.Regularity.html#5172" class="Bound">n</a><a id="5260" class="Symbol">)</a> <a id="5262" href="Meta.Regularity.html#5198" class="Bound">b</a><a id="5263" class="Symbol">)</a>
    <a id="5269" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="5274" class="Symbol">(</a><a id="5275" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="5278" class="Symbol">(</a><a id="5279" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5283" href="Meta.Regularity.html#5185" class="Bound">i</a> <a id="5285" href="Meta.Regularity.html#5211" class="Bound">a</a><a id="5286" class="Symbol">)</a> <a id="5288" class="Symbol">(</a><a id="5289" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="5293" href="Meta.Regularity.html#5195" class="Bound">nm</a> <a id="5296" href="Meta.Regularity.html#5230" class="Bound">b</a><a id="5297" class="Symbol">))</a>
  <a id="5302" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5305" href="Meta.Regularity.html#5305" class="Bound">pre</a> <a id="5309" href="Meta.Regularity.html#5309" class="Bound">n</a> <a id="5311" class="Symbol">(</a><a id="5312" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="5322" href="Meta.Regularity.html#5322" class="Bound">s</a><a id="5323" class="Symbol">)</a> <a id="5325" class="Symbol">=</a> <a id="5327" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="5332" class="Symbol">(</a><a id="5333" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="5343" href="Meta.Regularity.html#5322" class="Bound">s</a><a id="5344" class="Symbol">)</a>
  <a id="5348" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5351" href="Meta.Regularity.html#5351" class="Bound">pre</a> <a id="5355" href="Meta.Regularity.html#5355" class="Bound">n</a> <a id="5357" class="Symbol">(</a><a id="5358" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5362" href="Meta.Regularity.html#5362" class="Bound">l</a><a id="5363" class="Symbol">)</a> <a id="5365" class="Symbol">=</a> <a id="5367" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="5372" class="Symbol">(</a><a id="5373" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5377" href="Meta.Regularity.html#5362" class="Bound">l</a><a id="5378" class="Symbol">)</a>
  <a id="5382" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5385" href="Meta.Regularity.html#5385" class="Bound">pre</a> <a id="5389" href="Meta.Regularity.html#5389" class="Bound">n</a> <a id="5391" class="Symbol">(</a><a id="5392" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5397" href="Meta.Regularity.html#5397" class="Bound">x</a> <a id="5399" href="Meta.Regularity.html#5399" class="Bound">args</a><a id="5403" class="Symbol">)</a> <a id="5405" class="Symbol">=</a> <a id="5407" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5412" href="Meta.Regularity.html#5397" class="Bound">x</a> <a id="5414" href="Meta.Effect.Map.Base.html#398" class="Function Operator">&lt;$&gt;</a> <a id="5418" href="Meta.Regularity.html#3329" class="Function">go*</a> <a id="5422" href="Meta.Regularity.html#5385" class="Bound">pre</a> <a id="5426" href="Meta.Regularity.html#5389" class="Bound">n</a> <a id="5428" href="Meta.Regularity.html#5399" class="Bound">args</a>
  <a id="5435" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5438" href="Meta.Regularity.html#5438" class="Bound">pre</a> <a id="5442" href="Meta.Regularity.html#5442" class="Bound">n</a> <a id="5444" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="5452" class="Symbol">=</a> <a id="5454" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="5459" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

  <a id="5470" href="Meta.Regularity.html#3329" class="Function">go*</a> <a id="5474" href="Meta.Regularity.html#5474" class="Bound">pre</a> <a id="5478" href="Meta.Regularity.html#5478" class="Bound">n</a> <a id="5480" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5483" class="Symbol">=</a> <a id="5485" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="5490" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="5495" href="Meta.Regularity.html#3329" class="Function">go*</a> <a id="5499" href="Meta.Regularity.html#5499" class="Bound">pre</a> <a id="5503" href="Meta.Regularity.html#5503" class="Bound">n</a> <a id="5505" class="Symbol">(</a><a id="5506" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5510" href="Meta.Regularity.html#5510" class="Bound">i</a> <a id="5512" href="Meta.Regularity.html#5512" class="Bound">a</a> <a id="5514" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5516" href="Meta.Regularity.html#5516" class="Bound">as</a><a id="5518" class="Symbol">)</a> <a id="5520" class="Symbol">=</a> <a id="5522" class="Keyword">do</a>
    <a id="5529" href="Meta.Regularity.html#5529" class="Bound">a</a> <a id="5531" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="5533" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="5536" href="Meta.Regularity.html#5499" class="Bound">pre</a> <a id="5540" href="Meta.Regularity.html#5503" class="Bound">n</a> <a id="5542" href="Meta.Regularity.html#5512" class="Bound">a</a>
    <a id="5548" class="Symbol">(</a><a id="5549" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5553" href="Meta.Regularity.html#5510" class="Bound">i</a> <a id="5555" href="Meta.Regularity.html#5529" class="Bound">a</a> <a id="5557" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷_</a><a id="5559" class="Symbol">)</a> <a id="5561" href="Meta.Effect.Map.Base.html#398" class="Function Operator">&lt;$&gt;</a> <a id="5565" href="Meta.Regularity.html#3329" class="Function">go*</a> <a id="5569" href="Meta.Regularity.html#5499" class="Bound">pre</a> <a id="5573" href="Meta.Regularity.html#5503" class="Bound">n</a> <a id="5575" href="Meta.Regularity.html#5516" class="Bound">as</a>

  <a id="5581" class="Comment">-- To turn a term into a regularity path, given a level of precision,</a>
  <a id="5653" class="Comment">-- all we have to do is raise the term by one, do the procedure above,</a>
  <a id="5726" class="Comment">-- then wrap it in a lambda. Nice!</a>
  <a id="to-regularity-path"></a><a id="5763" href="Meta.Regularity.html#5763" class="Function">to-regularity-path</a> <a id="5782" class="Symbol">:</a> <a id="5784" href="Meta.Regularity.html#2351" class="Datatype">Regularity-precision</a> <a id="5805" class="Symbol">→</a> <a id="5807" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5812" class="Symbol">→</a> <a id="5814" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="5817" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5824" href="Meta.Regularity.html#5763" class="Function">to-regularity-path</a> <a id="5843" href="Meta.Regularity.html#5843" class="Bound">pre</a> <a id="5847" href="Meta.Regularity.html#5847" class="Bound">tm</a> <a id="5850" class="Symbol">=</a> <a id="5852" class="Keyword">do</a>
    <a id="5859" href="Meta.Regularity.html#5859" class="Bound">tm</a> <a id="5862" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="5864" href="Meta.Reflection.Subst.html#7504" class="Function">raiseTC</a> <a id="5872" class="Number">1</a> <a id="5874" href="Meta.Regularity.html#5847" class="Bound">tm</a>
    <a id="5881" class="Comment">-- Since we&#39;ll be comparing terms, Agda really wants them to be</a>
    <a id="5949" class="Comment">-- well-scoped. Since we shifted eeeverything up by one, we have to</a>
    <a id="6021" class="Comment">-- grow the context, too.</a>
    <a id="6051" href="Meta.Regularity.html#6051" class="Bound">tm</a> <a id="6054" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6056" href="Meta.Reflection.Base.html#4685" class="Function">resetting</a> <a id="6066" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="6068" href="Agda.Builtin.Reflection.html#9292" class="Postulate">extend-context</a> <a id="6083" class="String">&quot;i&quot;</a> <a id="6087" class="Symbol">(</a><a id="6088" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="6093" class="Symbol">(</a><a id="6094" class="Keyword">quoteTerm</a> <a id="6104" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="6105" class="Symbol">))</a> <a id="6108" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="6110" href="Meta.Regularity.html#3173" class="Function">go</a> <a id="6113" href="Meta.Regularity.html#5843" class="Bound">pre</a> <a id="6117" class="Number">0</a> <a id="6119" href="Meta.Regularity.html#5859" class="Bound">tm</a>
    <a id="6126" href="Meta.Effect.Idiom.Base.html#431" class="Field">pure</a> <a id="6131" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="6133" href="Meta.Reflection.Base.html#4161" class="Function">vlam</a> <a id="6138" class="String">&quot;i&quot;</a> <a id="6142" href="Meta.Regularity.html#6051" class="Bound">tm</a>

  <a id="6148" class="Comment">-- Extend a path x ＝ y to a path x′ ＝ y′, where x′ --&gt; x and y′ --&gt; y</a>
  <a id="6220" class="Comment">-- under the given regularity precision. Shorthand for composing</a>
  <a id="6287" class="Comment">--    regularity! ∙ p ∙ sym regularity!.</a>
  <a id="regular!-worker"></a><a id="6330" href="Meta.Regularity.html#6330" class="Function">regular!-worker</a> <a id="6346" class="Symbol">:</a>
    <a id="6352" class="Symbol">∀</a> <a id="6354" class="Symbol">{</a><a id="6355" href="Meta.Regularity.html#6355" class="Bound">ℓ</a><a id="6356" class="Symbol">}</a> <a id="6358" class="Symbol">{</a><a id="6359" href="Meta.Regularity.html#6359" class="Bound">A</a> <a id="6361" class="Symbol">:</a> <a id="6363" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="6368" href="Meta.Regularity.html#6355" class="Bound">ℓ</a><a id="6369" class="Symbol">}</a> <a id="6371" class="Symbol">{</a><a id="6372" href="Meta.Regularity.html#6372" class="Bound">x</a> <a id="6374" href="Meta.Regularity.html#6374" class="Bound">y</a> <a id="6376" class="Symbol">:</a> <a id="6378" href="Meta.Regularity.html#6359" class="Bound">A</a><a id="6379" class="Symbol">}</a>
    <a id="6385" class="Symbol">→</a> <a id="6387" href="Meta.Regularity.html#2351" class="Datatype">Regularity-precision</a>
    <a id="6412" class="Symbol">→</a> <a id="6414" href="Meta.Regularity.html#6372" class="Bound">x</a> <a id="6416" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="6418" href="Meta.Regularity.html#6374" class="Bound">y</a>
    <a id="6424" class="Symbol">→</a> <a id="6426" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="6435" class="Symbol">→</a> <a id="6437" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="6440" href="Foundations.Notation.Logic.html#4427" class="Field">⊤</a>
  <a id="6444" href="Meta.Regularity.html#6330" class="Function">regular!-worker</a> <a id="6460" class="Symbol">{</a><a id="6461" class="Argument">x</a> <a id="6463" class="Symbol">=</a> <a id="6465" href="Meta.Regularity.html#6465" class="Bound">x</a><a id="6466" class="Symbol">}</a> <a id="6468" class="Symbol">{</a><a id="6469" href="Meta.Regularity.html#6469" class="Bound">y</a><a id="6470" class="Symbol">}</a> <a id="6472" href="Meta.Regularity.html#6472" class="Bound">pre</a> <a id="6476" href="Meta.Regularity.html#6476" class="Bound">p</a> <a id="6478" href="Meta.Regularity.html#6478" class="Bound">goal</a> <a id="6483" class="Symbol">=</a> <a id="6485" class="Keyword">do</a>
    <a id="6492" href="Meta.Regularity.html#6492" class="Bound">gt</a> <a id="6495" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6497" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="6508" href="Meta.Regularity.html#6478" class="Bound">goal</a>
    <a id="6517" href="Meta.Regularity.html#6517" class="Bound">`x</a> <a id="6520" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6522" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="6530" href="Meta.Regularity.html#6465" class="Bound">x</a>
    <a id="6536" href="Meta.Regularity.html#6536" class="Bound">`y</a> <a id="6539" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6541" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="6549" href="Meta.Regularity.html#6469" class="Bound">y</a>
    <a id="6555" href="Meta.Regularity.html#6555" class="Bound">`p</a> <a id="6558" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6560" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="6568" href="Meta.Regularity.html#6476" class="Bound">p</a>
    <a id="6574" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6579" class="Symbol">(_</a> <a id="6582" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6584" href="Meta.Regularity.html#6584" class="Bound">l</a> <a id="6586" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6588" href="Meta.Regularity.html#6588" class="Bound">r</a><a id="6589" class="Symbol">)</a> <a id="6591" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6593" href="Meta.Reflection.Base.html#7287" class="Function">unapply-path</a> <a id="6606" href="Meta.Effect.Bind.Base.html#454" class="Function Operator">=&lt;&lt;</a> <a id="6610" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="6621" href="Meta.Regularity.html#6478" class="Bound">goal</a>
      <a id="6632" class="Keyword">where</a> <a id="6638" class="CatchallClause Symbol">_</a> <a id="6640" class="Symbol">→</a> <a id="6642" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a> <a id="6653" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="6660" href="Meta.Regularity.html#6660" class="Bound">l</a> <a id="6662" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6664" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="6674" href="Meta.Effect.Bind.Base.html#454" class="Function Operator">=&lt;&lt;</a> <a id="6678" href="Meta.Reflection.Base.html#5542" class="Function">wait-for-type</a> <a id="6692" href="Meta.Regularity.html#6584" class="Bound">l</a>
    <a id="6698" href="Meta.Regularity.html#6698" class="Bound">r</a> <a id="6700" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6702" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="6712" href="Meta.Effect.Bind.Base.html#454" class="Function Operator">=&lt;&lt;</a> <a id="6716" href="Meta.Reflection.Base.html#5542" class="Function">wait-for-type</a> <a id="6730" href="Meta.Regularity.html#6588" class="Bound">r</a>
    <a id="6736" href="Meta.Regularity.html#6736" class="Bound">reg</a> <a id="6740" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6742" href="Meta.Regularity.html#5763" class="Function">to-regularity-path</a> <a id="6761" href="Meta.Regularity.html#6472" class="Bound">pre</a> <a id="6765" href="Meta.Regularity.html#6660" class="Bound">l</a>
    <a id="6771" href="Meta.Regularity.html#6771" class="Bound">reg′</a> <a id="6776" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="6778" href="Meta.Regularity.html#5763" class="Function">to-regularity-path</a> <a id="6797" href="Meta.Regularity.html#6472" class="Bound">pre</a> <a id="6801" href="Meta.Regularity.html#6698" class="Bound">r</a>
    <a id="6807" href="Meta.Reflection.Base.html#9012" class="Function">unify-loudly</a> <a id="6820" href="Meta.Regularity.html#6478" class="Bound">goal</a> <a id="6825" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="6827" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6831" class="Symbol">(</a><a id="6832" class="Keyword">quote</a> <a id="6838" href="Meta.Regularity.html#1715" class="Function">double-comp</a><a id="6849" class="Symbol">)</a> <a id="6851" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a>
         <a id="6862" href="Meta.Regularity.html#6517" class="Bound">`x</a> <a id="6865" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6868" href="Meta.Regularity.html#6536" class="Bound">`y</a> <a id="6871" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6874" href="Meta.Regularity.html#6736" class="Bound">reg</a>
      <a id="6884" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6887" href="Meta.Regularity.html#6555" class="Bound">`p</a>
      <a id="6896" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6899" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6903" class="Symbol">(</a><a id="6904" class="Keyword">quote</a> <a id="6910" href="Foundations.Notation.Duality.html#749" class="Function">sym</a><a id="6913" class="Symbol">)</a> <a id="6915" class="Symbol">(</a><a id="6916" href="Meta.Regularity.html#6771" class="Bound">reg′</a> <a id="6921" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6924" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6926" class="Symbol">)</a>
      <a id="6934" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6937" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="6941" class="Keyword">module</a> <a id="Regularity"></a><a id="6948" href="Meta.Regularity.html#6948" class="Module">Regularity</a> <a id="6959" class="Keyword">where</a>
  <a id="6967" class="Keyword">open</a> <a id="6972" href="Meta.Regularity.html#2351" class="Module">Regularity-precision</a> <a id="6993" class="Keyword">public</a>
  <a id="7002" class="Comment">-- The reflection interface: Regularity.reduce! will, well, reduce a</a>
  <a id="7073" class="Comment">-- term. There&#39;s a lot of blocking involved in making this work.</a>
  <a id="7140" class="Keyword">macro</a>
    <a id="Regularity.reduce!"></a><a id="7150" href="Meta.Regularity.html#7150" class="Function">reduce!</a> <a id="7158" class="Symbol">:</a> <a id="7160" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7165" class="Symbol">→</a> <a id="7167" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7170" href="Foundations.Notation.Logic.html#4427" class="Field">⊤</a>
    <a id="7176" href="Meta.Regularity.html#7150" class="Function">reduce!</a> <a id="7184" href="Meta.Regularity.html#7184" class="Bound">goal</a> <a id="7189" class="Symbol">=</a> <a id="7191" class="Keyword">do</a>
      <a id="7200" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="7205" class="Symbol">(_</a> <a id="7208" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7210" href="Meta.Regularity.html#7210" class="Bound">l</a> <a id="7212" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7214" href="Meta.Regularity.html#7214" class="Bound">r</a><a id="7215" class="Symbol">)</a> <a id="7217" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="7219" href="Meta.Reflection.Base.html#7287" class="Function">unapply-path</a> <a id="7232" href="Meta.Effect.Bind.Base.html#454" class="Function Operator">=&lt;&lt;</a> <a id="7236" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="7247" href="Meta.Regularity.html#7184" class="Bound">goal</a>
        <a id="7260" class="Keyword">where</a> <a id="7266" class="CatchallClause Symbol">_</a> <a id="7268" class="Symbol">→</a> <a id="7270" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a> <a id="7281" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="7290" href="Meta.Regularity.html#7290" class="Bound">reg</a> <a id="7294" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="7296" href="Meta.Regularity.html#5763" class="Function">to-regularity-path</a> <a id="7315" href="Meta.Regularity.html#2389" class="InductiveConstructor">precise</a> <a id="7323" href="Meta.Effect.Bind.Base.html#454" class="Function Operator">=&lt;&lt;</a> <a id="7327" class="Symbol">(</a><a id="7328" href="Meta.Reflection.Base.html#5542" class="Function">wait-for-type</a> <a id="7342" href="Meta.Effect.Bind.Base.html#454" class="Function Operator">=&lt;&lt;</a> <a id="7346" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="7356" href="Meta.Regularity.html#7210" class="Bound">l</a><a id="7357" class="Symbol">)</a>
      <a id="7365" href="Meta.Reflection.Base.html#9012" class="Function">unify-loudly</a> <a id="7378" href="Meta.Regularity.html#7184" class="Bound">goal</a> <a id="7383" href="Meta.Regularity.html#7290" class="Bound">reg</a>

    <a id="7392" class="Comment">-- We then have wrappers that reduce on one side, and expand on the</a>
    <a id="7464" class="Comment">-- other, depending on how precise you want the reduction to be.</a>
    <a id="Regularity.precise!"></a><a id="7533" href="Meta.Regularity.html#7533" class="Function">precise!</a> <a id="7542" class="Symbol">:</a> <a id="7544" class="Symbol">∀</a> <a id="7546" class="Symbol">{</a><a id="7547" href="Meta.Regularity.html#7547" class="Bound">ℓ</a><a id="7548" class="Symbol">}</a> <a id="7550" class="Symbol">{</a><a id="7551" href="Meta.Regularity.html#7551" class="Bound">A</a> <a id="7553" class="Symbol">:</a> <a id="7555" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7560" href="Meta.Regularity.html#7547" class="Bound">ℓ</a><a id="7561" class="Symbol">}</a> <a id="7563" class="Symbol">{</a><a id="7564" href="Meta.Regularity.html#7564" class="Bound">x</a> <a id="7566" href="Meta.Regularity.html#7566" class="Bound">y</a> <a id="7568" class="Symbol">:</a> <a id="7570" href="Meta.Regularity.html#7551" class="Bound">A</a><a id="7571" class="Symbol">}</a> <a id="7573" class="Symbol">→</a> <a id="7575" href="Meta.Regularity.html#7564" class="Bound">x</a> <a id="7577" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="7579" href="Meta.Regularity.html#7566" class="Bound">y</a> <a id="7581" class="Symbol">→</a> <a id="7583" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7588" class="Symbol">→</a> <a id="7590" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7593" href="Foundations.Notation.Logic.html#4427" class="Field">⊤</a>
    <a id="Regularity.fast!"></a><a id="7599" href="Meta.Regularity.html#7599" class="Function">fast!</a> <a id="7605" class="Symbol">:</a> <a id="7607" class="Symbol">∀</a> <a id="7609" class="Symbol">{</a><a id="7610" href="Meta.Regularity.html#7610" class="Bound">ℓ</a><a id="7611" class="Symbol">}</a> <a id="7613" class="Symbol">{</a><a id="7614" href="Meta.Regularity.html#7614" class="Bound">A</a> <a id="7616" class="Symbol">:</a> <a id="7618" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7623" href="Meta.Regularity.html#7610" class="Bound">ℓ</a><a id="7624" class="Symbol">}</a> <a id="7626" class="Symbol">{</a><a id="7627" href="Meta.Regularity.html#7627" class="Bound">x</a> <a id="7629" href="Meta.Regularity.html#7629" class="Bound">y</a> <a id="7631" class="Symbol">:</a> <a id="7633" href="Meta.Regularity.html#7614" class="Bound">A</a><a id="7634" class="Symbol">}</a> <a id="7636" class="Symbol">→</a> <a id="7638" href="Meta.Regularity.html#7627" class="Bound">x</a> <a id="7640" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="7642" href="Meta.Regularity.html#7629" class="Bound">y</a> <a id="7644" class="Symbol">→</a> <a id="7646" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7651" class="Symbol">→</a> <a id="7653" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7656" href="Foundations.Notation.Logic.html#4427" class="Field">⊤</a>

    <a id="7663" href="Meta.Regularity.html#7533" class="Function">precise!</a> <a id="7672" href="Meta.Regularity.html#7672" class="Bound">p</a> <a id="7674" href="Meta.Regularity.html#7674" class="Bound">goal</a> <a id="7679" class="Symbol">=</a> <a id="7681" href="Meta.Regularity.html#6330" class="Function">regular!-worker</a> <a id="7697" href="Meta.Regularity.html#2389" class="InductiveConstructor">precise</a> <a id="7705" href="Meta.Regularity.html#7672" class="Bound">p</a> <a id="7707" href="Meta.Regularity.html#7674" class="Bound">goal</a>
    <a id="7716" href="Meta.Regularity.html#7599" class="Function">fast!</a> <a id="7722" href="Meta.Regularity.html#7722" class="Bound">p</a> <a id="7724" href="Meta.Regularity.html#7724" class="Bound">goal</a> <a id="7729" class="Symbol">=</a> <a id="7731" href="Meta.Regularity.html#6330" class="Function">regular!-worker</a> <a id="7747" href="Meta.Regularity.html#2397" class="InductiveConstructor">fast</a> <a id="7752" href="Meta.Regularity.html#7722" class="Bound">p</a> <a id="7754" href="Meta.Regularity.html#7724" class="Bound">goal</a>

    <a id="7764" class="Comment">-- For debugging purposes, this macro will take a term and output</a>
    <a id="7834" class="Comment">-- its (transport refl)-normal form, according to the given level of</a>
    <a id="7907" class="Comment">-- precision.</a>
    <a id="Regularity.reduct"></a><a id="7925" href="Meta.Regularity.html#7925" class="Function">reduct</a> <a id="7932" class="Symbol">:</a> <a id="7934" href="Meta.Regularity.html#2351" class="Datatype">Regularity-precision</a> <a id="7955" class="Symbol">→</a> <a id="7957" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7962" class="Symbol">→</a> <a id="7964" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7969" class="Symbol">→</a> <a id="7971" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7974" href="Foundations.Notation.Logic.html#4427" class="Field">⊤</a>
    <a id="7980" href="Meta.Regularity.html#7925" class="Function">reduct</a> <a id="7987" href="Meta.Regularity.html#7987" class="Bound">pres</a> <a id="7992" href="Meta.Regularity.html#7992" class="Bound">tm</a> <a id="7995" class="Symbol">_</a> <a id="7997" class="Symbol">=</a> <a id="7999" class="Keyword">do</a>
      <a id="8008" href="Meta.Regularity.html#8008" class="Bound">orig</a> <a id="8013" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="8015" href="Meta.Reflection.Base.html#5542" class="Function">wait-for-type</a> <a id="8029" href="Meta.Effect.Bind.Base.html#454" class="Function Operator">=&lt;&lt;</a> <a id="8033" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="8043" href="Meta.Regularity.html#7992" class="Bound">tm</a>
      <a id="8052" href="Meta.Regularity.html#8052" class="Bound">tm</a> <a id="8055" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="8057" href="Meta.Regularity.html#5763" class="Function">to-regularity-path</a> <a id="8076" href="Meta.Regularity.html#7987" class="Bound">pres</a> <a id="8081" href="Meta.Regularity.html#8008" class="Bound">orig</a>
      <a id="8092" href="Meta.Regularity.html#8092" class="Bound">red</a> <a id="8096" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="8098" href="Meta.Reflection.Subst.html#7872" class="Function">applyTC</a> <a id="8106" href="Meta.Regularity.html#8052" class="Bound">tm</a> <a id="8109" class="Symbol">(</a><a id="8110" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="8115" class="Symbol">(</a><a id="8116" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8120" class="Symbol">(</a><a id="8121" class="Keyword">quote</a> <a id="8127" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="8129" class="Symbol">)</a> <a id="8131" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8133" class="Symbol">))</a> <a id="8136" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">&gt;&gt;=</a> <a id="8140" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a>
      <a id="8156" href="Meta.Regularity.html#8156" class="Bound">`pres</a> <a id="8162" href="Meta.Effect.Bind.Base.html#310" class="Field Operator">←</a> <a id="8164" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="8172" href="Meta.Regularity.html#7987" class="Bound">pres</a>
      <a id="8183" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a>
        <a id="8202" href="Meta.Literals.FromProduct.html#419" class="Function Operator">[</a> <a id="8204" class="String">&quot;The term\n\n  &quot;</a> <a id="8221" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8223" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8232" href="Meta.Regularity.html#8008" class="Bound">orig</a> <a id="8237" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8239" class="String">&quot;\n\nreduces modulo &quot;</a>
        <a id="8269" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8271" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8280" href="Meta.Regularity.html#8156" class="Bound">`pres</a> <a id="8286" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8288" class="String">&quot; regularity to\n\n  &quot;</a>
        <a id="8319" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8321" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8330" href="Meta.Regularity.html#8092" class="Bound">red</a> <a id="8334" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8336" class="String">&quot;\n&quot;</a> <a id="8341" href="Meta.Literals.FromProduct.html#419" class="Function Operator">]</a>

<a id="8344" class="Comment">-- Test cases.</a>
<a id="8359" class="Keyword">module</a>
  <a id="8368" href="Meta.Regularity.html#8368" class="Module">_</a> <a id="8370" class="Symbol">{</a><a id="8371" href="Meta.Regularity.html#8371" class="Bound">ℓ</a> <a id="8373" href="Meta.Regularity.html#8373" class="Bound">ℓ′</a><a id="8375" class="Symbol">}</a> <a id="8377" class="Symbol">{</a><a id="8378" href="Meta.Regularity.html#8378" class="Bound">A</a> <a id="8380" class="Symbol">:</a> <a id="8382" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8387" href="Meta.Regularity.html#8371" class="Bound">ℓ</a><a id="8388" class="Symbol">}</a> <a id="8390" class="Symbol">{</a><a id="8391" href="Meta.Regularity.html#8391" class="Bound">B</a> <a id="8393" class="Symbol">:</a> <a id="8395" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8400" href="Meta.Regularity.html#8373" class="Bound">ℓ′</a><a id="8402" class="Symbol">}</a> <a id="8404" class="Symbol">(</a><a id="8405" href="Meta.Regularity.html#8405" class="Bound">f</a> <a id="8407" href="Meta.Regularity.html#8407" class="Bound">g</a> <a id="8409" class="Symbol">:</a> <a id="8411" href="Meta.Regularity.html#8378" class="Bound">A</a> <a id="8413" class="Symbol">→</a> <a id="8415" href="Meta.Regularity.html#8391" class="Bound">B</a><a id="8416" class="Symbol">)</a> <a id="8418" class="Symbol">(</a><a id="8419" href="Meta.Regularity.html#8419" class="Bound">x</a> <a id="8421" class="Symbol">:</a> <a id="8423" href="Meta.Regularity.html#8378" class="Bound">A</a><a id="8424" class="Symbol">)</a>
    <a id="8430" class="Symbol">(</a><a id="8431" href="Meta.Regularity.html#8431" class="Bound">a-loop</a> <a id="8438" class="Symbol">:</a> <a id="8440" class="Symbol">(</a><a id="8441" href="Meta.Regularity.html#8441" class="Bound">i</a> <a id="8443" class="Symbol">:</a> <a id="8445" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="8446" class="Symbol">)</a> <a id="8448" class="Symbol">→</a> <a id="8450" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8455" href="Meta.Regularity.html#8371" class="Bound">ℓ</a> <a id="8457" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">[</a> <a id="8459" class="Symbol">(</a><a id="8460" href="Meta.Regularity.html#8441" class="Bound">i</a> <a id="8462" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">∨</a> <a id="8464" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="8466" href="Meta.Regularity.html#8441" class="Bound">i</a><a id="8467" class="Symbol">)</a> <a id="8469" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">↦</a> <a id="8471" class="Symbol">(λ</a> <a id="8474" class="Symbol">.</a><a id="8475" href="Meta.Regularity.html#8475" class="Bound">_</a> <a id="8477" class="Symbol">→</a> <a id="8479" href="Meta.Regularity.html#8378" class="Bound">A</a><a id="8480" class="Symbol">)</a> <a id="8482" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">]</a><a id="8483" class="Symbol">)</a>
  <a id="8487" class="Keyword">where</a> <a id="8493" class="Keyword">private</a>

  <a id="8504" href="Meta.Regularity.html#8504" class="Function">p</a> <a id="8506" class="Symbol">:</a> <a id="8508" class="Symbol">(</a><a id="8509" href="Meta.Regularity.html#8509" class="Bound">h</a> <a id="8511" class="Symbol">:</a> <a id="8513" class="Symbol">∀</a> <a id="8515" href="Meta.Regularity.html#8515" class="Bound">x</a> <a id="8517" class="Symbol">→</a> <a id="8519" href="Meta.Regularity.html#8405" class="Bound">f</a> <a id="8521" href="Meta.Regularity.html#8515" class="Bound">x</a> <a id="8523" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8525" href="Meta.Regularity.html#8407" class="Bound">g</a> <a id="8527" href="Meta.Regularity.html#8515" class="Bound">x</a><a id="8528" class="Symbol">)</a>
    <a id="8534" class="Symbol">→</a> <a id="8536" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8546" class="Symbol">(λ</a> <a id="8549" href="Meta.Regularity.html#8549" class="Bound">i</a> <a id="8551" class="Symbol">→</a> <a id="8553" href="Meta.Regularity.html#8378" class="Bound">A</a> <a id="8555" class="Symbol">→</a> <a id="8557" href="Meta.Regularity.html#8391" class="Bound">B</a><a id="8558" class="Symbol">)</a>
        <a id="8568" class="Symbol">(λ</a> <a id="8571" href="Meta.Regularity.html#8571" class="Bound">x</a> <a id="8573" class="Symbol">→</a> <a id="8575" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8585" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a> <a id="8590" class="Symbol">(</a><a id="8591" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8601" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a> <a id="8606" class="Symbol">(</a><a id="8607" href="Meta.Regularity.html#8405" class="Bound">f</a> <a id="8609" class="Symbol">(</a><a id="8610" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8620" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a> <a id="8625" href="Meta.Regularity.html#8571" class="Bound">x</a><a id="8626" class="Symbol">))))</a> <a id="8631" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8633" href="Meta.Regularity.html#8407" class="Bound">g</a>
  <a id="8637" href="Meta.Regularity.html#8504" class="Function">p</a> <a id="8639" href="Meta.Regularity.html#8639" class="Bound">h</a> <a id="8641" class="Symbol">=</a> <a id="8643" href="Meta.Regularity.html#7150" class="Macro">Regularity.reduce!</a> <a id="8662" href="Foundations.Notation.Composition.html#530" class="Field Operator">∙</a> <a id="8664" href="Foundations.Base.html#9372" class="Function">fun-ext</a> <a id="8672" href="Meta.Regularity.html#8639" class="Bound">h</a>

  <a id="8677" href="Meta.Regularity.html#8677" class="Function">q</a> <a id="8679" class="Symbol">:</a> <a id="8681" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8691" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a> <a id="8696" class="Symbol">(</a><a id="8697" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8704" class="Symbol">(λ</a> <a id="8707" href="Meta.Regularity.html#8707" class="Bound">i</a> <a id="8709" class="Symbol">→</a> <a id="8711" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8716" class="Symbol">(</a><a id="8717" href="Meta.Regularity.html#8431" class="Bound">a-loop</a> <a id="8724" href="Meta.Regularity.html#8707" class="Bound">i</a><a id="8725" class="Symbol">))</a> <a id="8728" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8731" href="Meta.Regularity.html#8419" class="Bound">x</a><a id="8732" class="Symbol">)</a> <a id="8734" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8736" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8743" class="Symbol">(λ</a> <a id="8746" href="Meta.Regularity.html#8746" class="Bound">i</a> <a id="8748" class="Symbol">→</a> <a id="8750" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8755" class="Symbol">(</a><a id="8756" href="Meta.Regularity.html#8431" class="Bound">a-loop</a> <a id="8763" href="Meta.Regularity.html#8746" class="Bound">i</a><a id="8764" class="Symbol">))</a> <a id="8767" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8770" href="Meta.Regularity.html#8419" class="Bound">x</a>
  <a id="8774" href="Meta.Regularity.html#8677" class="Function">q</a> <a id="8776" class="Symbol">=</a> <a id="8778" href="Meta.Regularity.html#7150" class="Macro">Regularity.reduce!</a>

  <a id="8800" class="Comment">-- Imprecise/fast reduction: According to it, the normal form of the</a>
  <a id="8871" class="Comment">-- transport below is refl. That&#39;s.. not the case, at least we don&#39;t</a>
  <a id="8942" class="Comment">-- know so. Precise regularity handles it, though.</a>
  <a id="8995" class="Comment">-- q′ : ⊤</a>
  <a id="9007" class="Comment">-- q′ = {! Regularity.reduct Regularity.fast (transp (λ i → outS (a-loop i)) i0 x) !}</a>

  <a id="9096" href="Meta.Regularity.html#9096" class="Function">r</a> <a id="9098" class="Symbol">:</a> <a id="9100" class="Symbol">(</a><a id="9101" href="Meta.Regularity.html#9101" class="Bound">h</a> <a id="9103" class="Symbol">:</a> <a id="9105" class="Symbol">∀</a> <a id="9107" href="Meta.Regularity.html#9107" class="Bound">x</a> <a id="9109" class="Symbol">→</a> <a id="9111" href="Meta.Regularity.html#8405" class="Bound">f</a> <a id="9113" href="Meta.Regularity.html#9107" class="Bound">x</a> <a id="9115" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9117" href="Meta.Regularity.html#8407" class="Bound">g</a> <a id="9119" href="Meta.Regularity.html#9107" class="Bound">x</a><a id="9120" class="Symbol">)</a> <a id="9122" class="Symbol">→</a> <a id="9124" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9134" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a> <a id="9139" class="Symbol">(</a><a id="9140" href="Meta.Regularity.html#8405" class="Bound">f</a> <a id="9142" href="Meta.Regularity.html#8419" class="Bound">x</a><a id="9143" class="Symbol">)</a> <a id="9145" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9147" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9157" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a> <a id="9162" class="Symbol">(</a><a id="9163" href="Meta.Regularity.html#8407" class="Bound">g</a> <a id="9165" href="Meta.Regularity.html#8419" class="Bound">x</a><a id="9166" class="Symbol">)</a>
  <a id="9170" href="Meta.Regularity.html#9096" class="Function">r</a> <a id="9172" href="Meta.Regularity.html#9172" class="Bound">h</a> <a id="9174" class="Symbol">=</a> <a id="9176" href="Meta.Regularity.html#7533" class="Macro">Regularity.precise!</a> <a id="9196" class="Symbol">(</a><a id="9197" href="Meta.Regularity.html#9172" class="Bound">h</a> <a id="9199" href="Meta.Regularity.html#8419" class="Bound">x</a><a id="9200" class="Symbol">)</a>

  <a id="9205" href="Meta.Regularity.html#9205" class="Function">s</a> <a id="9207" class="Symbol">:</a> <a id="9209" class="Symbol">(</a><a id="9210" href="Meta.Regularity.html#9210" class="Bound">h</a> <a id="9212" class="Symbol">:</a> <a id="9214" class="Symbol">∀</a> <a id="9216" href="Meta.Regularity.html#9216" class="Bound">x</a> <a id="9218" class="Symbol">→</a> <a id="9220" href="Meta.Regularity.html#8405" class="Bound">f</a> <a id="9222" href="Meta.Regularity.html#9216" class="Bound">x</a> <a id="9224" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9226" href="Meta.Regularity.html#8407" class="Bound">g</a> <a id="9228" href="Meta.Regularity.html#9216" class="Bound">x</a><a id="9229" class="Symbol">)</a> <a id="9231" class="Symbol">→</a> <a id="9233" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9243" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a> <a id="9248" class="Symbol">(</a><a id="9249" href="Meta.Regularity.html#8407" class="Bound">g</a> <a id="9251" href="Meta.Regularity.html#8419" class="Bound">x</a><a id="9252" class="Symbol">)</a> <a id="9254" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9256" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9266" href="Foundations.Notation.Reflexivity.html#351" class="Field">refl</a> <a id="9271" class="Symbol">(</a><a id="9272" href="Meta.Regularity.html#8405" class="Bound">f</a> <a id="9274" href="Meta.Regularity.html#8419" class="Bound">x</a><a id="9275" class="Symbol">)</a>
  <a id="9279" href="Meta.Regularity.html#9205" class="Function">s</a> <a id="9281" href="Meta.Regularity.html#9281" class="Bound">h</a> <a id="9283" class="Symbol">=</a> <a id="9285" href="Foundations.Notation.Duality.html#749" class="Function">sym</a> <a id="9289" href="Foundations.Notation.Underlying.html#1770" class="Function Operator">$</a> <a id="9291" href="Meta.Regularity.html#7599" class="Macro">Regularity.fast!</a> <a id="9308" class="Symbol">(</a><a id="9309" href="Meta.Regularity.html#9281" class="Bound">h</a> <a id="9311" href="Meta.Regularity.html#8419" class="Bound">x</a><a id="9312" class="Symbol">)</a>
</pre></body></html>