<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.Regularity</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Pragma">--no-exact-split</a> <a id="37" class="Symbol">#-}</a>
<a id="41" class="Keyword">module</a> <a id="48" href="Meta.Regularity.html" class="Module">Meta.Regularity</a> <a id="64" class="Keyword">where</a>

<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="Meta.Prelude.html" class="Module">Meta.Prelude</a>
<a id="96" class="Keyword">open</a> <a id="101" class="Keyword">import</a> <a id="108" href="Meta.Reflection.Base.html" class="Module">Meta.Reflection.Base</a>
<a id="129" class="Keyword">open</a> <a id="134" class="Keyword">import</a> <a id="141" href="Meta.Reflection.Subst.html" class="Module">Meta.Reflection.Subst</a>

<a id="164" class="Keyword">open</a> <a id="169" class="Keyword">import</a> <a id="176" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="191" class="Keyword">open</a> <a id="196" class="Keyword">import</a> <a id="203" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="218" class="Keyword">open</a> <a id="223" class="Keyword">import</a> <a id="230" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="262" class="Keyword">open</a> <a id="267" class="Keyword">import</a> <a id="274" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="290" class="Keyword">open</a> <a id="295" class="Keyword">import</a> <a id="302" href="Data.Maybe.Instances.Alt.html" class="Module">Data.Maybe.Instances.Alt</a>
<a id="327" class="Keyword">open</a> <a id="332" class="Keyword">import</a> <a id="339" href="Data.Reflection.Abs.html" class="Module">Data.Reflection.Abs</a>
<a id="359" class="Keyword">open</a> <a id="364" class="Keyword">import</a> <a id="371" href="Data.Reflection.Argument.html" class="Module">Data.Reflection.Argument</a>
<a id="396" class="Keyword">open</a> <a id="401" class="Keyword">import</a> <a id="408" href="Data.Reflection.Error.html" class="Module">Data.Reflection.Error</a>
<a id="430" class="Keyword">open</a> <a id="435" class="Keyword">import</a> <a id="442" href="Data.Reflection.Fixity.html" class="Module">Data.Reflection.Fixity</a>
<a id="465" class="Keyword">open</a> <a id="470" class="Keyword">import</a> <a id="477" href="Data.Reflection.Instances.FromString.html" class="Module">Data.Reflection.Instances.FromString</a>
<a id="514" class="Keyword">open</a> <a id="519" class="Keyword">import</a> <a id="526" href="Data.Reflection.Literal.html" class="Module">Data.Reflection.Literal</a>
<a id="550" class="Keyword">open</a> <a id="555" class="Keyword">import</a> <a id="562" href="Data.Reflection.Meta.html" class="Module">Data.Reflection.Meta</a>
<a id="583" class="Keyword">open</a> <a id="588" class="Keyword">import</a> <a id="595" href="Data.Reflection.Name.html" class="Module">Data.Reflection.Name</a>
<a id="616" class="Keyword">open</a> <a id="621" class="Keyword">import</a> <a id="628" href="Data.Reflection.Term.html" class="Module">Data.Reflection.Term</a>


<a id="651" class="Comment">{-
A tactic for reducing &quot;transport refl x&quot; in other-wise normal terms. The
implementation is actually surprisingly simple: A term of the form (e.g.)

    transp (λ _ → A) i0 (f (transp (λ _ → B) i0 x))

is already a blueprint for how to normalise it. We simply have to turn it into

    λ i → transp (λ _ → A) i (f (transp (λ _ → B) i x))

so that the constant transports reduce away when (i = i1). Abstracting over i,
this gives a path from the initial term to its &quot;regular normal form&quot;, which
may be the worst name ever.

More generally, we replace terms of the form `transp Al φ x` with `transp Al (φ ∨ i) x`
recursively (inside-out), on the condition that Al is constant when i = i1.
-}</a>

<a id="1344" class="Keyword">private</a>
  <a id="1354" class="Keyword">open</a> <a id="1359" class="Keyword">import</a> <a id="1366" href="Agda.Primitive.Cubical.html" class="Module">Agda.Primitive.Cubical</a> <a id="1389" class="Keyword">using</a> <a id="1395" class="Symbol">(</a> <a id="1397" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a> <a id="1407" class="Symbol">)</a>
  <a id="1411" class="Comment">-- We have a double composition operator that doesn&#39;t use the</a>
  <a id="1475" class="Comment">-- fancy hcomp syntax in its definition. This has better type</a>
  <a id="1539" class="Comment">-- inference for one of the macros since it guarantees that the base</a>
  <a id="1610" class="Comment">-- (q i) is independent of j without any reduction.</a>
  <a id="double-comp"></a><a id="1664" href="Meta.Regularity.html#1664" class="Function">double-comp</a>
    <a id="1680" class="Symbol">:</a> <a id="1682" class="Symbol">∀</a> <a id="1684" class="Symbol">{</a><a id="1685" href="Meta.Regularity.html#1685" class="Bound">ℓ</a><a id="1686" class="Symbol">}</a> <a id="1688" class="Symbol">{</a><a id="1689" href="Meta.Regularity.html#1689" class="Bound">A</a> <a id="1691" class="Symbol">:</a> <a id="1693" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="1698" href="Meta.Regularity.html#1685" class="Bound">ℓ</a><a id="1699" class="Symbol">}</a> <a id="1701" class="Symbol">{</a><a id="1702" href="Meta.Regularity.html#1702" class="Bound">w</a> <a id="1704" href="Meta.Regularity.html#1704" class="Bound">z</a> <a id="1706" class="Symbol">:</a> <a id="1708" href="Meta.Regularity.html#1689" class="Bound">A</a><a id="1709" class="Symbol">}</a> <a id="1711" class="Symbol">(</a><a id="1712" href="Meta.Regularity.html#1712" class="Bound">x</a> <a id="1714" href="Meta.Regularity.html#1714" class="Bound">y</a> <a id="1716" class="Symbol">:</a> <a id="1718" href="Meta.Regularity.html#1689" class="Bound">A</a><a id="1719" class="Symbol">)</a>
    <a id="1725" class="Symbol">→</a> <a id="1727" href="Meta.Regularity.html#1702" class="Bound">w</a> <a id="1729" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1731" href="Meta.Regularity.html#1712" class="Bound">x</a> <a id="1733" class="Symbol">→</a> <a id="1735" href="Meta.Regularity.html#1712" class="Bound">x</a> <a id="1737" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1739" href="Meta.Regularity.html#1714" class="Bound">y</a> <a id="1741" class="Symbol">→</a> <a id="1743" href="Meta.Regularity.html#1714" class="Bound">y</a> <a id="1745" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1747" href="Meta.Regularity.html#1704" class="Bound">z</a>
    <a id="1753" class="Symbol">→</a> <a id="1755" href="Meta.Regularity.html#1702" class="Bound">w</a> <a id="1757" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="1759" href="Meta.Regularity.html#1704" class="Bound">z</a>
  <a id="1763" href="Meta.Regularity.html#1664" class="Function">double-comp</a> <a id="1775" href="Meta.Regularity.html#1775" class="Bound">x</a> <a id="1777" href="Meta.Regularity.html#1777" class="Bound">y</a> <a id="1779" href="Meta.Regularity.html#1779" class="Bound">p</a> <a id="1781" href="Meta.Regularity.html#1781" class="Bound">q</a> <a id="1783" href="Meta.Regularity.html#1783" class="Bound">r</a> <a id="1785" href="Meta.Regularity.html#1785" class="Bound">i</a> <a id="1787" class="Symbol">=</a> <a id="1789" href="Agda.Primitive.Cubical.html#1924" class="Primitive">primHComp</a>
    <a id="1803" class="Symbol">(λ</a> <a id="1806" class="Symbol">{</a> <a id="1808" href="Meta.Regularity.html#1808" class="Bound">j</a> <a id="1810" class="Symbol">(</a><a id="1811" href="Meta.Regularity.html#1785" class="Bound">i</a> <a id="1813" class="Symbol">=</a> <a id="1815" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="1817" class="Symbol">)</a> <a id="1819" class="Symbol">→</a> <a id="1821" href="Meta.Regularity.html#1779" class="Bound">p</a> <a id="1823" class="Symbol">(</a><a id="1824" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="1826" href="Meta.Regularity.html#1808" class="Bound">j</a><a id="1827" class="Symbol">)</a> <a id="1829" class="Symbol">;</a> <a id="1831" href="Meta.Regularity.html#1831" class="Bound">j</a> <a id="1833" class="Symbol">(</a><a id="1834" href="Meta.Regularity.html#1785" class="Bound">i</a> <a id="1836" class="Symbol">=</a> <a id="1838" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="1840" class="Symbol">)</a> <a id="1842" class="Symbol">→</a> <a id="1844" href="Meta.Regularity.html#1783" class="Bound">r</a> <a id="1846" href="Meta.Regularity.html#1831" class="Bound">j</a> <a id="1848" class="Symbol">})</a> <a id="1851" class="Symbol">(</a><a id="1852" href="Meta.Regularity.html#1781" class="Bound">q</a> <a id="1854" href="Meta.Regularity.html#1785" class="Bound">i</a><a id="1855" class="Symbol">)</a>

  <a id="1860" class="Comment">-- The regularity tactic can operate in two modes: `precise` will work</a>
  <a id="1933" class="Comment">-- with the type-checker to identify which `transp`s are along refl,</a>
  <a id="2004" class="Comment">-- and which should be preserved. The `fast` mode says YOLO and</a>
  <a id="2070" class="Comment">-- assumes that **every** application of `transp` is one that would</a>
  <a id="2140" class="Comment">-- reduce by regularity. Needless to say, only use `fast` when you&#39;re</a>
  <a id="2212" class="Comment">-- sure that&#39;s the case (e.g. the fibres of a displayed category over</a>
  <a id="2284" class="Comment">-- Sets)</a>
  <a id="2295" class="Keyword">data</a> <a id="Regularity-precision"></a><a id="2300" href="Meta.Regularity.html#2300" class="Datatype">Regularity-precision</a> <a id="2321" class="Symbol">:</a> <a id="2323" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="2328" class="Keyword">where</a>
    <a id="Regularity-precision.precise"></a><a id="2338" href="Meta.Regularity.html#2338" class="InductiveConstructor">precise</a> <a id="Regularity-precision.fast"></a><a id="2346" href="Meta.Regularity.html#2346" class="InductiveConstructor">fast</a> <a id="2351" class="Symbol">:</a> <a id="2353" href="Meta.Regularity.html#2300" class="Datatype">Regularity-precision</a>
  <a id="2376" class="Comment">-- As the name implies, `precise` is `precise`, while `fast` is</a>
  <a id="2442" class="Comment">-- `fast`. The reason is that `fast` will avoid traversing many of the</a>
  <a id="2515" class="Comment">-- terms involved in a `transp`: It doesn&#39;t care about the level, it</a>
  <a id="2586" class="Comment">-- doesn&#39;t care about the line, and it doesn&#39;t care about the</a>
  <a id="2650" class="Comment">-- cofibration.</a>

  <a id="2669" class="Comment">-- The core of the tactic is this triad of mutually recursive</a>
  <a id="2733" class="Comment">-- functions. In all three of them, the `Nat` argument indicates how</a>
  <a id="2804" class="Comment">-- many binders we&#39;ve gone under: it is the dimension variable we</a>
  <a id="2872" class="Comment">-- abstracted over at the start.</a>
  <a id="refl-transport"></a><a id="2907" href="Meta.Regularity.html#2907" class="Function">refl-transport</a> <a id="2922" class="Symbol">:</a> <a id="2924" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2926" class="Symbol">→</a> <a id="2928" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2933" class="Symbol">→</a> <a id="2935" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="2938" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="2945" class="Comment">-- ^ Determines whether an application of `transp` is a case of</a>
  <a id="3011" class="Comment">-- regularity, and if so, replaces it by `regular`. Precondition: its</a>
  <a id="3083" class="Comment">-- subterms must already be reduced.</a>
  <a id="go"></a><a id="3122" href="Meta.Regularity.html#3122" class="Function">go</a>  <a id="3126" class="Symbol">:</a> <a id="3128" href="Meta.Regularity.html#2300" class="Datatype">Regularity-precision</a> <a id="3149" class="Symbol">→</a> <a id="3151" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3153" class="Symbol">→</a> <a id="3155" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3160" class="Symbol">→</a> <a id="3162" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="3165" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="3172" class="Comment">-- ^ Reduces all the subterms, and finds applications of `transp` to</a>
  <a id="3243" class="Comment">-- hand off to `refl-transport`.</a>
  <a id="go*"></a><a id="3278" href="Meta.Regularity.html#3278" class="Function">go*</a> <a id="3282" class="Symbol">:</a> <a id="3284" href="Meta.Regularity.html#2300" class="Datatype">Regularity-precision</a> <a id="3305" class="Symbol">→</a> <a id="3307" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3309" class="Symbol">→</a> <a id="3311" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3316" class="Symbol">(</a><a id="3317" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3321" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3325" class="Symbol">)</a> <a id="3327" class="Symbol">→</a> <a id="3329" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="3332" class="Symbol">(</a><a id="3333" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3338" class="Symbol">(</a><a id="3339" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3343" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3347" class="Symbol">))</a>
  <a id="3352" class="Comment">-- ^ Isn&#39;t the termination checker just lovely?</a>

  <a id="3403" href="Meta.Regularity.html#2907" class="Function">refl-transport</a> <a id="3418" href="Meta.Regularity.html#3418" class="Bound">n</a> <a id="3420" href="Meta.Regularity.html#3420" class="Bound">tm</a><a id="3422" class="Symbol">@(</a><a id="3424" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3428" class="Symbol">(</a><a id="3429" class="Keyword">quote</a> <a id="3435" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3441" class="Symbol">)</a> <a id="3443" class="Symbol">(</a><a id="3444" href="Meta.Regularity.html#3444" class="Bound">ℓ</a> <a id="3446" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="3449" href="Meta.Regularity.html#3449" class="Bound">Al</a> <a id="3452" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3455" href="Meta.Regularity.html#3455" class="Bound">φ</a> <a id="3457" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3460" href="Meta.Regularity.html#3460" class="Bound">x</a> <a id="3462" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3465" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3467" class="Symbol">))</a> <a id="3470" class="Symbol">=</a>
    <a id="3476" class="Comment">-- This match might make you wonder: Can&#39;t Al be a line of</a>
    <a id="3539" class="Comment">-- functions, so that the transport will have more arguments? No:</a>
    <a id="3609" class="Comment">-- The term is in normal form.</a>
    <a id="3644" class="Symbol">(</a><a id="3645" class="Keyword">do</a>
      <a id="3654" href="Agda.Builtin.Reflection.html#11091" class="Postulate">debug-print</a> <a id="3666" class="String">&quot;tactic.regularity&quot;</a> <a id="3686" class="Number">10</a> <a id="3689" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="3691" class="String">&quot;Checking regularity of &quot;</a> <a id="3717" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3719" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="3728" href="Meta.Regularity.html#3420" class="Bound">tm</a> <a id="3731" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3733" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="3742" class="Keyword">let</a> <a id="3746" href="Meta.Regularity.html#3746" class="Bound">φ′</a> <a id="3749" class="Symbol">=</a> <a id="3751" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3755" class="Symbol">(</a><a id="3756" class="Keyword">quote</a> <a id="3762" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="3765" class="Symbol">)</a> <a id="3767" class="Symbol">(</a><a id="3768" href="Meta.Regularity.html#3455" class="Bound">φ</a> <a id="3770" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3773" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="3777" href="Meta.Regularity.html#3418" class="Bound">n</a> <a id="3779" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="3782" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3785" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3787" class="Symbol">)</a>
      <a id="3795" class="Keyword">let</a> <a id="3799" href="Meta.Regularity.html#3799" class="Bound">tm′</a> <a id="3803" class="Symbol">=</a> <a id="3805" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="3809" class="Symbol">(</a><a id="3810" class="Keyword">quote</a> <a id="3816" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="3822" class="Symbol">)</a> <a id="3824" class="Symbol">(</a><a id="3825" href="Meta.Regularity.html#3444" class="Bound">ℓ</a> <a id="3827" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="3830" href="Meta.Regularity.html#3449" class="Bound">Al</a> <a id="3833" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3836" href="Meta.Regularity.html#3746" class="Bound">φ′</a> <a id="3839" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3842" href="Meta.Regularity.html#3460" class="Bound">x</a> <a id="3844" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="3847" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3849" class="Symbol">)</a>
      <a id="3857" class="Comment">-- We simply ask Agda to check that the newly constructed term `transp Al (φ ∨ i) x`</a>
      <a id="3948" class="Comment">-- is correct, i.e. that Al is constant on (i = i1).</a>
      <a id="4007" class="Comment">-- If it isn&#39;t, we backtrack and leave the term unchanged.</a>
      <a id="4072" class="Comment">-- Note that if Al itself contains constant transports, we have already processed those,</a>
      <a id="4167" class="Comment">-- so they reduce away when (i = i1).</a>
      <a id="4211" href="Agda.Builtin.Reflection.html#8929" class="Postulate">check-type</a> <a id="4222" href="Meta.Regularity.html#3799" class="Bound">tm′</a> <a id="4226" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="4234" class="Comment">-- inferType doesn&#39;t trigger the constancy check https://github.com/agda/agda/issues/6585</a>
      <a id="4330" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="4335" href="Meta.Regularity.html#3799" class="Bound">tm′</a><a id="4338" class="Symbol">)</a> <a id="4340" href="Meta.Effect.Alt.html#342" class="Field Operator">&lt;|&gt;</a>
    <a id="4348" class="Symbol">(</a><a id="4349" class="Keyword">do</a>
      <a id="4358" href="Agda.Builtin.Reflection.html#11091" class="Postulate">debug-print</a> <a id="4370" class="String">&quot;tactic.regularity&quot;</a> <a id="4390" class="Number">10</a> <a id="4393" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="4395" class="String">&quot;NOT a (transport refl): &quot;</a> <a id="4422" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4424" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="4433" href="Meta.Regularity.html#3420" class="Bound">tm</a> <a id="4436" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4438" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="4447" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="4452" href="Meta.Regularity.html#3420" class="Bound">tm</a><a id="4454" class="Symbol">)</a>
  <a id="4458" href="Meta.Regularity.html#2907" class="CatchallClause Function">refl-transport</a><a id="4472" class="CatchallClause"> </a><a id="4473" class="CatchallClause Symbol">_</a><a id="4474" class="CatchallClause"> </a><a id="4475" href="Meta.Regularity.html#4475" class="CatchallClause Bound">tm</a> <a id="4478" class="Symbol">=</a> <a id="4480" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="4485" href="Meta.Regularity.html#4475" class="Bound">tm</a>

  <a id="4491" class="Comment">-- Boring term traversal.</a>
  <a id="4519" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="4522" href="Meta.Regularity.html#4522" class="Bound">pre</a> <a id="4526" href="Meta.Regularity.html#4526" class="Bound">n</a> <a id="4528" class="Symbol">(</a><a id="4529" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4533" href="Meta.Regularity.html#4533" class="Bound">x</a> <a id="4535" href="Meta.Regularity.html#4535" class="Bound">args</a><a id="4539" class="Symbol">)</a> <a id="4541" class="Symbol">=</a> <a id="4543" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4547" href="Meta.Regularity.html#4533" class="Bound">x</a> <a id="4549" href="Meta.Effect.Map.html#406" class="Function Operator">&lt;$&gt;</a> <a id="4553" href="Meta.Regularity.html#3278" class="Function">go*</a> <a id="4557" href="Meta.Regularity.html#4522" class="Bound">pre</a> <a id="4561" href="Meta.Regularity.html#4526" class="Bound">n</a> <a id="4563" href="Meta.Regularity.html#4535" class="Bound">args</a>
  <a id="4570" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="4573" href="Meta.Regularity.html#4573" class="Bound">pre</a> <a id="4577" href="Meta.Regularity.html#4577" class="Bound">n</a> <a id="4579" class="Symbol">(</a><a id="4580" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4584" href="Meta.Regularity.html#4584" class="Bound">c</a> <a id="4586" href="Meta.Regularity.html#4586" class="Bound">args</a><a id="4590" class="Symbol">)</a> <a id="4592" class="Symbol">=</a> <a id="4594" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="4598" href="Meta.Regularity.html#4584" class="Bound">c</a> <a id="4600" href="Meta.Effect.Map.html#406" class="Function Operator">&lt;$&gt;</a> <a id="4604" href="Meta.Regularity.html#3278" class="Function">go*</a> <a id="4608" href="Meta.Regularity.html#4573" class="Bound">pre</a> <a id="4612" href="Meta.Regularity.html#4577" class="Bound">n</a> <a id="4614" href="Meta.Regularity.html#4586" class="Bound">args</a>
  <a id="4621" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="4624" href="Meta.Regularity.html#2346" class="InductiveConstructor">fast</a> <a id="4629" href="Meta.Regularity.html#4629" class="Bound">n</a> <a id="4631" class="Symbol">(</a><a id="4632" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4636" class="Symbol">(</a><a id="4637" class="Keyword">quote</a> <a id="4643" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4649" class="Symbol">)</a> <a id="4651" class="Symbol">(</a><a id="4652" href="Meta.Regularity.html#4652" class="Bound">ℓ</a> <a id="4654" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="4657" href="Meta.Regularity.html#4657" class="Bound">Al</a> <a id="4660" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4663" href="Meta.Regularity.html#4663" class="Bound">φ</a> <a id="4665" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4668" href="Meta.Regularity.html#4668" class="Bound">x</a> <a id="4670" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4673" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4675" class="Symbol">))</a> <a id="4678" class="Symbol">=</a> <a id="4680" class="Keyword">do</a>
    <a id="4687" href="Meta.Regularity.html#4687" class="Bound">x</a> <a id="4689" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="4691" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="4694" href="Meta.Regularity.html#2346" class="InductiveConstructor">fast</a> <a id="4699" href="Meta.Regularity.html#4629" class="Bound">n</a> <a id="4701" href="Meta.Regularity.html#4668" class="Bound">x</a>
    <a id="4707" class="Keyword">let</a> <a id="4711" href="Meta.Regularity.html#4711" class="Bound">φ′</a> <a id="4714" class="Symbol">=</a> <a id="4716" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4720" class="Symbol">(</a><a id="4721" class="Keyword">quote</a> <a id="4727" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">_∨_</a><a id="4730" class="Symbol">)</a> <a id="4732" class="Symbol">(</a><a id="4733" href="Meta.Regularity.html#4663" class="Bound">φ</a> <a id="4735" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4738" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="4742" href="Meta.Regularity.html#4629" class="Bound">n</a> <a id="4744" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4747" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4750" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4752" class="Symbol">)</a>
    <a id="4758" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="4763" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="4765" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4769" class="Symbol">(</a><a id="4770" class="Keyword">quote</a> <a id="4776" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a><a id="4782" class="Symbol">)</a> <a id="4784" class="Symbol">(</a><a id="4785" href="Meta.Regularity.html#4652" class="Bound">ℓ</a> <a id="4787" href="Data.Reflection.Argument.html#1397" class="InductiveConstructor Operator">h∷</a> <a id="4790" href="Meta.Regularity.html#4657" class="Bound">Al</a> <a id="4793" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4796" href="Meta.Regularity.html#4711" class="Bound">φ′</a> <a id="4799" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4802" href="Meta.Regularity.html#4687" class="Bound">x</a> <a id="4804" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="4807" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4809" class="Symbol">)</a>
  <a id="4813" href="Meta.Regularity.html#3122" class="CatchallClause Function">go</a><a id="4815" class="CatchallClause"> </a><a id="4816" href="Meta.Regularity.html#4816" class="CatchallClause Bound">pre</a><a id="4819" class="CatchallClause"> </a><a id="4820" href="Meta.Regularity.html#4820" class="CatchallClause Bound">n</a><a id="4821" class="CatchallClause"> </a><a id="4822" class="CatchallClause Symbol">(</a><a id="4823" href="Agda.Builtin.Reflection.html#5251" class="CatchallClause InductiveConstructor">def</a><a id="4826" class="CatchallClause"> </a><a id="4827" href="Meta.Regularity.html#4827" class="CatchallClause Bound">f</a><a id="4828" class="CatchallClause"> </a><a id="4829" href="Meta.Regularity.html#4829" class="CatchallClause Bound">args</a><a id="4833" class="CatchallClause Symbol">)</a> <a id="4835" class="Symbol">=</a> <a id="4837" class="Keyword">do</a>
    <a id="4844" href="Meta.Regularity.html#4844" class="Bound">as</a> <a id="4847" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="4849" href="Meta.Regularity.html#3278" class="Function">go*</a> <a id="4853" href="Meta.Regularity.html#4816" class="Bound">pre</a> <a id="4857" href="Meta.Regularity.html#4820" class="Bound">n</a> <a id="4859" href="Meta.Regularity.html#4829" class="Bound">args</a>
    <a id="4868" href="Meta.Regularity.html#2907" class="Function">refl-transport</a> <a id="4883" href="Meta.Regularity.html#4820" class="Bound">n</a> <a id="4885" class="Symbol">(</a><a id="4886" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="4890" href="Meta.Regularity.html#4827" class="Bound">f</a> <a id="4892" href="Meta.Regularity.html#4844" class="Bound">as</a><a id="4894" class="Symbol">)</a>
  <a id="4898" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="4901" href="Meta.Regularity.html#4901" class="Bound">pre</a> <a id="4905" href="Meta.Regularity.html#4905" class="Bound">k</a> <a id="4907" href="Meta.Regularity.html#4907" class="Bound">t</a><a id="4908" class="Symbol">@(</a><a id="4910" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4914" href="Meta.Regularity.html#4914" class="Bound">v</a> <a id="4916" class="Symbol">(</a><a id="4917" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4921" href="Meta.Regularity.html#4921" class="Bound">nm</a> <a id="4924" href="Meta.Regularity.html#4924" class="Bound">b</a><a id="4925" class="Symbol">))</a> <a id="4928" class="Symbol">=</a> <a id="4930" href="Agda.Builtin.Reflection.html#5308" class="InductiveConstructor">lam</a> <a id="4934" href="Meta.Regularity.html#4914" class="Bound">v</a> <a id="4936" href="Foundations.Pi.Base.html#2101" class="Function Operator">∘</a> <a id="4938" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="4942" href="Meta.Regularity.html#4921" class="Bound">nm</a> <a id="4945" href="Meta.Effect.Map.html#406" class="Function Operator">&lt;$&gt;</a> <a id="4949" href="Meta.Reflection.Base.html#3400" class="Function">under-abs</a> <a id="4959" href="Meta.Regularity.html#4907" class="Bound">t</a> <a id="4961" class="Symbol">(</a><a id="4962" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="4965" href="Meta.Regularity.html#4901" class="Bound">pre</a> <a id="4969" class="Symbol">(</a><a id="4970" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4974" href="Meta.Regularity.html#4905" class="Bound">k</a><a id="4975" class="Symbol">)</a> <a id="4977" href="Meta.Regularity.html#4924" class="Bound">b</a><a id="4978" class="Symbol">)</a>
  <a id="4982" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="4985" href="Meta.Regularity.html#4985" class="Bound">pre</a> <a id="4989" href="Meta.Regularity.html#4989" class="Bound">n</a> <a id="4991" class="Symbol">(</a><a id="4992" href="Agda.Builtin.Reflection.html#5361" class="InductiveConstructor">pat-lam</a> <a id="5000" href="Meta.Regularity.html#5000" class="Bound">cs</a> <a id="5003" href="Meta.Regularity.html#5003" class="Bound">args</a><a id="5007" class="Symbol">)</a> <a id="5009" class="Symbol">=</a> <a id="5011" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a> <a id="5022" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="5024" class="String">&quot;regularity: Can not deal with pattern lambdas&quot;</a> <a id="5072" class="Comment">-- TODO can we do something about this?</a>
  <a id="5114" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="5117" href="Meta.Regularity.html#5117" class="Bound">pre</a> <a id="5121" href="Meta.Regularity.html#5121" class="Bound">n</a> <a id="5123" href="Meta.Regularity.html#5123" class="Bound">t</a><a id="5124" class="Symbol">@(</a><a id="5126" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="5129" class="Symbol">(</a><a id="5130" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5134" href="Meta.Regularity.html#5134" class="Bound">i</a> <a id="5136" href="Meta.Regularity.html#5136" class="Bound">a</a><a id="5137" class="Symbol">)</a> <a id="5139" class="Symbol">(</a><a id="5140" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="5144" href="Meta.Regularity.html#5144" class="Bound">nm</a> <a id="5147" href="Meta.Regularity.html#5147" class="Bound">b</a><a id="5148" class="Symbol">))</a> <a id="5151" class="Symbol">=</a> <a id="5153" class="Keyword">do</a>
    <a id="5160" href="Meta.Regularity.html#5160" class="Bound">a</a> <a id="5162" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5164" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="5167" href="Meta.Regularity.html#5117" class="Bound">pre</a> <a id="5171" href="Meta.Regularity.html#5121" class="Bound">n</a> <a id="5173" href="Meta.Regularity.html#5136" class="Bound">a</a>
    <a id="5179" href="Meta.Regularity.html#5179" class="Bound">b</a> <a id="5181" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5183" href="Meta.Reflection.Base.html#3400" class="Function">under-abs</a> <a id="5193" href="Meta.Regularity.html#5123" class="Bound">t</a> <a id="5195" class="Symbol">(</a><a id="5196" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="5199" href="Meta.Regularity.html#5117" class="Bound">pre</a> <a id="5203" class="Symbol">(</a><a id="5204" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="5208" href="Meta.Regularity.html#5121" class="Bound">n</a><a id="5209" class="Symbol">)</a> <a id="5211" href="Meta.Regularity.html#5147" class="Bound">b</a><a id="5212" class="Symbol">)</a>
    <a id="5218" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="5223" class="Symbol">(</a><a id="5224" href="Agda.Builtin.Reflection.html#5426" class="InductiveConstructor">pi</a> <a id="5227" class="Symbol">(</a><a id="5228" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5232" href="Meta.Regularity.html#5134" class="Bound">i</a> <a id="5234" href="Meta.Regularity.html#5160" class="Bound">a</a><a id="5235" class="Symbol">)</a> <a id="5237" class="Symbol">(</a><a id="5238" href="Agda.Builtin.Reflection.html#4285" class="InductiveConstructor">abs</a> <a id="5242" href="Meta.Regularity.html#5144" class="Bound">nm</a> <a id="5245" href="Meta.Regularity.html#5179" class="Bound">b</a><a id="5246" class="Symbol">))</a>
  <a id="5251" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="5254" href="Meta.Regularity.html#5254" class="Bound">pre</a> <a id="5258" href="Meta.Regularity.html#5258" class="Bound">n</a> <a id="5260" class="Symbol">(</a><a id="5261" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="5271" href="Meta.Regularity.html#5271" class="Bound">s</a><a id="5272" class="Symbol">)</a> <a id="5274" class="Symbol">=</a> <a id="5276" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="5281" class="Symbol">(</a><a id="5282" href="Agda.Builtin.Reflection.html#5477" class="InductiveConstructor">agda-sort</a> <a id="5292" href="Meta.Regularity.html#5271" class="Bound">s</a><a id="5293" class="Symbol">)</a>
  <a id="5297" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="5300" href="Meta.Regularity.html#5300" class="Bound">pre</a> <a id="5304" href="Meta.Regularity.html#5304" class="Bound">n</a> <a id="5306" class="Symbol">(</a><a id="5307" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5311" href="Meta.Regularity.html#5311" class="Bound">l</a><a id="5312" class="Symbol">)</a> <a id="5314" class="Symbol">=</a> <a id="5316" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="5321" class="Symbol">(</a><a id="5322" href="Agda.Builtin.Reflection.html#5509" class="InductiveConstructor">lit</a> <a id="5326" href="Meta.Regularity.html#5311" class="Bound">l</a><a id="5327" class="Symbol">)</a>
  <a id="5331" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="5334" href="Meta.Regularity.html#5334" class="Bound">pre</a> <a id="5338" href="Meta.Regularity.html#5338" class="Bound">n</a> <a id="5340" class="Symbol">(</a><a id="5341" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5346" href="Meta.Regularity.html#5346" class="Bound">x</a> <a id="5348" href="Meta.Regularity.html#5348" class="Bound">args</a><a id="5352" class="Symbol">)</a> <a id="5354" class="Symbol">=</a> <a id="5356" href="Agda.Builtin.Reflection.html#5544" class="InductiveConstructor">meta</a> <a id="5361" href="Meta.Regularity.html#5346" class="Bound">x</a> <a id="5363" href="Meta.Effect.Map.html#406" class="Function Operator">&lt;$&gt;</a> <a id="5367" href="Meta.Regularity.html#3278" class="Function">go*</a> <a id="5371" href="Meta.Regularity.html#5334" class="Bound">pre</a> <a id="5375" href="Meta.Regularity.html#5338" class="Bound">n</a> <a id="5377" href="Meta.Regularity.html#5348" class="Bound">args</a>
  <a id="5384" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="5387" href="Meta.Regularity.html#5387" class="Bound">pre</a> <a id="5391" href="Meta.Regularity.html#5391" class="Bound">n</a> <a id="5393" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a> <a id="5401" class="Symbol">=</a> <a id="5403" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="5408" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

  <a id="5419" href="Meta.Regularity.html#3278" class="Function">go*</a> <a id="5423" href="Meta.Regularity.html#5423" class="Bound">pre</a> <a id="5427" href="Meta.Regularity.html#5427" class="Bound">n</a> <a id="5429" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="5432" class="Symbol">=</a> <a id="5434" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="5439" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="5444" href="Meta.Regularity.html#3278" class="Function">go*</a> <a id="5448" href="Meta.Regularity.html#5448" class="Bound">pre</a> <a id="5452" href="Meta.Regularity.html#5452" class="Bound">n</a> <a id="5454" class="Symbol">(</a><a id="5455" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5459" href="Meta.Regularity.html#5459" class="Bound">i</a> <a id="5461" href="Meta.Regularity.html#5461" class="Bound">a</a> <a id="5463" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5465" href="Meta.Regularity.html#5465" class="Bound">as</a><a id="5467" class="Symbol">)</a> <a id="5469" class="Symbol">=</a> <a id="5471" class="Keyword">do</a>
    <a id="5478" href="Meta.Regularity.html#5478" class="Bound">a</a> <a id="5480" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5482" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="5485" href="Meta.Regularity.html#5448" class="Bound">pre</a> <a id="5489" href="Meta.Regularity.html#5452" class="Bound">n</a> <a id="5491" href="Meta.Regularity.html#5461" class="Bound">a</a>
    <a id="5497" class="Symbol">(</a><a id="5498" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="5502" href="Meta.Regularity.html#5459" class="Bound">i</a> <a id="5504" href="Meta.Regularity.html#5478" class="Bound">a</a> <a id="5506" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷_</a><a id="5508" class="Symbol">)</a> <a id="5510" href="Meta.Effect.Map.html#406" class="Function Operator">&lt;$&gt;</a> <a id="5514" href="Meta.Regularity.html#3278" class="Function">go*</a> <a id="5518" href="Meta.Regularity.html#5448" class="Bound">pre</a> <a id="5522" href="Meta.Regularity.html#5452" class="Bound">n</a> <a id="5524" href="Meta.Regularity.html#5465" class="Bound">as</a>

  <a id="5530" class="Comment">-- To turn a term into a regularity path, given a level of precision,</a>
  <a id="5602" class="Comment">-- all we have to do is raise the term by one, do the procedure above,</a>
  <a id="5675" class="Comment">-- then wrap it in a lambda. Nice!</a>
  <a id="to-regularity-path"></a><a id="5712" href="Meta.Regularity.html#5712" class="Function">to-regularity-path</a> <a id="5731" class="Symbol">:</a> <a id="5733" href="Meta.Regularity.html#2300" class="Datatype">Regularity-precision</a> <a id="5754" class="Symbol">→</a> <a id="5756" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5761" class="Symbol">→</a> <a id="5763" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="5766" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="5773" href="Meta.Regularity.html#5712" class="Function">to-regularity-path</a> <a id="5792" href="Meta.Regularity.html#5792" class="Bound">pre</a> <a id="5796" href="Meta.Regularity.html#5796" class="Bound">tm</a> <a id="5799" class="Symbol">=</a> <a id="5801" class="Keyword">do</a>
    <a id="5808" href="Meta.Regularity.html#5808" class="Bound">tm</a> <a id="5811" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="5813" href="Meta.Reflection.Subst.html#7597" class="Function">raiseTC</a> <a id="5821" class="Number">1</a> <a id="5823" href="Meta.Regularity.html#5796" class="Bound">tm</a>
    <a id="5830" class="Comment">-- Since we&#39;ll be comparing terms, Agda really wants them to be</a>
    <a id="5898" class="Comment">-- well-scoped. Since we shifted eeeverything up by one, we have to</a>
    <a id="5970" class="Comment">-- grow the context, too.</a>
    <a id="6000" href="Meta.Regularity.html#6000" class="Bound">tm</a> <a id="6003" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6005" href="Meta.Reflection.Base.html#4752" class="Function">resetting</a> <a id="6015" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="6017" href="Agda.Builtin.Reflection.html#9292" class="Postulate">extend-context</a> <a id="6032" class="String">&quot;i&quot;</a> <a id="6036" class="Symbol">(</a><a id="6037" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="6042" class="Symbol">(</a><a id="6043" class="Keyword">quoteTerm</a> <a id="6053" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="6054" class="Symbol">))</a> <a id="6057" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="6059" href="Meta.Regularity.html#3122" class="Function">go</a> <a id="6062" href="Meta.Regularity.html#5792" class="Bound">pre</a> <a id="6066" class="Number">0</a> <a id="6068" href="Meta.Regularity.html#5808" class="Bound">tm</a>
    <a id="6075" href="Meta.Effect.Idiom.html#376" class="Field">pure</a> <a id="6080" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="6082" href="Meta.Reflection.Base.html#4228" class="Function">vlam</a> <a id="6087" class="String">&quot;i&quot;</a> <a id="6091" href="Meta.Regularity.html#6000" class="Bound">tm</a>

  <a id="6097" class="Comment">-- Extend a path x ＝ y to a path x′ ＝ y′, where x′ --&gt; x and y′ --&gt; y</a>
  <a id="6169" class="Comment">-- under the given regularity precision. Shorthand for composing</a>
  <a id="6236" class="Comment">--    regularity! ∙ p ∙ sym regularity!.</a>
  <a id="regular!-worker"></a><a id="6279" href="Meta.Regularity.html#6279" class="Function">regular!-worker</a> <a id="6295" class="Symbol">:</a>
    <a id="6301" class="Symbol">∀</a> <a id="6303" class="Symbol">{</a><a id="6304" href="Meta.Regularity.html#6304" class="Bound">ℓ</a><a id="6305" class="Symbol">}</a> <a id="6307" class="Symbol">{</a><a id="6308" href="Meta.Regularity.html#6308" class="Bound">A</a> <a id="6310" class="Symbol">:</a> <a id="6312" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="6317" href="Meta.Regularity.html#6304" class="Bound">ℓ</a><a id="6318" class="Symbol">}</a> <a id="6320" class="Symbol">{</a><a id="6321" href="Meta.Regularity.html#6321" class="Bound">x</a> <a id="6323" href="Meta.Regularity.html#6323" class="Bound">y</a> <a id="6325" class="Symbol">:</a> <a id="6327" href="Meta.Regularity.html#6308" class="Bound">A</a><a id="6328" class="Symbol">}</a>
    <a id="6334" class="Symbol">→</a> <a id="6336" href="Meta.Regularity.html#2300" class="Datatype">Regularity-precision</a>
    <a id="6361" class="Symbol">→</a> <a id="6363" href="Meta.Regularity.html#6321" class="Bound">x</a> <a id="6365" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="6367" href="Meta.Regularity.html#6323" class="Bound">y</a>
    <a id="6373" class="Symbol">→</a> <a id="6375" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="6384" class="Symbol">→</a> <a id="6386" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="6389" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="6393" href="Meta.Regularity.html#6279" class="Function">regular!-worker</a> <a id="6409" class="Symbol">{</a><a id="6410" class="Argument">x</a> <a id="6412" class="Symbol">=</a> <a id="6414" href="Meta.Regularity.html#6414" class="Bound">x</a><a id="6415" class="Symbol">}</a> <a id="6417" class="Symbol">{</a><a id="6418" href="Meta.Regularity.html#6418" class="Bound">y</a><a id="6419" class="Symbol">}</a> <a id="6421" href="Meta.Regularity.html#6421" class="Bound">pre</a> <a id="6425" href="Meta.Regularity.html#6425" class="Bound">p</a> <a id="6427" href="Meta.Regularity.html#6427" class="Bound">goal</a> <a id="6432" class="Symbol">=</a> <a id="6434" class="Keyword">do</a>
    <a id="6441" href="Meta.Regularity.html#6441" class="Bound">gt</a> <a id="6444" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6446" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="6457" href="Meta.Regularity.html#6427" class="Bound">goal</a>
    <a id="6466" href="Meta.Regularity.html#6466" class="Bound">`x</a> <a id="6469" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6471" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="6479" href="Meta.Regularity.html#6414" class="Bound">x</a>
    <a id="6485" href="Meta.Regularity.html#6485" class="Bound">`y</a> <a id="6488" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6490" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="6498" href="Meta.Regularity.html#6418" class="Bound">y</a>
    <a id="6504" href="Meta.Regularity.html#6504" class="Bound">`p</a> <a id="6507" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6509" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="6517" href="Meta.Regularity.html#6425" class="Bound">p</a>
    <a id="6523" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6528" class="Symbol">(_</a> <a id="6531" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6533" href="Meta.Regularity.html#6533" class="Bound">l</a> <a id="6535" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6537" href="Meta.Regularity.html#6537" class="Bound">r</a><a id="6538" class="Symbol">)</a> <a id="6540" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6542" href="Meta.Reflection.Base.html#7354" class="Function">unapply-path</a> <a id="6555" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="6559" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="6570" href="Meta.Regularity.html#6427" class="Bound">goal</a>
      <a id="6581" class="Keyword">where</a> <a id="6587" class="CatchallClause Symbol">_</a> <a id="6589" class="Symbol">→</a> <a id="6591" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a> <a id="6602" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="6609" href="Meta.Regularity.html#6609" class="Bound">l</a> <a id="6611" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6613" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="6623" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="6627" href="Meta.Reflection.Base.html#5609" class="Function">wait-for-type</a> <a id="6641" href="Meta.Regularity.html#6533" class="Bound">l</a>
    <a id="6647" href="Meta.Regularity.html#6647" class="Bound">r</a> <a id="6649" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6651" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="6661" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="6665" href="Meta.Reflection.Base.html#5609" class="Function">wait-for-type</a> <a id="6679" href="Meta.Regularity.html#6537" class="Bound">r</a>
    <a id="6685" href="Meta.Regularity.html#6685" class="Bound">reg</a> <a id="6689" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6691" href="Meta.Regularity.html#5712" class="Function">to-regularity-path</a> <a id="6710" href="Meta.Regularity.html#6421" class="Bound">pre</a> <a id="6714" href="Meta.Regularity.html#6609" class="Bound">l</a>
    <a id="6720" href="Meta.Regularity.html#6720" class="Bound">reg′</a> <a id="6725" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="6727" href="Meta.Regularity.html#5712" class="Function">to-regularity-path</a> <a id="6746" href="Meta.Regularity.html#6421" class="Bound">pre</a> <a id="6750" href="Meta.Regularity.html#6647" class="Bound">r</a>
    <a id="6756" href="Meta.Reflection.Base.html#9079" class="Function">unify-loudly</a> <a id="6769" href="Meta.Regularity.html#6427" class="Bound">goal</a> <a id="6774" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="6776" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6780" class="Symbol">(</a><a id="6781" class="Keyword">quote</a> <a id="6787" href="Meta.Regularity.html#1664" class="Function">double-comp</a><a id="6798" class="Symbol">)</a> <a id="6800" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a>
         <a id="6811" href="Meta.Regularity.html#6466" class="Bound">`x</a> <a id="6814" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6817" href="Meta.Regularity.html#6485" class="Bound">`y</a> <a id="6820" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6823" href="Meta.Regularity.html#6685" class="Bound">reg</a>
      <a id="6833" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6836" href="Meta.Regularity.html#6504" class="Bound">`p</a>
      <a id="6845" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6848" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6852" class="Symbol">(</a><a id="6853" class="Keyword">quote</a> <a id="6859" href="Foundations.Correspondences.Binary.Symmetric.html#515" class="Function">sym</a><a id="6862" class="Symbol">)</a> <a id="6864" class="Symbol">(</a><a id="6865" href="Meta.Regularity.html#6720" class="Bound">reg′</a> <a id="6870" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6873" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6875" class="Symbol">)</a>
      <a id="6883" href="Data.Reflection.Argument.html#1364" class="InductiveConstructor Operator">v∷</a> <a id="6886" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="6890" class="Keyword">module</a> <a id="Regularity"></a><a id="6897" href="Meta.Regularity.html#6897" class="Module">Regularity</a> <a id="6908" class="Keyword">where</a>
  <a id="6916" class="Keyword">open</a> <a id="6921" href="Meta.Regularity.html#2300" class="Module">Regularity-precision</a> <a id="6942" class="Keyword">public</a>
  <a id="6951" class="Comment">-- The reflection interface: Regularity.reduce! will, well, reduce a</a>
  <a id="7022" class="Comment">-- term. There&#39;s a lot of blocking involved in making this work.</a>
  <a id="7089" class="Keyword">macro</a>
    <a id="Regularity.reduce!"></a><a id="7099" href="Meta.Regularity.html#7099" class="Function">reduce!</a> <a id="7107" class="Symbol">:</a> <a id="7109" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7114" class="Symbol">→</a> <a id="7116" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7119" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="7125" href="Meta.Regularity.html#7099" class="Function">reduce!</a> <a id="7133" href="Meta.Regularity.html#7133" class="Bound">goal</a> <a id="7138" class="Symbol">=</a> <a id="7140" class="Keyword">do</a>
      <a id="7149" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="7154" class="Symbol">(_</a> <a id="7157" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7159" href="Meta.Regularity.html#7159" class="Bound">l</a> <a id="7161" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7163" href="Meta.Regularity.html#7163" class="Bound">r</a><a id="7164" class="Symbol">)</a> <a id="7166" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="7168" href="Meta.Reflection.Base.html#7354" class="Function">unapply-path</a> <a id="7181" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="7185" href="Agda.Builtin.Reflection.html#8893" class="Postulate">infer-type</a> <a id="7196" href="Meta.Regularity.html#7133" class="Bound">goal</a>
        <a id="7209" class="Keyword">where</a> <a id="7215" class="CatchallClause Symbol">_</a> <a id="7217" class="Symbol">→</a> <a id="7219" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a> <a id="7230" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
      <a id="7239" href="Meta.Regularity.html#7239" class="Bound">reg</a> <a id="7243" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="7245" href="Meta.Regularity.html#5712" class="Function">to-regularity-path</a> <a id="7264" href="Meta.Regularity.html#2338" class="InductiveConstructor">precise</a> <a id="7272" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="7276" class="Symbol">(</a><a id="7277" href="Meta.Reflection.Base.html#5609" class="Function">wait-for-type</a> <a id="7291" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="7295" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="7305" href="Meta.Regularity.html#7159" class="Bound">l</a><a id="7306" class="Symbol">)</a>
      <a id="7314" href="Meta.Reflection.Base.html#9079" class="Function">unify-loudly</a> <a id="7327" href="Meta.Regularity.html#7133" class="Bound">goal</a> <a id="7332" href="Meta.Regularity.html#7239" class="Bound">reg</a>

    <a id="7341" class="Comment">-- We then have wrappers that reduce on one side, and expand on the</a>
    <a id="7413" class="Comment">-- other, depending on how precise you want the reduction to be.</a>
    <a id="Regularity.precise!"></a><a id="7482" href="Meta.Regularity.html#7482" class="Function">precise!</a> <a id="7491" class="Symbol">:</a> <a id="7493" class="Symbol">∀</a> <a id="7495" class="Symbol">{</a><a id="7496" href="Meta.Regularity.html#7496" class="Bound">ℓ</a><a id="7497" class="Symbol">}</a> <a id="7499" class="Symbol">{</a><a id="7500" href="Meta.Regularity.html#7500" class="Bound">A</a> <a id="7502" class="Symbol">:</a> <a id="7504" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7509" href="Meta.Regularity.html#7496" class="Bound">ℓ</a><a id="7510" class="Symbol">}</a> <a id="7512" class="Symbol">{</a><a id="7513" href="Meta.Regularity.html#7513" class="Bound">x</a> <a id="7515" href="Meta.Regularity.html#7515" class="Bound">y</a> <a id="7517" class="Symbol">:</a> <a id="7519" href="Meta.Regularity.html#7500" class="Bound">A</a><a id="7520" class="Symbol">}</a> <a id="7522" class="Symbol">→</a> <a id="7524" href="Meta.Regularity.html#7513" class="Bound">x</a> <a id="7526" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="7528" href="Meta.Regularity.html#7515" class="Bound">y</a> <a id="7530" class="Symbol">→</a> <a id="7532" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7537" class="Symbol">→</a> <a id="7539" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7542" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="Regularity.fast!"></a><a id="7548" href="Meta.Regularity.html#7548" class="Function">fast!</a> <a id="7554" class="Symbol">:</a> <a id="7556" class="Symbol">∀</a> <a id="7558" class="Symbol">{</a><a id="7559" href="Meta.Regularity.html#7559" class="Bound">ℓ</a><a id="7560" class="Symbol">}</a> <a id="7562" class="Symbol">{</a><a id="7563" href="Meta.Regularity.html#7563" class="Bound">A</a> <a id="7565" class="Symbol">:</a> <a id="7567" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="7572" href="Meta.Regularity.html#7559" class="Bound">ℓ</a><a id="7573" class="Symbol">}</a> <a id="7575" class="Symbol">{</a><a id="7576" href="Meta.Regularity.html#7576" class="Bound">x</a> <a id="7578" href="Meta.Regularity.html#7578" class="Bound">y</a> <a id="7580" class="Symbol">:</a> <a id="7582" href="Meta.Regularity.html#7563" class="Bound">A</a><a id="7583" class="Symbol">}</a> <a id="7585" class="Symbol">→</a> <a id="7587" href="Meta.Regularity.html#7576" class="Bound">x</a> <a id="7589" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="7591" href="Meta.Regularity.html#7578" class="Bound">y</a> <a id="7593" class="Symbol">→</a> <a id="7595" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7600" class="Symbol">→</a> <a id="7602" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7605" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

    <a id="7612" href="Meta.Regularity.html#7482" class="Function">precise!</a> <a id="7621" href="Meta.Regularity.html#7621" class="Bound">p</a> <a id="7623" href="Meta.Regularity.html#7623" class="Bound">goal</a> <a id="7628" class="Symbol">=</a> <a id="7630" href="Meta.Regularity.html#6279" class="Function">regular!-worker</a> <a id="7646" href="Meta.Regularity.html#2338" class="InductiveConstructor">precise</a> <a id="7654" href="Meta.Regularity.html#7621" class="Bound">p</a> <a id="7656" href="Meta.Regularity.html#7623" class="Bound">goal</a>
    <a id="7665" href="Meta.Regularity.html#7548" class="Function">fast!</a> <a id="7671" href="Meta.Regularity.html#7671" class="Bound">p</a> <a id="7673" href="Meta.Regularity.html#7673" class="Bound">goal</a> <a id="7678" class="Symbol">=</a> <a id="7680" href="Meta.Regularity.html#6279" class="Function">regular!-worker</a> <a id="7696" href="Meta.Regularity.html#2346" class="InductiveConstructor">fast</a> <a id="7701" href="Meta.Regularity.html#7671" class="Bound">p</a> <a id="7703" href="Meta.Regularity.html#7673" class="Bound">goal</a>

    <a id="7713" class="Comment">-- For debugging purposes, this macro will take a term and output</a>
    <a id="7783" class="Comment">-- its (transport refl)-normal form, according to the given level of</a>
    <a id="7856" class="Comment">-- precision.</a>
    <a id="Regularity.reduct"></a><a id="7874" href="Meta.Regularity.html#7874" class="Function">reduct</a> <a id="7881" class="Symbol">:</a> <a id="7883" href="Meta.Regularity.html#2300" class="Datatype">Regularity-precision</a> <a id="7904" class="Symbol">→</a> <a id="7906" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7911" class="Symbol">→</a> <a id="7913" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7918" class="Symbol">→</a> <a id="7920" href="Agda.Builtin.Reflection.html#8617" class="Postulate">TC</a> <a id="7923" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
    <a id="7929" href="Meta.Regularity.html#7874" class="Function">reduct</a> <a id="7936" href="Meta.Regularity.html#7936" class="Bound">pres</a> <a id="7941" href="Meta.Regularity.html#7941" class="Bound">tm</a> <a id="7944" class="Symbol">_</a> <a id="7946" class="Symbol">=</a> <a id="7948" class="Keyword">do</a>
      <a id="7957" href="Meta.Regularity.html#7957" class="Bound">orig</a> <a id="7962" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="7964" href="Meta.Reflection.Base.html#5609" class="Function">wait-for-type</a> <a id="7978" href="Meta.Effect.Bind.html#449" class="Function Operator">=&lt;&lt;</a> <a id="7982" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a> <a id="7992" href="Meta.Regularity.html#7941" class="Bound">tm</a>
      <a id="8001" href="Meta.Regularity.html#8001" class="Bound">tm</a> <a id="8004" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="8006" href="Meta.Regularity.html#5712" class="Function">to-regularity-path</a> <a id="8025" href="Meta.Regularity.html#7936" class="Bound">pres</a> <a id="8030" href="Meta.Regularity.html#7957" class="Bound">orig</a>
      <a id="8041" href="Meta.Regularity.html#8041" class="Bound">red</a> <a id="8045" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="8047" href="Meta.Reflection.Subst.html#7965" class="Function">applyTC</a> <a id="8055" href="Meta.Regularity.html#8001" class="Bound">tm</a> <a id="8058" class="Symbol">(</a><a id="8059" href="Data.Reflection.Argument.html#1588" class="Function">argN</a> <a id="8064" class="Symbol">(</a><a id="8065" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8069" class="Symbol">(</a><a id="8070" class="Keyword">quote</a> <a id="8076" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="8078" class="Symbol">)</a> <a id="8080" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8082" class="Symbol">))</a> <a id="8085" href="Meta.Effect.Bind.html#305" class="Field Operator">&gt;&gt;=</a> <a id="8089" href="Agda.Builtin.Reflection.html#8972" class="Postulate">normalise</a>
      <a id="8105" href="Meta.Regularity.html#8105" class="Bound">`pres</a> <a id="8111" href="Meta.Effect.Bind.html#305" class="Field Operator">←</a> <a id="8113" href="Agda.Builtin.Reflection.html#9104" class="Postulate">quoteTC</a> <a id="8121" href="Meta.Regularity.html#7936" class="Bound">pres</a>
      <a id="8132" href="Agda.Builtin.Reflection.html#8830" class="Postulate">type-error</a>
        <a id="8151" href="Meta.Literals.FromProduct.html#385" class="Function Operator">[</a> <a id="8153" class="String">&quot;The term\n\n  &quot;</a> <a id="8170" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8172" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8181" href="Meta.Regularity.html#7957" class="Bound">orig</a> <a id="8186" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8188" class="String">&quot;\n\nreduces modulo &quot;</a>
        <a id="8218" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8220" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8229" href="Meta.Regularity.html#8105" class="Bound">`pres</a> <a id="8235" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8237" class="String">&quot; regularity to\n\n  &quot;</a>
        <a id="8268" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8270" href="Data.Reflection.Error.html#191" class="InductiveConstructor">term-err</a> <a id="8279" href="Meta.Regularity.html#8041" class="Bound">red</a> <a id="8283" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8285" class="String">&quot;\n&quot;</a> <a id="8290" href="Meta.Literals.FromProduct.html#385" class="Function Operator">]</a>

<a id="8293" class="Comment">-- Test cases.</a>
<a id="8308" class="Keyword">module</a>
  <a id="8317" href="Meta.Regularity.html#8317" class="Module">_</a> <a id="8319" class="Symbol">{</a><a id="8320" href="Meta.Regularity.html#8320" class="Bound">ℓ</a> <a id="8322" href="Meta.Regularity.html#8322" class="Bound">ℓ′</a><a id="8324" class="Symbol">}</a> <a id="8326" class="Symbol">{</a><a id="8327" href="Meta.Regularity.html#8327" class="Bound">A</a> <a id="8329" class="Symbol">:</a> <a id="8331" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8336" href="Meta.Regularity.html#8320" class="Bound">ℓ</a><a id="8337" class="Symbol">}</a> <a id="8339" class="Symbol">{</a><a id="8340" href="Meta.Regularity.html#8340" class="Bound">B</a> <a id="8342" class="Symbol">:</a> <a id="8344" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8349" href="Meta.Regularity.html#8322" class="Bound">ℓ′</a><a id="8351" class="Symbol">}</a> <a id="8353" class="Symbol">(</a><a id="8354" href="Meta.Regularity.html#8354" class="Bound">f</a> <a id="8356" href="Meta.Regularity.html#8356" class="Bound">g</a> <a id="8358" class="Symbol">:</a> <a id="8360" href="Meta.Regularity.html#8327" class="Bound">A</a> <a id="8362" class="Symbol">→</a> <a id="8364" href="Meta.Regularity.html#8340" class="Bound">B</a><a id="8365" class="Symbol">)</a> <a id="8367" class="Symbol">(</a><a id="8368" href="Meta.Regularity.html#8368" class="Bound">x</a> <a id="8370" class="Symbol">:</a> <a id="8372" href="Meta.Regularity.html#8327" class="Bound">A</a><a id="8373" class="Symbol">)</a>
    <a id="8379" class="Symbol">(</a><a id="8380" href="Meta.Regularity.html#8380" class="Bound">a-loop</a> <a id="8387" class="Symbol">:</a> <a id="8389" class="Symbol">(</a><a id="8390" href="Meta.Regularity.html#8390" class="Bound">i</a> <a id="8392" class="Symbol">:</a> <a id="8394" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="8395" class="Symbol">)</a> <a id="8397" class="Symbol">→</a> <a id="8399" href="Foundations.Prim.Type.html#322" class="Primitive">Type</a> <a id="8404" href="Meta.Regularity.html#8320" class="Bound">ℓ</a> <a id="8406" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">[</a> <a id="8408" class="Symbol">(</a><a id="8409" href="Meta.Regularity.html#8390" class="Bound">i</a> <a id="8411" href="Foundations.Prim.Interval.html#517" class="Primitive Operator">∨</a> <a id="8413" href="Foundations.Prim.Interval.html#565" class="Primitive Operator">~</a> <a id="8415" href="Meta.Regularity.html#8390" class="Bound">i</a><a id="8416" class="Symbol">)</a> <a id="8418" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">↦</a> <a id="8420" class="Symbol">(λ</a> <a id="8423" class="Symbol">.</a><a id="8424" href="Meta.Regularity.html#8424" class="Bound">_</a> <a id="8426" class="Symbol">→</a> <a id="8428" href="Meta.Regularity.html#8327" class="Bound">A</a><a id="8429" class="Symbol">)</a> <a id="8431" href="Foundations.Prim.Extension.html#218" class="Postulate Operator">]</a><a id="8432" class="Symbol">)</a>
  <a id="8436" class="Keyword">where</a> <a id="8442" class="Keyword">private</a>

  <a id="8453" href="Meta.Regularity.html#8453" class="Function">p</a> <a id="8455" class="Symbol">:</a> <a id="8457" class="Symbol">(</a><a id="8458" href="Meta.Regularity.html#8458" class="Bound">h</a> <a id="8460" class="Symbol">:</a> <a id="8462" class="Symbol">∀</a> <a id="8464" href="Meta.Regularity.html#8464" class="Bound">x</a> <a id="8466" class="Symbol">→</a> <a id="8468" href="Meta.Regularity.html#8354" class="Bound">f</a> <a id="8470" href="Meta.Regularity.html#8464" class="Bound">x</a> <a id="8472" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8474" href="Meta.Regularity.html#8356" class="Bound">g</a> <a id="8476" href="Meta.Regularity.html#8464" class="Bound">x</a><a id="8477" class="Symbol">)</a>
    <a id="8483" class="Symbol">→</a> <a id="8485" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8495" class="Symbol">(λ</a> <a id="8498" href="Meta.Regularity.html#8498" class="Bound">i</a> <a id="8500" class="Symbol">→</a> <a id="8502" href="Meta.Regularity.html#8327" class="Bound">A</a> <a id="8504" class="Symbol">→</a> <a id="8506" href="Meta.Regularity.html#8340" class="Bound">B</a><a id="8507" class="Symbol">)</a>
        <a id="8517" class="Symbol">(λ</a> <a id="8520" href="Meta.Regularity.html#8520" class="Bound">x</a> <a id="8522" class="Symbol">→</a> <a id="8524" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8534" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="8539" class="Symbol">(</a><a id="8540" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8550" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="8555" class="Symbol">(</a><a id="8556" href="Meta.Regularity.html#8354" class="Bound">f</a> <a id="8558" class="Symbol">(</a><a id="8559" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8569" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="8574" href="Meta.Regularity.html#8520" class="Bound">x</a><a id="8575" class="Symbol">))))</a> <a id="8580" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8582" href="Meta.Regularity.html#8356" class="Bound">g</a>
  <a id="8586" href="Meta.Regularity.html#8453" class="Function">p</a> <a id="8588" href="Meta.Regularity.html#8588" class="Bound">h</a> <a id="8590" class="Symbol">=</a> <a id="8592" href="Meta.Regularity.html#7099" class="Macro">Regularity.reduce!</a> <a id="8611" href="Foundations.Correspondences.Binary.Transitive.html#475" class="Field Operator">∙</a> <a id="8613" href="Foundations.Base.html#10718" class="Function">fun-ext</a> <a id="8621" href="Meta.Regularity.html#8588" class="Bound">h</a>

  <a id="8626" href="Meta.Regularity.html#8626" class="Function">q</a> <a id="8628" class="Symbol">:</a> <a id="8630" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="8640" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="8645" class="Symbol">(</a><a id="8646" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8653" class="Symbol">(λ</a> <a id="8656" href="Meta.Regularity.html#8656" class="Bound">i</a> <a id="8658" class="Symbol">→</a> <a id="8660" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8665" class="Symbol">(</a><a id="8666" href="Meta.Regularity.html#8380" class="Bound">a-loop</a> <a id="8673" href="Meta.Regularity.html#8656" class="Bound">i</a><a id="8674" class="Symbol">))</a> <a id="8677" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8680" href="Meta.Regularity.html#8368" class="Bound">x</a><a id="8681" class="Symbol">)</a> <a id="8683" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="8685" href="Foundations.Prim.Kan.html#328" class="Primitive">transp</a> <a id="8692" class="Symbol">(λ</a> <a id="8695" href="Meta.Regularity.html#8695" class="Bound">i</a> <a id="8697" class="Symbol">→</a> <a id="8699" href="Foundations.Prim.Extension.html#252" class="Primitive">outS</a> <a id="8704" class="Symbol">(</a><a id="8705" href="Meta.Regularity.html#8380" class="Bound">a-loop</a> <a id="8712" href="Meta.Regularity.html#8695" class="Bound">i</a><a id="8713" class="Symbol">))</a> <a id="8716" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8719" href="Meta.Regularity.html#8368" class="Bound">x</a>
  <a id="8723" href="Meta.Regularity.html#8626" class="Function">q</a> <a id="8725" class="Symbol">=</a> <a id="8727" href="Meta.Regularity.html#7099" class="Macro">Regularity.reduce!</a>

  <a id="8749" class="Comment">-- Imprecise/fast reduction: According to it, the normal form of the</a>
  <a id="8820" class="Comment">-- transport below is refl. That&#39;s.. not the case, at least we don&#39;t</a>
  <a id="8891" class="Comment">-- know so. Precise regularity handles it, though.</a>
  <a id="8944" class="Comment">-- q′ : ⊤</a>
  <a id="8956" class="Comment">-- q′ = {! Regularity.reduct Regularity.fast (transp (λ i → outS (a-loop i)) i0 x) !}</a>

  <a id="9045" href="Meta.Regularity.html#9045" class="Function">r</a> <a id="9047" class="Symbol">:</a> <a id="9049" class="Symbol">(</a><a id="9050" href="Meta.Regularity.html#9050" class="Bound">h</a> <a id="9052" class="Symbol">:</a> <a id="9054" class="Symbol">∀</a> <a id="9056" href="Meta.Regularity.html#9056" class="Bound">x</a> <a id="9058" class="Symbol">→</a> <a id="9060" href="Meta.Regularity.html#8354" class="Bound">f</a> <a id="9062" href="Meta.Regularity.html#9056" class="Bound">x</a> <a id="9064" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9066" href="Meta.Regularity.html#8356" class="Bound">g</a> <a id="9068" href="Meta.Regularity.html#9056" class="Bound">x</a><a id="9069" class="Symbol">)</a> <a id="9071" class="Symbol">→</a> <a id="9073" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9083" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="9088" class="Symbol">(</a><a id="9089" href="Meta.Regularity.html#8354" class="Bound">f</a> <a id="9091" href="Meta.Regularity.html#8368" class="Bound">x</a><a id="9092" class="Symbol">)</a> <a id="9094" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9096" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9106" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="9111" class="Symbol">(</a><a id="9112" href="Meta.Regularity.html#8356" class="Bound">g</a> <a id="9114" href="Meta.Regularity.html#8368" class="Bound">x</a><a id="9115" class="Symbol">)</a>
  <a id="9119" href="Meta.Regularity.html#9045" class="Function">r</a> <a id="9121" href="Meta.Regularity.html#9121" class="Bound">h</a> <a id="9123" class="Symbol">=</a> <a id="9125" href="Meta.Regularity.html#7482" class="Macro">Regularity.precise!</a> <a id="9145" class="Symbol">(</a><a id="9146" href="Meta.Regularity.html#9121" class="Bound">h</a> <a id="9148" href="Meta.Regularity.html#8368" class="Bound">x</a><a id="9149" class="Symbol">)</a>

  <a id="9154" href="Meta.Regularity.html#9154" class="Function">s</a> <a id="9156" class="Symbol">:</a> <a id="9158" class="Symbol">(</a><a id="9159" href="Meta.Regularity.html#9159" class="Bound">h</a> <a id="9161" class="Symbol">:</a> <a id="9163" class="Symbol">∀</a> <a id="9165" href="Meta.Regularity.html#9165" class="Bound">x</a> <a id="9167" class="Symbol">→</a> <a id="9169" href="Meta.Regularity.html#8354" class="Bound">f</a> <a id="9171" href="Meta.Regularity.html#9165" class="Bound">x</a> <a id="9173" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9175" href="Meta.Regularity.html#8356" class="Bound">g</a> <a id="9177" href="Meta.Regularity.html#9165" class="Bound">x</a><a id="9178" class="Symbol">)</a> <a id="9180" class="Symbol">→</a> <a id="9182" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9192" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="9197" class="Symbol">(</a><a id="9198" href="Meta.Regularity.html#8356" class="Bound">g</a> <a id="9200" href="Meta.Regularity.html#8368" class="Bound">x</a><a id="9201" class="Symbol">)</a> <a id="9203" href="Foundations.Prim.Kan.html#1264" class="Function Operator">＝</a> <a id="9205" href="Foundations.Prim.Kan.html#1859" class="Function">transport</a> <a id="9215" href="Foundations.Correspondences.Binary.Reflexive.html#337" class="Field">refl</a> <a id="9220" class="Symbol">(</a><a id="9221" href="Meta.Regularity.html#8354" class="Bound">f</a> <a id="9223" href="Meta.Regularity.html#8368" class="Bound">x</a><a id="9224" class="Symbol">)</a>
  <a id="9228" href="Meta.Regularity.html#9154" class="Function">s</a> <a id="9230" href="Meta.Regularity.html#9230" class="Bound">h</a> <a id="9232" class="Symbol">=</a> <a id="9234" href="Foundations.Correspondences.Binary.Symmetric.html#515" class="Function">sym</a> <a id="9238" href="Meta.Notation.Underlying.html#1747" class="Function Operator">$</a> <a id="9240" href="Meta.Regularity.html#7548" class="Macro">Regularity.fast!</a> <a id="9257" class="Symbol">(</a><a id="9258" href="Meta.Regularity.html#9230" class="Bound">h</a> <a id="9260" href="Meta.Regularity.html#8368" class="Bound">x</a><a id="9261" class="Symbol">)</a>
</pre></body></html>