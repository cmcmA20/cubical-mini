<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Meta.HLevel</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>
<a id="24" class="Comment">-- -vtactic.hlevel:20 -vtc.def:10</a>
<a id="58" class="Keyword">module</a> <a id="65" href="Meta.HLevel.html" class="Module">Meta.HLevel</a> <a id="77" class="Keyword">where</a>

<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="Foundations.Base.html" class="Module">Foundations.Base</a>
<a id="113" class="Keyword">open</a> <a id="118" class="Keyword">import</a> <a id="125" href="Foundations.Equiv.html" class="Module">Foundations.Equiv</a>
<a id="143" class="Keyword">open</a> <a id="148" class="Keyword">import</a> <a id="155" href="Foundations.HLevel.html" class="Module">Foundations.HLevel</a> <a id="174" class="Keyword">public</a>
<a id="181" class="Keyword">open</a> <a id="186" class="Keyword">import</a> <a id="193" href="Foundations.Pi.html" class="Module">Foundations.Pi</a>
<a id="208" class="Keyword">open</a> <a id="213" class="Keyword">import</a> <a id="220" href="Foundations.Sigma.html" class="Module">Foundations.Sigma</a>

<a id="239" class="Keyword">open</a> <a id="244" class="Keyword">import</a> <a id="251" href="Meta.Foldable.html" class="Module">Meta.Foldable</a>
<a id="265" class="Keyword">open</a> <a id="270" class="Keyword">import</a> <a id="277" href="Meta.Literals.FromNat.html" class="Module">Meta.Literals.FromNat</a>
<a id="299" class="Keyword">open</a> <a id="304" class="Keyword">import</a> <a id="311" href="Meta.Literals.FromProduct.html" class="Module">Meta.Literals.FromProduct</a>
<a id="337" class="Keyword">open</a> <a id="342" class="Keyword">import</a> <a id="349" href="Meta.Literals.FromString.html" class="Module">Meta.Literals.FromString</a>
<a id="374" class="Keyword">open</a> <a id="379" class="Keyword">import</a> <a id="386" href="Meta.Reflection.html" class="Module">Meta.Reflection</a>

<a id="403" class="Keyword">open</a> <a id="408" class="Keyword">import</a> <a id="415" href="Structures.n-Type.html" class="Module">Structures.n-Type</a>

<a id="434" class="Keyword">open</a> <a id="439" class="Keyword">import</a> <a id="446" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="461" class="Keyword">open</a> <a id="466" class="Keyword">import</a> <a id="473" href="Data.List.Base.html" class="Module">Data.List.Base</a>
<a id="488" class="Keyword">open</a> <a id="493" class="Keyword">import</a> <a id="500" href="Data.List.Operations.html" class="Module">Data.List.Operations</a>
<a id="521" class="Keyword">open</a> <a id="526" class="Keyword">import</a> <a id="533" href="Data.List.Instances.Foldable.html" class="Module">Data.List.Instances.Foldable</a>
<a id="562" class="Keyword">open</a> <a id="567" class="Keyword">import</a> <a id="574" href="Data.List.Instances.FromProduct.html" class="Module">Data.List.Instances.FromProduct</a>
<a id="606" class="Keyword">open</a> <a id="611" class="Keyword">import</a> <a id="618" href="Data.List.Instances.Idiom.html" class="Module">Data.List.Instances.Idiom</a>
<a id="644" class="Keyword">open</a> <a id="649" class="Keyword">import</a> <a id="656" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>
<a id="672" class="Keyword">open</a> <a id="677" class="Keyword">import</a> <a id="684" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>

<a id="699" class="Comment">{-
Tactic for generating readable h-level proofs automatically. Contains an
essential reimplementation of the instance search mechanism, with
support for arbitrary level offsets (`level-minus) and searching under
binders (`search-under). Ambiguity is explicitly supported: the first
goal for which we can complete a proof tree is the one we go with.

The tactic works in a naÏve way, trying h-level lemmas until one
succeeds. There are three ways of making progress: Using a *projection
hint*, using a *decomposition hint*, or by falling back to instance
selection. The instance selection fallback is self-explanatory.

Projection hints handle the situation is-hlevel (X .p) n, where X
inhabits a record that contains evidence of its hlevel. If there is a
projection hint with `underlying-type == p`, then we use `has-level
(get-argument (X .p))` as the solution. Being a base case, projection
hints also handle raising h-levels: If `get-level (X .p) &lt; n`, we solve
by raising `has-level ...` the appropriate amount.

Decomposition hints are slightly more interesting. Decomposition hints
apply to a type, say P, and instruct the tactic on how to build an
application of type (is-hlevel P n). The way this application is built
is customizable.

Finding rules
-------------

Rules are found using instance search, specifically for the
&#39;hlevel-decomposition&#39; and &#39;hlevel-projection&#39; types. The
hlevel-projection type is flat, so the runtime of
projection-decomposition is *linear in the number of possible
projections*.

The hlevel-decomposition type is more interesting, since it is indexed
by the type that it can decompose. That way, we can use Agda&#39;s own
instance selection mechanism to narrow down to relevant decompositions.

Nondeterminism
--------------

In case more than one projection and/or decomposition hint is possible,
they will all be tried in order. This allows the tactic to generate
sensible-looking code, by trying simpler decompositions first. As an
example, the non-dependent lemmas for → and × will be tried before those
for Π and Σ, just like a human would.
-}</a>

<a id="2784" class="Comment">-- | Specifies how an argument should be filled in during elaboration of</a>
<a id="2857" class="Comment">-- an h-level lemma.</a>
<a id="2878" class="Keyword">data</a> <a id="Arg-spec"></a><a id="2883" href="Meta.HLevel.html#2883" class="Datatype">Arg-spec</a> <a id="2892" class="Symbol">:</a> <a id="2894" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="2899" class="Keyword">where</a>
  <a id="Arg-spec.`level-minus"></a><a id="2907" href="Meta.HLevel.html#2907" class="InductiveConstructor">`level-minus</a>  <a id="2921" class="Symbol">:</a> <a id="2923" class="Symbol">(</a><a id="2924" href="Meta.HLevel.html#2924" class="Bound">n</a> <a id="2926" class="Symbol">:</a> <a id="2928" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="2929" class="Symbol">)</a> <a id="2931" class="Symbol">→</a> <a id="2933" href="Meta.HLevel.html#2883" class="Datatype">Arg-spec</a>
  <a id="2944" class="Comment">-- ^ Insert the level we&#39;re solving for minus the given offset (note</a>
  <a id="3015" class="Comment">-- that this is the wonky subtraction operation, &quot;monus&quot;) at this</a>
  <a id="3083" class="Comment">-- argument position</a>

  <a id="Arg-spec.`search-under"></a><a id="3107" href="Meta.HLevel.html#3107" class="InductiveConstructor">`search-under</a> <a id="3121" class="Symbol">:</a> <a id="3123" class="Symbol">(</a><a id="3124" href="Meta.HLevel.html#3124" class="Bound">n</a> <a id="3126" class="Symbol">:</a> <a id="3128" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3129" class="Symbol">)</a> <a id="3131" class="Symbol">→</a> <a id="3133" href="Meta.HLevel.html#2883" class="Datatype">Arg-spec</a>
  <a id="3144" class="Comment">-- ^ Recursively search for an h-level witness, under @n@ visible</a>
  <a id="3212" class="Comment">-- lambdas. This is suitable for lemmas of type</a>
  <a id="3262" class="Comment">-- (∀ x y z → is-hlevel ...) → is-hlevel ...</a>

  <a id="Arg-spec.`meta"></a><a id="3310" href="Meta.HLevel.html#3310" class="InductiveConstructor">`meta</a>         <a id="3324" class="Symbol">:</a> <a id="3326" href="Meta.HLevel.html#2883" class="Datatype">Arg-spec</a>
  <a id="3337" class="Comment">-- ^ Insert a meta at this argument position. No search will be</a>
  <a id="3403" class="Comment">-- performed for this meta, so it must be solved from the context in</a>
  <a id="3474" class="Comment">-- which the lemma is used.</a>

<a id="3503" class="Comment">-- Common patterns: Keep the level, search in the current scope.</a>
<a id="3568" class="Keyword">pattern</a> <a id="`search"></a><a id="3576" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="3584" class="Symbol">=</a> <a id="3586" href="Meta.HLevel.html#3107" class="InductiveConstructor">`search-under</a> <a id="3600" class="Number">0</a>
<a id="3602" class="Keyword">pattern</a> <a id="`level"></a><a id="3610" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="3617" class="Symbol">=</a> <a id="3619" href="Meta.HLevel.html#2907" class="InductiveConstructor">`level-minus</a> <a id="3632" class="Number">0</a>

<a id="3635" class="Comment">-- | A specification for how to decompose the type @T@ into</a>
<a id="3695" class="Comment">-- sub-components, to establish an h-level result.</a>
<a id="3746" class="Keyword">data</a> <a id="hlevel-decomposition"></a><a id="3751" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="3772" class="Symbol">{</a><a id="3773" href="Meta.HLevel.html#3773" class="Bound">ℓ</a><a id="3774" class="Symbol">}</a> <a id="3776" class="Symbol">(</a><a id="3777" href="Meta.HLevel.html#3777" class="Bound">T</a> <a id="3779" class="Symbol">:</a> <a id="3781" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3786" href="Meta.HLevel.html#3773" class="Bound">ℓ</a><a id="3787" class="Symbol">)</a> <a id="3789" class="Symbol">:</a> <a id="3791" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="3796" class="Keyword">where</a>
  <a id="hlevel-decomposition.decomp"></a><a id="3804" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a>
    <a id="3815" class="Symbol">:</a> <a id="3817" class="Symbol">(</a><a id="3818" href="Meta.HLevel.html#3818" class="Bound">h-level-lemma</a> <a id="3832" class="Symbol">:</a> <a id="3834" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="3838" class="Symbol">)</a> <a id="3840" class="Symbol">(</a><a id="3841" href="Meta.HLevel.html#3841" class="Bound">arguments</a> <a id="3851" class="Symbol">:</a> <a id="3853" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3858" href="Meta.HLevel.html#2883" class="Datatype">Arg-spec</a><a id="3866" class="Symbol">)</a>
    <a id="3872" class="Symbol">→</a> <a id="3874" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="3895" href="Meta.HLevel.html#3777" class="Bound">T</a>
  <a id="3899" class="Comment">-- To prove that T has a given h-level, we can invoke the</a>
  <a id="3959" class="Comment">-- @h-level-lemma@ with the specified @arguments@.</a>

<a id="4011" class="Comment">-- | How to decompose an application of a record selector into something</a>
<a id="4084" class="Comment">-- which might have an h-level.</a>
<a id="4116" class="Keyword">record</a> <a id="hlevel-projection"></a><a id="4123" href="Meta.HLevel.html#4123" class="Record">hlevel-projection</a> <a id="4141" class="Symbol">(</a><a id="4142" href="Meta.HLevel.html#4142" class="Bound">proj</a> <a id="4147" class="Symbol">:</a> <a id="4149" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="4153" class="Symbol">)</a> <a id="4155" class="Symbol">:</a> <a id="4157" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="4162" class="Keyword">where</a>
  <a id="4170" class="Keyword">field</a>
    <a id="hlevel-projection.has-level"></a><a id="4180" href="Meta.HLevel.html#4180" class="Field">has-level</a> <a id="4190" class="Symbol">:</a> <a id="4192" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
    <a id="4201" class="Comment">-- ^ The name of the h-level lemma. It must be sufficient to apply</a>
    <a id="4272" class="Comment">-- this name to the argument (see get-argument below); arg specs are</a>
    <a id="4345" class="Comment">-- not supported.</a>
    <a id="hlevel-projection.get-level"></a><a id="4367" href="Meta.HLevel.html#4367" class="Field">get-level</a> <a id="4377" class="Symbol">:</a> <a id="4379" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="4384" class="Symbol">→</a> <a id="4386" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4389" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4398" class="Comment">-- ^ Given an application of underlying-type, what h-level does this</a>
    <a id="4471" class="Comment">-- type have? Necessary for computing lifts.</a>
    <a id="hlevel-projection.get-argument"></a><a id="4520" href="Meta.HLevel.html#4520" class="Field">get-argument</a> <a id="4533" class="Symbol">:</a> <a id="4535" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4540" class="Symbol">(</a><a id="4541" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4545" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="4549" class="Symbol">)</a> <a id="4551" class="Symbol">→</a> <a id="4553" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="4556" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
    <a id="4565" class="Comment">-- ^ Extract the argument out from under the application.</a>
<a id="4623" class="Comment">{-
Using projections
-----------------

Projection decomposition happens as follows; suppose we have some
neutral

  n = def (quote X) as

in order, every &#39;hlevel-projection&#39; instance definition will be tried;
Let us call a generic instance I. If I.underlying-type == X, then we&#39;ll
use this instance, otherwise, we fail (i.e. backtrack and try another
projection).

To use this instance, the get-level and get-argument functions are
involved; get-argument must take &#39;as&#39; and return some representative
sub-expression e. get-level will receive e&#39;s inferred type and must
return the h-level of the type n. Finally, we return

  I.has-level (get-argument e),

possibly wrapped in (k - get-level (get-argument e)) applications of
is-hlevel-suc.
-}</a>

<a id="5368" class="Keyword">open</a> <a id="5373" href="Meta.HLevel.html#4123" class="Module">hlevel-projection</a>
<a id="5391" class="Keyword">private</a>
  <a id="5401" class="Comment">-- Throw an empty type error to try another alternative, stating the</a>
  <a id="5472" class="Comment">-- purpose of backtracking for debugging:</a>
  <a id="backtrack"></a><a id="5516" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="5526" class="Symbol">:</a> <a id="5528" class="Symbol">∀</a> <a id="5530" class="Symbol">{</a><a id="5531" href="Meta.HLevel.html#5531" class="Bound">ℓ</a><a id="5532" class="Symbol">}</a> <a id="5534" class="Symbol">{</a><a id="5535" href="Meta.HLevel.html#5535" class="Bound">A</a> <a id="5537" class="Symbol">:</a> <a id="5539" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="5544" href="Meta.HLevel.html#5531" class="Bound">ℓ</a><a id="5545" class="Symbol">}</a> <a id="5547" class="Symbol">→</a> <a id="5549" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5554" href="Agda.Builtin.Reflection.html#7893" class="Datatype">ErrorPart</a> <a id="5564" class="Symbol">→</a> <a id="5566" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="5569" href="Meta.HLevel.html#5535" class="Bound">A</a>
  <a id="5573" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="5583" href="Meta.HLevel.html#5583" class="Bound">note</a> <a id="5588" class="Symbol">=</a> <a id="5590" class="Keyword">do</a>
    <a id="5597" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="5608" class="String">&quot;tactic.hlevel&quot;</a> <a id="5624" class="Number">10</a> <a id="5627" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="5629" class="String">&quot;Backtracking search... &quot;</a> <a id="5655" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5657" href="Meta.HLevel.html#5583" class="Bound">note</a>
    <a id="5666" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="5676" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="5678" class="String">&quot;Search hit a dead-end: &quot;</a> <a id="5704" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5706" href="Meta.HLevel.html#5583" class="Bound">note</a>

  <a id="5714" class="Comment">-- A list of names which we should not reduce while trying to invert</a>
  <a id="5785" class="Comment">-- an application of is-hlevel/is-prop/is-set into an &#39;underlying</a>
  <a id="5853" class="Comment">-- type&#39; and level arguments.</a>
  <a id="atoms"></a><a id="5885" href="Meta.HLevel.html#5885" class="Function">atoms</a> <a id="5891" class="Symbol">:</a> <a id="5893" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5898" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>
  <a id="5905" href="Meta.HLevel.html#5885" class="Function">atoms</a> <a id="5911" class="Symbol">=</a> <a id="5913" href="Meta.Literals.FromProduct.html#317" class="Function Operator">[</a> <a id="5915" class="Keyword">quote</a> <a id="5921" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a>
          <a id="5944" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5946" class="Keyword">quote</a> <a id="5952" href="Foundations.Base.html#13475" class="Function">is-prop</a>
          <a id="5970" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5972" class="Keyword">quote</a> <a id="5978" href="Foundations.Base.html#13707" class="Function">is-set</a>
          <a id="5995" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5997" class="Keyword">quote</a> <a id="6003" href="Foundations.Prim.Equiv.html#481" class="Function Operator">_≃_</a>
          <a id="6017" href="Meta.Literals.FromProduct.html#317" class="Function Operator">]</a>

  <a id="6022" class="Keyword">pattern</a> <a id="nat-lit"></a><a id="6030" href="Meta.HLevel.html#6030" class="InductiveConstructor">nat-lit</a> <a id="6038" href="Meta.HLevel.html#6095" class="Bound">n</a> <a id="6040" class="Symbol">=</a>
    <a id="6046" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6050" class="Symbol">(</a><a id="6051" class="Keyword">quote</a> <a id="6057" href="Agda.Builtin.FromNat.html#281" class="Field">Number.fromNat</a><a id="6071" class="Symbol">)</a> <a id="6073" class="Symbol">(_</a> <a id="6076" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6078" class="Symbol">_</a> <a id="6080" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6082" class="Symbol">_</a> <a id="6084" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6086" class="InductiveConstructor">lit</a> <a id="6090" class="Symbol">(</a><a id="6091" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="6095" href="Meta.HLevel.html#6095" class="Bound">n</a><a id="6096" class="Symbol">)</a> <a id="6098" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6101" class="Symbol">_)</a>

  <a id="6107" class="Comment">-- Decompose an application of is-hlevel and/or one of the other</a>
  <a id="6174" class="Comment">-- &#39;hlevel-types&#39; into its constituent parts. Invariant:</a>
  <a id="6233" class="Comment">--</a>
  <a id="6238" class="Comment">--    decompose-is-hlevel′ t = (n , a) ⊢ t = is-of-hlevel n a</a>
  <a id="decompose-is-hlevel′"></a><a id="6302" href="Meta.HLevel.html#6302" class="Function">decompose-is-hlevel′</a> <a id="6323" class="Symbol">:</a> <a id="6325" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6330" class="Symbol">→</a> <a id="6332" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6335" class="Symbol">(</a><a id="6336" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6341" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6343" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6347" class="Symbol">)</a>

  <a id="6352" class="Comment">-- Infer the type of the given term, and decompose it according to</a>
  <a id="6421" class="Comment">-- decompose-is-hlevel′.</a>
  <a id="decompose-is-hlevel"></a><a id="6448" href="Meta.HLevel.html#6448" class="Function">decompose-is-hlevel</a> <a id="6468" class="Symbol">:</a> <a id="6470" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6475" class="Symbol">→</a> <a id="6477" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="6480" class="Symbol">(</a><a id="6481" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="6486" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="6488" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="6492" class="Symbol">)</a>
  <a id="6496" href="Meta.HLevel.html#6448" class="Function">decompose-is-hlevel</a> <a id="6516" href="Meta.HLevel.html#6516" class="Bound">goal</a> <a id="6521" class="Symbol">=</a> <a id="6523" class="Keyword">do</a>
    <a id="6530" href="Meta.HLevel.html#6530" class="Bound">ty</a> <a id="6533" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6535" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="6550" class="Symbol">(</a><a id="6551" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="6557" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6559" href="Meta.HLevel.html#5885" class="Function">atoms</a><a id="6564" class="Symbol">)</a> <a id="6566" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="6568" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="6578" href="Meta.HLevel.html#6516" class="Bound">goal</a> <a id="6583" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="6587" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
    <a id="6598" href="Meta.HLevel.html#6302" class="Function">decompose-is-hlevel′</a> <a id="6619" href="Meta.HLevel.html#6530" class="Bound">ty</a>

  <a id="6625" href="Meta.HLevel.html#6302" class="Function">decompose-is-hlevel′</a> <a id="6646" href="Meta.HLevel.html#6646" class="Bound">ty</a> <a id="6649" class="Symbol">=</a> <a id="6651" class="Keyword">do</a>
    <a id="6658" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6662" class="Symbol">(</a><a id="6663" class="Keyword">quote</a> <a id="6669" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a><a id="6681" class="Symbol">)</a> <a id="6683" class="Symbol">(_</a> <a id="6686" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6688" href="Meta.HLevel.html#6688" class="Bound">lv</a> <a id="6691" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6694" href="Meta.HLevel.html#6694" class="Bound">ty</a> <a id="6697" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6700" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6702" class="Symbol">)</a> <a id="6704" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6706" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6711" href="Meta.HLevel.html#6646" class="Bound">ty</a>
      <a id="6720" class="Keyword">where</a>
        <a id="6734" class="Comment">-- Handle the ones with special names:</a>
        <a id="6781" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6785" class="Symbol">(</a><a id="6786" class="Keyword">quote</a> <a id="6792" href="Foundations.Base.html#13707" class="Function">is-set</a><a id="6798" class="Symbol">)</a> <a id="6800" class="Symbol">(_</a> <a id="6803" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6805" href="Meta.HLevel.html#6805" class="Bound">ty</a> <a id="6808" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6811" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6813" class="Symbol">)</a> <a id="6815" class="Symbol">→</a> <a id="6817" class="Keyword">do</a>
          <a id="6830" href="Meta.HLevel.html#6830" class="Bound">ty</a> <a id="6833" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6835" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="6851" href="Meta.HLevel.html#6805" class="Bound">ty</a>
          <a id="6864" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6869" class="Symbol">(</a><a id="6870" class="Keyword">quoteTerm</a> <a id="6880" class="Number">2</a> <a id="6882" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6884" href="Meta.HLevel.html#6830" class="Bound">ty</a><a id="6886" class="Symbol">)</a>

        <a id="6897" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="6901" class="Symbol">(</a><a id="6902" class="Keyword">quote</a> <a id="6908" href="Foundations.Base.html#13475" class="Function">is-prop</a><a id="6915" class="Symbol">)</a> <a id="6917" class="Symbol">(_</a> <a id="6920" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6922" href="Meta.HLevel.html#6922" class="Bound">ty</a> <a id="6925" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="6928" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6930" class="Symbol">)</a> <a id="6932" class="Symbol">→</a> <a id="6934" class="Keyword">do</a>
          <a id="6947" href="Meta.HLevel.html#6947" class="Bound">ty</a> <a id="6950" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="6952" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="6968" href="Meta.HLevel.html#6922" class="Bound">ty</a>
          <a id="6981" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="6986" class="Symbol">(</a><a id="6987" class="Keyword">quoteTerm</a> <a id="6997" class="Number">1</a> <a id="6999" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7001" href="Meta.HLevel.html#6947" class="Bound">ty</a><a id="7003" class="Symbol">)</a>

        <a id="7014" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="7018" class="Symbol">(</a><a id="7019" class="Keyword">quote</a> <a id="7025" href="Foundations.Base.html#13273" class="Function">is-contr</a><a id="7033" class="Symbol">)</a> <a id="7035" class="Symbol">(_</a> <a id="7038" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="7040" href="Meta.HLevel.html#7040" class="Bound">ty</a> <a id="7043" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="7046" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7048" class="Symbol">)</a> <a id="7050" class="Symbol">→</a> <a id="7052" class="Keyword">do</a>
          <a id="7065" href="Meta.HLevel.html#7065" class="Bound">ty</a> <a id="7068" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7070" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="7086" href="Meta.HLevel.html#7040" class="Bound">ty</a>
          <a id="7099" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7104" class="Symbol">(</a><a id="7105" class="Keyword">quoteTerm</a> <a id="7115" class="Number">0</a> <a id="7117" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7119" href="Meta.HLevel.html#7065" class="Bound">ty</a><a id="7121" class="Symbol">)</a>

        <a id="7132" class="CatchallClause Symbol">_</a> <a id="7134" class="Symbol">→</a> <a id="7136" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="7146" class="String">&quot;Goal type isn&#39;t is-hlevel&quot;</a>

    <a id="7179" class="Comment">-- To support having bare hlevel! in the source file, we need to</a>
    <a id="7248" class="Comment">-- block decomposition on having a rigid-ish type at the</a>
    <a id="7309" class="Comment">-- top-level. Otherwise the first hint that matches will get</a>
    <a id="7374" class="Comment">-- matched endlessly until we run out of fuel!</a>
    <a id="7425" href="Meta.HLevel.html#7425" class="Bound">ty</a> <a id="7428" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7430" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="7446" href="Meta.HLevel.html#6694" class="Bound">ty</a>
    <a id="7453" href="Meta.HLevel.html#7453" class="Bound">lv</a> <a id="7456" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="7458" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a> <a id="7474" href="Meta.HLevel.html#6688" class="Bound">lv</a>
    <a id="7481" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="7486" class="Symbol">(</a><a id="7487" href="Meta.HLevel.html#7453" class="Bound">lv</a> <a id="7490" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7492" href="Meta.HLevel.html#7425" class="Bound">ty</a><a id="7494" class="Symbol">)</a>

<a id="7497" class="Comment">{-
Lifting n-Types
---------------

The n-types are the leaves of the hlevel solving process, so they&#39;re
pretty much our only opportunity to adjust levels in a big way. Suppose
you have

  T = def (quote X) as

with
  get-level (get-argument T) = n
  w : is-of-hlevel n T

but what you want is a witness of is-of-hlevel (k + n) T, where k is some
numeral? Well, the solution is obvious: we can compute k - n and lift
T&#39;s witness (k - n) levels. Right?

No: we&#39;re dealing with potential open naturals, so we have to be careful
about performing ‘symbolic’ subtractions. The way we do this is with,
essentially, a loop: If w doesn&#39;t work, then try

  is-hlevel-suc n w : is-hlevel (suc n) T

until you reach a sucᵏ n = k + n. Actually, slightly more efficient, we
keep around a counter k′ for the number of tries, and transfer successors
from the wanted level (k + n) until is-of-hlevel-+ n (sucᵏ′ n) w works.
-}</a>
  <a id="lift-sol"></a><a id="8409" href="Meta.HLevel.html#8409" class="Function">lift-sol</a> <a id="8418" class="Symbol">:</a> <a id="8420" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8425" class="Symbol">→</a> <a id="8427" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8432" class="Symbol">→</a> <a id="8434" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8436" class="Symbol">→</a> <a id="8438" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8445" href="Meta.HLevel.html#8409" class="Function">lift-sol</a> <a id="8454" href="Meta.HLevel.html#8454" class="Bound">tm</a> <a id="8457" class="Symbol">_</a> <a id="8459" class="Number">0</a> <a id="8461" class="Symbol">=</a> <a id="8463" href="Meta.HLevel.html#8454" class="Bound">tm</a>
  <a id="8468" href="Meta.HLevel.html#8409" class="CatchallClause Function">lift-sol</a><a id="8476" class="CatchallClause"> </a><a id="8477" href="Meta.HLevel.html#8477" class="CatchallClause Bound">tm</a><a id="8479" class="CatchallClause"> </a><a id="8480" href="Meta.HLevel.html#8480" class="CatchallClause Bound">l1</a><a id="8482" class="CatchallClause"> </a><a id="8483" href="Meta.HLevel.html#8483" class="CatchallClause Bound">l</a> <a id="8485" class="Symbol">=</a> <a id="8487" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="8491" class="Symbol">(</a><a id="8492" class="Keyword">quote</a> <a id="8498" href="Foundations.HLevel.Base.html#2820" class="Function">is-of-hlevel-+</a><a id="8512" class="Symbol">)</a> <a id="8514" class="Symbol">(</a><a id="8515" href="Meta.HLevel.html#8480" class="Bound">l1</a> <a id="8518" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="8521" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8525" class="Symbol">(</a><a id="8526" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8530" href="Meta.HLevel.html#8483" class="Bound">l</a><a id="8531" class="Symbol">)</a> <a id="8533" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="8536" href="Meta.HLevel.html#8477" class="Bound">tm</a> <a id="8539" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="8542" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8544" class="Symbol">)</a>

  <a id="pred-term"></a><a id="8549" href="Meta.HLevel.html#8549" class="Function">pred-term</a> <a id="8559" class="Symbol">:</a> <a id="8561" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8566" class="Symbol">→</a> <a id="8568" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="8574" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
  <a id="8581" href="Meta.HLevel.html#8549" class="Function">pred-term</a> <a id="8591" class="Symbol">(</a><a id="8592" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="8596" class="Symbol">(</a><a id="8597" class="Keyword">quote</a> <a id="8603" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="8606" class="Symbol">)</a> <a id="8608" class="Symbol">(</a><a id="8609" href="Meta.HLevel.html#8609" class="Bound">x</a> <a id="8611" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="8614" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8616" class="Symbol">))</a> <a id="8619" class="Symbol">=</a> <a id="8621" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8626" href="Meta.HLevel.html#8609" class="Bound">x</a>
  <a id="8630" href="Meta.HLevel.html#8549" class="Function">pred-term</a> <a id="8640" class="Symbol">(</a><a id="8641" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8645" class="Symbol">(</a><a id="8646" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8650" href="Meta.HLevel.html#8650" class="Bound">n</a><a id="8651" class="Symbol">))</a> <a id="8654" class="Keyword">with</a> <a id="8659" href="Meta.HLevel.html#8650" class="Bound">n</a>
  <a id="8663" class="Symbol">...</a> <a id="8667" class="Symbol">|</a> <a id="8669" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8673" href="Meta.HLevel.html#8673" class="Bound">k</a> <a id="8675" class="Symbol">=</a> <a id="8677" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8682" class="Symbol">(</a><a id="8683" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="8687" class="Symbol">(</a><a id="8688" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="8692" href="Meta.HLevel.html#8673" class="Bound">k</a><a id="8693" class="Symbol">))</a>
  <a id="8698" class="CatchallClause Symbol">...</a><a id="8701" class="CatchallClause"> </a><a id="8702" class="CatchallClause Symbol">|</a><a id="8703" class="CatchallClause"> </a><a id="8704" class="CatchallClause Symbol">_</a> <a id="8706" class="Symbol">=</a> <a id="8708" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
  <a id="8718" href="Meta.HLevel.html#8549" class="CatchallClause Function">pred-term</a><a id="8727" class="CatchallClause"> </a><a id="8728" class="CatchallClause Symbol">_</a> <a id="8730" class="Symbol">=</a> <a id="8732" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="lifting-loop"></a><a id="8743" href="Meta.HLevel.html#8743" class="Function">lifting-loop</a> <a id="8756" class="Symbol">:</a> <a id="8758" class="Symbol">(</a><a id="8759" href="Meta.HLevel.html#8759" class="Bound">fuel</a> <a id="8764" class="Symbol">:</a> <a id="8766" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="8767" class="Symbol">)</a> <a id="8769" class="Symbol">→</a> <a id="8771" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="8773" class="Symbol">→</a> <a id="8775" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8780" class="Symbol">→</a> <a id="8782" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8787" class="Symbol">→</a> <a id="8789" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8794" class="Symbol">→</a> <a id="8796" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="8801" class="Symbol">→</a> <a id="8803" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="8806" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="8810" href="Meta.HLevel.html#8743" class="Function">lifting-loop</a> <a id="8823" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="8828" class="Symbol">_</a> <a id="8830" class="Symbol">_</a> <a id="8832" class="Symbol">_</a> <a id="8834" class="Symbol">_</a> <a id="8836" class="Symbol">_</a> <a id="8838" class="Symbol">=</a> <a id="8840" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="8850" class="String">&quot;Lifting loop ran out of fuel&quot;</a>
  <a id="8883" href="Meta.HLevel.html#8743" class="Function">lifting-loop</a> <a id="8896" class="Symbol">(</a><a id="8897" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="8901" href="Meta.HLevel.html#8901" class="Bound">fuel</a><a id="8905" class="Symbol">)</a> <a id="8907" href="Meta.HLevel.html#8907" class="Bound">it</a> <a id="8910" href="Meta.HLevel.html#8910" class="Bound">solution</a> <a id="8919" href="Meta.HLevel.html#8919" class="Bound">goal</a> <a id="8924" href="Meta.HLevel.html#8924" class="Bound">l1</a> <a id="8927" href="Meta.HLevel.html#8927" class="Bound">l2</a> <a id="8930" class="Symbol">=</a>
    <a id="8936" href="Meta.HLevel.html#9151" class="Function">let&#39;s-hope</a> <a id="8947" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="8951" class="Keyword">do</a>
      <a id="8960" class="Symbol">(</a><a id="8961" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8966" href="Meta.HLevel.html#8966" class="Bound">l2′</a><a id="8969" class="Symbol">)</a> <a id="8971" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="8973" href="Meta.HLevel.html#8549" class="Function">pred-term</a> <a id="8983" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="8987" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="8997" href="Meta.HLevel.html#8927" class="Bound">l2</a> <a id="9000" class="Keyword">where</a>
        <a id="9014" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="9022" class="Symbol">→</a> <a id="9024" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="9034" class="String">&quot;Lifting loop reached its end with no success&quot;</a>
      <a id="9087" href="Meta.HLevel.html#8743" class="Function">lifting-loop</a> <a id="9100" href="Meta.HLevel.html#8901" class="Bound">fuel</a> <a id="9105" class="Symbol">(</a><a id="9106" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="9110" href="Meta.HLevel.html#8907" class="Bound">it</a><a id="9112" class="Symbol">)</a> <a id="9114" href="Meta.HLevel.html#8910" class="Bound">solution</a> <a id="9123" href="Meta.HLevel.html#8919" class="Bound">goal</a> <a id="9128" href="Meta.HLevel.html#8924" class="Bound">l1</a> <a id="9131" href="Meta.HLevel.html#8966" class="Bound">l2′</a>
    <a id="9139" class="Keyword">where</a>
      <a id="9151" href="Meta.HLevel.html#9151" class="Function">let&#39;s-hope</a> <a id="9162" class="Symbol">:</a> <a id="9164" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9167" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="9175" href="Meta.HLevel.html#9151" class="Function">let&#39;s-hope</a> <a id="9186" class="Symbol">=</a> <a id="9188" class="Keyword">do</a>
        <a id="9199" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9210" class="String">&quot;tactic.hlevel&quot;</a> <a id="9226" class="Number">30</a> <a id="9229" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="9231" class="String">&quot;Lifting loop: Trying &quot;</a> <a id="9255" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9257" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9265" class="Symbol">(</a><a id="9266" href="Meta.HLevel.html#8409" class="Function">lift-sol</a> <a id="9275" href="Meta.HLevel.html#8910" class="Bound">solution</a> <a id="9284" href="Meta.HLevel.html#8924" class="Bound">l1</a> <a id="9287" href="Meta.HLevel.html#8907" class="Bound">it</a><a id="9289" class="Symbol">)</a> <a id="9291" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9293" class="String">&quot; for level &quot;</a> <a id="9307" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9309" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9317" href="Meta.HLevel.html#8927" class="Bound">l2</a> <a id="9320" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9322" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="9333" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="9339" href="Meta.HLevel.html#8919" class="Bound">goal</a> <a id="9344" class="Symbol">(</a><a id="9345" href="Meta.HLevel.html#8409" class="Function">lift-sol</a> <a id="9354" href="Meta.HLevel.html#8910" class="Bound">solution</a> <a id="9363" href="Meta.HLevel.html#8924" class="Bound">l1</a> <a id="9366" href="Meta.HLevel.html#8907" class="Bound">it</a><a id="9368" class="Symbol">)</a>
    <a id="9374" class="Comment">-- con (quote suc) (</a>

  <a id="9398" class="Comment">-- Projection decomposition.</a>
  <a id="treat-as-n-type"></a><a id="9429" href="Meta.HLevel.html#9429" class="Function">treat-as-n-type</a> <a id="9445" class="Symbol">:</a> <a id="9447" class="Symbol">∀</a> <a id="9449" class="Symbol">{</a><a id="9450" href="Meta.HLevel.html#9450" class="Bound">n</a><a id="9451" class="Symbol">}</a> <a id="9453" class="Symbol">→</a> <a id="9455" href="Meta.HLevel.html#4123" class="Record">hlevel-projection</a> <a id="9473" href="Meta.HLevel.html#9450" class="Bound">n</a> <a id="9475" class="Symbol">→</a> <a id="9477" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="9482" class="Symbol">→</a> <a id="9484" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="9487" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="9491" href="Meta.HLevel.html#9429" class="Function">treat-as-n-type</a> <a id="9507" href="Meta.HLevel.html#9507" class="Bound">projection</a> <a id="9518" href="Meta.HLevel.html#9518" class="Bound">goal</a> <a id="9523" class="Symbol">=</a> <a id="9525" class="Keyword">do</a>
    <a id="9532" class="Comment">-- First we must be looking at a goal which is of the type is-hlevel</a>
    <a id="9605" class="Comment">-- A n. We&#39;ll need both n and A.</a>
    <a id="9642" class="Symbol">(</a><a id="9643" href="Meta.HLevel.html#9643" class="Bound">wanted-level</a> <a id="9656" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9658" href="Meta.HLevel.html#9658" class="Bound">ty</a><a id="9660" class="Symbol">)</a> <a id="9662" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="9664" href="Meta.HLevel.html#6448" class="Function">decompose-is-hlevel</a> <a id="9684" href="Meta.HLevel.html#9518" class="Bound">goal</a>
    <a id="9693" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="9704" class="String">&quot;tactic.hlevel&quot;</a> <a id="9720" class="Number">10</a> <a id="9723" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="9731" class="String">&quot;Attempting to treat as &quot;</a> <a id="9757" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9759" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9767" href="Meta.HLevel.html#9643" class="Bound">wanted-level</a> <a id="9780" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9782" class="String">&quot;-Type: &quot;</a> <a id="9792" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9794" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9802" href="Meta.HLevel.html#9658" class="Bound">ty</a> <a id="9805" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9807" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="9814" href="Meta.HLevel.html#9814" class="Bound">ty</a> <a id="9817" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="9819" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="9826" href="Meta.HLevel.html#9658" class="Bound">ty</a>

    <a id="9834" class="Comment">-- Reduce the type to whnf and check whether the outermost term</a>
    <a id="9902" class="Comment">-- constructor is an application of the projection we&#39;re looking</a>
    <a id="9971" class="Comment">-- for.</a>
    <a id="9983" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="9987" href="Meta.HLevel.html#9987" class="Bound">namen</a> <a id="9993" href="Meta.HLevel.html#9993" class="Bound">args</a> <a id="9998" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10000" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="10009" href="Meta.HLevel.html#9814" class="Bound">ty</a>
      <a id="10018" class="Keyword">where</a> <a id="10024" href="Meta.HLevel.html#10024" class="CatchallClause Bound">what</a> <a id="10029" class="Symbol">→</a> <a id="10031" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="10041" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="10043" class="String">&quot;Thing isn&#39;t an application, it is &quot;</a> <a id="10080" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10082" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10090" href="Meta.HLevel.html#10024" class="Bound">what</a> <a id="10095" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10097" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10105" href="Meta.HLevel.html#10105" class="Bound">it</a> <a id="10108" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10110" href="Meta.HLevel.html#9507" class="Bound">projection</a> <a id="10121" class="Symbol">.</a><a id="10122" href="Meta.HLevel.html#4520" class="Field">get-argument</a> <a id="10135" href="Meta.HLevel.html#9993" class="Bound">args</a>

    <a id="10145" class="Comment">-- And compute the level of the projected thing, in addition to a</a>
    <a id="10215" class="Comment">-- numeral form of the wanted level.</a>
    <a id="10256" href="Meta.HLevel.html#10256" class="Bound">actual-level</a> <a id="10269" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10271" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="10281" href="Meta.HLevel.html#10105" class="Bound">it</a> <a id="10284" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="10288" href="Meta.HLevel.html#9507" class="Bound">projection</a> <a id="10299" class="Symbol">.</a><a id="10300" href="Meta.HLevel.html#4367" class="Field">get-level</a>

    <a id="10315" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="10326" class="String">&quot;tactic.hlevel&quot;</a> <a id="10342" class="Number">10</a> <a id="10345" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="10353" class="String">&quot;... but it&#39;s actually a(n) &quot;</a> <a id="10383" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10385" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10393" href="Meta.HLevel.html#10256" class="Bound">actual-level</a> <a id="10406" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10408" class="String">&quot;-Type&quot;</a> <a id="10416" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="10418" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="10426" href="Meta.HLevel.html#10426" class="Bound">lv</a> <a id="10429" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10431" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10441" href="Meta.HLevel.html#9643" class="Bound">wanted-level</a>
    <a id="10458" href="Meta.HLevel.html#10458" class="Bound">lv′</a> <a id="10462" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10464" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="10474" href="Meta.HLevel.html#10256" class="Bound">actual-level</a>
    <a id="10491" href="Meta.HLevel.html#8743" class="Function">lifting-loop</a> <a id="10504" class="Number">10000</a> <a id="10510" class="Number">0</a> <a id="10512" class="Symbol">(</a><a id="10513" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10517" class="Symbol">(</a><a id="10518" href="Meta.HLevel.html#9507" class="Bound">projection</a> <a id="10529" class="Symbol">.</a><a id="10530" href="Meta.HLevel.html#4180" class="Field">has-level</a><a id="10539" class="Symbol">)</a> <a id="10541" class="Symbol">(</a><a id="10542" href="Meta.HLevel.html#10105" class="Bound">it</a> <a id="10545" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="10548" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10550" class="Symbol">))</a> <a id="10553" href="Meta.HLevel.html#9518" class="Bound">goal</a> <a id="10558" href="Meta.HLevel.html#10458" class="Bound">lv′</a> <a id="10562" href="Meta.HLevel.html#10426" class="Bound">lv</a>

    <a id="10570" href="Agda.Builtin.Reflection.html#9521" class="Postulate">commitTC</a>

  <a id="10582" class="Comment">-- Fall back to Agda&#39;s instance search mechanism. This isn&#39;t as</a>
  <a id="10648" class="Comment">-- straightforward as just using the &#39;hlevel&#39; function for a couple of</a>
  <a id="10721" class="Comment">-- reasons.</a>
  <a id="use-instance-search"></a><a id="10735" href="Meta.HLevel.html#10735" class="Function">use-instance-search</a> <a id="10755" class="Symbol">:</a> <a id="10757" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="10762" class="Symbol">→</a> <a id="10764" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="10769" class="Symbol">→</a> <a id="10771" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="10774" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="10778" href="Meta.HLevel.html#10735" class="Function">use-instance-search</a> <a id="10798" href="Meta.HLevel.html#10798" class="Bound">has-alts</a> <a id="10807" href="Meta.HLevel.html#10807" class="Bound">goal</a> <a id="10812" class="Symbol">=</a> <a id="10814" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="10829" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="10831" class="Keyword">do</a>
    <a id="10838" class="Symbol">(</a><a id="10839" href="Meta.HLevel.html#10839" class="Bound">lv</a> <a id="10842" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="10844" href="Meta.HLevel.html#10844" class="Bound">ty</a><a id="10846" class="Symbol">)</a> <a id="10848" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10850" href="Meta.HLevel.html#6448" class="Function">decompose-is-hlevel</a> <a id="10870" href="Meta.HLevel.html#10807" class="Bound">goal</a>
    <a id="10879" href="Meta.HLevel.html#10879" class="Bound">solved</a><a id="10885" class="Symbol">@(</a><a id="10887" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="10892" href="Meta.HLevel.html#10892" class="Bound">mv</a> <a id="10895" class="Symbol">_)</a> <a id="10898" href="Meta.Bind.html#190" class="Field Operator">←</a>
      <a id="10906" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="10915" class="Symbol">(</a><a id="10916" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="10920" class="Symbol">(</a><a id="10921" class="Keyword">quote</a> <a id="10927" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a><a id="10939" class="Symbol">)</a> <a id="10941" class="Symbol">(</a><a id="10942" href="Meta.HLevel.html#10839" class="Bound">lv</a> <a id="10945" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="10948" href="Meta.HLevel.html#10844" class="Bound">ty</a> <a id="10951" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="10954" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10956" class="Symbol">))</a> <a id="10959" class="Keyword">where</a> <a id="10965" class="CatchallClause Symbol">_</a> <a id="10967" class="Symbol">→</a> <a id="10969" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="10979" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="10986" href="Meta.HLevel.html#10986" class="Bound">instances</a> <a id="10996" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="10998" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="11011" href="Meta.HLevel.html#10892" class="Bound">mv</a>

    <a id="11019" href="Meta.HLevel.html#11019" class="Bound">t</a> <a id="11021" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="11023" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="11031" href="Meta.HLevel.html#10986" class="Bound">instances</a>
    <a id="11045" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="11056" class="String">&quot;tactic.hlevel&quot;</a> <a id="11072" class="Number">10</a> <a id="11075" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
      <a id="11083" class="String">&quot;Using instance search for\n&quot;</a> <a id="11113" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11115" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11123" href="Meta.HLevel.html#10844" class="Bound">ty</a> <a id="11126" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
      <a id="11134" class="String">&quot;\nFound candidates\n &quot;</a> <a id="11158" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11160" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11168" href="Meta.HLevel.html#11019" class="Bound">t</a> <a id="11170" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11172" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

    <a id="11180" class="Comment">-- We actually want to manage the instance searching ourselves,</a>
    <a id="11248" class="Comment">-- sorta, to avoid getting into situations where the macro has</a>
    <a id="11315" class="Comment">-- committed to instance search but Agda will disagree with it.</a>
    <a id="11383" class="Keyword">let</a>
      <a id="11393" href="Meta.HLevel.html#11393" class="Bound">go</a> <a id="11396" class="Symbol">:</a> <a id="11398" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="11403" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="11408" class="Symbol">→</a> <a id="11410" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="11413" class="Symbol">(</a><a id="11414" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="11416" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="11418" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="11422" class="Symbol">)</a>
      <a id="11430" href="Meta.HLevel.html#11393" class="Bound">go</a> <a id="11433" class="Symbol">=</a> <a id="11435" class="Symbol">λ</a> <a id="11437" class="Keyword">where</a>
        <a id="11451" class="Comment">-- If there is *exactly* one instance candidate for this goal,</a>
        <a id="11522" class="Comment">-- then we can go ahead and solve it. That&#39;s because having</a>
        <a id="11590" class="Comment">-- exactly one instance means Agda will solve using that</a>
        <a id="11655" class="Comment">-- instance!</a>
        <a id="11676" class="Symbol">(</a><a id="11677" href="Meta.HLevel.html#11677" class="Bound">x</a> <a id="11679" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11681" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11683" class="Symbol">)</a> <a id="11685" class="Symbol">→</a> <a id="11687" class="Keyword">do</a>
          <a id="11700" class="Comment">-- Note that, since getInstances works by creating a new meta,</a>
          <a id="11773" class="Comment">-- we have to commit to the instance ourselves.</a>
          <a id="11831" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11837" href="Meta.HLevel.html#10879" class="Bound">solved</a> <a id="11844" href="Meta.HLevel.html#11677" class="Bound">x</a>
          <a id="11856" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="11871" class="Symbol">(</a><a id="11872" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="11878" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="11880" class="Keyword">quote</a> <a id="11886" href="Foundations.HLevel.Base.html#282" class="Function">hlevel</a> <a id="11893" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="11895" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11897" class="Symbol">)</a> <a id="11899" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="11901" href="Agda.Builtin.Reflection.html#10063" class="Postulate">withReconstructed</a> <a id="11919" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="11924" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="11938" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="11944" href="Meta.HLevel.html#10807" class="Bound">goal</a> <a id="11949" class="Symbol">(</a><a id="11950" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="11954" class="Symbol">(</a><a id="11955" class="Keyword">quote</a> <a id="11961" href="Foundations.HLevel.Base.html#282" class="Function">hlevel</a><a id="11967" class="Symbol">)</a> <a id="11969" class="Symbol">(</a><a id="11970" href="Meta.HLevel.html#10839" class="Bound">lv</a> <a id="11973" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="11976" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="11978" class="Symbol">))</a>
          <a id="11991" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="11996" class="Symbol">(</a><a id="11997" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12000" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12002" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="12006" class="Symbol">)</a>

        <a id="12017" class="Comment">-- If there are any more alternatives to be tried after this</a>
        <a id="12086" class="Comment">-- one, then we fail (backtrack). Otherwise, we discard the TC</a>
        <a id="12157" class="Comment">-- state but indicate success: this will cause the meta to be</a>
        <a id="12227" class="Comment">-- solved with an interaction point (if using</a>
        <a id="12281" class="Comment">-- elaborate-and-give).</a>
        <a id="12313" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="12316" class="Symbol">→</a> <a id="12318" href="Data.Bool.Base.html#492" class="Function Operator">if</a> <a id="12321" href="Meta.HLevel.html#10798" class="Bound">has-alts</a>
          <a id="12340" href="Data.Bool.Base.html#492" class="Function Operator">then</a> <a id="12345" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="12355" class="String">&quot;No possible instances, but have other decompositions to try&quot;</a>
          <a id="12427" href="Data.Bool.Base.html#492" class="Function Operator">else</a> <a id="12432" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="12437" class="Symbol">(</a><a id="12438" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="12441" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="12443" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="12448" class="Symbol">)</a>

        <a id="12459" class="CatchallClause Symbol">_</a> <a id="12461" class="Symbol">→</a> <a id="12463" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="12473" class="String">&quot;Too many possible instances; will not use instance search for this goal&quot;</a>
    <a id="12551" href="Meta.HLevel.html#11393" class="Bound">go</a> <a id="12554" href="Meta.HLevel.html#10986" class="Bound">instances</a>

  <a id="12567" class="Comment">-- Entry point for calling the tactic.</a>
  <a id="search"></a><a id="12608" href="Meta.HLevel.html#12608" class="Function">search</a> <a id="12615" class="Symbol">:</a> <a id="12617" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="12622" class="Symbol">→</a> <a id="12624" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12629" class="Symbol">→</a> <a id="12631" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="12633" class="Symbol">→</a> <a id="12635" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="12640" class="Symbol">→</a> <a id="12642" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="12645" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="12649" class="Comment">-- Give up if we&#39;re out of fuel:</a>
  <a id="12684" href="Meta.HLevel.html#12608" class="Function">search</a> <a id="12691" href="Meta.HLevel.html#12691" class="Bound">has-alts</a> <a id="12700" class="Symbol">_</a>     <a id="12706" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="12714" href="Meta.HLevel.html#12714" class="Bound">goal</a> <a id="12719" class="Symbol">=</a> <a id="12721" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="12727" href="Meta.HLevel.html#12714" class="Bound">goal</a> <a id="12732" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>

  <a id="12743" class="Comment">-- Actual main loop: try using the hints database, try treating the</a>
  <a id="12813" class="Comment">-- goal as an n-type, fall back to instance search.</a>
  <a id="12867" href="Meta.HLevel.html#12608" class="Function">search</a> <a id="12874" href="Meta.HLevel.html#12874" class="Bound">has-alts</a> <a id="12883" href="Meta.HLevel.html#12883" class="Bound">level</a> <a id="12889" class="Symbol">(</a><a id="12890" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="12894" href="Meta.HLevel.html#12894" class="Bound">n</a><a id="12895" class="Symbol">)</a> <a id="12897" href="Meta.HLevel.html#12897" class="Bound">goal</a> <a id="12902" class="Symbol">=</a>
    <a id="12908" href="Meta.HLevel.html#13226" class="Function">use-projections</a>
      <a id="12930" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="12934" href="Meta.HLevel.html#21570" class="Function">use-hints</a>
      <a id="12950" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="12954" href="Meta.HLevel.html#10735" class="Function">use-instance-search</a> <a id="12974" href="Meta.HLevel.html#12874" class="Bound">has-alts</a> <a id="12983" href="Meta.HLevel.html#12897" class="Bound">goal</a>
      <a id="12994" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="12998" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="13008" class="String">&quot;Search failed!!&quot;</a>
    <a id="13030" class="Keyword">where</a>
      <a id="13042" class="Keyword">open</a> <a id="13047" href="Meta.HLevel.html#4123" class="Module">hlevel-projection</a>

      <a id="13072" class="Comment">-- Nondeterministically use a projection for establishing the</a>
      <a id="13140" class="Comment">-- result. This follows the approach described in [Using</a>
      <a id="13203" class="Comment">-- projections].</a>
      <a id="13226" href="Meta.HLevel.html#13226" class="Function">use-projections</a> <a id="13242" class="Symbol">:</a> <a id="13244" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="13247" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="13255" href="Meta.HLevel.html#13226" class="Function">use-projections</a> <a id="13271" class="Symbol">=</a> <a id="13273" class="Keyword">do</a>
        <a id="13284" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13288" href="Meta.HLevel.html#13288" class="Bound">qn</a> <a id="13291" class="Symbol">_</a> <a id="13293" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13295" class="Symbol">(</a><a id="13296" href="Agda.Builtin.Sigma.html#263" class="Field">snd</a> <a id="13300" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="13304" href="Meta.HLevel.html#6448" class="Function">decompose-is-hlevel</a> <a id="13324" href="Meta.HLevel.html#12897" class="Bound">goal</a><a id="13328" class="Symbol">)</a> <a id="13330" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="13334" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
          <a id="13351" class="Keyword">where</a> <a id="13357" class="CatchallClause Symbol">_</a> <a id="13359" class="Symbol">→</a> <a id="13361" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="13371" class="String">&quot;Term is not headed by a definition; ignoring projections.&quot;</a>

        <a id="13440" href="Meta.HLevel.html#13440" class="Bound">goalt</a> <a id="13446" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13448" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="13458" href="Meta.HLevel.html#12897" class="Bound">goal</a>
        <a id="13471" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="13482" class="String">&quot;tactic.hlevel&quot;</a> <a id="13498" class="Number">20</a> <a id="13501" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="13513" class="String">&quot;Will attempt to use projections for goal\n  &quot;</a> <a id="13560" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13562" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13570" href="Meta.HLevel.html#13440" class="Bound">goalt</a> <a id="13576" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13578" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="13590" class="Symbol">(</a><a id="13591" href="Meta.HLevel.html#13591" class="Bound">solved</a> <a id="13598" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13600" href="Meta.HLevel.html#13600" class="Bound">instances</a><a id="13609" class="Symbol">)</a> <a id="13611" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13613" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="13628" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="13630" class="Keyword">do</a>
          <a id="13643" href="Meta.HLevel.html#13643" class="Bound">solved</a><a id="13649" class="Symbol">@(</a><a id="13651" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="13656" href="Meta.HLevel.html#13656" class="Bound">mv</a> <a id="13659" class="Symbol">_)</a> <a id="13662" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13664" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="13673" class="Symbol">(</a><a id="13674" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="13678" class="Symbol">(</a><a id="13679" class="Keyword">quote</a> <a id="13685" href="Meta.HLevel.html#4123" class="Record">hlevel-projection</a><a id="13702" class="Symbol">)</a> <a id="13704" class="Symbol">(</a><a id="13705" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="13709" class="Symbol">(</a><a id="13710" href="Agda.Builtin.Reflection.html#4283" class="InductiveConstructor">name</a> <a id="13715" href="Meta.HLevel.html#13288" class="Bound">qn</a><a id="13717" class="Symbol">)</a> <a id="13719" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="13722" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13724" class="Symbol">))</a>
            <a id="13739" class="Keyword">where</a> <a id="13745" class="CatchallClause Symbol">_</a> <a id="13747" class="Symbol">→</a> <a id="13749" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="13759" class="Symbol">(</a><a id="13760" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="13768" href="Meta.HLevel.html#12897" class="Bound">goal</a> <a id="13773" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13775" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13777" class="Symbol">)</a>

          <a id="13790" class="Comment">-- If there are some hints, then great, otherwise we discard</a>
          <a id="13861" class="Comment">-- the TC state.</a>
          <a id="13888" class="Symbol">(</a><a id="13889" href="Meta.HLevel.html#13889" class="Bound">x</a> <a id="13891" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13893" href="Meta.HLevel.html#13893" class="Bound">xs</a><a id="13895" class="Symbol">)</a> <a id="13897" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="13899" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="13912" href="Meta.HLevel.html#13656" class="Bound">mv</a>
            <a id="13927" class="Keyword">where</a> <a id="13933" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="13936" class="Symbol">→</a> <a id="13938" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="13943" class="Symbol">((</a><a id="13945" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="13953" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13955" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="13957" class="Symbol">)</a> <a id="13959" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13961" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="13966" class="Symbol">)</a>

          <a id="13979" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="13984" class="Symbol">((</a><a id="13986" href="Meta.HLevel.html#13643" class="Bound">solved</a> <a id="13993" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="13995" href="Meta.HLevel.html#13889" class="Bound">x</a> <a id="13997" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="13999" href="Meta.HLevel.html#13893" class="Bound">xs</a><a id="14001" class="Symbol">)</a> <a id="14003" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14005" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="14009" class="Symbol">)</a>

        <a id="14020" href="Meta.Foldable.html#489" class="Function">nondet</a> <a id="14027" class="Symbol">(</a><a id="14028" href="Meta.Idiom.html#121" class="InductiveConstructor">eff</a> <a id="14032" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="14036" class="Symbol">)</a> <a id="14038" href="Meta.HLevel.html#13600" class="Bound">instances</a> <a id="14048" class="Symbol">λ</a> <a id="14050" href="Meta.HLevel.html#14050" class="Bound">a</a> <a id="14052" class="Symbol">→</a> <a id="14054" class="Keyword">do</a>
          <a id="14067" href="Meta.HLevel.html#14067" class="Bound">projection</a> <a id="14078" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="14080" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="14090" class="Symbol">{</a><a id="14091" class="Argument">A</a> <a id="14093" class="Symbol">=</a> <a id="14095" href="Meta.HLevel.html#4123" class="Record">hlevel-projection</a> <a id="14113" href="Meta.HLevel.html#13288" class="Bound">qn</a><a id="14115" class="Symbol">}</a> <a id="14117" href="Meta.HLevel.html#14050" class="Bound">a</a>
          <a id="14129" href="Meta.HLevel.html#14129" class="Bound">ty</a> <a id="14132" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="14134" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="14149" class="Symbol">(</a><a id="14150" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="14156" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="14158" href="Meta.HLevel.html#5885" class="Function">atoms</a><a id="14163" class="Symbol">)</a> <a id="14165" class="Symbol">(</a><a id="14166" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="14176" href="Meta.HLevel.html#12897" class="Bound">goal</a> <a id="14181" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="14185" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="14191" class="Symbol">)</a>
          <a id="14203" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="14214" class="String">&quot;tactic.hlevel&quot;</a> <a id="14230" class="Number">20</a> <a id="14233" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="14247" class="String">&quot;Outer type: &quot;</a> <a id="14262" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14264" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="14272" href="Meta.HLevel.html#14129" class="Bound">ty</a> <a id="14275" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="14277" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="14290" href="Meta.HLevel.html#9429" class="Function">treat-as-n-type</a> <a id="14306" href="Meta.HLevel.html#14067" class="Bound">projection</a> <a id="14317" href="Meta.HLevel.html#12897" class="Bound">goal</a> <a id="14322" href="Meta.Bind.html#296" class="Function Operator">&gt;&gt;</a> <a id="14325" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="14331" href="Meta.HLevel.html#13591" class="Bound">solved</a> <a id="14338" href="Meta.HLevel.html#14050" class="Bound">a</a>

      <a id="14347" class="Comment">-- Get rid of any invisible binders that lead the term.</a>
      <a id="14409" href="Meta.HLevel.html#14409" class="Function">remove-invisible</a> <a id="14426" class="Symbol">:</a> <a id="14428" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14433" class="Symbol">→</a> <a id="14435" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14440" class="Symbol">→</a> <a id="14442" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="14445" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14456" href="Meta.HLevel.html#14409" class="Function">remove-invisible</a>
        <a id="14481" class="Symbol">(</a><a id="14482" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14486" class="Symbol">_</a> <a id="14488" class="Symbol">(</a><a id="14489" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14493" class="Symbol">_</a> <a id="14495" href="Meta.HLevel.html#14495" class="Bound">t</a><a id="14496" class="Symbol">))</a>
        <a id="14507" class="Symbol">(</a><a id="14508" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="14511" class="Symbol">(</a><a id="14512" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="14516" class="Symbol">(</a><a id="14517" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="14526" href="Meta.HLevel.html#14526" class="Bound">invisible</a> <a id="14536" class="Symbol">_)</a> <a id="14539" class="Symbol">_)</a> <a id="14542" class="Symbol">(</a><a id="14543" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14547" class="Symbol">_</a> <a id="14549" href="Meta.HLevel.html#14549" class="Bound">ret</a><a id="14552" class="Symbol">))</a>
        <a id="14563" class="Symbol">=</a> <a id="14565" href="Meta.HLevel.html#14409" class="Function">remove-invisible</a> <a id="14582" href="Meta.HLevel.html#14495" class="Bound">t</a> <a id="14584" href="Meta.HLevel.html#14549" class="Bound">ret</a>
      <a id="14594" href="Meta.HLevel.html#14409" class="CatchallClause Function">remove-invisible</a><a id="14610" class="CatchallClause"> </a><a id="14611" href="Meta.HLevel.html#14611" class="CatchallClause Bound">inner</a><a id="14616" class="CatchallClause"> </a><a id="14617" class="CatchallClause Symbol">_</a> <a id="14619" class="Symbol">=</a> <a id="14621" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="14626" href="Meta.HLevel.html#14611" class="Bound">inner</a>

      <a id="14639" class="Comment">-- Search using decompositions involves manipulating the scope,</a>
      <a id="14709" class="Comment">-- which is why it&#39;s spread over so many functions, and even then,</a>
      <a id="14782" class="Comment">-- some are too big.</a>

      <a id="14810" class="Comment">-- Wrap the given term in a series of visible lambdas.</a>
      <a id="14871" href="Meta.HLevel.html#14871" class="Function">wrap-lams</a> <a id="14881" class="Symbol">:</a> <a id="14883" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="14885" class="Symbol">→</a> <a id="14887" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="14892" class="Symbol">→</a> <a id="14894" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
      <a id="14905" href="Meta.HLevel.html#14871" class="Function">wrap-lams</a> <a id="14915" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="14920" href="Meta.HLevel.html#14920" class="Bound">r</a> <a id="14922" class="Symbol">=</a> <a id="14924" href="Meta.HLevel.html#14920" class="Bound">r</a>
      <a id="14932" href="Meta.HLevel.html#14871" class="Function">wrap-lams</a> <a id="14942" class="Symbol">(</a><a id="14943" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="14947" href="Meta.HLevel.html#14947" class="Bound">x</a><a id="14948" class="Symbol">)</a> <a id="14950" href="Meta.HLevel.html#14950" class="Bound">r</a> <a id="14952" class="Symbol">=</a> <a id="14954" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="14958" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="14966" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="14968" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="14972" class="String">&quot;a&quot;</a> <a id="14976" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="14978" href="Meta.HLevel.html#14871" class="Function">wrap-lams</a> <a id="14988" href="Meta.HLevel.html#14947" class="Bound">x</a> <a id="14990" href="Meta.HLevel.html#14950" class="Bound">r</a>

      <a id="14999" class="Comment">-- Compute a continuation which extends the context by n visible</a>
      <a id="15070" class="Comment">-- variables, all typed &#39;unknown&#39;.</a>
      <a id="15111" href="Meta.HLevel.html#15111" class="Function">extend-n</a> <a id="15120" class="Symbol">:</a> <a id="15122" class="Symbol">∀</a> <a id="15124" class="Symbol">{</a><a id="15125" href="Meta.HLevel.html#15125" class="Bound">ℓ</a><a id="15126" class="Symbol">}</a> <a id="15128" class="Symbol">→</a> <a id="15130" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="15132" class="Symbol">→</a> <a id="15134" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15137" class="Symbol">((</a><a id="15139" href="Meta.HLevel.html#15139" class="Bound">A</a> <a id="15141" class="Symbol">:</a> <a id="15143" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="15148" href="Meta.HLevel.html#15125" class="Bound">ℓ</a><a id="15149" class="Symbol">)</a> <a id="15151" class="Symbol">→</a> <a id="15153" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15156" href="Meta.HLevel.html#15139" class="Bound">A</a> <a id="15158" class="Symbol">→</a> <a id="15160" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="15163" href="Meta.HLevel.html#15139" class="Bound">A</a><a id="15164" class="Symbol">)</a>
      <a id="15172" href="Meta.HLevel.html#15111" class="Function">extend-n</a> <a id="15181" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="15186" class="Symbol">=</a> <a id="15188" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15193" class="Symbol">λ</a> <a id="15195" href="Meta.HLevel.html#15195" class="Bound">_</a> <a id="15197" href="Meta.HLevel.html#15197" class="Bound">x</a> <a id="15199" class="Symbol">→</a> <a id="15201" href="Meta.HLevel.html#15197" class="Bound">x</a>
      <a id="15209" href="Meta.HLevel.html#15111" class="Function">extend-n</a> <a id="15218" class="Symbol">(</a><a id="15219" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="15223" href="Meta.HLevel.html#15223" class="Bound">n</a><a id="15224" class="Symbol">)</a> <a id="15226" class="Symbol">=</a> <a id="15228" class="Keyword">do</a>
        <a id="15239" href="Meta.HLevel.html#15239" class="Bound">rest</a> <a id="15244" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="15246" href="Meta.HLevel.html#15111" class="Function">extend-n</a> <a id="15255" href="Meta.HLevel.html#15223" class="Bound">n</a>
        <a id="15265" href="Foundations.Prim.Type.html#599" class="InductiveConstructor">lift</a> <a id="15270" href="Meta.HLevel.html#15270" class="Bound">mv</a> <a id="15273" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="15275" href="Meta.HLevel.html#15239" class="Bound">rest</a> <a id="15280" class="Symbol">(</a><a id="15281" href="Foundations.Prim.Type.html#538" class="Record">Lift</a> <a id="15286" class="Symbol">_</a> <a id="15288" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15292" class="Symbol">)</a> <a id="15294" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15296" href="Foundations.Prim.Type.html#599" class="InductiveConstructor">lift</a> <a id="15301" href="Meta.Idiom.html#282" class="Field Operator">&lt;$&gt;</a> <a id="15305" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="15314" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="15330" class="Keyword">let</a> <a id="15334" href="Meta.HLevel.html#15334" class="Bound">domain</a> <a id="15341" class="Symbol">=</a> <a id="15343" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="15347" class="Symbol">(</a><a id="15348" href="Agda.Builtin.Reflection.html#3637" class="InductiveConstructor">arg-info</a> <a id="15357" href="Agda.Builtin.Reflection.html#2762" class="InductiveConstructor">visible</a> <a id="15365" class="Symbol">(</a><a id="15366" href="Agda.Builtin.Reflection.html#3463" class="InductiveConstructor">modality</a> <a id="15375" href="Agda.Builtin.Reflection.html#3019" class="InductiveConstructor">relevant</a> <a id="15384" href="Agda.Builtin.Reflection.html#3241" class="InductiveConstructor">quantity-ω</a><a id="15394" class="Symbol">))</a> <a id="15397" href="Meta.HLevel.html#15270" class="Bound">mv</a>
        <a id="15408" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="15413" class="Symbol">λ</a> <a id="15415" href="Meta.HLevel.html#15415" class="Bound">a</a> <a id="15417" href="Meta.HLevel.html#15417" class="Bound">k</a> <a id="15419" class="Symbol">→</a> <a id="15421" href="Meta.HLevel.html#15239" class="Bound">rest</a> <a id="15426" href="Meta.HLevel.html#15415" class="Bound">a</a> <a id="15428" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15430" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="15444" class="String">&quot;a&quot;</a> <a id="15448" href="Meta.HLevel.html#15334" class="Bound">domain</a> <a id="15455" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="15457" href="Meta.HLevel.html#15417" class="Bound">k</a>

      <a id="15466" class="Comment">-- Given a list of argument specs, actually unify the goal with</a>
      <a id="15536" class="Comment">-- the solution of decomposition, and call a continuation to</a>
      <a id="15603" class="Comment">-- perform any outstanding searches.</a>
      <a id="15646" href="Meta.HLevel.html#15646" class="Function">gen-args</a>
        <a id="15663" class="Symbol">:</a> <a id="15665" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>              <a id="15683" class="Comment">-- ^ Are there any alternatives after this one?</a>
        <a id="15739" class="Symbol">→</a> <a id="15741" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>              <a id="15759" class="Comment">-- ^ What level are we searching for?</a>

        <a id="15806" class="Symbol">→</a> <a id="15808" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>              <a id="15826" class="Comment">-- ^ Name of the lemma,</a>
        <a id="15858" class="Symbol">→</a> <a id="15860" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15865" href="Meta.HLevel.html#2883" class="Datatype">Arg-spec</a>     <a id="15878" class="Comment">-- ^ and the arguments we should invent.</a>

        <a id="15928" class="Symbol">→</a> <a id="15930" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="15935" class="Symbol">(</a><a id="15936" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="15940" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="15944" class="Symbol">)</a>
        <a id="15954" class="Comment">-- ^ Accumulator: computed arguments (criminally, in reverse</a>
        <a id="16023" class="Comment">-- order)</a>
        <a id="16041" class="Symbol">→</a> <a id="16043" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="16046" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
          <a id="16058" class="Comment">-- ^ Accumulator/continuation: what do we need to do after</a>
          <a id="16127" class="Comment">-- unifying the goal with the lemma?. This is both</a>
          <a id="16188" class="Comment">-- continuation (it can be used to run something after the</a>
          <a id="16257" class="Comment">-- arguments are built) and accumulator (searching recursively</a>
          <a id="16330" class="Comment">-- is done last).</a>
        <a id="16356" class="Symbol">→</a> <a id="16358" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="16361" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>              <a id="16376" class="Comment">-- ^ Returns nada</a>
      <a id="16400" href="Meta.HLevel.html#15646" class="Function">gen-args</a> <a id="16409" href="Meta.HLevel.html#16409" class="Bound">has-alts</a> <a id="16418" href="Meta.HLevel.html#16418" class="Bound">level</a> <a id="16424" href="Meta.HLevel.html#16424" class="Bound">defn</a> <a id="16429" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="16432" href="Meta.HLevel.html#16432" class="Bound">accum</a> <a id="16438" href="Meta.HLevel.html#16438" class="Bound">cont</a> <a id="16443" class="Symbol">=</a> <a id="16445" class="Keyword">do</a>
        <a id="16456" class="Comment">-- If we have no arguments to generate, then we can go ahead and</a>
        <a id="16529" class="Comment">-- use the accumulator as-is.</a>
        <a id="16567" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="16573" href="Meta.HLevel.html#12897" class="Bound">goal</a> <a id="16578" class="Symbol">(</a><a id="16579" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16583" href="Meta.HLevel.html#16424" class="Bound">defn</a> <a id="16588" class="Symbol">(</a><a id="16589" href="Data.List.Base.html#972" class="Function">reverse-fast</a> <a id="16602" href="Meta.HLevel.html#16432" class="Bound">accum</a><a id="16607" class="Symbol">))</a>
        <a id="16618" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="16629" class="String">&quot;tactic.hlevel&quot;</a> <a id="16645" class="Number">10</a> <a id="16648" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="16660" class="String">&quot;Committed to solution: &quot;</a> <a id="16686" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16688" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="16696" class="Symbol">(</a><a id="16697" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="16701" href="Meta.HLevel.html#16424" class="Bound">defn</a> <a id="16706" class="Symbol">(</a><a id="16707" href="Data.List.Base.html#883" class="Function">reverse</a> <a id="16715" href="Meta.HLevel.html#16432" class="Bound">accum</a><a id="16720" class="Symbol">))</a> <a id="16723" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16725" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="16736" href="Meta.HLevel.html#16438" class="Bound">cont</a>

      <a id="16748" href="Meta.HLevel.html#15646" class="Function">gen-args</a> <a id="16757" href="Meta.HLevel.html#16757" class="Bound">has-alts</a> <a id="16766" href="Meta.HLevel.html#16766" class="Bound">level</a> <a id="16772" href="Meta.HLevel.html#16772" class="Bound">defn</a> <a id="16777" class="Symbol">(</a><a id="16778" href="Meta.HLevel.html#16778" class="Bound">x</a> <a id="16780" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="16782" href="Meta.HLevel.html#16782" class="Bound">args</a><a id="16786" class="Symbol">)</a> <a id="16788" href="Meta.HLevel.html#16788" class="Bound">accum</a> <a id="16794" href="Meta.HLevel.html#16794" class="Bound">cont</a> <a id="16799" class="Keyword">with</a> <a id="16804" href="Meta.HLevel.html#16778" class="Bound">x</a>
      <a id="16812" class="Comment">-- If we got asked for the level without an adjustment (i.e. monus</a>
      <a id="16885" class="Comment">-- by zero), then we may as well not bother *trying* to adjust it.</a>
      <a id="16958" class="Comment">-- Saves a bit of computation.</a>
      <a id="16995" class="Symbol">...</a> <a id="16999" class="Symbol">|</a> <a id="17001" href="Meta.HLevel.html#2907" class="InductiveConstructor">`level-minus</a> <a id="17014" class="Number">0</a> <a id="17016" class="Symbol">=</a> <a id="17018" href="Meta.HLevel.html#15646" class="Function">gen-args</a> <a id="17027" class="Bound">has-alts</a> <a id="17036" class="Bound">level</a> <a id="17042" class="Bound">defn</a> <a id="17047" class="Bound">args</a> <a id="17052" class="Symbol">(</a><a id="17053" class="Bound">level</a> <a id="17059" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="17062" class="Bound">accum</a><a id="17067" class="Symbol">)</a> <a id="17069" class="Bound">cont</a>
      <a id="17080" class="Comment">-- If we have to insert the level minus some offset, then we need</a>
      <a id="17152" class="Comment">-- to do the computation:</a>
      <a id="17184" class="Symbol">...</a> <a id="17188" class="Symbol">|</a> <a id="17190" href="Meta.HLevel.html#2907" class="InductiveConstructor">`level-minus</a> <a id="17203" href="Meta.HLevel.html#17203" class="Bound">n</a><a id="17204" class="Symbol">@(</a><a id="17206" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="17210" class="Symbol">_)</a> <a id="17213" class="Symbol">=</a>
        <a id="17223" class="Keyword">do</a>
          <a id="17236" href="Meta.HLevel.html#17236" class="Bound">level</a> <a id="17242" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="17244" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="17254" class="Bound">level</a>
          <a id="17270" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="17281" class="String">&quot;tactic.hlevel&quot;</a> <a id="17297" class="Number">10</a> <a id="17300" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
            <a id="17314" class="String">&quot;Hint demands offset, performing symbolic monus, subtracting from\n  &quot;</a> <a id="17385" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17387" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="17395" href="Meta.HLevel.html#17236" class="Bound">level</a> <a id="17401" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="17403" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
          <a id="17416" href="Meta.HLevel.html#17416" class="Bound">level′′</a> <a id="17424" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="17426" href="Meta.HLevel.html#18011" class="Function">monus</a> <a id="17432" href="Meta.HLevel.html#17236" class="Bound">level</a> <a id="17438" href="Meta.HLevel.html#17203" class="Bound">n</a>
          <a id="17450" class="Comment">-- Reduce otherwise we get Number.fromNat as the term</a>
          <a id="17514" href="Meta.HLevel.html#15646" class="Function">gen-args</a> <a id="17523" class="Bound">has-alts</a> <a id="17532" href="Meta.HLevel.html#17236" class="Bound">level</a> <a id="17538" class="Bound">defn</a> <a id="17543" class="Bound">args</a> <a id="17548" class="Symbol">(</a><a id="17549" href="Meta.HLevel.html#17416" class="Bound">level′′</a> <a id="17557" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="17560" class="Bound">accum</a><a id="17565" class="Symbol">)</a> <a id="17567" class="Bound">cont</a>
        <a id="17580" class="Keyword">where</a>
          <a id="17596" class="Comment">-- A &#39;symbolic&#39; monus function. If we&#39;re looking at an actual</a>
          <a id="17668" class="Comment">-- number, then we can just do the computation in TC, but</a>
          <a id="17736" class="Comment">-- otherwise we have to reimplement the builtin subtraction,</a>
          <a id="17807" class="Comment">-- where the minuend is a *term* rather than a number. In</a>
          <a id="17875" class="Comment">-- addition to being a bad operation (monus, grr), it&#39;s</a>
          <a id="17941" class="Comment">-- *partial*. We can end up backtracking while subtracting.</a>
          <a id="18011" href="Meta.HLevel.html#18011" class="Function">monus</a> <a id="18017" class="Symbol">:</a> <a id="18019" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="18024" class="Symbol">→</a> <a id="18026" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="18028" class="Symbol">→</a> <a id="18030" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="18033" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a>
          <a id="18048" href="Meta.HLevel.html#18011" class="Function">monus</a> <a id="18054" class="Symbol">(</a><a id="18055" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="18059" class="Symbol">(</a><a id="18060" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18064" href="Meta.HLevel.html#18064" class="Bound">n</a><a id="18065" class="Symbol">))</a> <a id="18068" href="Meta.HLevel.html#18068" class="Bound">k</a> <a id="18070" class="Symbol">=</a> <a id="18072" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18077" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="18079" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="18083" class="Symbol">(</a><a id="18084" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="18088" class="Symbol">(</a><a id="18089" href="Meta.HLevel.html#18064" class="Bound">n</a> <a id="18091" href="Agda.Builtin.Nat.html#426" class="Primitive Operator">-</a> <a id="18093" href="Meta.HLevel.html#18068" class="Bound">k</a><a id="18094" class="Symbol">))</a>
          <a id="18107" href="Meta.HLevel.html#18011" class="CatchallClause Function">monus</a><a id="18112" class="CatchallClause"> </a><a id="18113" href="Meta.HLevel.html#18113" class="CatchallClause Bound">tm</a><a id="18115" class="CatchallClause"> </a><a id="18116" href="Agda.Builtin.Nat.html#221" class="CatchallClause InductiveConstructor">zero</a> <a id="18121" class="Symbol">=</a> <a id="18123" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18128" href="Meta.HLevel.html#18113" class="Bound">tm</a>
          <a id="18141" href="Meta.HLevel.html#18011" class="Function">monus</a> <a id="18147" href="Meta.HLevel.html#18147" class="Bound">thezero</a><a id="18154" class="Symbol">@(</a><a id="18156" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18160" class="Symbol">(</a><a id="18161" class="Keyword">quote</a> <a id="18167" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="18171" class="Symbol">)</a> <a id="18173" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18175" class="Symbol">)</a> <a id="18177" class="Symbol">(</a><a id="18178" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18182" href="Meta.HLevel.html#18182" class="Bound">it</a><a id="18184" class="Symbol">)</a> <a id="18186" class="Symbol">=</a> <a id="18188" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="18193" href="Meta.HLevel.html#18147" class="Bound">thezero</a>
          <a id="18211" href="Meta.HLevel.html#18011" class="Function">monus</a> <a id="18217" class="Symbol">(</a><a id="18218" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="18222" class="Symbol">(</a><a id="18223" class="Keyword">quote</a> <a id="18229" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="18232" class="Symbol">)</a> <a id="18234" class="Symbol">(</a><a id="18235" href="Meta.HLevel.html#18235" class="Bound">x</a> <a id="18237" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="18240" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="18242" class="Symbol">))</a> <a id="18245" class="Symbol">(</a><a id="18246" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="18250" href="Meta.HLevel.html#18250" class="Bound">it</a><a id="18252" class="Symbol">)</a> <a id="18254" class="Symbol">=</a> <a id="18256" class="Keyword">do</a>
            <a id="18271" href="Meta.HLevel.html#18271" class="Bound">x</a> <a id="18273" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="18275" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="18282" href="Meta.HLevel.html#18235" class="Bound">x</a>
            <a id="18296" href="Meta.HLevel.html#18011" class="Function">monus</a> <a id="18302" href="Meta.HLevel.html#18271" class="Bound">x</a> <a id="18304" href="Meta.HLevel.html#18250" class="Bound">it</a>
          <a id="18317" href="Meta.HLevel.html#18011" class="CatchallClause Function">monus</a><a id="18322" class="CatchallClause"> </a><a id="18323" href="Meta.HLevel.html#18323" class="CatchallClause Bound">tm</a><a id="18325" class="CatchallClause"> </a><a id="18326" class="CatchallClause Symbol">(</a><a id="18327" href="Agda.Builtin.Nat.html#234" class="CatchallClause InductiveConstructor">suc</a><a id="18330" class="CatchallClause"> </a><a id="18331" href="Meta.HLevel.html#18331" class="CatchallClause Bound">it</a><a id="18333" class="CatchallClause Symbol">)</a> <a id="18335" class="Symbol">=</a> <a id="18337" class="Keyword">do</a>
            <a id="18352" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="18363" class="String">&quot;tactic.hlevel&quot;</a> <a id="18379" class="Number">10</a> <a id="18382" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="18384" class="String">&quot;Dunno how to take 1 from &quot;</a> <a id="18412" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18414" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="18422" href="Meta.HLevel.html#18323" class="Bound">tm</a> <a id="18425" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="18427" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
            <a id="18442" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="18452" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="18462" class="Comment">-- Insert a metavariable, to be solved by Agda. It&#39;d be sad if the</a>
      <a id="18535" class="Comment">-- macro handled everything!</a>
      <a id="18570" class="Symbol">...</a> <a id="18574" class="Symbol">|</a> <a id="18576" href="Meta.HLevel.html#3310" class="InductiveConstructor">`meta</a> <a id="18582" class="Symbol">=</a> <a id="18584" href="Meta.HLevel.html#15646" class="Function">gen-args</a> <a id="18593" class="Bound">has-alts</a> <a id="18602" class="Bound">level</a> <a id="18608" class="Bound">defn</a> <a id="18613" class="Bound">args</a> <a id="18618" class="Symbol">(</a><a id="18619" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="18627" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="18630" class="Bound">accum</a><a id="18635" class="Symbol">)</a> <a id="18637" class="Bound">cont</a>

      <a id="18649" class="Symbol">...</a> <a id="18653" class="Symbol">|</a> <a id="18655" href="Meta.HLevel.html#3107" class="InductiveConstructor">`search-under</a> <a id="18669" href="Meta.HLevel.html#18669" class="Bound">under</a> <a id="18675" class="Symbol">=</a> <a id="18677" class="Keyword">do</a>
        <a id="18688" class="Comment">-- To search under some variables, we work in a scope extended</a>
        <a id="18759" class="Comment">-- by &#39;under&#39;-many variables. The metavariable lives in that</a>
        <a id="18828" class="Comment">-- scope, so we have to quantify over the variables we</a>
        <a id="18891" class="Comment">-- introduced to use it outside, i.e., in the actual (outer)</a>
        <a id="18960" class="Comment">-- search problem.</a>
        <a id="18987" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="18998" class="String">&quot;tactic.hlevel&quot;</a> <a id="19014" class="Number">10</a> <a id="19017" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19019" class="String">&quot;Going under &quot;</a> <a id="19034" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19036" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="19044" class="Symbol">(</a><a id="19045" href="Agda.Builtin.Reflection.html#5203" class="InductiveConstructor">lit</a> <a id="19049" class="Symbol">(</a><a id="19050" href="Agda.Builtin.Reflection.html#4113" class="InductiveConstructor">nat</a> <a id="19054" href="Meta.HLevel.html#18669" class="Bound">under</a><a id="19059" class="Symbol">))</a> <a id="19062" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19064" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="19075" href="Meta.HLevel.html#19075" class="Bound">gounder</a> <a id="19083" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="19085" href="Meta.HLevel.html#15111" class="Function">extend-n</a> <a id="19094" href="Meta.HLevel.html#18669" class="Bound">under</a>
        <a id="19108" href="Meta.HLevel.html#19108" class="Bound">mv</a> <a id="19111" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="19113" href="Meta.HLevel.html#19075" class="Bound">gounder</a> <a id="19121" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19126" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19128" class="Keyword">do</a>
          <a id="19141" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19152" class="String">&quot;tactic.hlevel&quot;</a> <a id="19168" class="Number">10</a> <a id="19171" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19173" class="String">&quot;In extended context&quot;</a>
          <a id="19205" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="19214" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a>
        <a id="19230" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="19241" class="String">&quot;tactic.hlevel&quot;</a> <a id="19257" class="Number">10</a> <a id="19260" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19262" class="String">&quot;Metavariable: &quot;</a> <a id="19279" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19281" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="19289" class="Symbol">(</a><a id="19290" href="Meta.HLevel.html#14871" class="Function">wrap-lams</a> <a id="19300" href="Meta.HLevel.html#18669" class="Bound">under</a> <a id="19306" href="Meta.HLevel.html#19108" class="Bound">mv</a><a id="19308" class="Symbol">)</a> <a id="19310" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="19312" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="19323" class="Comment">-- After we&#39;ve put the mv wrapped under some lambdas in the</a>
        <a id="19391" class="Comment">-- argument list,</a>
        <a id="19417" href="Meta.HLevel.html#15646" class="Function">gen-args</a> <a id="19426" class="Bound">has-alts</a> <a id="19435" class="Bound">level</a> <a id="19441" class="Bound">defn</a> <a id="19446" class="Bound">args</a> <a id="19451" class="Symbol">(</a><a id="19452" href="Meta.HLevel.html#14871" class="Function">wrap-lams</a> <a id="19462" href="Meta.HLevel.html#18669" class="Bound">under</a> <a id="19468" href="Meta.HLevel.html#19108" class="Bound">mv</a> <a id="19471" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="19474" class="Bound">accum</a><a id="19479" class="Symbol">)</a> <a id="19481" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19483" class="Keyword">do</a>
          <a id="19496" class="Comment">-- On our way back up, we do any more searching that needed to</a>
          <a id="19569" class="Comment">-- get done, and..</a>
          <a id="19598" class="Bound">cont</a>
          <a id="19613" class="Comment">-- go back under the new scope to recursively search for</a>
          <a id="19680" class="Comment">-- levels.</a>
          <a id="19701" href="Meta.HLevel.html#19075" class="Bound">gounder</a> <a id="19709" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="19711" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="19713" href="Meta.HLevel.html#12608" class="Function">search</a> <a id="19720" class="Bound">has-alts</a> <a id="19729" href="Agda.Builtin.Reflection.html#5288" class="InductiveConstructor">unknown</a> <a id="19737" href="Meta.HLevel.html#12894" class="Bound">n</a> <a id="19739" href="Meta.HLevel.html#19108" class="Bound">mv</a>

      <a id="19749" class="Comment">-- Try all the candidate hints in order. This is a version of</a>
      <a id="19817" class="Comment">-- &#39;nondet&#39; which additionally threads whether we&#39;re looking at</a>
      <a id="19887" class="Comment">-- last alternative.</a>
      <a id="19914" href="Meta.HLevel.html#19914" class="Function">use-decomp-hints</a> <a id="19931" class="Symbol">:</a> <a id="19933" class="Symbol">(</a><a id="19934" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19939" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="19941" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="19945" class="Symbol">)</a> <a id="19947" class="Symbol">→</a> <a id="19949" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19954" class="Symbol">→</a> <a id="19956" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="19961" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="19966" class="Symbol">→</a> <a id="19968" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="19971" class="Symbol">(</a><a id="19972" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="19974" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="19976" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="19980" class="Symbol">)</a>
      <a id="19988" href="Meta.HLevel.html#19914" class="Function">use-decomp-hints</a> <a id="20005" class="Symbol">(</a><a id="20006" href="Meta.HLevel.html#20006" class="Bound">lv</a> <a id="20009" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="20011" href="Meta.HLevel.html#20011" class="Bound">goal-ty</a><a id="20018" class="Symbol">)</a> <a id="20020" href="Meta.HLevel.html#20020" class="Bound">solved</a> <a id="20027" class="Symbol">(</a><a id="20028" href="Meta.HLevel.html#20028" class="Bound">c1</a> <a id="20031" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20033" href="Meta.HLevel.html#20033" class="Bound">cs</a><a id="20035" class="Symbol">)</a> <a id="20037" class="Symbol">=</a> <a id="20039" class="Keyword">do</a>
        <a id="20050" href="Meta.HLevel.html#20050" class="Bound">ty</a> <a id="20053" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20055" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="20065" href="Meta.HLevel.html#20028" class="Bound">c1</a>
        <a id="20076" href="Meta.HLevel.html#20076" class="Bound">c1′</a> <a id="20080" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20082" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="20089" href="Meta.HLevel.html#20028" class="Bound">c1</a>
        <a id="20100" class="Symbol">(</a><a id="20101" href="Meta.HLevel.html#14409" class="Function">remove-invisible</a> <a id="20118" href="Meta.HLevel.html#20076" class="Bound">c1′</a> <a id="20122" href="Meta.HLevel.html#20050" class="Bound">ty</a> <a id="20125" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="20129" class="Symbol">λ</a> <a id="20131" class="Keyword">where</a>

          <a id="20148" class="Comment">-- If we have an actual decomp constructor, then we can try</a>
          <a id="20218" class="Comment">-- using its argument specification to construct a little</a>
          <a id="20286" class="Comment">-- h-level lemma</a>
          <a id="20313" class="Symbol">(</a><a id="20314" href="Agda.Builtin.Reflection.html#4888" class="InductiveConstructor">con</a> <a id="20318" class="Symbol">(</a><a id="20319" class="Keyword">quote</a> <a id="20325" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a><a id="20331" class="Symbol">)</a> <a id="20333" class="Symbol">(_</a> <a id="20336" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20338" class="Symbol">_</a> <a id="20340" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20342" href="Meta.HLevel.html#20342" class="Bound">nm</a> <a id="20345" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="20348" href="Meta.HLevel.html#20348" class="Bound">argspec</a> <a id="20356" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="20359" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20361" class="Symbol">))</a> <a id="20364" class="Symbol">→</a> <a id="20366" class="Keyword">do</a>
            <a id="20381" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="20392" class="String">&quot;tactic.hlevel&quot;</a> <a id="20408" class="Number">10</a> <a id="20411" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
              <a id="20427" class="String">&quot;Using &quot;</a> <a id="20436" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20438" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20446" href="Meta.HLevel.html#20342" class="Bound">nm</a> <a id="20449" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20451" class="String">&quot; decomposition for:\n  &quot;</a>
              <a id="20491" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20493" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="20501" class="Symbol">(</a><a id="20502" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="20506" class="Symbol">(</a><a id="20507" class="Keyword">quote</a> <a id="20513" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a><a id="20525" class="Symbol">)</a> <a id="20527" class="Symbol">(</a><a id="20528" href="Meta.HLevel.html#20006" class="Bound">lv</a> <a id="20531" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="20534" href="Meta.HLevel.html#20011" class="Bound">goal-ty</a> <a id="20542" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="20545" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="20547" class="Symbol">))</a> <a id="20550" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="20552" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

            <a id="20568" href="Meta.HLevel.html#20568" class="Bound">nm′</a> <a id="20572" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20574" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20584" href="Meta.HLevel.html#20342" class="Bound">nm</a>
            <a id="20599" href="Meta.HLevel.html#20599" class="Bound">argsp</a> <a id="20605" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="20607" href="Agda.Builtin.Reflection.html#8836" class="Postulate">unquoteTC</a> <a id="20617" href="Meta.HLevel.html#20348" class="Bound">argspec</a>
            <a id="20637" class="Comment">-- Generate the argument spine, and discard the instance</a>
            <a id="20706" class="Comment">-- search meta.</a>
            <a id="20734" href="Meta.HLevel.html#15646" class="Function">gen-args</a> <a id="20743" class="Symbol">(</a><a id="20744" href="Data.Bool.Base.html#169" class="Function">not</a> <a id="20748" class="Symbol">(</a><a id="20749" href="Data.List.Operations.html#440" class="Function">length</a> <a id="20756" href="Meta.HLevel.html#20033" class="Bound">cs</a> <a id="20759" href="Agda.Builtin.Nat.html#631" class="Primitive Operator">==</a> <a id="20762" class="Number">0</a><a id="20763" class="Symbol">))</a> <a id="20766" href="Meta.HLevel.html#20006" class="Bound">lv</a> <a id="20769" href="Meta.HLevel.html#20568" class="Bound">nm′</a> <a id="20773" href="Meta.HLevel.html#20599" class="Bound">argsp</a> <a id="20779" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="20782" class="Symbol">(</a><a id="20783" href="Agda.Builtin.Reflection.html#8339" class="Postulate">returnTC</a> <a id="20792" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="20794" class="Symbol">)</a>
            <a id="20808" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="20814" href="Meta.HLevel.html#20020" class="Bound">solved</a> <a id="20821" href="Meta.HLevel.html#20028" class="Bound">c1</a>

            <a id="20837" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="20842" class="Symbol">(</a><a id="20843" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="20846" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="20848" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="20852" class="Symbol">)</a>

          <a id="20865" class="Comment">-- It&#39;s possible that this particular hint was a bust, i.e.</a>
          <a id="20935" class="Comment">-- because someone wasn&#39;t being careful with what</a>
          <a id="20995" class="Comment">-- hlevel-decomposition instances they&#39;ve defined. That&#39;s no</a>
          <a id="21066" class="Comment">-- matter: we can just ignore it.</a>
          <a id="21110" class="CatchallClause Symbol">_</a> <a id="21112" class="Symbol">→</a> <a id="21114" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="21124" class="String">&quot;Non-canonical hint&quot;</a><a id="21144" class="Symbol">)</a>
          <a id="21156" class="Comment">-- If we didn&#39;t manage to get the hint to work, for any</a>
          <a id="21222" class="Comment">-- reason, try again with the rest of the hints.</a>
          <a id="21281" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a> <a id="21285" href="Meta.HLevel.html#19914" class="Function">use-decomp-hints</a> <a id="21302" class="Symbol">(</a><a id="21303" href="Meta.HLevel.html#20006" class="Bound">lv</a> <a id="21306" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21308" href="Meta.HLevel.html#20011" class="Bound">goal-ty</a><a id="21315" class="Symbol">)</a> <a id="21317" href="Meta.HLevel.html#20020" class="Bound">solved</a> <a id="21324" href="Meta.HLevel.html#20033" class="Bound">cs</a>

      <a id="21334" href="Meta.HLevel.html#19914" class="Function">use-decomp-hints</a> <a id="21351" class="Symbol">(_</a> <a id="21354" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21356" href="Meta.HLevel.html#21356" class="Bound">goal-ty</a><a id="21363" class="Symbol">)</a> <a id="21365" class="Symbol">_</a> <a id="21367" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="21370" class="Symbol">=</a>
        <a id="21380" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="21390" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="21392" class="String">&quot;Ran out of decomposition hints for &quot;</a> <a id="21430" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21432" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="21440" href="Meta.HLevel.html#21356" class="Bound">goal-ty</a> <a id="21448" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="21450" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

      <a id="21460" class="Comment">-- Using the hints involving querying Agda for potential</a>
      <a id="21523" class="Comment">-- instances, then trying each in order.</a>
      <a id="21570" href="Meta.HLevel.html#21570" class="Function">use-hints</a> <a id="21580" class="Symbol">:</a> <a id="21582" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="21585" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
      <a id="21593" href="Meta.HLevel.html#21570" class="Function">use-hints</a> <a id="21603" class="Symbol">=</a> <a id="21605" href="Agda.Builtin.Reflection.html#11120" class="Postulate">runSpeculative</a> <a id="21620" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="21622" class="Keyword">do</a>
        <a id="21633" class="Symbol">(</a><a id="21634" href="Meta.HLevel.html#21634" class="Bound">lv</a> <a id="21637" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="21639" href="Meta.HLevel.html#21639" class="Bound">ty</a><a id="21641" class="Symbol">)</a> <a id="21643" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="21645" href="Meta.HLevel.html#6448" class="Function">decompose-is-hlevel</a> <a id="21665" href="Meta.HLevel.html#12897" class="Bound">goal</a>

        <a id="21679" class="Comment">-- Note that if the type here is a metavariable, the tactic is..</a>
        <a id="21752" class="Comment">-- loopy.</a>
        <a id="21770" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="21775" href="Meta.HLevel.html#21639" class="Bound">ty</a> <a id="21778" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="21782" class="Symbol">λ</a> <a id="21784" class="Keyword">where</a>
          <a id="21800" class="Symbol">(</a><a id="21801" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="21806" href="Meta.HLevel.html#21806" class="Bound">m</a> <a id="21808" class="Symbol">_)</a> <a id="21811" class="Symbol">→</a> <a id="21813" class="Keyword">do</a>
            <a id="21828" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="21839" class="String">&quot;tactic.hlevel&quot;</a> <a id="21855" class="Number">10</a>
              <a id="21872" class="String">&quot;Type under is-hlevel is metavariable, blocking to avoid infinite loop&quot;</a>
            <a id="21956" href="Agda.Builtin.Reflection.html#9468" class="Postulate">blockOnMeta</a> <a id="21968" href="Meta.HLevel.html#21806" class="Bound">m</a>
          <a id="21980" class="CatchallClause Symbol">_</a> <a id="21982" class="Symbol">→</a> <a id="21984" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="21989" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>

        <a id="22001" class="Comment">-- Create a meta of type hlevel-decomposition to find any possible hints..</a>
        <a id="22084" href="Meta.HLevel.html#22084" class="Bound">solved</a><a id="22090" class="Symbol">@(</a><a id="22092" href="Agda.Builtin.Reflection.html#5238" class="InductiveConstructor">meta</a> <a id="22097" href="Meta.HLevel.html#22097" class="Bound">mv</a> <a id="22100" class="Symbol">_)</a> <a id="22103" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22105" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="22114" class="Symbol">(</a><a id="22115" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="22119" class="Symbol">(</a><a id="22120" class="Keyword">quote</a> <a id="22126" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a><a id="22146" class="Symbol">)</a> <a id="22148" class="Symbol">(</a><a id="22149" href="Meta.HLevel.html#21639" class="Bound">ty</a> <a id="22152" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="22155" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22157" class="Symbol">))</a>
          <a id="22170" class="Keyword">where</a> <a id="22176" class="CatchallClause Symbol">_</a> <a id="22178" class="Symbol">→</a> <a id="22180" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="22190" class="Symbol">(</a><a id="22191" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22199" href="Meta.HLevel.html#21639" class="Bound">ty</a> <a id="22202" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22204" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="22206" class="Symbol">)</a>
        <a id="22216" href="Meta.HLevel.html#22216" class="Bound">instances</a> <a id="22226" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22228" href="Agda.Builtin.Reflection.html#11315" class="Postulate">getInstances</a> <a id="22241" href="Meta.HLevel.html#22097" class="Bound">mv</a>

        <a id="22253" href="Meta.HLevel.html#22253" class="Bound">t</a> <a id="22255" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="22257" href="Agda.Builtin.Reflection.html#8783" class="Postulate">quoteTC</a> <a id="22265" href="Meta.HLevel.html#22216" class="Bound">instances</a>
        <a id="22283" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="22294" class="String">&quot;tactic.hlevel&quot;</a> <a id="22310" class="Number">10</a> <a id="22313" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
          <a id="22325" class="String">&quot;Finding decompositions for\n&quot;</a> <a id="22356" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22368" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22376" href="Meta.HLevel.html#21639" class="Bound">ty</a> <a id="22379" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22391" class="String">&quot;\nFound candidates\n &quot;</a> <a id="22415" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
          <a id="22427" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="22435" href="Meta.HLevel.html#22253" class="Bound">t</a> <a id="22437" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="22439" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

        <a id="22451" class="Comment">-- And try using the hints.</a>
        <a id="22487" href="Meta.HLevel.html#19914" class="Function">use-decomp-hints</a> <a id="22504" class="Symbol">(</a><a id="22505" href="Meta.HLevel.html#21634" class="Bound">lv</a> <a id="22508" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="22510" href="Meta.HLevel.html#21639" class="Bound">ty</a><a id="22512" class="Symbol">)</a> <a id="22514" href="Meta.HLevel.html#22084" class="Bound">solved</a> <a id="22521" href="Meta.HLevel.html#22216" class="Bound">instances</a>

  <a id="22534" class="Comment">-- At the top-level, our goal doesn&#39;t need to have literally the type</a>
  <a id="22606" class="Comment">-- is-hlevel A n. It can be under any number of Πs, both implicit and</a>
  <a id="22678" class="Comment">-- explicit. This means that a goal like (∀ x → is-hlevel T n) can be</a>
  <a id="22750" class="Comment">-- solved using just hlevel!, rather than λ _ → hlevel!. Of course,</a>
  <a id="22820" class="Comment">-- the effect is the same.</a>
  <a id="decompose-is-hlevel-top"></a><a id="22849" href="Meta.HLevel.html#22849" class="Function">decompose-is-hlevel-top</a>
    <a id="22877" class="Symbol">:</a> <a id="22879" class="Symbol">∀</a> <a id="22881" class="Symbol">{</a><a id="22882" href="Meta.HLevel.html#22882" class="Bound">ℓ</a><a id="22883" class="Symbol">}</a> <a id="22885" class="Symbol">{</a><a id="22886" href="Meta.HLevel.html#22886" class="Bound">A</a> <a id="22888" class="Symbol">:</a> <a id="22890" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="22895" href="Meta.HLevel.html#22882" class="Bound">ℓ</a><a id="22896" class="Symbol">}</a>
    <a id="22902" class="Symbol">→</a> <a id="22904" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22909" class="Symbol">→</a> <a id="22911" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22914" class="Symbol">(</a><a id="22915" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22920" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22922" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22927" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22929" class="Symbol">(</a><a id="22930" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22933" href="Meta.HLevel.html#22886" class="Bound">A</a> <a id="22935" class="Symbol">→</a> <a id="22937" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="22940" href="Meta.HLevel.html#22886" class="Bound">A</a><a id="22941" class="Symbol">)</a> <a id="22943" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="22945" class="Symbol">(</a><a id="22946" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="22951" class="Symbol">→</a> <a id="22953" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a><a id="22957" class="Symbol">))</a>
  <a id="22962" href="Meta.HLevel.html#22849" class="Function">decompose-is-hlevel-top</a> <a id="22986" href="Meta.HLevel.html#22986" class="Bound">goal</a> <a id="22991" class="Symbol">=</a>
    <a id="22997" class="Keyword">do</a>
      <a id="23006" href="Meta.HLevel.html#23006" class="Bound">ty</a> <a id="23009" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23011" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="23026" class="Symbol">(</a><a id="23027" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="23033" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23035" href="Meta.HLevel.html#5885" class="Function">atoms</a><a id="23040" class="Symbol">)</a> <a id="23042" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a>
        <a id="23052" class="Symbol">(</a><a id="23053" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="23063" href="Meta.HLevel.html#22986" class="Bound">goal</a> <a id="23068" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23072" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a><a id="23078" class="Symbol">)</a> <a id="23080" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23084" href="Meta.Reflection.html#5373" class="Function">wait-just-a-bit</a>
      <a id="23106" href="Meta.HLevel.html#23128" class="Function">go</a> <a id="23109" href="Meta.HLevel.html#23006" class="Bound">ty</a>
    <a id="23116" class="Keyword">where</a>
      <a id="23128" href="Meta.HLevel.html#23128" class="Function">go</a> <a id="23131" class="Symbol">:</a> <a id="23133" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23138" class="Symbol">→</a> <a id="23140" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23143" class="Symbol">_</a>
      <a id="23151" href="Meta.HLevel.html#23128" class="Function">go</a> <a id="23154" class="Symbol">(</a><a id="23155" href="Agda.Builtin.Reflection.html#5120" class="InductiveConstructor">pi</a> <a id="23158" class="Symbol">(</a><a id="23159" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23163" href="Meta.HLevel.html#23163" class="Bound">as</a> <a id="23166" href="Meta.HLevel.html#23166" class="Bound">at</a><a id="23168" class="Symbol">)</a> <a id="23170" class="Symbol">(</a><a id="23171" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23175" href="Meta.HLevel.html#23175" class="Bound">vn</a> <a id="23178" href="Meta.HLevel.html#23178" class="Bound">cd</a><a id="23180" class="Symbol">))</a> <a id="23183" class="Symbol">=</a> <a id="23185" class="Keyword">do</a>
        <a id="23196" class="Symbol">(</a><a id="23197" href="Meta.HLevel.html#23197" class="Bound">hlevel</a> <a id="23204" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23206" href="Meta.HLevel.html#23206" class="Bound">inner</a> <a id="23212" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23214" href="Meta.HLevel.html#23214" class="Bound">enter</a> <a id="23220" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23222" href="Meta.HLevel.html#23222" class="Bound">leave</a><a id="23227" class="Symbol">)</a> <a id="23229" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23231" href="Meta.HLevel.html#23128" class="Function">go</a> <a id="23234" href="Meta.HLevel.html#23178" class="Bound">cd</a>
        <a id="23245" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23250" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23252" href="Meta.HLevel.html#23197" class="Bound">hlevel</a> <a id="23259" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23261" href="Meta.HLevel.html#23206" class="Bound">inner</a> <a id="23267" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23269" href="Agda.Builtin.Reflection.html#8971" class="Postulate">extendContext</a> <a id="23283" href="Meta.HLevel.html#23175" class="Bound">vn</a> <a id="23286" class="Symbol">(</a><a id="23287" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="23291" href="Meta.HLevel.html#23163" class="Bound">as</a> <a id="23294" href="Meta.HLevel.html#23166" class="Bound">at</a><a id="23296" class="Symbol">)</a> <a id="23298" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23300" class="Symbol">λ</a> <a id="23302" href="Meta.HLevel.html#23302" class="Bound">t</a> <a id="23304" class="Symbol">→</a> <a id="23306" href="Agda.Builtin.Reflection.html#5002" class="InductiveConstructor">lam</a> <a id="23310" class="Symbol">(</a><a id="23311" href="Meta.Reflection.html#1207" class="Function">arg-vis</a> <a id="23319" href="Meta.HLevel.html#23163" class="Bound">as</a><a id="23321" class="Symbol">)</a> <a id="23323" class="Symbol">(</a><a id="23324" href="Agda.Builtin.Reflection.html#3979" class="InductiveConstructor">abs</a> <a id="23328" href="Meta.HLevel.html#23175" class="Bound">vn</a> <a id="23331" href="Meta.HLevel.html#23302" class="Bound">t</a><a id="23332" class="Symbol">)</a>
      <a id="23340" href="Meta.HLevel.html#23128" class="CatchallClause Function">go</a><a id="23342" class="CatchallClause"> </a><a id="23343" href="Meta.HLevel.html#23343" class="CatchallClause Bound">tm</a> <a id="23346" class="Symbol">=</a> <a id="23348" class="Keyword">do</a>
        <a id="23359" class="Symbol">(</a><a id="23360" href="Meta.HLevel.html#23360" class="Bound">hlevel</a> <a id="23367" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23369" href="Meta.HLevel.html#23369" class="Bound">inner</a><a id="23374" class="Symbol">)</a> <a id="23376" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23378" href="Meta.HLevel.html#6302" class="Function">decompose-is-hlevel′</a> <a id="23399" href="Meta.HLevel.html#23343" class="Bound">tm</a>
        <a id="23410" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="23415" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23417" href="Meta.HLevel.html#23360" class="Bound">hlevel</a> <a id="23424" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23426" href="Meta.HLevel.html#23369" class="Bound">inner</a> <a id="23432" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23434" class="Symbol">(λ</a> <a id="23437" href="Meta.HLevel.html#23437" class="Bound">x</a> <a id="23439" class="Symbol">→</a> <a id="23441" href="Meta.HLevel.html#23437" class="Bound">x</a><a id="23442" class="Symbol">)</a> <a id="23444" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23446" class="Symbol">(λ</a> <a id="23449" href="Meta.HLevel.html#23449" class="Bound">x</a> <a id="23451" class="Symbol">→</a> <a id="23453" href="Meta.HLevel.html#23449" class="Bound">x</a><a id="23454" class="Symbol">)</a>

<a id="23457" class="Comment">-- This is public so it&#39;s usable in tactic attributes. It decomposes the</a>
<a id="23530" class="Comment">-- top-level goal type and enters the search loop.</a>
<a id="hlevel-tactic-worker"></a><a id="23581" href="Meta.HLevel.html#23581" class="Function">hlevel-tactic-worker</a> <a id="23602" class="Symbol">:</a> <a id="23604" href="Agda.Builtin.Reflection.html#4687" class="Datatype">Term</a> <a id="23609" class="Symbol">→</a> <a id="23611" href="Agda.Builtin.Reflection.html#8296" class="Postulate">TC</a> <a id="23614" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="23616" href="Meta.HLevel.html#23581" class="Function">hlevel-tactic-worker</a> <a id="23637" href="Meta.HLevel.html#23637" class="Bound">goal</a> <a id="23642" class="Symbol">=</a> <a id="23644" class="Keyword">do</a>
  <a id="23649" href="Meta.HLevel.html#23649" class="Bound">ty</a> <a id="23652" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23654" href="Agda.Builtin.Reflection.html#10460" class="Postulate">withReduceDefs</a> <a id="23669" class="Symbol">(</a><a id="23670" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="23676" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23678" href="Meta.HLevel.html#5885" class="Function">atoms</a><a id="23683" class="Symbol">)</a> <a id="23685" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23687" href="Agda.Builtin.Reflection.html#8572" class="Postulate">inferType</a> <a id="23697" href="Meta.HLevel.html#23637" class="Bound">goal</a> <a id="23702" href="Meta.Bind.html#190" class="Field Operator">&gt;&gt;=</a> <a id="23706" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a>
  <a id="23715" href="Agda.Builtin.Reflection.html#10748" class="Postulate">debugPrint</a> <a id="23726" class="String">&quot;tactic.hlevel&quot;</a> <a id="23742" class="Number">10</a> <a id="23745" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="23747" class="String">&quot;Target type: &quot;</a> <a id="23763" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23765" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="23773" href="Meta.HLevel.html#23649" class="Bound">ty</a> <a id="23776" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23778" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="23783" class="Symbol">(</a><a id="23784" href="Meta.HLevel.html#23784" class="Bound">lv</a> <a id="23787" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23789" href="Meta.HLevel.html#23789" class="Bound">ty</a> <a id="23792" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23794" href="Meta.HLevel.html#23794" class="Bound">enter</a> <a id="23800" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="23802" href="Meta.HLevel.html#23802" class="Bound">leave</a><a id="23807" class="Symbol">)</a> <a id="23809" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="23811" href="Meta.HLevel.html#22849" class="Function">decompose-is-hlevel-top</a> <a id="23835" href="Meta.HLevel.html#23637" class="Bound">goal</a> <a id="23840" href="Meta.Alt.html#315" class="Field Operator">&lt;|&gt;</a>
    <a id="23848" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a>
      <a id="23864" class="Symbol">(</a> <a id="23866" class="String">&quot;Goal type is not of the form ``is-hlevel A n&#39;&#39;:\n&quot;</a>
      <a id="23924" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23926" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="23934" href="Meta.HLevel.html#23649" class="Bound">ty</a>
      <a id="23943" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="23945" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="23947" class="Symbol">)</a>

  <a id="23952" class="Comment">-- 10 units of fuel isn&#39;t too many but it&#39;s enough for any realistic</a>
  <a id="24023" class="Comment">-- use-case. Note the scope nonsense: we have to &#39;enter&#39; to get under</a>
  <a id="24095" class="Comment">-- the Πs (extend the scope with their argument types), then &#39;leave&#39;</a>
  <a id="24166" class="Comment">-- (wrap in lambdas) to get back out.</a>
  <a id="24206" href="Meta.HLevel.html#24206" class="Bound">solved</a> <a id="24213" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="24215" href="Meta.HLevel.html#23794" class="Bound">enter</a> <a id="24221" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="24223" class="Keyword">do</a>
    <a id="24230" href="Meta.HLevel.html#24230" class="Bound">goal′</a> <a id="24236" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="24238" href="Meta.Reflection.html#1851" class="Function">new-meta</a> <a id="24247" class="Symbol">(</a><a id="24248" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="24252" class="Symbol">(</a><a id="24253" class="Keyword">quote</a> <a id="24259" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a><a id="24271" class="Symbol">)</a> <a id="24273" class="Symbol">(</a><a id="24274" href="Meta.HLevel.html#23784" class="Bound">lv</a> <a id="24277" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="24280" href="Meta.HLevel.html#23789" class="Bound">ty</a> <a id="24283" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="24286" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="24288" class="Symbol">))</a>
    <a id="24295" href="Meta.HLevel.html#12608" class="Function">search</a> <a id="24302" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="24308" href="Meta.HLevel.html#23784" class="Bound">lv</a> <a id="24311" class="Number">10</a> <a id="24314" href="Meta.HLevel.html#24230" class="Bound">goal′</a>
    <a id="24324" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="24329" href="Meta.HLevel.html#24230" class="Bound">goal′</a>
  <a id="24337" href="Agda.Builtin.Reflection.html#8469" class="Postulate">unify</a> <a id="24343" href="Meta.HLevel.html#23637" class="Bound">goal</a> <a id="24348" class="Symbol">(</a><a id="24349" href="Meta.HLevel.html#23802" class="Bound">leave</a> <a id="24355" href="Meta.HLevel.html#24206" class="Bound">solved</a><a id="24361" class="Symbol">)</a>

<a id="24364" class="Comment">-- Entry points to the macro</a>
<a id="24393" class="Comment">----------------------------</a>
<a id="24422" class="Keyword">macro</a> <a id="hlevel!"></a><a id="24428" href="Meta.HLevel.html#24428" class="Function">hlevel!</a> <a id="24436" class="Symbol">=</a> <a id="24438" href="Meta.HLevel.html#23581" class="Function">hlevel-tactic-worker</a>

<a id="24460" class="Keyword">private</a> <a id="24468" class="Keyword">variable</a>
  <a id="24479" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a> <a id="24481" href="Meta.HLevel.html#24481" class="Generalizable">ℓ′</a> <a id="24484" href="Meta.HLevel.html#24484" class="Generalizable">ℓa</a> <a id="24487" href="Meta.HLevel.html#24487" class="Generalizable">ℓb</a> <a id="24490" href="Meta.HLevel.html#24490" class="Generalizable">ℓc</a> <a id="24493" href="Meta.HLevel.html#24493" class="Generalizable">ℓd</a> <a id="24496" class="Symbol">:</a> <a id="24498" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="24506" href="Meta.HLevel.html#24506" class="Generalizable">T</a> <a id="24508" class="Symbol">:</a> <a id="24510" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24515" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a>
  <a id="24519" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="24521" class="Symbol">:</a> <a id="24523" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24528" href="Meta.HLevel.html#24484" class="Generalizable">ℓa</a>
  <a id="24533" href="Meta.HLevel.html#24533" class="Generalizable">B</a> <a id="24535" class="Symbol">:</a> <a id="24537" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="24539" class="Symbol">→</a> <a id="24541" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24546" href="Meta.HLevel.html#24487" class="Generalizable">ℓb</a>
  <a id="24551" href="Meta.HLevel.html#24551" class="Generalizable">C</a> <a id="24553" class="Symbol">:</a> <a id="24555" class="Symbol">(</a><a id="24556" href="Meta.HLevel.html#24556" class="Bound">a</a> <a id="24558" class="Symbol">:</a> <a id="24560" href="Meta.HLevel.html#24519" class="Generalizable">A</a><a id="24561" class="Symbol">)</a> <a id="24563" class="Symbol">(</a><a id="24564" href="Meta.HLevel.html#24564" class="Bound">b</a> <a id="24566" class="Symbol">:</a> <a id="24568" href="Meta.HLevel.html#24533" class="Generalizable">B</a> <a id="24570" href="Meta.HLevel.html#24556" class="Bound">a</a><a id="24571" class="Symbol">)</a> <a id="24573" class="Symbol">→</a> <a id="24575" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24580" href="Meta.HLevel.html#24490" class="Generalizable">ℓc</a>
  <a id="24585" href="Meta.HLevel.html#24585" class="Generalizable">D</a> <a id="24587" class="Symbol">:</a> <a id="24589" class="Symbol">(</a><a id="24590" href="Meta.HLevel.html#24590" class="Bound">a</a> <a id="24592" class="Symbol">:</a> <a id="24594" href="Meta.HLevel.html#24519" class="Generalizable">A</a><a id="24595" class="Symbol">)</a> <a id="24597" class="Symbol">(</a><a id="24598" href="Meta.HLevel.html#24598" class="Bound">b</a> <a id="24600" class="Symbol">:</a> <a id="24602" href="Meta.HLevel.html#24533" class="Generalizable">B</a> <a id="24604" href="Meta.HLevel.html#24590" class="Bound">a</a><a id="24605" class="Symbol">)</a> <a id="24607" class="Symbol">(</a><a id="24608" href="Meta.HLevel.html#24608" class="Bound">c</a> <a id="24610" class="Symbol">:</a> <a id="24612" href="Meta.HLevel.html#24551" class="Generalizable">C</a> <a id="24614" href="Meta.HLevel.html#24590" class="Bound">a</a> <a id="24616" href="Meta.HLevel.html#24598" class="Bound">b</a><a id="24617" class="Symbol">)</a> <a id="24619" class="Symbol">→</a> <a id="24621" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24626" href="Meta.HLevel.html#24493" class="Generalizable">ℓd</a>
  <a id="24631" href="Meta.HLevel.html#24631" class="Generalizable">n</a> <a id="24633" class="Symbol">:</a> <a id="24635" href="Foundations.Base.html#12913" class="Function">HLevel</a>

<a id="24643" class="Comment">-- In addition to using the macro as a.. well, macro, it can be used as</a>
<a id="24715" class="Comment">-- a tactic argument, to replace instance search by the more powerful</a>
<a id="24785" class="Comment">-- decomposition-projection mechanism of the tactic. We provide only</a>
<a id="24854" class="Comment">-- some of the most common helpers:</a>
<a id="el!"></a><a id="24890" href="Meta.HLevel.html#24890" class="Function">el!</a> <a id="24894" class="Symbol">:</a> <a id="24896" class="Symbol">(</a><a id="24897" href="Meta.HLevel.html#24897" class="Bound">A</a> <a id="24899" class="Symbol">:</a> <a id="24901" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="24906" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a><a id="24907" class="Symbol">)</a> <a id="24909" class="Symbol">{@(</a><a id="24912" class="Keyword">tactic</a> <a id="24919" href="Meta.HLevel.html#23581" class="Function">hlevel-tactic-worker</a><a id="24939" class="Symbol">)</a> <a id="24941" href="Meta.HLevel.html#24941" class="Bound">hl</a> <a id="24944" class="Symbol">:</a> <a id="24946" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a> <a id="24959" href="Meta.HLevel.html#24631" class="Generalizable">n</a> <a id="24961" href="Meta.HLevel.html#24897" class="Bound">A</a><a id="24962" class="Symbol">}</a> <a id="24964" class="Symbol">→</a> <a id="24966" href="Structures.n-Type.html#336" class="Function">n-Type</a> <a id="24973" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a> <a id="24975" href="Meta.HLevel.html#24631" class="Generalizable">n</a>
<a id="24977" href="Meta.HLevel.html#24890" class="Function">el!</a> <a id="24981" href="Meta.HLevel.html#24981" class="Bound">A</a> <a id="24983" class="Symbol">{</a><a id="24984" href="Meta.HLevel.html#24984" class="Bound">hl</a><a id="24986" class="Symbol">}</a> <a id="24988" class="Symbol">=</a> <a id="24990" href="Structures.n-Type.html#471" class="Function">el</a> <a id="24993" href="Meta.HLevel.html#24981" class="Bound">A</a> <a id="24995" href="Meta.HLevel.html#24984" class="Bound">hl</a>

<a id="prop-extₑ!"></a><a id="24999" href="Meta.HLevel.html#24999" class="Function">prop-extₑ!</a>
  <a id="25012" class="Symbol">:</a> <a id="25014" class="Symbol">{</a><a id="25015" href="Meta.HLevel.html#25015" class="Bound">B</a> <a id="25017" class="Symbol">:</a> <a id="25019" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="25024" href="Meta.HLevel.html#24487" class="Generalizable">ℓb</a><a id="25026" class="Symbol">}</a>
    <a id="25032" class="Symbol">{@(</a><a id="25035" class="Keyword">tactic</a> <a id="25042" href="Meta.HLevel.html#23581" class="Function">hlevel-tactic-worker</a><a id="25062" class="Symbol">)</a> <a id="25064" href="Meta.HLevel.html#25064" class="Bound">aprop</a> <a id="25070" class="Symbol">:</a> <a id="25072" href="Foundations.Base.html#13475" class="Function">is-prop</a> <a id="25080" href="Meta.HLevel.html#24519" class="Generalizable">A</a><a id="25081" class="Symbol">}</a>
    <a id="25087" class="Symbol">{@(</a><a id="25090" class="Keyword">tactic</a> <a id="25097" href="Meta.HLevel.html#23581" class="Function">hlevel-tactic-worker</a><a id="25117" class="Symbol">)</a> <a id="25119" href="Meta.HLevel.html#25119" class="Bound">bprop</a> <a id="25125" class="Symbol">:</a> <a id="25127" href="Foundations.Base.html#13475" class="Function">is-prop</a> <a id="25135" href="Meta.HLevel.html#25015" class="Bound">B</a><a id="25136" class="Symbol">}</a>
  <a id="25140" class="Symbol">→</a> <a id="25142" class="Symbol">(</a><a id="25143" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="25145" class="Symbol">→</a> <a id="25147" href="Meta.HLevel.html#25015" class="Bound">B</a><a id="25148" class="Symbol">)</a> <a id="25150" class="Symbol">→</a> <a id="25152" class="Symbol">(</a><a id="25153" href="Meta.HLevel.html#25015" class="Bound">B</a> <a id="25155" class="Symbol">→</a> <a id="25157" href="Meta.HLevel.html#24519" class="Generalizable">A</a><a id="25158" class="Symbol">)</a>
  <a id="25162" class="Symbol">→</a> <a id="25164" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="25166" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="25168" href="Meta.HLevel.html#25015" class="Bound">B</a>
<a id="25170" href="Meta.HLevel.html#24999" class="Function">prop-extₑ!</a> <a id="25181" class="Symbol">{</a><a id="25182" href="Meta.HLevel.html#25182" class="Bound">aprop</a><a id="25187" class="Symbol">}</a> <a id="25189" class="Symbol">{</a><a id="25190" href="Meta.HLevel.html#25190" class="Bound">bprop</a><a id="25195" class="Symbol">}</a> <a id="25197" class="Symbol">=</a> <a id="25199" href="Foundations.Equiv.Properties.html#2839" class="Function">prop-extₑ</a> <a id="25209" href="Meta.HLevel.html#25182" class="Bound">aprop</a> <a id="25215" href="Meta.HLevel.html#25190" class="Bound">bprop</a>

<a id="Σ-prop-path!"></a><a id="25222" href="Meta.HLevel.html#25222" class="Function">Σ-prop-path!</a>
  <a id="25237" class="Symbol">:</a> <a id="25239" class="Symbol">{@(</a><a id="25242" class="Keyword">tactic</a> <a id="25249" href="Meta.HLevel.html#23581" class="Function">hlevel-tactic-worker</a><a id="25269" class="Symbol">)</a> <a id="25271" href="Meta.HLevel.html#25271" class="Bound">bxprop</a> <a id="25278" class="Symbol">:</a> <a id="25280" class="Symbol">∀</a> <a id="25282" href="Meta.HLevel.html#25282" class="Bound">x</a> <a id="25284" class="Symbol">→</a> <a id="25286" href="Foundations.Base.html#13475" class="Function">is-prop</a> <a id="25294" class="Symbol">(</a><a id="25295" href="Meta.HLevel.html#24533" class="Generalizable">B</a> <a id="25297" href="Meta.HLevel.html#25282" class="Bound">x</a><a id="25298" class="Symbol">)}</a>
  <a id="25303" class="Symbol">→</a> <a id="25305" class="Symbol">{</a><a id="25306" href="Meta.HLevel.html#25306" class="Bound">x</a> <a id="25308" href="Meta.HLevel.html#25308" class="Bound">y</a> <a id="25310" class="Symbol">:</a> <a id="25312" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="25314" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="25316" href="Meta.HLevel.html#24533" class="Generalizable">B</a><a id="25317" class="Symbol">}</a>
  <a id="25321" class="Symbol">→</a> <a id="25323" href="Meta.HLevel.html#25306" class="Bound">x</a> <a id="25325" class="Symbol">.</a><a id="25326" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="25330" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25332" href="Meta.HLevel.html#25308" class="Bound">y</a> <a id="25334" class="Symbol">.</a><a id="25335" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a>
  <a id="25341" class="Symbol">→</a> <a id="25343" href="Meta.HLevel.html#25306" class="Bound">x</a> <a id="25345" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="25347" href="Meta.HLevel.html#25308" class="Bound">y</a>
<a id="25349" href="Meta.HLevel.html#25222" class="Function">Σ-prop-path!</a> <a id="25362" class="Symbol">{</a><a id="25363" href="Meta.HLevel.html#25363" class="Bound">bxprop</a><a id="25369" class="Symbol">}</a> <a id="25371" class="Symbol">=</a> <a id="25373" href="Foundations.Sigma.Properties.html#3918" class="Function">Σ-prop-path</a> <a id="25385" href="Meta.HLevel.html#25363" class="Bound">bxprop</a>

<a id="prop!"></a><a id="25393" href="Meta.HLevel.html#25393" class="Function">prop!</a>
  <a id="25401" class="Symbol">:</a> <a id="25403" class="Symbol">{</a><a id="25404" href="Meta.HLevel.html#25404" class="Bound">A</a> <a id="25406" class="Symbol">:</a> <a id="25408" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="25410" class="Symbol">→</a> <a id="25412" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="25417" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a><a id="25418" class="Symbol">}</a> <a id="25420" class="Symbol">{@(</a><a id="25423" class="Keyword">tactic</a> <a id="25430" href="Meta.HLevel.html#23581" class="Function">hlevel-tactic-worker</a><a id="25450" class="Symbol">)</a> <a id="25452" href="Meta.HLevel.html#25452" class="Bound">aip</a> <a id="25456" class="Symbol">:</a> <a id="25458" href="Foundations.Base.html#13475" class="Function">is-prop</a> <a id="25466" class="Symbol">(</a><a id="25467" href="Meta.HLevel.html#25404" class="Bound">A</a> <a id="25469" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25471" class="Symbol">)}</a>
  <a id="25476" class="Symbol">→</a> <a id="25478" class="Symbol">{</a><a id="25479" href="Meta.HLevel.html#25479" class="Bound">x</a> <a id="25481" class="Symbol">:</a> <a id="25483" href="Meta.HLevel.html#25404" class="Bound">A</a> <a id="25485" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="25487" class="Symbol">}</a> <a id="25489" class="Symbol">{</a><a id="25490" href="Meta.HLevel.html#25490" class="Bound">y</a> <a id="25492" class="Symbol">:</a> <a id="25494" href="Meta.HLevel.html#25404" class="Bound">A</a> <a id="25496" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="25498" class="Symbol">}</a>
  <a id="25502" class="Symbol">→</a> <a id="25504" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="25510" href="Meta.HLevel.html#25404" class="Bound">A</a> <a id="25512" href="Meta.HLevel.html#25479" class="Bound">x</a> <a id="25514" href="Meta.HLevel.html#25490" class="Bound">y</a>
<a id="25516" href="Meta.HLevel.html#25393" class="Function">prop!</a> <a id="25522" class="Symbol">{</a><a id="25523" href="Meta.HLevel.html#25523" class="Bound">A</a><a id="25524" class="Symbol">}</a> <a id="25526" class="Symbol">{</a><a id="25527" href="Meta.HLevel.html#25527" class="Bound">aip</a><a id="25530" class="Symbol">}</a> <a id="25532" class="Symbol">{</a><a id="25533" href="Meta.HLevel.html#25533" class="Bound">x</a><a id="25534" class="Symbol">}</a> <a id="25536" class="Symbol">{</a><a id="25537" href="Meta.HLevel.html#25537" class="Bound">y</a><a id="25538" class="Symbol">}</a> <a id="25540" class="Symbol">=</a>
  <a id="25544" href="Foundations.HLevel.Base.html#1134" class="Function">is-prop→pathP</a> <a id="25558" class="Symbol">(λ</a> <a id="25561" href="Meta.HLevel.html#25561" class="Bound">i</a> <a id="25563" class="Symbol">→</a> <a id="25565" href="Foundations.Base.html#17192" class="Function">coe0→i</a> <a id="25572" class="Symbol">(λ</a> <a id="25575" href="Meta.HLevel.html#25575" class="Bound">j</a> <a id="25577" class="Symbol">→</a> <a id="25579" href="Foundations.Base.html#13475" class="Function">is-prop</a> <a id="25587" class="Symbol">(</a><a id="25588" href="Meta.HLevel.html#25523" class="Bound">A</a> <a id="25590" href="Meta.HLevel.html#25575" class="Bound">j</a><a id="25591" class="Symbol">))</a> <a id="25594" href="Meta.HLevel.html#25561" class="Bound">i</a> <a id="25596" href="Meta.HLevel.html#25527" class="Bound">aip</a><a id="25599" class="Symbol">)</a> <a id="25601" href="Meta.HLevel.html#25533" class="Bound">x</a> <a id="25603" href="Meta.HLevel.html#25537" class="Bound">y</a>

<a id="25606" class="Keyword">open</a> <a id="25611" href="Meta.HLevel.html#4123" class="Module">hlevel-projection</a>

<a id="25630" class="Comment">-- Hint database bootstrap</a>
<a id="25657" class="Comment">--------------------------</a>
<a id="25684" class="Comment">-- This instance block contains most of the decompositions we have</a>
<a id="25751" class="Comment">-- defined in the dependencies of this module.</a>

<a id="25799" class="Keyword">instance</a>
  <a id="decomp-lift"></a><a id="25810" href="Meta.HLevel.html#25810" class="Function">decomp-lift</a> <a id="25822" class="Symbol">:</a> <a id="25824" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="25845" class="Symbol">(</a><a id="25846" href="Foundations.Prim.Type.html#538" class="Record">Lift</a> <a id="25851" href="Meta.HLevel.html#24481" class="Generalizable">ℓ′</a> <a id="25854" href="Meta.HLevel.html#24519" class="Generalizable">A</a><a id="25855" class="Symbol">)</a>
  <a id="25859" href="Meta.HLevel.html#25810" class="Function">decomp-lift</a> <a id="25871" class="Symbol">=</a> <a id="25873" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="25880" class="Symbol">(</a><a id="25881" class="Keyword">quote</a> <a id="25887" href="Foundations.HLevel.Retracts.html#5281" class="Function">Lift-is-of-hlevel</a><a id="25904" class="Symbol">)</a> <a id="25906" class="Symbol">(</a><a id="25907" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="25914" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="25916" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="25924" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="25926" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="25928" class="Symbol">)</a>

  <a id="25933" class="Comment">-- Non-dependent Π and Σ for readability (lol) first</a>
  <a id="decomp-fun"></a><a id="25988" href="Meta.HLevel.html#25988" class="Function">decomp-fun</a> <a id="25999" class="Symbol">:</a> <a id="26001" class="Symbol">{</a><a id="26002" href="Meta.HLevel.html#26002" class="Bound">B</a> <a id="26004" class="Symbol">:</a> <a id="26006" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26011" href="Meta.HLevel.html#24487" class="Generalizable">ℓb</a><a id="26013" class="Symbol">}</a> <a id="26015" class="Symbol">→</a> <a id="26017" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="26038" class="Symbol">(</a><a id="26039" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="26041" class="Symbol">→</a> <a id="26043" href="Meta.HLevel.html#26002" class="Bound">B</a><a id="26044" class="Symbol">)</a>
  <a id="26048" href="Meta.HLevel.html#25988" class="Function">decomp-fun</a> <a id="26059" class="Symbol">=</a> <a id="26061" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="26068" class="Symbol">(</a><a id="26069" class="Keyword">quote</a> <a id="26075" href="Foundations.HLevel.Retracts.html#4186" class="Function">fun-is-of-hlevel</a><a id="26091" class="Symbol">)</a> <a id="26093" class="Symbol">(</a><a id="26094" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="26101" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26103" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="26111" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26113" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26115" class="Symbol">)</a>

  <a id="decomp-prod"></a><a id="26120" href="Meta.HLevel.html#26120" class="Function">decomp-prod</a> <a id="26132" class="Symbol">:</a> <a id="26134" class="Symbol">{</a><a id="26135" href="Meta.HLevel.html#26135" class="Bound">B</a> <a id="26137" class="Symbol">:</a> <a id="26139" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26144" href="Meta.HLevel.html#24487" class="Generalizable">ℓb</a><a id="26146" class="Symbol">}</a> <a id="26148" class="Symbol">→</a> <a id="26150" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="26171" class="Symbol">(</a><a id="26172" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="26174" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="26176" href="Meta.HLevel.html#26135" class="Bound">B</a><a id="26177" class="Symbol">)</a>
  <a id="26181" href="Meta.HLevel.html#26120" class="Function">decomp-prod</a> <a id="26193" class="Symbol">=</a> <a id="26195" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="26202" class="Symbol">(</a><a id="26203" class="Keyword">quote</a> <a id="26209" href="Foundations.HLevel.Retracts.html#5056" class="Function">×-is-of-hlevel</a><a id="26223" class="Symbol">)</a> <a id="26225" class="Symbol">(</a><a id="26226" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="26233" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26235" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="26243" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26245" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="26253" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26255" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26257" class="Symbol">)</a>

  <a id="26262" class="Comment">-- Dependent type formers:</a>
  <a id="decomp-pi³"></a><a id="26291" href="Meta.HLevel.html#26291" class="Function">decomp-pi³</a> <a id="26302" class="Symbol">:</a> <a id="26304" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="26325" class="Symbol">(∀</a> <a id="26328" href="Meta.HLevel.html#26328" class="Bound">a</a> <a id="26330" href="Meta.HLevel.html#26330" class="Bound">b</a> <a id="26332" href="Meta.HLevel.html#26332" class="Bound">c</a> <a id="26334" class="Symbol">→</a> <a id="26336" href="Meta.HLevel.html#24585" class="Generalizable">D</a> <a id="26338" href="Meta.HLevel.html#26328" class="Bound">a</a> <a id="26340" href="Meta.HLevel.html#26330" class="Bound">b</a> <a id="26342" href="Meta.HLevel.html#26332" class="Bound">c</a><a id="26343" class="Symbol">)</a>
  <a id="26347" href="Meta.HLevel.html#26291" class="Function">decomp-pi³</a> <a id="26358" class="Symbol">=</a> <a id="26360" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="26367" class="Symbol">(</a><a id="26368" class="Keyword">quote</a> <a id="26374" href="Foundations.HLevel.Retracts.html#3891" class="Function">Π₃-is-of-hlevel</a><a id="26389" class="Symbol">)</a> <a id="26391" class="Symbol">(</a><a id="26392" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="26399" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26401" href="Meta.HLevel.html#3107" class="InductiveConstructor">`search-under</a> <a id="26415" class="Number">3</a> <a id="26417" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26419" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26421" class="Symbol">)</a>

  <a id="decomp-pi²"></a><a id="26426" href="Meta.HLevel.html#26426" class="Function">decomp-pi²</a> <a id="26437" class="Symbol">:</a> <a id="26439" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="26460" class="Symbol">(∀</a> <a id="26463" href="Meta.HLevel.html#26463" class="Bound">a</a> <a id="26465" href="Meta.HLevel.html#26465" class="Bound">b</a> <a id="26467" class="Symbol">→</a> <a id="26469" href="Meta.HLevel.html#24551" class="Generalizable">C</a> <a id="26471" href="Meta.HLevel.html#26463" class="Bound">a</a> <a id="26473" href="Meta.HLevel.html#26465" class="Bound">b</a><a id="26474" class="Symbol">)</a>
  <a id="26478" href="Meta.HLevel.html#26426" class="Function">decomp-pi²</a> <a id="26489" class="Symbol">=</a> <a id="26491" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="26498" class="Symbol">(</a><a id="26499" class="Keyword">quote</a> <a id="26505" href="Foundations.HLevel.Retracts.html#3645" class="Function">Π₂-is-of-hlevel</a><a id="26520" class="Symbol">)</a> <a id="26522" class="Symbol">(</a><a id="26523" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="26530" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26532" href="Meta.HLevel.html#3107" class="InductiveConstructor">`search-under</a> <a id="26546" class="Number">2</a> <a id="26548" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26550" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26552" class="Symbol">)</a>

  <a id="decomp-pi"></a><a id="26557" href="Meta.HLevel.html#26557" class="Function">decomp-pi</a> <a id="26567" class="Symbol">:</a> <a id="26569" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="26590" class="Symbol">(∀</a> <a id="26593" href="Meta.HLevel.html#26593" class="Bound">a</a> <a id="26595" class="Symbol">→</a> <a id="26597" href="Meta.HLevel.html#24533" class="Generalizable">B</a> <a id="26599" href="Meta.HLevel.html#26593" class="Bound">a</a><a id="26600" class="Symbol">)</a>
  <a id="26604" href="Meta.HLevel.html#26557" class="Function">decomp-pi</a> <a id="26614" class="Symbol">=</a> <a id="26616" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="26623" class="Symbol">(</a><a id="26624" class="Keyword">quote</a> <a id="26630" href="Foundations.HLevel.Retracts.html#2884" class="Function">Π-is-of-hlevel</a><a id="26644" class="Symbol">)</a> <a id="26646" class="Symbol">(</a><a id="26647" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="26654" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26656" href="Meta.HLevel.html#3107" class="InductiveConstructor">`search-under</a> <a id="26670" class="Number">1</a> <a id="26672" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26674" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26676" class="Symbol">)</a>

  <a id="decomp-impl-pi"></a><a id="26681" href="Meta.HLevel.html#26681" class="Function">decomp-impl-pi</a> <a id="26696" class="Symbol">:</a> <a id="26698" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="26719" class="Symbol">(∀</a> <a id="26722" class="Symbol">{</a><a id="26723" href="Meta.HLevel.html#26723" class="Bound">a</a><a id="26724" class="Symbol">}</a> <a id="26726" class="Symbol">→</a> <a id="26728" href="Meta.HLevel.html#24533" class="Generalizable">B</a> <a id="26730" href="Meta.HLevel.html#26723" class="Bound">a</a><a id="26731" class="Symbol">)</a>
  <a id="26735" href="Meta.HLevel.html#26681" class="Function">decomp-impl-pi</a> <a id="26750" class="Symbol">=</a> <a id="26752" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="26759" class="Symbol">(</a><a id="26760" class="Keyword">quote</a> <a id="26766" href="Foundations.HLevel.Retracts.html#3330" class="Function">Π-is-of-hlevel-implicit</a><a id="26789" class="Symbol">)</a> <a id="26791" class="Symbol">(</a><a id="26792" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="26799" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26801" href="Meta.HLevel.html#3107" class="InductiveConstructor">`search-under</a> <a id="26815" class="Number">1</a> <a id="26817" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26819" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26821" class="Symbol">)</a>

  <a id="decomp-equiv-right"></a><a id="26826" href="Meta.HLevel.html#26826" class="Function">decomp-equiv-right</a> <a id="26845" class="Symbol">:</a> <a id="26847" class="Symbol">{</a><a id="26848" href="Meta.HLevel.html#26848" class="Bound">B</a> <a id="26850" class="Symbol">:</a> <a id="26852" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="26857" href="Meta.HLevel.html#24487" class="Generalizable">ℓb</a><a id="26859" class="Symbol">}</a> <a id="26861" class="Symbol">→</a> <a id="26863" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="26884" class="Symbol">(</a><a id="26885" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="26887" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="26889" href="Meta.HLevel.html#26848" class="Bound">B</a><a id="26890" class="Symbol">)</a>
  <a id="26894" href="Meta.HLevel.html#26826" class="Function">decomp-equiv-right</a> <a id="26913" class="Symbol">=</a> <a id="26915" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="26922" class="Symbol">(</a><a id="26923" class="Keyword">quote</a> <a id="26929" href="Foundations.HLevel.Retracts.html#6358" class="Function">≃-is-of-hlevel-right-suc</a><a id="26953" class="Symbol">)</a> <a id="26955" class="Symbol">(</a><a id="26956" href="Meta.HLevel.html#2907" class="InductiveConstructor">`level-minus</a> <a id="26969" class="Number">1</a> <a id="26971" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26973" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="26981" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="26983" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="26985" class="Symbol">)</a>

  <a id="decomp-equiv-left"></a><a id="26990" href="Meta.HLevel.html#26990" class="Function">decomp-equiv-left</a> <a id="27008" class="Symbol">:</a> <a id="27010" class="Symbol">{</a><a id="27011" href="Meta.HLevel.html#27011" class="Bound">B</a> <a id="27013" class="Symbol">:</a> <a id="27015" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="27020" href="Meta.HLevel.html#24487" class="Generalizable">ℓb</a><a id="27022" class="Symbol">}</a> <a id="27024" class="Symbol">→</a> <a id="27026" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="27047" class="Symbol">(</a><a id="27048" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="27050" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="27052" href="Meta.HLevel.html#27011" class="Bound">B</a><a id="27053" class="Symbol">)</a>
  <a id="27057" href="Meta.HLevel.html#26990" class="Function">decomp-equiv-left</a> <a id="27075" class="Symbol">=</a> <a id="27077" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="27084" class="Symbol">(</a><a id="27085" class="Keyword">quote</a> <a id="27091" href="Foundations.HLevel.Retracts.html#6006" class="Function">≃-is-of-hlevel-left-suc</a><a id="27114" class="Symbol">)</a> <a id="27116" class="Symbol">(</a><a id="27117" href="Meta.HLevel.html#2907" class="InductiveConstructor">`level-minus</a> <a id="27130" class="Number">1</a> <a id="27132" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27134" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="27142" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27144" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27146" class="Symbol">)</a>

  <a id="decomp-equiv"></a><a id="27151" href="Meta.HLevel.html#27151" class="Function">decomp-equiv</a> <a id="27164" class="Symbol">:</a> <a id="27166" class="Symbol">{</a><a id="27167" href="Meta.HLevel.html#27167" class="Bound">B</a> <a id="27169" class="Symbol">:</a> <a id="27171" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="27176" href="Meta.HLevel.html#24487" class="Generalizable">ℓb</a><a id="27178" class="Symbol">}</a> <a id="27180" class="Symbol">→</a> <a id="27182" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="27203" class="Symbol">(</a><a id="27204" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="27206" href="Foundations.Prim.Equiv.html#481" class="Function Operator">≃</a> <a id="27208" href="Meta.HLevel.html#27167" class="Bound">B</a><a id="27209" class="Symbol">)</a>
  <a id="27213" href="Meta.HLevel.html#27151" class="Function">decomp-equiv</a> <a id="27226" class="Symbol">=</a> <a id="27228" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="27235" class="Symbol">(</a><a id="27236" class="Keyword">quote</a> <a id="27242" href="Foundations.HLevel.Retracts.html#5486" class="Function">≃-is-of-hlevel</a><a id="27256" class="Symbol">)</a> <a id="27258" class="Symbol">(</a><a id="27259" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="27266" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27268" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="27276" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27278" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="27286" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27288" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="27291" class="Symbol">)</a>

  <a id="decomp-sigma"></a><a id="27296" href="Meta.HLevel.html#27296" class="Function">decomp-sigma</a> <a id="27309" class="Symbol">:</a> <a id="27311" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="27332" class="Symbol">(</a><a id="27333" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="27335" href="Meta.HLevel.html#24519" class="Generalizable">A</a> <a id="27337" href="Meta.HLevel.html#24533" class="Generalizable">B</a><a id="27338" class="Symbol">)</a>
  <a id="27342" href="Meta.HLevel.html#27296" class="Function">decomp-sigma</a> <a id="27355" class="Symbol">=</a> <a id="27357" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="27364" class="Symbol">(</a><a id="27365" class="Keyword">quote</a> <a id="27371" href="Foundations.HLevel.Retracts.html#4347" class="Function">Σ-is-of-hlevel</a><a id="27385" class="Symbol">)</a> <a id="27387" class="Symbol">(</a><a id="27388" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="27395" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27397" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="27405" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27407" href="Meta.HLevel.html#3107" class="InductiveConstructor">`search-under</a> <a id="27421" class="Number">1</a> <a id="27423" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27425" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27427" class="Symbol">)</a>

  <a id="27432" class="Comment">-- Path decomposition rules we have in scope. Note the use of</a>
  <a id="27496" class="Comment">-- nondeterminism: the following three instances both compete for</a>
  <a id="27564" class="Comment">-- solving the same goals --- but generally only one will be</a>
  <a id="27627" class="Comment">-- applicable. That way we don&#39;t have to juggle h-levels quite as</a>
  <a id="27695" class="Comment">-- much.</a>
  <a id="decomp-path′"></a><a id="27706" href="Meta.HLevel.html#27706" class="Function">decomp-path′</a> <a id="27719" class="Symbol">:</a> <a id="27721" class="Symbol">{</a><a id="27722" href="Meta.HLevel.html#27722" class="Bound">a</a> <a id="27724" href="Meta.HLevel.html#27724" class="Bound">b</a> <a id="27726" class="Symbol">:</a> <a id="27728" href="Meta.HLevel.html#24519" class="Generalizable">A</a><a id="27729" class="Symbol">}</a> <a id="27731" class="Symbol">→</a> <a id="27733" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="27754" class="Symbol">(</a><a id="27755" href="Meta.HLevel.html#27722" class="Bound">a</a> <a id="27757" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27759" href="Meta.HLevel.html#27724" class="Bound">b</a><a id="27760" class="Symbol">)</a>
  <a id="27764" href="Meta.HLevel.html#27706" class="Function">decomp-path′</a> <a id="27777" class="Symbol">=</a> <a id="27779" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="27786" class="Symbol">(</a><a id="27787" class="Keyword">quote</a> <a id="27793" href="Foundations.HLevel.Base.html#4376" class="Function">path-is-of-hlevel′</a><a id="27811" class="Symbol">)</a> <a id="27813" class="Symbol">(</a><a id="27814" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="27821" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27823" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="27831" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27833" href="Meta.HLevel.html#3310" class="InductiveConstructor">`meta</a> <a id="27839" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27841" href="Meta.HLevel.html#3310" class="InductiveConstructor">`meta</a> <a id="27847" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27849" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27851" class="Symbol">)</a>

  <a id="decomp-path"></a><a id="27856" href="Meta.HLevel.html#27856" class="Function">decomp-path</a> <a id="27868" class="Symbol">:</a> <a id="27870" class="Symbol">{</a><a id="27871" href="Meta.HLevel.html#27871" class="Bound">a</a> <a id="27873" href="Meta.HLevel.html#27873" class="Bound">b</a> <a id="27875" class="Symbol">:</a> <a id="27877" href="Meta.HLevel.html#24519" class="Generalizable">A</a><a id="27878" class="Symbol">}</a> <a id="27880" class="Symbol">→</a> <a id="27882" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="27903" class="Symbol">(</a><a id="27904" href="Meta.HLevel.html#27871" class="Bound">a</a> <a id="27906" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="27908" href="Meta.HLevel.html#27873" class="Bound">b</a><a id="27909" class="Symbol">)</a>
  <a id="27913" href="Meta.HLevel.html#27856" class="Function">decomp-path</a> <a id="27925" class="Symbol">=</a> <a id="27927" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="27934" class="Symbol">(</a><a id="27935" class="Keyword">quote</a> <a id="27941" href="Foundations.HLevel.Base.html#3779" class="Function">path-is-of-hlevel</a><a id="27958" class="Symbol">)</a> <a id="27960" class="Symbol">(</a><a id="27961" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="27968" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27970" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="27978" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="27980" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="27982" class="Symbol">)</a>

  <a id="decomp-univalence"></a><a id="27987" href="Meta.HLevel.html#27987" class="Function">decomp-univalence</a> <a id="28005" class="Symbol">:</a> <a id="28007" class="Symbol">{</a><a id="28008" href="Meta.HLevel.html#28008" class="Bound">A</a> <a id="28010" href="Meta.HLevel.html#28010" class="Bound">B</a> <a id="28012" class="Symbol">:</a> <a id="28014" href="Foundations.Prim.Type.html#295" class="Primitive">Type</a> <a id="28019" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a><a id="28020" class="Symbol">}</a> <a id="28022" class="Symbol">→</a> <a id="28024" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="28045" class="Symbol">(</a><a id="28046" href="Meta.HLevel.html#28008" class="Bound">A</a> <a id="28048" href="Foundations.Prim.Kan.html#1272" class="Function Operator">＝</a> <a id="28050" href="Meta.HLevel.html#28010" class="Bound">B</a><a id="28051" class="Symbol">)</a>
  <a id="28055" href="Meta.HLevel.html#27987" class="Function">decomp-univalence</a> <a id="28073" class="Symbol">=</a> <a id="28075" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="28082" class="Symbol">(</a><a id="28083" class="Keyword">quote</a> <a id="28089" href="Structures.n-Type.html#950" class="Function">＝-is-of-hlevel</a><a id="28103" class="Symbol">)</a> <a id="28105" class="Symbol">(</a><a id="28106" href="Meta.HLevel.html#3610" class="InductiveConstructor">`level</a> <a id="28113" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28115" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="28123" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28125" href="Meta.HLevel.html#3576" class="InductiveConstructor">`search</a> <a id="28133" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28135" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="28138" class="Symbol">)</a>

  <a id="28143" class="Comment">-- This one really ought to work with instance selection only, but</a>
  <a id="28212" class="Comment">-- Agda has trouble with the (1 + k + n) level in H-Level-n-Type. The</a>
  <a id="28284" class="Comment">-- decomposition here is a bit more flexible.</a>
  <a id="decomp-ntype"></a><a id="28332" href="Meta.HLevel.html#28332" class="Function">decomp-ntype</a> <a id="28345" class="Symbol">:</a> <a id="28347" href="Meta.HLevel.html#3751" class="Datatype">hlevel-decomposition</a> <a id="28368" class="Symbol">(</a><a id="28369" href="Structures.n-Type.html#336" class="Function">n-Type</a> <a id="28376" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a> <a id="28378" href="Meta.HLevel.html#24631" class="Generalizable">n</a><a id="28379" class="Symbol">)</a>
  <a id="28383" href="Meta.HLevel.html#28332" class="Function">decomp-ntype</a> <a id="28396" class="Symbol">=</a> <a id="28398" href="Meta.HLevel.html#3804" class="InductiveConstructor">decomp</a> <a id="28405" class="Symbol">(</a><a id="28406" class="Keyword">quote</a> <a id="28412" href="Structures.n-Type.html#2315" class="Function">n-Type-is-of-hlevel</a><a id="28431" class="Symbol">)</a> <a id="28433" class="Symbol">(</a><a id="28434" href="Meta.HLevel.html#2907" class="InductiveConstructor">`level-minus</a> <a id="28447" class="Number">1</a> <a id="28449" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28451" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28453" class="Symbol">)</a>

  <a id="hlevel-proj-n-type"></a><a id="28458" href="Meta.HLevel.html#28458" class="Function">hlevel-proj-n-type</a> <a id="28477" class="Symbol">:</a> <a id="28479" href="Meta.HLevel.html#4123" class="Record">hlevel-projection</a> <a id="28497" class="Symbol">(</a><a id="28498" class="Keyword">quote</a> <a id="28504" href="Structures.n-Type.html#557" class="Function">Carrier</a><a id="28511" class="Symbol">)</a>
  <a id="28515" href="Meta.HLevel.html#28458" class="Function">hlevel-proj-n-type</a> <a id="28534" class="Symbol">.</a><a id="28535" href="Meta.HLevel.html#4180" class="Field">has-level</a> <a id="28545" class="Symbol">=</a> <a id="28547" class="Keyword">quote</a> <a id="28553" href="Structures.n-Type.html#616" class="Function">carrier-is-tr</a>
  <a id="28569" href="Meta.HLevel.html#28458" class="Function">hlevel-proj-n-type</a> <a id="28588" class="Symbol">.</a><a id="28589" href="Meta.HLevel.html#4367" class="Field">get-level</a> <a id="28599" href="Meta.HLevel.html#28599" class="Bound">ty</a> <a id="28602" class="Symbol">=</a> <a id="28604" class="Keyword">do</a>
    <a id="28611" href="Agda.Builtin.Reflection.html#4945" class="InductiveConstructor">def</a> <a id="28615" class="Symbol">(</a><a id="28616" class="Keyword">quote</a> <a id="28622" href="Structures.n-Type.html#336" class="Function">n-Type</a><a id="28628" class="Symbol">)</a> <a id="28630" class="Symbol">(</a><a id="28631" href="Meta.HLevel.html#28631" class="Bound">ell</a> <a id="28635" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="28638" href="Meta.HLevel.html#28638" class="Bound">lv′t</a> <a id="28643" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="28646" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28648" class="Symbol">)</a> <a id="28650" href="Meta.Bind.html#190" class="Field Operator">←</a> <a id="28652" href="Agda.Builtin.Reflection.html#8687" class="Postulate">reduce</a> <a id="28659" href="Meta.HLevel.html#28599" class="Bound">ty</a>
      <a id="28668" class="Keyword">where</a> <a id="28674" class="CatchallClause Symbol">_</a> <a id="28676" class="Symbol">→</a> <a id="28678" href="Meta.HLevel.html#5516" class="Function">backtrack</a> <a id="28688" href="Foundations.Pi.Base.html#957" class="Function Operator">$</a> <a id="28690" class="String">&quot;Type of thing isn&#39;t n-Type, it is &quot;</a> <a id="28727" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28729" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="28737" href="Meta.HLevel.html#28599" class="Bound">ty</a> <a id="28740" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28742" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="28749" href="Agda.Builtin.Reflection.html#8651" class="Postulate">normalise</a> <a id="28759" href="Meta.HLevel.html#28638" class="Bound">lv′t</a>
  <a id="28766" href="Meta.HLevel.html#28458" class="Function">hlevel-proj-n-type</a> <a id="28785" class="Symbol">.</a><a id="28786" href="Meta.HLevel.html#4520" class="Field">get-argument</a> <a id="28799" class="Symbol">(_</a> <a id="28802" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28804" class="Symbol">_</a> <a id="28806" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="28808" href="Meta.HLevel.html#28808" class="Bound">it</a> <a id="28811" href="Meta.Reflection.html#2374" class="InductiveConstructor Operator">v∷</a> <a id="28814" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="28816" class="Symbol">)</a> <a id="28818" class="Symbol">=</a> <a id="28820" href="Meta.Idiom.html#583" class="Field">pure</a> <a id="28825" href="Meta.HLevel.html#28808" class="Bound">it</a>
  <a id="28830" href="Meta.HLevel.html#28458" class="CatchallClause Function">hlevel-proj-n-type</a><a id="28848" class="CatchallClause"> </a><a id="28849" class="CatchallClause Symbol">.</a><a id="28850" href="Meta.HLevel.html#4520" class="CatchallClause Field">get-argument</a><a id="28862" class="CatchallClause"> </a><a id="28863" class="CatchallClause Symbol">_</a> <a id="28865" class="Symbol">=</a> <a id="28867" href="Agda.Builtin.Reflection.html#8509" class="Postulate">typeError</a> <a id="28877" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>


<a id="28882" class="Comment">-- Usage</a>
<a id="28891" class="Keyword">private</a>
  <a id="28901" class="Keyword">module</a> <a id="28908" href="Meta.HLevel.html#28908" class="Module">_</a> <a id="28910" class="Symbol">{</a><a id="28911" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="28913" class="Symbol">:</a> <a id="28915" href="Structures.n-Type.html#336" class="Function">n-Type</a> <a id="28922" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a> <a id="28924" class="Number">2</a><a id="28925" class="Symbol">}</a> <a id="28927" class="Symbol">{</a><a id="28928" href="Meta.HLevel.html#28928" class="Bound">B</a> <a id="28930" class="Symbol">:</a> <a id="28932" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="28934" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="28936" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="28938" class="Symbol">→</a> <a id="28940" href="Structures.n-Type.html#336" class="Function">n-Type</a> <a id="28947" href="Meta.HLevel.html#24479" class="Generalizable">ℓ</a> <a id="28949" class="Number">3</a><a id="28950" class="Symbol">}</a> <a id="28952" class="Keyword">where</a>
    <a id="28962" href="Meta.HLevel.html#28962" class="Function">some-def</a> <a id="28971" class="Symbol">=</a> <a id="28973" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="28975" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="28977" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="28983" href="Meta.HLevel.html#28983" class="Function">_</a> <a id="28985" class="Symbol">:</a> <a id="28987" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a> <a id="29000" class="Number">2</a> <a id="29002" class="Symbol">(</a><a id="29003" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29005" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29007" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29009" class="Symbol">→</a> <a id="29011" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29013" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29015" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29017" class="Symbol">→</a> <a id="29019" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29021" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29023" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29025" class="Symbol">→</a> <a id="29027" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29029" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29031" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29032" class="Symbol">)</a>
    <a id="29038" class="Symbol">_</a> <a id="29040" class="Symbol">=</a> <a id="29042" href="Meta.HLevel.html#24428" class="Macro">hlevel!</a>

    <a id="29055" href="Meta.HLevel.html#29055" class="Function">_</a> <a id="29057" class="Symbol">:</a> <a id="29059" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a> <a id="29072" class="Number">3</a> <a id="29074" class="Symbol">(</a><a id="29075" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="29077" href="Meta.HLevel.html#28962" class="Function">some-def</a> <a id="29086" class="Symbol">λ</a> <a id="29088" href="Meta.HLevel.html#29088" class="Bound">x</a> <a id="29090" class="Symbol">→</a> <a id="29092" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29094" href="Meta.HLevel.html#28928" class="Bound">B</a> <a id="29096" href="Meta.HLevel.html#29088" class="Bound">x</a> <a id="29098" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29099" class="Symbol">)</a>
    <a id="29105" class="Symbol">_</a> <a id="29107" class="Symbol">=</a> <a id="29109" href="Meta.HLevel.html#24428" class="Macro">hlevel!</a>

    <a id="29122" href="Meta.HLevel.html#29122" class="Function">_</a> <a id="29124" class="Symbol">:</a> <a id="29126" class="Symbol">∀</a> <a id="29128" href="Meta.HLevel.html#29128" class="Bound">a</a> <a id="29130" class="Symbol">→</a> <a id="29132" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a> <a id="29145" class="Number">5</a> <a id="29147" class="Symbol">(</a><a id="29148" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29150" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29152" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29154" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29156" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29158" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29160" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29162" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29164" class="Symbol">(</a><a id="29165" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29167" class="Symbol">→</a> <a id="29169" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29171" href="Meta.HLevel.html#28928" class="Bound">B</a> <a id="29173" href="Meta.HLevel.html#29128" class="Bound">a</a> <a id="29175" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29176" class="Symbol">))</a>
    <a id="29183" class="Symbol">_</a> <a id="29185" class="Symbol">=</a> <a id="29187" href="Meta.HLevel.html#24428" class="Macro">hlevel!</a>

    <a id="29200" href="Meta.HLevel.html#29200" class="Function">_</a> <a id="29202" class="Symbol">:</a> <a id="29204" class="Symbol">∀</a> <a id="29206" href="Meta.HLevel.html#29206" class="Bound">a</a> <a id="29208" class="Symbol">→</a> <a id="29210" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a> <a id="29223" class="Number">3</a> <a id="29225" class="Symbol">(</a><a id="29226" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29228" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29230" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29232" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29234" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29236" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29238" href="Meta.Underlying.html#170" class="Field Operator">⌟</a> <a id="29240" href="Foundations.Sigma.Base.html#498" class="Function Operator">×</a> <a id="29242" class="Symbol">(</a><a id="29243" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="29245" class="Symbol">→</a> <a id="29247" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29249" href="Meta.HLevel.html#28928" class="Bound">B</a> <a id="29251" href="Meta.HLevel.html#29206" class="Bound">a</a> <a id="29253" href="Meta.Underlying.html#170" class="Field Operator">⌟</a><a id="29254" class="Symbol">))</a>
    <a id="29261" class="Symbol">_</a> <a id="29263" class="Symbol">=</a> <a id="29265" href="Meta.HLevel.html#24428" class="Macro">hlevel!</a>

    <a id="29278" href="Meta.HLevel.html#29278" class="Function">_</a> <a id="29280" class="Symbol">:</a> <a id="29282" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a> <a id="29295" class="Number">2</a> <a id="29297" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29299" href="Meta.HLevel.html#28911" class="Bound">A</a> <a id="29301" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29307" class="Symbol">_</a> <a id="29309" class="Symbol">=</a> <a id="29311" href="Meta.HLevel.html#24428" class="Macro">hlevel!</a>

    <a id="29324" class="Comment">-- this one uses `H-Level-nType` instance which is compile-time only</a>
    <a id="29397" class="Symbol">@</a><a id="29398" class="Number">0</a> <a id="29400" href="Meta.HLevel.html#29400" class="Function">_</a> <a id="29402" class="Symbol">:</a> <a id="29404" class="Symbol">∀</a> <a id="29406" href="Meta.HLevel.html#29406" class="Bound">n</a> <a id="29408" class="Symbol">→</a> <a id="29410" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a> <a id="29423" class="Symbol">(</a><a id="29424" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="29428" href="Meta.HLevel.html#29406" class="Bound">n</a><a id="29429" class="Symbol">)</a> <a id="29431" class="Symbol">(</a><a id="29432" href="Structures.n-Type.html#336" class="Function">n-Type</a> <a id="29439" href="Meta.HLevel.html#28922" class="Bound">ℓ</a> <a id="29441" href="Meta.HLevel.html#29406" class="Bound">n</a><a id="29442" class="Symbol">)</a>
    <a id="29448" class="Symbol">_</a> <a id="29450" class="Symbol">=</a> <a id="29452" href="Meta.HLevel.html#24428" class="Macro">hlevel!</a>

    <a id="29465" href="Meta.HLevel.html#29465" class="Function">_</a> <a id="29467" class="Symbol">:</a> <a id="29469" class="Symbol">∀</a> <a id="29471" href="Meta.HLevel.html#29471" class="Bound">n</a> <a id="29473" class="Symbol">(</a><a id="29474" href="Meta.HLevel.html#29474" class="Bound">x</a> <a id="29476" class="Symbol">:</a> <a id="29478" href="Structures.n-Type.html#336" class="Function">n-Type</a> <a id="29485" href="Meta.HLevel.html#28922" class="Bound">ℓ</a> <a id="29487" href="Meta.HLevel.html#29471" class="Bound">n</a><a id="29488" class="Symbol">)</a> <a id="29490" class="Symbol">→</a> <a id="29492" href="Foundations.Base.html#13062" class="Function">is-of-hlevel</a> <a id="29505" class="Symbol">(</a><a id="29506" class="Number">2</a> <a id="29508" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="29510" href="Meta.HLevel.html#29471" class="Bound">n</a><a id="29511" class="Symbol">)</a> <a id="29513" href="Meta.Underlying.html#170" class="Field Operator">⌞</a> <a id="29515" href="Meta.HLevel.html#29474" class="Bound">x</a> <a id="29517" href="Meta.Underlying.html#170" class="Field Operator">⌟</a>
    <a id="29523" class="Symbol">_</a> <a id="29525" class="Symbol">=</a> <a id="29527" class="Symbol">λ</a> <a id="29529" href="Meta.HLevel.html#29529" class="Bound">n</a> <a id="29531" href="Meta.HLevel.html#29531" class="Bound">x</a> <a id="29533" class="Symbol">→</a> <a id="29535" href="Meta.HLevel.html#24428" class="Macro">hlevel!</a>
</pre></body></html>